While you may want to remove the following header from this file for
your own use, please do not redistribute the file without it, so that
credit may be given where credit is due.
-----------------------------------------------------------
Last edited 1/30/88

This list is the result of the time and effort of a large number of people, 
among them
     Janet Jack        January 1985  (original list)
     J. Weaver Jr.     January 1985
     John Cooper       February 1985
     Skip Gilbrech     February 1985
     Bob Jack
     Jim Kyle          April 1985
     John Ruschmeyer   <ihnp4!vax135!petsd!moncol!john> August 1985
     Bill Frolik       <ihnp4!hplabs!hp-pcd!bill>       August 1985
     Ross M. Greenberg <greenber%timeinc.uucp@brl.arpa> August 1985

     Mike Morearty <...!ucbvax!cory!morearty> \  early 1987
     Ed Nather     <...!ut-sally!nather>       > several undocumented DOS
     Pete Holzmann <{pyramid}!octopus!pete>   /  calls in another list

     Dan Lanciani  <ddl@harvard.harvard.edu> various, incl. NetBIOS func calls
     Ralf Brown    <ralf@cs.cmu.edu> INT 24h and DOS func 59h error codes
     Dan Davison   <dd@lanl.gov>     DOS 3.3 function calls      11/87
     Bill White    <wwhite@teknowledge-vaxc.arpa> DOS 3.3        11/87
     Richard Hargrove <killer!richardh@harvard.harvard.edu> EGA  11/87
     Vincent Broman <broman@bugs.nosc.mil> Cordata BIOS/Minix    12/87
     Dennis Grinberg <grinberg@bimacs.bitnet> MCGA/VGA           12/87
     Brad Davis    <tektronix!sequent!gssc!bradd> GSS, DGIS       1/88

Information on Tseng/Ahead/Paradise EGA video modes from a list posted by
Dan Kegel 3/87.

Information on the INT 10h functions supported by the EGA BIOS was derived
from the article "Graphic Enhancement" found in the April 1985 _PC Tech
Journal_, pages 58ff., and is marked with the string (EGA). jrh.

Information on functions unique to the Portable PC and the Convertible was
derived from a similar list compiled by David E. Powell, and added by
Ralf Brown on 11/14/87.

Information on LIM EMS 3.2 functions was derived from _Advanced_MSDOS_, by
Ray Duncan. Added by Ralf Brown 11/19/87.

Information on LIM EMS 4.0 functions was derived from the transcription of
the specification by Dick Flanagan.  Added by Ralf Brown, 11/20/87

Some of the information on MCGA/VGA BIOS calls was derived from _Byte_,
Volume 12 Number 12.

Various and sundry info on which machines support which calls was derived from
the BIOS comparison in _Byte_, Volume 12 Number 12 and added by Ralf Brown,
1/4/88.

COMPAQ DOS 3.31 INT 25/26 from a posting by John Lefor, 1/25/88.
-----------------------------------------------------------
If you know any information which is not in this list, or which is
incorrect, please let me know!

	       Ralf Brown
	 Arpa: ralf@cs.cmu.edu
	 UUCP: {uunet,ucbvax,harvard}!cs.cmu.edu!ralf
	 BIT:  ralf%cs.cmu.edu@cmuccvma
	 FIDO: Ralf Brown at 1:129/31  (more subject to change than the others)
-----------------------------------------------------------
---cut---cut---cut---cut---cut---cut---cut---cut---cut---cut---
-----------------------------------------------------------
Key to system abbreviations
(unless otherwise indicated, a function is available on all systems)
	PC      IBM PC
	XT      IBM PC XT
	PORT    IBM PC Portable (uses same BIOS as XT)
	Jr      IBM PCjr
	AT      IBM PC AT
	XT2     IBM PC XT 2
	XT286   IBM PC XT/286
	CONV    IBM Convertible
	PS      IBM PS/2, any model
	PS30    IBM PS/2 Model 30 and below
	PS50+   IBM PS/2 Model 50,60,80
	CGA     Color Graphics Adapter
	EGA     Enhanced Graphics Adapter
	VGA     Video Graphics Array
	MCGA    Multi-Color Graphics Array
	TopView TopView/DESQview/TaskView/other TopView-compatible environments

IBM, PC, PS/2, TopView are trademarks of IBM Corporation
DESQview is a trademark of Quarterdeck Office Systems
TaskView is a trademark of Sunny Hill Software
Various other names are trademarks of their respective companies
-----------------------------------------------------------
INT 00 - DIVIDE ERROR
   Automatically called at end of DIV or IDIV operation that results in error.
   Normally set by DOS to display an error message and abort the program.
-----------------------------------------------------------
INT 01 - SINGLE-STEP
   Generated at end of each machine instruction if TF bit in FLAGS is set.
   This is what makes the T command of DEBUG work for single-stepping.  It is
   not generated after MOV to segment register or POP of segment register
   (unless you have a very early 8088 with a microcode bug).
-----------------------------------------------------------
INT 02 - NMI (NON-MASKABLE INTERRUPT)
   Generated by NMI signal in hardware.  This signal has various uses:

   Parity error: all except Jr and CONV
   Coprocessor interrupt: all except Jr and CONV
   Keyboard interrupt: Jr, CONV
   I/O channel check: CONV, PS50+
   Disk-controller power-on request: CONV
   System suspend: CONV
   Real-time clock: CONV
   System watch-dog timer, time-out interrupt: PS50+
   DMA timer time-out interrupt: PS50+
-----------------------------------------------------------
INT 03 - 1-BYTE INTERRUPT
   Generated by opcode 0CCh. Similar to 8080's RST instruction.  Generally
   used to set breakpoints for DEBUG.
   Also used by Turbo Pascal versions 1,2,3 when {$U+} specified
-----------------------------------------------------------
INT 04 - OVERFLOW (internal interrupt)
   Generated by INTO instruction if OF flag is set.  If flag is not set, INTO
   is effectively a NOP.  Used to trap any arithmetic errors when program is
   ready to handle them rather than immediately when they occur.
-----------------------------------------------------------
INT 05 - PRINT-SCREEN KEY
   Automatically called by keyboard scan when print-screen key is pressed.
   Normally executes routine to print the screen, but may call any routine that
   can safely be executed from inside the keyboard scanner.  Status and result
   byte for default handler is at address 0050:0000.
-----------------------------------------------------------
INT 05 - BOUND CHECK FAILED (80286 internal interrupt)
-----------------------------------------------------------
INT 06 - UNDEFINED OPCODE (80286 internal interrupt)
-----------------------------------------------------------
INT 07 - NO MATH UNIT AVAILABLE (80286 protected-mode internal)
-----------------------------------------------------------
INT 08 thru 0F - Vectored Hardware Lines
   In IBM, these 8 interrupts are generated in response to IRQ 0 through
   IRQ 7 (if enabled via port 21h).
				     [Tandy 1000]       [Adapters]
     IRQ0 - timer interrupt
     IRQ1 - keyboard interrupt
     IRQ2 - EGA vertical retrace     [fixed disk]       [TOPS&PCnet default]
     IRQ3 - serial port 2 (com2:)                       [TOPS&PCnet alternate]
     IRQ4 - serial port 1 (com1:)
     IRQ5 - fixed disk (PC/AT: LPT2) [60 Hz ram refresh]
     IRQ6 - diskette interrupt
     IRQ7 - PPI interrupt (lpt1:, lpt2:)
-----------------------------------------------------------
INT 08 - DOUBLE FAULT (80286 protected-mode internal)
-----------------------------------------------------------
INT 09 - MATH UNIT PROTECTION FAULT (80286 protected-mode internal)
-----------------------------------------------------------
INT 0A - INVALID TASK STATE SEGMENT (80286 protected-mode internal)
-----------------------------------------------------------
INT 0B - NOT PRESENT (80286 protected-mode internal)
-----------------------------------------------------------
INT 0C - STACK FAULT (80286 protected-mode internal)
-----------------------------------------------------------
INT 0D - GENERAL PROTECTION VIOLATION (80286 internal interrupt)
   Called in real mode when an instruction attempts to access a word operand
   located at offset 0FFFFh
-----------------------------------------------------------
INT 0E - PAGE FAULT (80386 native-mode internal)
-----------------------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE
	AH = 00h
	AL = mode
	   00h = 40x25 B&W @B800h
	   01h = 40x25 color @B800h
	   02h = 80x25 B&W @B800h
	   03h = 80x25 color @B800h
	   04h = 320x200 graphics, 4 color @B800h
	   05h = 320x200 graphics, 4-tone gray scale @B800h
	   06h = 640x200 graphics, B&W @B800h
	   07h = monochrome @B000h
	   08h = 160x200 graphics, 16 color @B800h (PCjr/Tandy 1000)
	   09h = 320x200 graphics, 16 color @B800h (PCjr/Tandy 1000)
	   0Ah = 640x200 graphics, 4 color @B800h (PCjr/Tandy 1000)
	   0Bh = reserved (used internally by EGA BIOS)
	   0Ch = reserved (used internally by EGA BIOS)
	   0Dh = 320x200 graphics, 16 color @A000h (EGA/VGA)
	   0Eh = 640x200 graphics, 16 color @A000h (EGA/VGA)
	   0Fh = 640x350 graphics, monochrome @A000h (EGA/VGA)
	   10h = 640x350 graphics, 4 or 16 color @A000h (EGA/VGA)
	   11h = 640x480 graphics, monochrome @A000h (VGA/MCGA)
	   12h = 640x480 graphics, 16 colors @A000h (VGA only)
	   13h = 320x200 graphics, 256 colors @A000h (VGA/MCGA)
	   18h = 132x44 text, 8x8 pixel box  (Tseng Labs EVA)
	   19h = 132x25 text, 8x14 pixel box (Tseng Labs EVA)
	   1Ah = 132x28 text, 8x13 pixel box (Tseng Labs EVA)
	   22h = 132x44 text, 8x8 pixel box  (Tseng Labs EVA, Ahead Sys EGA2001)
	   23h = 132x25 text, 6x14 pixel box (Tseng Labs EVA)
	       = 132x25 text, 8x14 pixel box (Ahead Systems EGA2001)
	   24h = 132x28 text, 6x13 pixel box (Tseng Labs EVA)
	   25h = 640x480 graphics, ??? color (Tseng Labs EVA)
	   26h = 80x60 text, 8x8 pixel box   (Tseng Labs EVA)
	       = 640x480 graphics, ??? color (Ahead Systems EGA2001)
	   30h = ???x??? (AT&T 6300)
	   40h = 640x400 graphics (AT&T 6300)
	   48h = 640x400 graphics+80x50 text (AT&T 6300)
	   50h = 132x25 text, 9x14 pixel box (Ahead Systems EGA2001)
	       = 640x480 graphics, ??? colors (Paradise EGA-480)
	   51h = 80x30 text, 8x16 pixel box   (Paradise EGA-480)
	   52h = 132x44 text, 9x8 pixel box  (Ahead Systems EGA2001)
	   54h = 132x43 text, 8x8 pixel box  (Paradise EGA-480)
	   55h = 132x25 text, 8x14 pixel box (Paradise EGA-480)
	   60h = 400 line graphics+80 column text (Corona/Cordata BIOS v4.10+)
	   61h = 400 line graphics (Corona/Cordata BIOS v4.10+)
	   74h = 640x400 graphics (Toshiba 3100)
	   ??? = 640x225 graphics (Z-100)
	   ??? = 640x400 graphics (Z-100)
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR CHARACTERISTICS
	AH = 01h
	CH bits 5-6 = blink attribute
		     (00=normal, 01=invisible, 10=slow, 11=fast)
	CH bits 0-4 = start line for cursor in char. cell
	CL bits 0-4 = end line for cursor in char. cell
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
	AH = 02h
	DH,DL = row, column (0,0 = upper left)
	BH = page number
	    0 in graphics modes
	    0-3 in modes 2&3
	    0-7 in modes 0&1
-----------------------------------------------------------
INT 10 - VIDEO - READ CURSOR POSITION
	AH = 03h
	BH = page number
	    0 in graphics modes
	    0-3 in modes 2&3
	    0-7 in modes 0&1
Return: DH = row
	DL = column
	CH = cursor start line
	CL = cursor end line
-----------------------------------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION (all but PS)
	AH = 04h
Return: AH = 0: light pen switch not activated
	AH = 1: light pen values in registers
	    DH = row of current position
	    DL = column of current position
	    CH = raster line (0-199) (EGA) old graphics modes
	    CX = (EGA) raster line (0-nnn) new graphics modes
	    BX = pixel column (0-319 or 0-639)
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DISPLAY PAGE
	AH = 05h
	AL =
	    0-7: new page value for modes 0 & 1
	    0-3: new page value for modes 2 & 3
	    80h: read CRT/CPU page registers [PCjr only]
	    81h: set CPU page register to value in BL [PCjr only]
	    82h: set CRT page register to value in BH [PCjr only]
	    83h: set both display registers [PCjr only]
	    {Corona/Cordata BIOS v4.10+}
	    0: set address of graphics bitmap buffer (video modes 60h,61h)
	       BX = segment of buffer
	    0Fh: get address of graphics bitmap buffer (video modes 60h,61h)
Return: BH = CRT page register (if AL >= 80h)
	BL = CPU page register (if AL >= 80h)
	DX = segment of graphics bitmap buffer (video modes 60h,61h; AL=0Fh)
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE UP
	AH = 06h
	AL = number of lines to scroll window (0 = blank whole window)
	BH = attributes to be used on blanked lines
	CH,CL = row,column of upper left corner of window to scroll
	DH,DL = row,column of lower right corner of window
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE DOWN
	AH = 07h
	AL = number of lines to scroll window (0 = blank whole window)
	BH = attributes to be used on blanked lines
	CH,CL = row,column of upper left corner of window to scroll
	DH,DL = row,column of lower right corner of window
-----------------------------------------------------------
INT 10 - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
	AH = 08h
	BH = display page
Return: AL = character
	AH = attribute of character (alpha modes)
-----------------------------------------------------------
INT 10 - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POS
	AH = 09h
	AL = character
	BH = display page - alpha mode
	BL = attributes of char (alpha modes) or color (graphics modes)
	     if bit 7 == 1 in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POS
	AH = 0Ah
	AL = character
	BH = display page - alpha mode
	BL = color of character (graphics mode)
	CX = number of times to write character
	     (EGA) in graphics modes, replication count in CX works correctly
	     only if all character written are contains on the same row
-----------------------------------------------------------
INT 10 - VIDEO - SET COLOR PALETTE
	(EGA) CGA-compatible modes
	AH = 0Bh
	BH = palette color ID
	BL = color to be used with color ID
	(EGA) (graphics modes)
	if BH == 0, BL contains background and border colors (0-15)
	if BH == 1, BL contains palette being selected (0-1)
	      (text modes)
	if BH == 0, BL contains border color (0-15) only
		    (EGA) BL contains border color (0-15) and high-intensity
		    background color (16-31)
-----------------------------------------------------------
INT 10 - VIDEO - WRITE DOT ON SCREEN
	AH = 0Ch
	AL = color of dot (0/1 in mode 6, 0-3 in modes 4 and 5)
	     if bit 7 set, new color will be XORed with current pixel
	DX = row (0 - 199)
	CX = column (0 - 319 in modes 4/5, 0 - 639 in mode 6)
	Note: video modes 4-6 only
-----------------------------------------------------------
INT 10 - VIDEO - READ DOT ON SCREEN
	AH = 0Dh
	CX = column (0 - 319 or 639)
	DX = row (0 - 199)
Return: AL = color read
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
	AH = 0Eh
	AL = character
	BH = display page (alpha modes)
	BL = foreground color (graphics modes)
-----------------------------------------------------------
INT 10 - VIDEO - GET CURRENT VIDEO MODE
	AH = 0Fh
Return: AH = number of columns on screen
	AL = current video mode
	BH = current active display page
-----------------------------------------------------------
INT 10 - VIDEO - SET PALETTE REGISTERS (Jr, PS, TANDY 1000, EGA, VGA)
	AH = 10h
	AL = 0: set palette register
		BL = palette register to set
		BH = color value to store
	AL = 1: set border color register
		BH = color value to store
	AL = 2: set all palette registers
		ES:DX = pointer to 17-byte list
			bytes 0-15 = values for palette regs. 0-15
			byte 16 = value for border register
	(EGA/VGA/MCGA)
	AL = 3: toggle intensity/blinking bit
		BL = 0: enable intensity
		BL = 1: enable blink
	(VGA/MCGA)
	AL = 7: read individual palette register (VGA only)
		??? = register number
		Return: ??? = palette register value
	AL = 8: read overscan (border color) register (VGA only)
		Return: ??? = value
	AL = 9: read all palette registers and overscan register (VGA only)
		??? = buffer address
		Return: ???
	AL = 10h: set individual DAC register
		??? = register number
		??? = new value
	AL = 12h: set block of DAC registers
		???
	AL = 13h: select video DAC color page (VGA only)
		??? = color page
	AL = 15h: read individual DAC register
		??? = register number
		Return: ??? = value
	AL = 17h: read block of DAC registers
		???
		Return: ???
	AL = 1Ah: read video DAC color-page state (VGA only)
		Return: ???
	AL = 1Bh: perform gray-scale summing
		???
-----------------------------------------------------------
INT 10 - VIDEO - CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
	AH = 11h
	The following functions will cause a mode set, completely resetting
	the video environment, but without clearing the video buffer
	AL = 00h, 10h: load user-specified patterns
	    ES:BP = pointer to user table
	    CX    = count of patterns to store
	    DX    = character offset into map 2 block
	    BL    = block to load in map 2
	    BH    = number of bytes per character pattern
	AL = 01h, 11h: load ROM monochrome patterns (8 by 14)
	    BL    = block to load
	AL = 02h, 12h: load ROM 8 by 8 double-dot patterns
	    BL    = block to load
	AL = 03h: set block specifier
	    BL    = block specifier
	AL = 04h, 14h: load ROM 8x16 character set (VGA)
	The routines called with AL=1xh are designed to be called only
	immediately after a mode set and are similar to the routines called
	with AL=0xh, except that:
	      Page 0 must be active.
	      Bytes/character is recalculated.
	      Max character rows is recalculated.
	      CRT buffer length is recalculated.
	      CRTC registers are reprogrammed as follows:
		     R09 = bytes/char-1 ; max scan line (mode 7 only)
		     R0A = bytes/char-2 ; cursor start
		     R0B = 0            ; cursor end
		     R12 = ((rows+1)*(bytes/char))-1 ; vertical display end
		     R14 = bytes/char   ; underline loc
			   (*** BUG: should be 1 less ***)
	The following functions are meant to be called only after a mode set:
	AL = 20h: user 8 by 8 graphics characters (INT 1Fh)
	    ES:BP = pointer to user table
	AL = 21h: user graphics characters
	    ES:BP = pointer to user table
	    CX    = bytes per character
	    BL    = row specifier
		   0: user set - DL = number of rows
		   1: 14 rows
		   2: 25 rows
		   3: 43 rows
	AL = 22h: ROM 8 by 14 set
	    BL    = row specifier
	AL = 23h: ROM 8 by 8 double dot
	    BL    = row specifier
	AL = 24h: load 8x16 graphics characters (VGA)
	AL = 30h: return information
	    BH    = pointer specifier
		   0: INT 1Fh pointer
		   1: INT 44h pointer
		   2: ROM 8 by 14 character font pointer
		   3: ROM 8 by 8 double dot font pointer
		   4: ROM 8 by 8 DD font (top half)
		   5: ROM alpha alternate (9 by 14) pointer
	    Returns: ES:BP = specified pointer value
		     CX    = bytes/character
		     DL    = character rows on screen
-----------------------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA)
	AH = 12h
	BL = 10h: return EGA information
	     Returns:
	     BH = 0: color mode in effect (3Dx)
		  1: mono mode in effect (3Bx)
	     BL = 0:  64k bytes memory installed
		  1: 128k bytes memory installed
		  2: 192k bytes memory installed
		  3: 256k bytes memory installed
	     CH = feature bits
	     CL = switch settings
	BL = 20h: select alternate print screen routine
	BL = 30h: select vertical resolution for alphanumeric modes (VGA only)
	     ???
	BL = 31h: enable/disable default palette loading (VGA/MCGA)
	     ??? = on/off
	BL = 32h: enable/disable video addressing (VGA/MCGA)
	     ??? = on/off
	BL = 33h: enable/disable default gray-scale summing (VGA/MCGA)
	     ??? = on/off
	BL = 34h: enable/disable alphanumeric cursor emulation (VGA only)
	     ??? = on/off
	BL = 35h: display-switch interface
	     ???
-----------------------------------------------------------
INT 10 - VIDEO - WRITE STRING (AT,XT286,PS,EGA,VGA)
	AH = 13h
	AL = mode
	    bit 0: set in order to move cursor after write
	    bit 1: set if string contains alternating characters and attributes
	BL = attribute if AL bit 1 clear
	BH = display page number
	DH,DL = row,column of starting cursor position
	CX = length of string
	ES:BP = pointer to start of string
-----------------------------------------------------------
INT 10 - VIDEO - LOAD LCD CHARACTER FONT (CONVERTIBLE)
	AH = 14h
	AL = 0 load user-specified font
	    ES:DI = pointer to character font
	    BH = number of bytes per character
	    BL = 0: load main font (block 0)
		 1: load alternate font (block 1)
	    CX = number of characters to store
	    DX = character offset into RAM font area
	AL = 1 load system rom default font
	    BL = 0: load main font (block 0)
		 1: load alternate font (block 1)
	AL = 2 set mapping of LCD high intensity attributes
	    BL = 0: ignore high intensity attribute
		 1: map high intensity to underscore
		 2: map high intensity to revrese video
		 3: map high intensity to selected alternate font
-----------------------------------------------------------
INT 10 - VIDEO - GET PHYSICAL DISPLAY PARAMETERS (CONVERTIBLE)
	AH = 15h
Return: AX = alternate display adapter type
	ES:DI = pointer to parameter table
	       word 0: monitor model number
		    1: vertical pixels per meter
		    2: horizontal pixels per meter
		    3: total vertical pixels
		    4: total horizontal pixels
		    5: horizontal pixel separation in micrometers
		    6: vertical pixel separation in micrometers
-----------------------------------------------------------
INT 10 - VIDEO - DISPLAY COMBINATION (PS,VGA/MCGA)
	AH = 1Ah
	AL = 0: read display combination code
	     1: set display combination code
Return: ???
-----------------------------------------------------------
INT 10 - VIDEO - FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)
	AH = 1Bh
	???
Return: ???
-----------------------------------------------------------
INT 10 - VIDEO - SAVE/RESTORE VIDEO STATE (PS50+,VGA)
	AH = 1Ch
	AL = 0: return state buffer size
	     1: save video state
		??? = buffer address
	     2: restore video state
		??? = buffer address
Return: ???
-----------------------------------------------------------
INT 10 - Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES
	AX = 6A00h
        BX = 0000
        CX = 0000
        DX = buffer length (may be 0)
        ES:DI = address of buffer
Return: BX = number of bytes stored in buffer
        CX = bytes required for all descriptions (0 if no DGIS)
Note:   buffer contains descriptions and addresses of DGIS-compatible
        display(s) and printer(s)
-----------------------------------------------------------
INT 10 - DGIS - REDIRECT CHARACTER OUTPUT
	AX = 6A01h
        CX = 0000
        ES:DI = ADDRESS OF DEVICE TO SEND INT 10 OUTPUT TO
Return: CX = 0    output could not be redirected
             else INT 10h output now routed to requested display
-----------------------------------------------------------
INT 10 - DGIS - INQUIRE INT 10 OUTPUT DEVICE
	AX = 6A02h
        ES:DI = 0:0
Return: ES:DI = 0:0  if current display is non-DGIS
                else address of the current DGIS INT 10 display
-----------------------------------------------------------
INT 10 - VIDEO - GET VIDEO RAM ADDRESS [TANDY 1000]
	AH = 70h
Return: AX  = segment address of the following
	[BX] = offset address of green plane
	[CX] = segment address of green plane
	[DX] = segment address of red/blue plane
	       (red offset = 0, blue offset = 4000)
-----------------------------------------------------------
INT 10 - VIDEO - GET INCRAM ADDRESSES [TANDY 1000]
	AH = 71h
Return: AX  = segment address of the following
	[BX] = segment address of INCRAM
	[CX] = offset address of INCRAM
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN RIGHT [TANDY 1000]
	AH = 72h
	AL = number of columns blanked at left of window
	     0 = blank entire window
	BH = attributes to be used on blank columns
	CH,CL = row, column of upper left corner of window
	DH,DL = row, column of lower right corner
----------------------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN LEFT [TANDY 1000]
	AH = 73h
	AL = number of columns blanked at right of window
	     0 = blank entire window
	BH = attributes to be used on blank columns
	CH,CL = row, column of upper left corner of window
	DH,DL = row, column of lower right corner
-----------------------------------------------------------
INT 10 - VIDEO - ??? (DESQview)
	AH = 80h
	DX = 4456h
	ES:DI = pointer to ???
Return: DS = segment of DESQview data structure for video buffer
-----------------------------------------------------------
INT 10 - VIDEO - ??? (DESQview)
	AH = 81h
	DX = 4456h
Return: ES = segment of DESQview data structure for video buffer
-----------------------------------------------------------
INT 10 - VIDEO - ??? (DESQview)
	AH = 82h
	DX = 4456h
Return: DS = segment in DESQview for ???
	ES = segment of DESQview data structure for video buffer
	AL = ???
	AH = ???
	BL = ???
	BH = ???
	CL = ???
	CH = ???
-----------------------------------------------------------
INT 10 - VIDEO (TopView) - GET VIDEO BUFFER
	AH = FEh
	ES:DI = segment:offset of assumed video buffer
Return: ES:DI = segment:offset of actual video buffer
-----------------------------------------------------------
INT 10 - VIDEO (TopView) - UPDATE VIDEO BUFFER
	AH = FFh
	CX = number of sequential characters that have been modified
	DI = offset of first character that has been modified
	ES = segment of video buffer
Note: avoid CX=0
-----------------------------------------------------------
INT 11 - EQUIPMENT DETERMINATION
Return: AX = "equipment flag" bits
	    0       diskette installed
	    1       8087 present
	    2,3     always = 11
	    4,5     initial video mode
		    01 = 40x25 color
		    10 = 80x25 color
		    11 = 80X25 IBM monochrome
	    6,7     number of diskette drives (only if bit 0 = 1)
		    00 = 1, 01 = 2
	    8       0 = dma present, 1= no dma on system (PCjr?)
	    9,10,11 number of RS232 cards
	    12      game I/O attached
	    13      serial printer installed (IBM-PCjr)
		    internal modem installed (Convertible)
	    14,15   number of printers
-----------------------------------------------------------
INT 12 - MEMORY SIZE
Return: AX = number of contiguous 1K blocks of memory
-----------------------------------------------------------
INT 13 - DISK - RESET DISK SYSTEM
	AH = 00h
-----------------------------------------------------------
INT 13 - DISK - STATUS OF DISK SYSTEM
	AH = 01h
Return: AL = status
	    00h = successful completion
	    01h = bad command
	    02h = address mark not found
	    03h = write attempted on write-protected disk
	    04h = sector not found
	    05h = reset failed (hard disk)
	    06h = diskette changed
	    07h = parameter act. failed (hard disk)
	    08h = DMA overrun
	    09h = DMA across 64K boundary
	    0Ah = bad sector detected (hard disk)
	    0Bh = bad track detected (hard disk)
	    0Ch = unsupported track
	    10h = bad CRC/ECC
	    11h = data ECC corrected
	    20h = controller failure
	    40h = seek failed
	    80h = time out
	    AAh = drive not ready (hard disk)
	    BBh = undefined error (hard disk)
-----------------------------------------------------------
INT 13 - DISK - READ SECTORS INTO MEMORY
	AH = 02h
	AL = number of sectors to read
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector
	DH = head
	DL = drive
	ES:BX = address of buffer to fill
Return: CF = set if error occurred
	AH = status (see AH=1 above)
	AL = number of sectors read
-----------------------------------------------------------
INT 13 - DISK - WRITE SECTORS FROM MEMORY
	AH = 03h
	AL = number of sectors to write
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector
	DH = head
	DL = drive
	ES:BX = address of buffer
Return: CF = set if error occurred
	AH = status (see AH=1 above)
	AL = number of sectors written
-----------------------------------------------------------
INT 13 - DISK - VERIFY SECTORS
	AH = 04h
	AL = number of sectors to verify
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector
	DH = head
	DL = drive
Return: CF = set if error occurred
	AH = status (see AH=1 above)
	AL = number of sectors verified
-----------------------------------------------------------
INT 13 - FLOPPY - FORMAT TRACK
	AH = 05h
	AL = number of sectors to create on this track
	CH = track
	CL = sector
	DH = head
	DL = drive
	ES:BX = pointer to array of 4-byte address fields
	       byte 1 = track
	       byte 2 = head
	       byte 3 = sector
	       byte 4 = bytes/sector  0=128, 1=256, 2=512, 3=1024
Return: CF set if error occurred
	AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK
	AH = 05h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer
		the first 2*(sectors/track) bytes contain F,N for each sector
		   F = 00 for good sector, 80h for bad sector
		   N = sector number
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)
	AH = 06h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer
		the first 2*(sectors/track) bytes contain F,N for each sector
		   F = 00 for good sector, 80h for bad sector
		   N = sector number
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)
	AH = 07h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer, see AH=6 above
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
	AH = 08h
	DL = DRIVE NUMBER
Return: CF set on error
	AH = status code (see AH=1 above)
	DL = number of consecutive acknowledging drives
	DH = maximum value for head number
	CL = maximum value fo sector number
	CH = maximum value for cylinder number
-----------------------------------------------------------
INT 13 - FIXED DISK - INITIALIZE TWO FIXED DISK BASE TABLES (XT,AT,XT286,PS)
	AH = 09h
Return: CF set on error
	AH = status code (see AH=1 above)
	INT 41h points to table for drive 0
	INT 46h points to table for drive 1
-----------------------------------------------------------
INT 13 - FIXED DISK - READ LONG (XT,AT,XT286,PS)
	AH = 0Ah
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
	CL = sector
	ES:BX = pointer to buffer to fill
Return: CF set on error
	AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - WRITE LONG (XT,AT,XT286,PS)
	AH = 0Bh
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
	CL = sector
	ES:BX = pointer to buffer containing data
Return: CF set on error
	AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - SEEK TO CYLINDER (XT,AT,XT286,PS)
	AH = 0Ch
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
Return: CF set on error
	AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - ALTERNATE DISK RESET (XT,PORT,AT,XT286,PS)
	AH = 0Dh
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - READ SECTOR BUFFER (XT,PORT,PS)
	AH = 0Eh
	AL = number of sectors
	CH = cylinder (bits 8,9 in top two bits of CL)
	CL = sector number
	DH = head number
	DL = drive number
	ES:BX = pointer to buffer
Return: AL = number of sectors actually transferred
	AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - WRITE SECTOR BUFFER (XT,PORT,PS)
	AH = 0Fh
	AL = number of sectors
	CH = cylinder (bits 8,9 in top two bits of CL)
	CL = sector number
	DH = head number
	DL = drive number
	ES:BX = pointer to buffer
Return: AL = number of sectors actually transferred
	AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - TEST FOR DRIVE READY (XT,AT,XT286,PS)
	AH = 10h
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - RECALIBRATE DRIVE (XT,PORT,AT,XT286,PS)
	AH = 11h
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - CONTROLER RAM DIAGNOSTIC (XT,PORT,PS)
	AH = 12h
Return: AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - DRIVE DIAGNOSTIC (XT,PORT,PS)
	AH = 13h
Return: AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - CONTROLLER DIAGNOSTICS (XT,PORT,AT,XT286,PS)
	AH = 14h
Return: CF set on error
	AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
	AH = 15h
	DL = drive ID
Return: AH = disk type
	    0 = disk not there
	    1 = floppy, no change detection present
	    2 = floppy with change detection
	    3 = fixed disk
	       CX:DX = number of 512-byte sectors
-----------------------------------------------------------
INT 13 - DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
	AH = 16h
	DL = drive to check
Return: AH = disk change status
	    0 = no disk change
	    6 = disk changed
-----------------------------------------------------------
INT 13 - DISK - SET TYPE (AT,XT2,XT286,CONV,PS)
	AH = 17h
	AL = disk type
	    00 = no disk
	    01 = regular disk in regular drive
	    02 = regular disk in high-capacity drive
	    03 = high-capacity disk in high-capacity drive
	DL = drive ID
-----------------------------------------------------------
INT 13 - DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
	AH = 18h
	DL = drive number
	CH = lower 8 bits of number of tracks
	CL = sectors per track (bits 0-5)
	     top 2 bits of number of tracks (bits 6,7)
Return: AH = 00h  requested combination supported
	     01h  function not available
	     0Ch  not supported or drive type unknown
	     80h  there is no disk in the drive
	ES:DI = pointer to 11-byte parameter table
-----------------------------------------------------------
INT 13 - FIXED DISK - PARK HEADS (XT286,PS)
	AH = 19h
-----------------------------------------------------------
INT 13 - ESDI FIXED DISK - FORMAT UNIT (PS50+)
	AH = 1Ah
	???
-----------------------------------------------------------
INT 14 - SERIAL I/O - INITIALIZE USART
	AH = 00h
	AL = initializing parameters
	    7 - 6 - 5      4 - 3     2    1 - 0
	    -BAUD RATE-    PARITY   STOP   WORD
				    BITS  LENGTH
	    000  110 BD    00 none  0-1   10 - 7
	    001  150 BD    01 odd   1-2   11 - 8
	    010  300 BD    11 even
	    011  600 BD
	    100 1200 BD
	    101 2400 BD
	    110 4800 BD
	    111 9600 BD (4800 ON PCjr)
	DX = port number
Return: AX port status--see below
-----------------------------------------------------------
INT 14 - SERIAL I/O - TRANSMIT CHARACTER
	AH = 01h
	AL = character
	DX = port number
Return: AH = RS-232 status code bits
	    0: data ready
	    1: overrun error
	    2: parity error
	    3: framing error
	    4: break detected
	    5: transmission buffer register empty
	    6: transmission shift register empty
	    7: time out--if set, other bits invalid
	AL = modem status bits
	    0: delta Clear-To-Send
	    1: delta Data-Set-Ready
	    2: trailing edge of ring detected
	    3: change, receive line signal detected
	    4: Clear-To-Send
	    5: Data-Set-Ready
	    6: ring detected
	    7: receive line signal detected
-----------------------------------------------------------
INT 14 - SERIAL I/O - RECEIVE CHARACTER
	AH = 02h
Return: AL = character received
	AH = RS-232 status code (see above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - GET USART STATUS
	AH = 03h
Return: AH = RS-232 status code (see above)
	AL = modem status code (see above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - EXTENDED INITIALIZE (CONVERTIBLE?,PS)
	AH = 04h
	AL = break status
	    0 if break
	    1 if no break
	BH = parity
	    0 no parity
	    1 odd parity
	    2 even parity
	    3 stick parity odd
	    4 stick parity even
	BL = number of stop bits
	    0: one stop bit
	    1: two stop bits (1.5 if 5 bit word length)
	CH = word length
	    0: 5 bits
	    1: 6 bits
	    2: 7 bits
	    3: 8 bits
	CL = baud rate
	    0: 110
	    1: 150
	    2: 300
	    3: 600
	    4: 1200
	    5: 2400
	    6: 4800
	    7: 9600
	    8: 19200
Return: AL = modem status (see above)
	AH = line control status (see above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - EXTENDED COMMUNICATION PORT CONTROL (CONVERTIBLE?,PS)
	AH = 05h
	AL = 0 read modem control register
	      Return: BL = modem control register (see below)
		      AH = status
	AL = 1 write modem control register
	      BL = modem control register
		  bit 0: data terminal ready
		  bit 1: request to send
		  bit 2: OUT1
		  bit 3: OUT2
		  bit 4: LOOP
		  bits 5-7 reserved
	      Return: AH = status
-----------------------------------------------------------
INT 15 - CASSETTE - TURN ON MOTOR (PC,Jr)
	AH = 00h
Return: motor turned on
-----------------------------------------------------------
INT 15 - CASSETTE - TURN OFF MOTOR (PC,Jr)
	AH = 01h
Return: motor turned off
-----------------------------------------------------------
INT 15 - CASSETTE - READ DATA BLOCKS (PC,Jr)
	AH = 02h
	CX = count of bytes
	ES:BX = pointer to data area
Return: CF set on error
	DX = count of bytes read
	ES:BX = pointer past last byte read
-----------------------------------------------------------
INT 15 - CASSETTE - WRITE DATA BLOCKS (PC,Jr)
	AH = 03h
	CX = count of bytes to write
	ES:BX = pointer to data area
Return: ES:BX = pointer past last byte written
-----------------------------------------------------------
Int 15 - SYSTEM - FORMAT UNIT PERIODIC INTERRUPT (PS ESDI drives only)
	AH = 0Fh
	???
Return: ???
-----------------------------------------------------------
INT 15 - TopView - GIVE UP CPU TIME
	AX = 1000h
Return: after other processes run
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - ???
	AX = 1001h
	BX = number of bytes???
Return: ES:DI = pointer to ???
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - MAKE TONE
	AX = 1019h
	BX = frequency in Hertz
	CX = duration in clock ticks (18.2 ticks/sec)
Return: immediately, tone continues to completion
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - SWITCH TO INTERNAL STACK
	AX = 101Ah
Return: stack switched
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - POP-UP ERROR WINDOW
	AX = 101Fh
	BX = number of characters to display
	DS:DI = pointer to text of message
	CH = width of error window
	CL = height of error window
	DX = ???
Return: BX = ???
Note: window remains on-screen until ESC is pressed
-----------------------------------------------------------
INT 15 - TopView - GET VERSION
	AX = 1022h
	BX = 0
Return: BX nonzero, TopView or compat loaded
	(BL = major version, BH = minor version)
Notes: TaskView returns BX = 0001h, DESQview 2.0 returns BX = 0A01h
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - ???
	AX = 1021h
	BX = segment of ???
Return: nothing???
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - SWITCH BACK TO PROGRAM'S STACK
	AX = 1025h
Return: stack switched back
Note: call only after INT 15h/AX=101Ah
-----------------------------------------------------------
INT 15 - TopView commands
	AH = 11h
	AL = various
Note: in DESQview 2.00, these function calls are identical to AH=DEh, so
      see those below
-----------------------------------------------------------
INT 15 - DESQview (TopView???) commands
	AH = 12h
	BX = subfunction
	    0001h returns two words on stack
	    0003h returns two words on stack
	    0005h returns two words on stack
	    0007h returns two words on stack
	    0000,0002,0004,0006 pop-up error window (at least in DV 2.00)
	    0008h,0009h,000Ah, (etc???) return two zero words on stack
	    010Ah returns two words on stack
	    010Fh
	       CX = ???
	       SI = ???
	       Return: two words on stack
	    0200h takes two words off the stack
	    0400h takes two words off the stack
	    0405h ???
	    0407h ???
	    0500h same as 0501h below, but takes two additional words on stack
	    0807h ???
	    0A00h takes four words off the stack
	    0A04h takes four words off the stack
	    0A05h takes two words off the stack
	    0B00h takes four words off the stack
	    0B04h takes four words off the stack
	    0B05h takes two words off the stack
	    0B07h takes two words off the stack
	    0C00h takes four words off the stack
	    0C07h ???
	    0D00h takes two words off the stack
	    0D07h takes nothing on stack
	    0E00h takes DWORD pointer off stack
	    0E03h ???
	    0E05h ???
	    0F00h takes two words off the stack
	    0F05h ???
	    1201h takes four words off stack
		  DWORD pointer to ???
		  WORD ???
		  WORD ???
	    1405h takes two words off stack
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - EXIT PROGRAM
	AH = 12h
	BX = 0201h
Return: never
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - WINDOW MANIPULATION
	AH = 12h
	BX = 0501h
	STACK: push DWORD address of data struc
		    WORD 0 ???
		    WORD total len of structure
	       service routine will pop these four words
Return: indicated actions performed

Data Structure:
	MAGIC  DB  1Bh
	MODE   DB  ?   ; almost always 0, but I've also seen 1 and 10h
	LENGTH DW  ?   ; length of remainder in bytes
	var-length fields follow, each an OPCODE followed by
	     zero or more args

Opcodes:args
	00h  display 20h blanks with the default attribute
	01h-1Fh display OPCODE blanks with the default attribute
	20h  display char with default attribute 20h times
	     BYTE char to repeat
	21h-3Fh display char with default attribute OPCODE-20h times
	     BYTE char to repeat
	40h  display 20h blanks with specified attribute
	     BYTE attribute of blanks
	41h-5Fh display OPCODE-40h blanks with specified attribute
	     BYTE attribute of blanks
	60h  display next 20h characters
	     20h BYTES characters to display
	61h-7Fh display next OPCODE-60h characters
	     N BYTES characters to display
	80h-87h  display N blanks with default attribute
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	88h-8Fh display N copies of the character
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE character to repeat
	90h-97h  ???
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE ???
	98h-9FH  display string at "cursor" pos
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     N BYTES string to display
	A0h  set "cursor" row
	     BYTE row number (0 is top border)
	A1h  set "cursor" column
	     BYTE column number (0 is left border)
	B0h  move "cursor" down
	     BYTE #rows
	B1h  move "cursor" right
	     BYTE #cols
	C0h  set "cursor" position
	     BYTE row number
	     BYTE column number
	C2h  set window pos
	     BYTE upper left row
	     BYTE upper left column
	C3h  set current window size
	     BYTE #rows
	     BYTE #cols
	C5h  set maximum size of window
	     BYTE #rows
	     BYTE #cols
	D4h followed by E4h updates physical screen after a series of
	     manipulations
	D5h  ??? (no args)
	DAh  turn on color translation (maybe to make color programs viewable
	     on mono display???)
	DBh  turn off color translation
	DCh  enable special actions for control characters (default)
	DDh  disable special control char handling, all chars displayable by
	     BIOS TTY call
	E0h  repeat following commands
	     BYTE number of times
	E1h  end of commands to repeat, start repeating them
	E2h  set color
	     BYTE color (1=normal, 2=bold, 8=reverse (on mono))
	E3h  ??? (no args)
	E6h  ???
	     BYTE ???
	     BYTE ???
	EFh  set window name
	     BYTE length of name
	     N BYTES name
	F2h  ???
	     BYTE ???
	     BYTE ???
	F4h  ???
	     BYTE ???
	F7h  ???
	     STRING???
	FEh  ??? (no args)
	FFh  ???
Note: if MODE == 1
	 C2h, C3h, C5h, EFh, and probably others return the current setting in
	 their argument(s), rather than setting a new value
-----------------------------------------------------------
INT 15 - PRINT.COM - ??? (AT,XT286,PS50+)
	AH = 20h
	AL = subfunction
	    00h ???
	    01h ???
	    10h setup of SYSREQ routine (OS hook)
	    11h completion of SYSREQ function (OS hook)
Note: AL = 0,1 set or reset some flags which affect what PRINT does when it
      tries to access the disk
-----------------------------------------------------------
INT 15 - SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)
	AH = 21h
	???
Return: ???
-----------------------------------------------------------
INT 15 - READ/MODIFY PROFILES (CONVERTIBLE)
	AH = 40h
	AL = subfunction
	    0: get system profile in CX and BX
	    1: set system profile from CX and BX
	    2: get internal modem profile in BX
	    3: set internal modem profile from BX
-----------------------------------------------------------
INT 15 - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
	AH = 41h
	AL = condition type
	    bits 0-2: condition to wait for
		     0 any external event
		     1 compare and return if equal
		     2 compare and return if not equal
		     3 test and return if not zero
		     4 test and return if zero
	    bit 3:    reserved
	    bit 4:    1=port address, 0=user byte
	    bits 5-7: reserved
	BH = condition compare or mask value
	BL = timeout value times 55 milliseconds
	    0 means no timeout
	DX = I/O port address if AL bit 4 set
	ES:DI = pointer to user byte if AL bit 4 clear
-----------------------------------------------------------
INT 15 - REQUEST SYSTEM POWER OFF (CONVERTIBLE)
	AH = 42h
	AL = 0 to use system profile
	     1 to foce suspend regardless of system profile
-----------------------------------------------------------
INT 15 - READ SYSTEM STATUS (CONVERTIBLE)
	AH = 43h
Return: AL = status bits
	    bit 0: LCD detached
	    bit 1: reserved
	    bit 2: RS232/parallel adapter powered on
	    bit 3: internal modem powered on
	    bit 4: power activated by alarm
	    bit 5: standby power lost
	    bit 6: extern apower in use
	    bit 7: power low
-----------------------------------------------------------
INT 15 - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)
	AH = 44h
	AL = 0 to power off
	     1 to power on
-----------------------------------------------------------
INT 15 - HOOK - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)
	AH = 4Fh
	AL = scan code
	CF set
Return: AL = scan code
	CF set
Note: Called by INT 9 handler to translate scan codes
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)
	AH = 80h
	BX = device ID
	CX = process type
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE CLOSE (AT,XT2,XT286,PS)
	AH = 81h
	BX = device ID
	CX = process type
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE PROGRAM TERMINATE (AT,XT2,XT286,PS)
	AH = 82h
	BX = device ID
-----------------------------------------------------------
INT 15 - EVENT WAIT (AT,XT286,CONV,PS)
	AH = 83h
	AL = SUBSERVICE
	    0 = set interval
	    1 = cancel
	ES:BX = pointer to event flag (bit 7 set when interval expires)
	CX,DX = number of microseconds to wait (only accurate to 977 us)
Return: CF set if function already busy
-----------------------------------------------------------
INT 15 - READ JOYSTICK SWITCH SETTINGS (AT,XT2,XT286,PS)
	AH = 84h
	DX = 0
Return: AL = switch settings (bits 7-4)
-----------------------------------------------------------
INT 15 - READ JOYSTICK INPUTS (AT,XT2,XT286,PS)
	AH = 84h
	DX = 1
Return: AX = A(x) value
	BX = A(y) value
	CX = B(x) value
	DX = B(y) value
-----------------------------------------------------------
INT 15 - OS HOOK - SYSTEM REQUEST KEY PRESS (AT,XT2,XT286,CONV,PS)
	AH = 85h  (called by keyboard decode routine)
Return: AL = 00 press
	AL = 01 release
-----------------------------------------------------------
INT 15 - WAIT (AT,XT2,XT286,CONV,PS)
	AH = 86h
	CX,DX = number of microseconds to wait (only accurate to 977 us)
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
	AH = 87h
	CX = number of words to move
	ES:SI = pointer to global descriptor table
	       offset 0h  null descriptor (need not be initialized)
		      8h  uninitialized, will be made into GDT descriptor
		     10h  descriptor for source of move
		     18h  descriptor for destination of move
		     20h  uninitialized, used by BIOS
		     28h  uninitialized, will be made into SS descriptor
Return: source copied into destination
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - GET MEMORY SIZE (AT,XT286,PS)
	AH = 88h
Return: AX = memory size
-----------------------------------------------------------
INT 15 - SWITCH TO VIRTUAL MODE (AT,XT286,PS50+)
	AH = 89h
	BL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)
	BH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)
	DS:SI = pointer to GDT for protected mode
	       offset 0h  null descriptor
		      8h  GDT descriptor
		     10h  IDT descriptor
		     18h  DS
		     20h  ES
		     28h  SS
		     30h  CS
		     38h  uninitialized, used to build descriptor for BIOS CS
	CX = offset into protected-mode CS to jump to
Return: CF set on error
	   AH = 0FFh  error enabling address line 20
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE BUSY LOOP (AT,XT2,XT286,CONV,PS)
	AH = 90h
	AL = TYPE CODE
	    00h: disk
	    01h: diskette
	    02h: keyboard
	    80h: network
		ES:BX = NCB
	    FCh: disk reset
	    FDh: diskette motor start
	    FEh: printer
Return: CF set if wait time satisfied
Note: type codes are allocated as follows:
	00-7F non-reentrant devices; OS must arbitrate access
	80-BF reentrant devices; ES:BX points to a unique control block
	C0-FF wait-only calls, no complementary INT 15/AH=91h call
-----------------------------------------------------------
INT 15 - OS HOOK - SET FLAG AND COMPLETE INTERRUPT (AT,XT2,XT286,CONV,PS)
	AH = 91h
	AL = type code, see AH=90h above
-----------------------------------------------------------
INT 15 - GET SYSTEM CONFIGURATION (XT after 1/10/86,AT model 3x9,CONV,XT286,PS)
	AH = C0h
Return: CF = 1 if BIOS doesn't support call
	ES:BX pointer to ROM table
	     byte_count  dw   ?   ; number of bytes following
	     model       db   ?   ; PC=ff, XT=fe or fb, PCjr = fd, etc, etc
	     submodel    db   ?   ; distingushes between AT and XT/286, etc.
	     BIOS_rev    db   ?   ; 0 for first release, 1 for 2nd, etc.
	     featbyte    db   ?   ; 80h = DMA channel 3 used by hd BIOS
				  ; 40h = 2nd 8259 installed
				  ; 20h = Real-Time Clock installed
				  ; 10h = INT 15h called upon INT 9h
				  ;  8h = wait for external event supported
				  ;  4h = extended BIOS area allocated at 640K
				  ;  2h = bus is Micro Channel instead of PC
				  ;  1h   reserved
	     res1        dw   0
	     res2        dw   0
Note: the 1/10/86 XT BIOS returns an incorrect value for featbyte.
-----------------------------------------------------------
INT 15 - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)
	AH = C1h
	???
Return: ???
-----------------------------------------------------------
INT 15 - POINTING DEVICE BIOS INTERFACE (PS)
	AH = C2h
	???
Return: ???
-----------------------------------------------------------
INT 15 - DESQview - ???
	AH = C2h
	AL = subfunction
	    00h ???
	       BH = ???
	    01h set something to default values
	    02h ???
	       BH = ???
	    03h ???
	       BH = ???
	    04h points to RET instruction
	    05h same as 01h, but also takes input value in BH
	       BH = ???
	    06h ???
	       BH = 01h or 02h stored, otherwise ignored
	    07h ???
	       ES:BX = pointer to ???
	       Return: AL = 00h
Note: the values in BH for those functions that take it as input are stored
      in different locations for each subfunction
----------------------------------------------------------
INT 15 - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)
	AH = C3h
	???
Return: ???
-----------------------------------------------------------
INT 15 - PROGRAMMABLE OPTION SELECT (PS50+)
	AH = C4h
	???
Return: ???
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - GET PROGRAM NAME
	AX = DE00h
Return: AX = offset into DESQVIEW.DVO of current program:
	       BYTE  length of name
	     N BYTES name
	     2 BYTES keys to invoke program (second = 00h if only one key used)
	     3 BYTES ??? (I see 0 always)
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - ???
	AX = DE01h
	???
Return: nothing
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - ???
	AH = DEh
	AL =
	     02h  ???
		  Return: nothing (NOP in DV 2.00)
	     03h  ???
		  Return: nothing (NOP in DV 2.00)
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - GET AVAILABLE COMMON MEMORY
	AX = DE04h
Return: BX = bytes of common memory available
	CX = largest block available
	DX = total common memory in bytes
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - GET AVAILABLE CONVENTIONAL MEMORY
	AX = DE05h
Return: BX = K of memory available
	CX = largest block available
	DX = total conventional memory in K
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - GET AVAILABLE EXPANDED MEMORY
	AX = DE06h
Return: BX = K of expanded memory available
	CX = largest block available
	DX = total expanded memory in K
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - ???
	AH = DEh
	AL =
	     07h  ???
		  Return: AX = ???
	     08h  ???
		  Return: AX = 0  ???
			       1  ???
	     09h  ???
		  Return: nothing (NOP in DV 2.00)
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - DISPLAY CHARACTER ON STATUS LINE
	AX = DE0Ah
	BL = character
Return: character displayed, next call will display in next position (which
	wraps back to the start of the line if off the right edge of screen)
Notes:  displays character on bottom line of *physical* screen, regardless
	of current size of window (even entirely hidden)
	does not know about graphics display modes, just pokes the characters
	into display memory
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - ???
	AH = DEh
	AL =
	     0Bh  Set ???
		  BL = 0
		       1
		       2
		       >2 pops up error window in DV 2.00
		  BH = ???
		  Return: ???
	     0Ch  ???
		  BX = number of bytes ??? (gets converted to paragraphs)
		  Return: ES:DI = pointer to ???
	     0Dh  ???
		  Return: nothing
	     0Eh  ???
		  Return: BX = 0 ???
			       1 ???
	     0Fh  ???
		  Return: AX = ???
			  BX = ???
	     10h  ???
		  BX = ???
		  Return: BX = ???
	     11h  ???
		  BL = 0 ???
		       nonzero ???
		  Return: nothing
-----------------------------------------------------------
INT 16 - KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
	AH = 00h
Return: AH = scan code
	AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - CHECK BUFFER, DO NOT CLEAR
	AH = 01h
Return: ZF = 0 character in buffer
	    AH = scan code
	    AL = character
	ZF = 1 no character in buffer
-----------------------------------------------------------
INT 16 - KEYBOARD - GET SHIFT STATUS
	AH = 02h
	AL = shift status bits
	    0 = right shift key depressed
	    1 = left shift key depressed
	    2 = CTRL depressed
	    3 = ALT depressed
	    4 = SCROLL LOCK active
	    5 = NUM LOCK active
	    6 = CAPS LOCK active
	    7 = INSERT state active
-----------------------------------------------------------
INT 16 - KEYBOARD - SET DELAYS (Jr,AT model 339,XT286,PS)
	AH = 03h
	AL = subfunction
	    0 reset typematic (PCjr)
	    1 increase initial delay (PCjr)
	    2 increase continuing delay (PCjr)
	    3 increase both delays (PCjr)
	    4 turn off typematic (PCjr)
	    5 Set typematic rate (AT or PS/2)
	BH = 00 - 03 for delays of 250ms, 500ms, 750ms, or 1s
	BL = 00 - 1F for typematic rates of 30cps down to 2cps
-----------------------------------------------------------
INT 16 - KEYBOARD - KEYCLICK (Jr,CONV)
	AH = 04h
	AL =
	    0 click off
	    1 click on
-----------------------------------------------------------
INT 16 - KEYBOARD - WRITE TO KEYBOARD BUFFER (AT model 339,XT2,XT286,PS)
	AH = 05h
	CH = scan code
	CL = character
Return: AL = 1 if buffer full
-----------------------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
	AH = 10h
Return: AH = scan code
	AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
	AH = 11h
Return: ZF = 0 if keystroke available
	    AH = scan code \ meaningless if ZF = 1
	    AL = character /
	ZF = 1 if kbd buffer empty
-----------------------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS)
	AH = 12h
Return: AL (same as for AH=02)
	   bit 7: Ins ON
	   bit 6: CapsLock ON
	   bit 5: NumLock ON
	   bit 4: ScrollLock ON
	   bit 3: Either ALT key down
	   bit 2: Either CTRL key down
	   bit 1: Left shift key down
	   bit 0: Right shift key down
	AH
	   bit 7: SysReq key down
	   bit 6: CapsLock key down
	   bit 5: NumLock key down
	   bit 4: ScrollLock key down
	   bit 3: Right Alt key down
	   bit 2: Right Ctrl key down
	   bit 1: Left Alt key down
	   bit 0: Right Alt key down
-----------------------------------------------------------
INT 17 - PRINTER - OUTPUT CHARACTER
	AH = 00h
	AL = character
Return: AH = status bits
	    0 = time out
	    1 = unused
	    2 = unused
	    3 = I/O error
	    4 = selected
	    5 = out of paper
	    6 = acknowledge
	    7 = not busy
-----------------------------------------------------------
INT 17 - PRINTER - INITIALIZE
	AH = 01h
Return: AH = status (see above)
-----------------------------------------------------------
INT 17 - PRINTER - GET STATUS
	AH = 02h
Return: AH = status (see above)
-----------------------------------------------------------
INT 18 - TRANSFER TO ROM BASIC
   causes transfer to ROM-bases BASIC (IBM-PC)
   often reboots a compatible; often has no effect at all
-----------------------------------------------------------
INT 19 - DISK BOOT
   causes reboot of disk system (no memory test performed)
-----------------------------------------------------------
INT 1A - CLOCK - GET TIME OF DAY
	AH = 00h
Return: CX = high (most signif.) portion of clock count
	DX = low (least signif.) portion of clock count
	AL = 0 if clock was read or written (via AH=0,1)
	       within the current 24-hour period
	       Otherwise, AL > 0
-----------------------------------------------------------
INT 1A - CLOCK - SET TIME OF DAY
	AH = 01h
	CX = high (most signif.) portion of clock count
	DX = low (least signif.) portion of clock count
-----------------------------------------------------------
INT 1A - CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 02h
Return: CH = hours
	CL = minutes
	DH = seconds
-----------------------------------------------------------
INT 1A - CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 03h
	CH = hours
	CL = minutes
	DH = seconds
	DL = 1, if daylight savings; 0 if standard time
-----------------------------------------------------------
INT 1A - CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 04h
Return: DL = day
	DH = month
	CL = year
	CH = century (19 or 20)
-----------------------------------------------------------
INT 1A - CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 05h
	DL = day
	DH = month
	CL = year
	CH = century (19 or 20)
-----------------------------------------------------------
INT 1A - CLOCK - SET ALARM (AT,XT286,CONV,PS)
	AH = 06h
	CH = hours
	CL = minutes
	DH = seconds
Return: CF set if alarm already set or clock inoperable
	INT 4Ah will be called when alarm goes off
-----------------------------------------------------------
INT 1A - CLOCK - RESET ALARM (AT,XT286,CONV,PS)
	AH = 07h
-----------------------------------------------------------
INT 1A - CLOCK - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE)
	AH = 08h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
-----------------------------------------------------------
INT 1A - CLOCK - READ RTC ALARM TIME AND STATUS (CONV,PS30)
	AH = 09h
Return: CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
	DL = alarm status
	    0  alarm not enabled
	    1  alarm enabled but will not power up system
	    2  alarm will power up system
-----------------------------------------------------------
INT 1A - CLOCK - READ SYSTEM-TIMER DAY COUNTER (XT2,PS)
	AH = 0Ah
	???
Return: ???
-----------------------------------------------------------
INT 1A - CLOCK - SET SYSTEM-TIMER DAY COUNTER (XT2,PS)
	AH = 0Bh
	???
Return: ???
-----------------------------------------------------------
INT 1A - SET UP SOUND MULTIPLEXOR (PCjr ONLY)
	AH = 80h
	AL = 0 source is 8253 channel 2
	     1 source is cassette input
	     2 source is I/O channle "Audio IN"
	     3 source is sound generator chip
-----------------------------------------------------------
INT 1B - CTRL-BREAK KEY
   This interrupt is called when the keyboard scanner of the IBM
   machines detects CTRL and BREAK pressed at the same time. It
   normally points to a short routine in DOS which sets the
   Ctrl-C flag, thus invoking INT 23h the next time DOS checks
   for Ctrl-C.
-----------------------------------------------------------
INT 1C - CLOCK TICK
   This interrupt is called (in the IBM) at the end of each time-update
   operation by the real-time clock routines. It normally points to an
   IRET.
-----------------------------------------------------------
INT 1D -> 6845 VIDEO INIT TABLES
	table for modes 0 and 1   \
	table for modes 2 and 3    \ each table is 16 bytes long and
	table for modes 4,5, and 6 / contains values for 6845 registers
	table for mode 7          /
	4 words -- size of video RAM for modes 0/1, 2/3, 4/5, and 6/7
	8 bytes -- number of columns in each mode
	8 bytes -- video controller mode byte for each mode
-----------------------------------------------------------
INT 1E -> DISKETTE PARAMS (BASE TABLE)
	(Default at F000:EFC7 in PC and most compatibles)
	db      step rate & head unload times
	db      head load time & DMA
	db      motor off time
	db      sector size (0->128, 1->256, 2->512, 3->1024)
	db      last sector number (8 or 9 typical)
	db      inter-sector gap size on read/write (42 typical)
	db      data transfer length (255 typical)
	db      inter-sector gap size on format (80 typical)
	db      sector fill on format (f6 typical)
	db      head-settle time ms (typical 25, 2.10->15)
	db      motor start-up time (1/8 secs) (typical 4, 2.10->2)
-----------------------------------------------------------
INT 1F -> GRAPHICS SET 2
       (NOT a vector!) pointer to bitmaps for high 128 chars
-----------------------------------------------------------
INT 20 - Minix - SEND/RECEIVE MESSAGE
	AX = process ID of other process
	BX = pointer to message
	CX = 1 send
	     2 receive
	     3 send&receive
Note: the message contains the system call number (numbered as in V7 Unix(tm))
      and the call parameters
-----------------------------------------------------------
INT 20 - DOS - PROGRAM TERMINATION
returns to DOS
-----------------------------------------------------------
INT 21 - DOS - PROGRAM TERMINATION
	AH = 00h
Same action as INT 20; returns to DOS.
-----------------------------------------------------------
INT 21 - DOS - KEYBOARD INPUT
	AH = 01h
Return: AL = character read
-----------------------------------------------------------
INT 21 - DOS - DISPLAY OUTPUT
	AH = 02h
	DL = character
-----------------------------------------------------------
INT 21 - DOS - AUX INPUT
	AH = 03h
Return: AL = character read
-----------------------------------------------------------
INT 21 - DOS - AUX OUTPUT
	AH = 04h
	DL = character to send
-----------------------------------------------------------
INT 21 - DOS - PRINTER OUTPUT
	AH = 05h
	DL = character to print
-----------------------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
	AH = 06h
	DL = character <> FFh
-----------------------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER INPUT
	AH = 06h
	DL = 0FFh
Return: ZF set   = no character
	ZF clear = character recieved
		  AL = character
Note: Character is echoed to STDOUT if received.
-----------------------------------------------------------
INT 21 - DOS - DIRECT STDIN INPUT, NO ECHO
	Reg AH = 07h
Note: same as Function 6 for input but char not echoed
-----------------------------------------------------------
INT 21 - DOS - KEYBOARD INPUT, NO ECHO
	AH = 08h
Return: AL = character
-----------------------------------------------------------
INT 21 - DOS - PRINT STRING
	AH = 09h
	DS:DX = address of string terminated by "$"
-----------------------------------------------------------
INT 21 - DOS - BUFFERED KEYBOARD INPUT
	AH = 0Ah
	DS:DX = address of buffer
Note: first byte of buffer must contain maximum length
      on return the second byte contains actual length, third and
	subsequent bytes contain the input line
-----------------------------------------------------------
INT 21 - DOS - CHECK STANDARD INPUT STATUS
	AH = 0Bh
Return: AL = FFh if character available
	     00h if no character
-----------------------------------------------------------
INT 21 - DOS - CLEAR KEYBOARD BUFFER
	AH = 0Ch
	AL must be 1, 6, 7, 8, or 0Ah.
Flushes all typeahead input, then executes function specified
by AL (effectively moving it to AH and repeating the INT 21 call).
  If AL contains a value not in the list above, the keyboard buffer is
flushed and no other action is taken.
-----------------------------------------------------------
INT 21 - DOS - DISK RESET
	AH = 0Dh
Flushes all disk buffers.
-----------------------------------------------------------
INT 21 - DOS - SELECT DISK
	AH = 0Eh
	DL = new default drive number (0 = A, 1 = B, etc.)
Return: AL = number of logical drives
-----------------------------------------------------------
INT 21 - DOS - OPEN DISK FILE
	AH = 0Fh
	DS:DX = address of FCB
Return: AL = 00h file found
	     FFh file not found
-----------------------------------------------------------
INT 21 - DOS - CLOSE DISK FILE
	AH = 10h
	DS:DX = address of FCB
Return: AL = 00h directory update successful
	     FFh file not found in directory
-----------------------------------------------------------
INT 21 - DOS - SEARCH FIRST USING FCB
	AH = 11h
	DS:DX = address of FCB
Return: AL = status
	    00h file found
	    FFh file not found
Note: If file found, FCB is created at DTA address and set up to
      OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - DOS - SEARCH NEXT USING FCB
	AH = 12h
	DS:DX = address of FCB
Return: AL = status
	    00h file found
	    FFh file not found
Note: If file found, FCB is created at DTA address and set up to
      OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - DOS - DELETE FILE via FCB
	AH = 13h
	DS:DX = address of FCB
Return: AL = status
	    00h file found
	    FFh file not found
-----------------------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK FILE READ
	AH = 14h
	DS:DX = address of FCB
Return: AL = status
	    0 successful read
	    1 end of file
	    2 data transfer area too small
	    3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK RECORD WRITE
	AH = 15h
	DS:DX = address of FCB
Return: AL = status
	    0 successful write
	    1 disk full
	    2 data transfer area too small
-----------------------------------------------------------
INT 21 - DOS - CREATE A DISK FILE
	AH = 16h
	DS:DX = address of FCB
Return: AL = status
	    00h successful creation
	    FFh directory full
-----------------------------------------------------------
INT 21 - DOS - RENAME FILE via FCB
	AH = 17h
	DS:DX = address of FCB
	FCB contains new name starting at byte 17h.
Return: AL = status
	    00h file found
	    FFh file not found
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
	AH = 18h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS - GET DEFAULT DISK NUMBER
	AH = 19h
Return: AL = current drive number (letter - 'A')
-----------------------------------------------------------
INT 21 - DOS - SET DISK TRANSFER AREA ADDRESS
	AH = 1Ah
	DS:DX = address of buffer
-----------------------------------------------------------
INT 21 - DOS - GET DEFAULT DRIVE DISK SIZE
	AH = 1Bh
Return: DS:BX points to FAT ID byte
	DX = number of allocation units on disk
	AL = number of sectors per allocation unit (cluster)
	CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - DOS - GET SPECIFIC DRIVE'S DISK SIZE
	AH = 1Ch
	DL = Drive Number to check
Return: DS:BX points to FAT ID byte
	DX = number of allocation units on disk
	AL = number of sectors per allocation unit (cluster)
	CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
	AH = 1Dh
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
	AH = 1Eh
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - GET DEFAULT DRIVE PARAMETER BLOCK
	AH = 1Fh
Return: AL = 00h No Error
	     FFh Error
	DS:BX = pointer to drive parameter block
Note: for DOS 2.x and 3.x, this just invokes function 32h with DL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
	AH = 20h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD READ
	AH = 21h
	DS:DX = address of FCB
Return: AL = status
	    0 successful read
	    1 end of file
	    2 data transfer area too small
	    3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD WRITE
	AH = 22h
Same setup as Random Read, but writes to disk
-----------------------------------------------------------
INT 21 - DOS - GET FILE SIZE
	AH = 23h
	DS:DX = address of FCB
Return: AL = status
	    00h file found
	    FFh file not found
Note: FCB set to number of records
-----------------------------------------------------------
INT 21 - DOS - SET RANDOM RECORD FIELD
	AH = 24h
	DS:DX = address of FCB
Return: Random Record Field of FCB is set to be same as Current Block
	and Current Record.
Note: FCB must be OPEN already
-----------------------------------------------------------
INT 21 - DOS - SET INTERRUPT VECTOR
	AH = 25h
	AL = interrupt number
	DS:DX = new vector to be used for specified interrupt
-----------------------------------------------------------
INT 21 - DOS - CREATE PSP
	AH = 26h
	DX = Segment number to set up PSP at
Return: Current PSP is copied to specified segment
-----------------------------------------------------------
INT 21 - DOS - RANDOM BLOCK READ
	AH = 27h
	DS:DX = address of FCB
	CX = number of records to be read
Return: AL = status
	    0 successful read
	    1 end of file
	    2 data transfer area too small
	    3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - RANDOM BLOCK WRITE
	AH = 28h
	DS:DX = address of FCB
	CX = number of records to be written
	     if zero, truncate file to current random file position
Return: AL = status
	    0 successful write
	    1 disk full
	    2 data transfer area too small
-----------------------------------------------------------
INT 21 - DOS - PARSE FILENAME
	AH = 29h
	DS:SI = pointer to string to parse
	ES:DI = pointer to memory to fill with unopened FCB
	AL = bit mask to control parsing
	    0 = 0: parsing stops if file separator found
		1: leading separator ignored
	    1 = 0: drive number in FCB set to default drive if not present
		   in string
		1: drive number in FCB not changed
	    2 = 0: filename in FCB set to blanks if no filename in string
		1: filename in FCB not changed if string does not contain
		   a filename
	    3 = 0: extension in FCB set to blanks if no extension in string
		1: extension left unchanged
Return: AL = 00: no wildcards in name or extension
	     01: wildcards appeared
	DS:SI = pointer to first byte after parsed string
	ES:DI = unopened FCB
-----------------------------------------------------------
INT 21 - DOS - GET CURRENT DATE
	AH = 2Ah
Return: DL = day
	DH = month
	CX = year
	AL = day of the week (0=Sunday, 1=Monday, etc.)
-----------------------------------------------------------
INT 21 - DOS - SET CURRENT DATE
	AH = 2Bh
	DL = day
	DH = month
	CX = year
Return: AL = 00h if no error
	AL = FFh if bad value sent to routine
	(DOS 3.3 also sets CMOS clock)
-----------------------------------------------------------
INT 21 - DESQview - INSTALLATION CHECK
	AH = 2Bh
	AL = subfunction
	    01h get version
		Return: BX = version (v2.00 returns 2, v2.01 returns 0201h)
	    02h ???
	    04h returns BH = ???, BL = ???, DX = ???
	    05h ???
	CX = 4445h
	DX = 5351h
Return: AL = 00h if DESQview installed, plus any other return values
	   = FFh if DESQview not installed
-----------------------------------------------------------
INT 21 - DOS - GET CURRENT TIME
	AH = 2Ch
Return: CH = hours
	CL = minutes
	DH = seconds
	DL = hundredths of seconds
Note: time is updated approximately every 5/100 second
-----------------------------------------------------------
INT 21 - DOS - SET CURRENT TIME
	AH = 2Dh
	CH = hours
	CL = minutes
	DH = seconds
	DL = hundredths of seconds
Return: AL = 00h if no error
	AL = FFh if bad value sent to routine
	(DOS 3.3 also sets CMOS clock)
-----------------------------------------------------------
INT 21 - DOS - SET VERIFY FLAG
	AH = 2Eh
	DL = 0
	AL = 1 VERIFY on
	     0 VERIFY off
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DISK TRANSFER AREA ADDRESS
	AH = 2Fh
Return: ES:BX = address of DTA
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DOS VERSION
	AH = 30h
Return: AL = Major Version number
	AH = Minor Version number
	BH = OEM number
	BL:CX = 24-bit user number
-----------------------------------------------------------
INT 21 - DOS 2+ - TERMINATE BUT STAY RESIDENT
	AH = 31h
	AL = exit code
	DX = program size, in paragraphs
-----------------------------------------------------------
INT 21 - DOS Internal - GET DRIVE PARAMETER BLOCK
	AH = 32h
	DL = drive number
	    0 = default, 1 = A, etc.
Return: AL = 0FFh if invalid drive number, else
	DS:BX = address of drive parameter block.

		STRUCTURE OF DOS DRIVE PARAMETER BLOCK:

DPBLOCK         STRUCT          ;OFFSET
DISK_OFFSET     DB      ?       ;  0.  drive number (0 = A, etc.)
UNIT_OFFSET     DB      ?       ;  1.  unit number within device driver
SECTOR_SIZE     DW      ?       ;  2.  number of bytes per sector
MAX_CLUSTER     DB      ?       ;  4.  largest sector number in cluster
				;      add one for number of sectors/cluster
LOG2_SECTORS    DB      ?       ;  5.  log base two of the cluster size
RESERVED        DW      ?       ;  6.  number of reserved (boot) sectors
FAT_COUNT       DB      ?       ;  8.  number of copies of the FAT
ROOT_COUNT      DW      ?       ;  9.  number of root directory entries
DATA_START      DW      ?       ; 11.  first data sector on medium
MAX_NUMBER      DW      ?       ; 13.  largest possible cluster number
				;      subtract one for number of data clusters
FAT_SECTORS     DB      ?       ; 15.  number of sectors in one FAT copy
ROOT_START      DW      ?       ; 16.  first sector of root directory
DEVICE_ADDR     DD      ?       ; 18.  address of device driver for this drive
DESCRIPTOR      DB      ?       ; 22.  media descriptor byte for medium
VALID_BYTE      DB      ?       ; 23.  0FFh indicates block must be rebuilt
NEXT_BLOCK      DD      ?       ; 24.  address of next device block in list

;       FROM THIS POINT ON, DOS 3 DIFFERS FROM 2:

		IF      DOS2
DIR_START       DW      ?       ; 28.  starting cluster of current directory
				;      zero indicates the root directory
PATH_NAME       DB      64 DUP (?)
				; 30.  ASCIIZ current directory path string
		ELSE    DOS3
;               on my XT, this was always:
		DW      0
		DW      0FFFFh
		ENDIF
DPBLOCK         ENDS
-----------------------------------------------------------
INT 21 - DOS 2+ - EXTENDED CONTROL-BREAK CHECKING
	AH = 33h
	AL = subfunction
	    00h Get State
	    01h Set
	       DL = 0 for OFF or 1 for ON
	    02h internal, called by PRINT.COM (DOS 3.1)
Return: DL = current BREAK setting if AL = 00h
	    0 BREAK=OFF
	    1 BREAK=ON
	AL = FFh if error
-----------------------------------------------------------
INT 21 - DOS Internal - RETURN CritSectFlag POINTER
	AH = 34h
Return: ES:BX points to DOS "Critical Section Flag"
Notes:
   When byte pointed to is zero, DOS is supposed to be safe to interrupt.
   NOT RELIABLE according to Chris Dunford.

   Examination of DOS 2.10 code in this area indicates that the byte
   immediately FOLLOWING this "Critical Section Flag" must be 00 to permit
   the PRINT.COM interrupt to be called.

   For DOS 3.0 and 3.1 (except COMPAQ DOS 3.0), the byte BEFORE the
   "Critical Section Flag" must be zero, and for COMPAQ DOS 3.0, the byte
   01AAh before it must be zero.
-----------------------------------------------------------
INT 21 - DOS 2+ - GET INTERRUPT VECTOR
	AH = 35h
	AL = interrupt number
Return: ES:BX = value of interrupt vector
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DISK SPACE
	AH = 36h
	DL = drive code (0 = default, 1 = A, 2 = B, etc.)
Return: AX = number of sectors per cluster
	     or 0FFFFh if invalid drive
	BX = number of available clusters
	CX = bytes per sector
	DX = total clusters
Note: multiply AX x CX x BX for free space on disk
      multiply AX x CX x DX for total disk space
-----------------------------------------------------------
INT 21 - DOS Internal - SWITCHAR/AVAILDEV
	AH = 37h
	AL = subfunction
	   0 Read switch character (returns current character in DL)
	   1 Set switch character (specify new character in DL)
	   2 (DOS 2.x only) Read device availability (as set by function AL=3)
	   3 (DOS 2.x only) Set device availability, where:
	     DL = 0 means /DEV/ must preceed device names
	     DL <> 0 means /DEV/ need not preceed device names
Return: DL = Switch character (if AL=0 or 1)
	     Device availability flag (if AL=2 or 3)
	AL=0FFh means the value in AL was not in the range 0-3.
-----------------------------------------------------------
INT 21 - DOS 2+ - GET COUNTRY-DEPENDENT INFORMATION
	AH = 38h
--DOS 2.x--
	AL = 0  get current-country info
	DS:DX = segment:offset of buffer for returned info
Return: BX = country code
	buffer at DS:DX filled as follows:
	   bytes 0-1 = date format   0 = USA    mm dd yy
				     1 = Europe dd mm yy
				     2 = Japan  yy mm dd
	   byte 2    = currency symbol
	   byte 3    = 00h
	   byte 4    = thousands separator char
	   byte 5    = 00h
	   byte 6    = decimal separator char
	   byte 7    = 00h
	   bytes 8-1Fh reserved

--DOS 3.x--
	AL = 0 for current country
	AL = 01h thru 0FEh for specific country with code <255
	AL = 0FFh for specific country with code >= 255
	   BX = 16-bit country code
	DS:DX = segment:offset of buffer for returned info
	DX = 0FFFFh if setting country code, rather than getting info
Return: (if DX <> 0FFFFh)
	BX = country code
	DS:DX filled in:
	      bytes 0-1 = date format (see above)
	      bytes 2-6 = currency symbol string, ASCIZ
	      byte 7    = thousands seaprator char
	      byte 8    = 00h
	      byte 9    = decimal separator char
	      byte 0Ah  = 00h
	      byte 0Bh  = date separator char
	      byte 0Ch  = 00h
	      byte 0Dh  = time separator char
	      byte 0Eh  = 00h
	      byte 0Fh  = currency format
			   bit 1 = number of spaces between value and curr sym
			   bit 0 = 0 if currency symbol precedes value
				   1 if currency symbol follows value
	      byte 10h  = number of digits after decimal in currency
	      byte 11h  = time format
			   bit 0 = 0 if 12-hour clock
				   1 if 24-hour clock
	      bytes 12h-15h = address of case map routine (FAR CALL)
	      byte 16h  = data-list separator char
	      byte 17h  = 00h
	      bytes 18h-21h reserved
      If error:
	CF set
	AX = error code
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE A SUBDIRECTORY (MKDIR)
	AH = 39h
	DS:DX = address of ASCIIZ pathname
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - REMOVE A DIRECTORY ENTRY (RMDIR)
	AH = 3Ah
	DS:DX = address of ASCIIZ pathname
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - CHANGE THE CURRENT DIRECTORY (CHDIR)
	AH = 3Bh
	DS:DX = address of ASCIIZ directory name
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE A FILE WITH HANDLE (CREAT)
	AH = 3Ch
	CX = attributes for file
	DS:DX = address of ASCIZ filename
Return: CF = 1 if error
	    AX = Error Code
	CF = 0 successful
	    AX = file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - OPEN DISK FILE WITH HANDLE
	AH = 3Dh
	AL = access code
	    0 = Read Only
	    1 = Write Only
	    2 = Read/Write
	AL bits 7-3 = file-sharing modes (DOS 3.x)
	    bit 7    = inheritance flag, set for no inheritance
	    bits 4-6 = sharing mode
		      000 compatibility mode
		      001 exclusive (deny all)
		      010 write access denied (deny write)
		      011 read access denied (deny read)
		      100 full access permitted (deny none)
	    bit 3    = reserved, should be zero
	DS:DX = address of ASCIZ filename
	DX = OFFSET ADDRESS OF ASCIIZ
Return: CF = 1 if error
	    AX = Error Code
	CF = 0 successful
	    AX = file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - CLOSE A FILE WITH HANDLE
	AH = 3Eh
	BX = file handle
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - READ FROM FILE WITH HANDLE
	AH = 3Fh
	BX = file handle
	CX = number of bytes to read
	DS:DX = address of buffer
Return: CF = 1 if error
	    AX = Error Code
	CF = 0 successful
	    AX = number of bytes read
-----------------------------------------------------------
INT 21 - DOS 2+ - WRITE TO FILE WITH HANDLE
	AH = 40h
	BX = file handle
	CX = number of bytes to write
	DS:DX = pointer to buffer
Return: CF = 1 if error
	    AX = Error Code
	CF = 0 successful
	    AX = number of bytes written
Note: if CX is zero, no data is written, and the file is truncated or extended
      to the current position
-----------------------------------------------------------
INT 21 - DOS 2+ - DELETE A FILE (UNLINK)
	AH = 41h
	DS:DX = pointer to ASCIIZ name of file to delete
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
	AH = 42h
	AL = method value
	    0 = offset from beginning of file
	    1 = offset from present location
	    2 = offset from end of file
	BX = file handle
	CX:DX = offset in bytes
Return: CF = 1 if error
	    AX = Error Code
	CF = 0 successful
	    DX:AX = new offset
-----------------------------------------------------------
INT 21 - DOS 2+ - GET/PUT FILE ATTRIBUTES (CHMOD)
	AH = 43h
	AL =
	    0 = get file attributes
	    1 = put file attributes
	       CX = file attribute bits
		   0 = read only
		   1 = hidden file
		   2 = system file
		   3 = volume label
		   4 = subdirectory
		   5 = written since backup
	DX = pointer to ASCIIZ file name
Return: CF = 1 if error
	    AX = Error Code if any
	CX = file attributes on get
-----------------------------------------------------------
INT 21 - DOS 2+ - IOCTL
	AH = 44h
	AL =
	   0 = Get device information (DX)
	   1 = Set device information (DH must be 0 on entry)
	       DX BITS =
		 0 = console input device
		 1 = console output device
		 2 = null device
		 3 = clock device
		 5 = binary mode
		 6 = EOF
		 7 = device is character device if set
		     if not, EOF = 0 if channel has been written
		     bits 0-5 are block device number
		12 = network device
		14 = can process control strings (AL=2-5, can only be read)
		15 reserved
	   2 = Read CX bytes to DS:DX from BX control channel
	       Return: AX = number of bytes transferred
	   3 = Write CX bytes from DS:DX from BX control channel
	       Return: AX = number of bytes transferred
	   4 = as 2 but for drive BL
	       Return: AX = number of bytes transferred
	   5 = as 3 but for drive BL
	       Return: AX = number of bytes transferred
	   6 = Get input status
	       Return: AL = FFh for ready, 00h for not ready
	   7 = Get output status
	       Return: AL = FFh for ready or 00h for not ready
	   8 = Is block device BL changeable? (DOS 3.x)
	       Return: AX = 0 removable
			    1 fixed
	   9 = Is logical device BL local? (DOS 3.x)
	       DX (attribute word) bit 12 (1000h) = 0 = yes
	  10 = Is handle BX local? (DOS 3)
	       DX (attribute word) bit 15 (8000h) = 0 = yes
	  11 = Change sharing retry count to DX (def 3), (DOS 3.x)
	       delay CX (def 1)
	  12 = General IOCTL (DOS 3.3 [3.2?])
	BX = file handle (or BL = drive number w/0 = default)
Return: CF = 1 if error
	    AX = Error Code
Note: only subfunctions 00h,06h,07h are available for files
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE DUPLICATE HANDLE (DUP)
	AH = 45h
	BX = file handle to duplicate
Return: CF = 1 if error
	    AX = Error Code
	CF = 0 successful
	    AX = new file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - FORCE DUPLICATE HANDLE (FORCDUP) (DUP2)
	AH = 46h
	BX = Existing file handle
	CX = new file handle
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - GET CURRENT DIRECTORY
	AH = 47h
	DL = drive (0=default, 1=A, etc.)
	DS:SI points to 64-byte buffer area
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - ALLOCATE MEMORY
	AH = 48h
	BX = number of 16-byte paragraphs desired
Return: CF = 1 if error
	    AX = Error Code
	    BX = Maximum available
	CF = 0 successful
	    AX = segment of allocated memory block
-----------------------------------------------------------
INT 21 - DOS 2+ - FREE MEMORY
	AH = 49h
	ES = Segment address of area to be freed
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
	AH = 4Ah
	ES = Segment address of block to change
	BX = New size in paragraphs
Return: CF = 1 if error
	    AX = Error Code
	    BX = Maximum size possible for the block
-----------------------------------------------------------
INT 21 - DOS 2+ - LOAD OR EXECUTE (EXEC)
	AH = 4Bh
	AL = subfunction
	    0 = load and execute program
	    2 = load (Internal) but do not execute
	    3 = load overlay; do not create PSP
	DS:DX = filename
	ES:BX = parameter block
	       AL =
		0 => word segment environment pointer
		     dword command line pointer
		     dword FCB 1
		     dword FCB 2
		3 => word segment load address
		     word segment relocation factor
Return: CF = 1 if error
	    AX = Error Code

struct exec {
	unsigned exec_magic;    /* 0x4d, 0x5a signature */
	unsigned exec_isr;      /* image size remainder (mod 512) */
	unsigned exec_size;     /* file size in pages (512) */
	unsigned exec_nrel;     /* number of relocation items */
	unsigned exec_hsize;    /* header size in paragraphs */
	unsigned exec_min;      /* minimum extra paragraphs */
	unsigned exec_max;      /* maximum extra paragraphs */
	unsigned exec_ss;       /* stack segment */
	unsigned exec_sp;       /* stack offset */
	unsigned exec_cksum;    /* word checksum of entire file */
	unsigned exec_pc;       /* initial pc */
	unsigned exec_cs;       /* code segment */
	unsigned exec_orel;     /* offset of relocation table */
	unsigned exec_ovno;     /* overlay number */
};
-----------------------------------------------------------
INT 21 - DOS 2+ - QUIT WITH EXIT CODE (EXIT)
	AH = 4Ch
	AL = exit code
Return: never returns
-----------------------------------------------------------
INT 21 - DOS 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
	AH = 4Dh
Return: AL = exit code of subprogram (functions 31h or 4Ch)
	AH = circumstance which caused termination
	    0 = Terminate/abort
	    1 = Control-C
	    2 = Hard error
	    3 = Terminate and stay resident
-----------------------------------------------------------
INT 21 - DOS 2+ - FIND FIRST ASCIIZ (FIND FIRST)
	AH = 4Eh
	CX = search attributes
	DS:DX = pointer to ASCIIZ filename
Return: CF = 1 if error
	    AX = Error Code if any
	[DTA] = data block
	      byte  00h:     drive letter (undocumented)
	      bytes 01h-0Bh: search template (undocumented)
	      bytes 0Ch-14h: reserved
	      byte  15h:     attribute of file found
	      bytes 16h-17h: file time
	      bytes 18h-19h: file date
	      bytes 1Ah-1Dh: file size
	      bytes 1Eh-3Ah: ASCIZ filename+extension
-----------------------------------------------------------
INT 21 - DOS 2+ - FIND NEXT ASCIIZ (FIND NEXT)
	AH = 4Fh
Return: CF = 1 if error
	    AX = Error Code
	[DTA] = data block, see AH = 4Eh above
-----------------------------------------------------------
INT 21 - DOS Internal - SET PSP SEGMENT
	AH = 50h
	BX = Segment address of new PSP
Note: under DOS 2.xx, this function cannot be invoked inside an INT 28h handler
      without a prior call to function 5Dh
-----------------------------------------------------------
INT 21 - DOS Internal - GET PSP SEGMENT
	AH = 51h
Return: BX = Current PSP Segment

struct psp {
	char psp_int20[2];      /* 00h: exit */
	unsigned psp_msize;     /* 02h: memory size in paragraphs */
	char psp_res0[1];       /* 04h: ??? (0) */
	char psp_dos[5];        /* 05h: far call to dos */
	int (*psp_term)();      /* 0ah: terminate address */
	unsigned psp_tseg;      /* 0ch: terminate segment */
	int (*psp_break)();     /* 0eh: break address */
	unsigned psp_bseg;      /* 10h: break segment */
	int (*psp_error)();     /* 12h: error address */
	unsigned psp_eseg;      /* 14h: error segment */
	unsigned psp_ppsp;      /* 16h: parent psp segment */
	char psp_ofile[20];     /* 18h: open files, 0xff = unused */
	unsigned psp_envp;      /* 2ch: environment segment */
	char far *psp_oldstack; /* 2eh: far ptr to processes SS:SP??? */
	int psp_nfiles;         /* 32h: max open files */
	char *psp_aofile;       /* 34h: ofile address */
	unsigned psp_aoseg;     /* 36h: ofile segment */
	char psp_res3[24];      /* 38h: unused??? */
	char psp_int21[3];      /* 50h: int 21, far return */
	char psp_res4[2];       /* 53h: unused??? */
	char psp_xfcb1[7];      /* 55h: FCB #1 extension */
	char psp_fcb1[9];       /* 5ch: FCB #1 */
	char psp_xfcb2[7];      /* 65h: FCB #2 extension */
	char psp_fcb2[20];      /* 6ch: FCB #2 */
	char psp_dma[128];      /* 80h: Command Tail */
};
Note: under DOS 2.xx, this function cannot be invoked inside an INT 28h handler
      without a prior call to function 5Dh
-----------------------------------------------------------
INT 21 - DOS Internal - GET DISK LIST
	AH = 52h
Return: ES:BX points to DOS list of lists

List of Lists:
Bytes   Value
-2&-1   Segment of first memory control block
0-3     Pointer to first DOS disk block (see func 36h)
4-7     ??? Partially Unknown. Pointer to a device driver. Maybe first
	       resident driver?
8-B     Pointer to CLOCK$ device driver, whether installable or
	       resident
C-F     Pointer to actual CON: device driver, whether installable
	       or resident
-----DOS 2.x
10      Number of logical drives in system
11-12   Maximum bytes/block of any block device
13-16   ???
17      Beginning (not a pointer. The real beginning!) of NUL device
	   driver. This is the first device on DOS's linked list
	   of device drivers.
-----DOS 3.x
10-11   Maximum bytes/block of any block device (0200h)
12-15   ??? Pointer to current directory block?
16-19   Partially Undefined: Pointer to array of drive info:
	       51h bytes per drive, starting with A: ...
	       00-3F Current path as ASCIIZ, starting with 'x:\'
	       40-43 ??? I see zeros always
	       44    ??? Flags? I see 40h, except for
		       entry after last valid entry = 00h
	       45-48 Pointer to DOS Disk Block for this drive
	       49-4A ??? Current track or block? -1 if never accessed.
	       4B-4E ??? I see -1 always
	       4F-52 ??? I see 2 always
1A-1D   ??? Pointer to data area, maybe including cluster
	       allocation table?
1E-1F   ??? I see zero always
20      Number of block devices.
21      Value of LASTDRIVE command in CONFIG.SYS (default 5)
22      Beginning (not a pointer. The real beginning!) of NUL device
	   driver. This is the first device on DOS's linked list
	   of device drivers.
-----------------------------------------------------------
INT 21 - DOS Internal - TRANSLATE BPB
	AH = 53h
	DS:SI points to BPB (Bios Parameter Block)
	ES:BP points to area for DOS Disk Block
Translates BPB (Bios Parameter Block, see below) into a DOS Disk Block
(see function call 32h).

BPB
Bytes   Value
0-1     Bytes/sector. Get from DDB bytes 2-3.
2       Sectors/cluster. Get from: (DDB byte 4) + 1
3-4     Reserved sectors. Get from: DDB bytes 6-7
5       Number of FATs. Get from: DDB byte 8
6-7     Number of root dir entries. Get from: DDB bytes 9-A
8-9     Total # of sectors. Get from:
	((DDB bytes D-E) - 1) * (sectors per cluster (BPB byte 2))
	  + (DDB Bytes B-C)
A       Media descriptor byte. Get from: DDB byte 16
B-C     Number of sectors/FAT. Get from: DDB byte F
-----------------------------------------------------------
INT 21 - DOS 2+ - GET VERIFY FLAG
	AH = 54h
Return: AL = 0 if flag OFF
	AL = 1 if flag ON
-----------------------------------------------------------
INT 21 - DOS Internal - CREATE PSP
	AH = 55h
	DX = Segment number to set up PSP at
Note: Like func 26h but creates "child" PSP rather than copying existing one.
-----------------------------------------------------------
INT 21 - DOS 2+ - RENAME A FILE
	AH = 56h
	DS:DX = pointer to ASCIZ old name
	ES:DI = pointer to ASCIZ new name
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - GET/SET FILE'S DATE/TIME
	AH = 57h
	AL = function code
	    0 = get date and time
	    1 = set date and time
	       CX = time to be set
	       DX = date to be set
	BX = file handle
Return: CF = 1 if error
	    AX = Error Code
	CX = time of last write (if AL = 0)
	DX = date of last write (if AL = 0)
-----------------------------------------------------------
INT 21 - DOS 3.x - GET/SET MEMORY ALLOCATION STRATEGY
	AH = 58h
	AL = function code
	    0 = get allocation strategy
	    1 = set allocation strategy
	       BL = strategy code
		   0 first fit (use first memory block large enough)
		   1 best fit (use smallest memory block large enough)
		   2 last fit (use high part of last usable memory block)
Return: CF = 1 error
	    AX = Error Code
	CF = 0 successful
	    AX = strategy code
Note: the Set subfunction accepts any value in BL; 2 or greater means last fit.
      the Get subfunction returns the last value set, so programs should check
      whether the value is >= 2, not just equal to 2.
-----------------------------------------------------------
INT 21 - DOS 3.x - GET EXTENDED ERROR CODE
	AH = 59h
	BX = version code (0000 for DOS 3.0)
Return: AX = extended error code
	BH = class of error
	BL = suggested action code
	CH = locus (where error occurred)
Error codes:
	01 function number invalid
	02 file not found
	03 path not found
	04 too many open files
	05 access denied
	06 invalid handle
	07 memory control block destroyed
	08 insufficient memory
	09 memory block address invalid
	0A environment invalid
	0B format invalid
	0C access code invalid
	0D data invalid
	0F invalid drive
	10 attempted to remove current directory
	11 not same device
	12 no more files
	13 disk write-protected
	14 unknown unit
	15 drive not ready
	16 unknown command
	17 data error (CRC)
	18 bad request structure length
	19 seek error
	1A unknwon media type
	1B sector not found
	1C printer out of paper
	1D write fault
	1E read fault
	1F general failure
	20 sharing violation
	21 lock violation
	22 disk change invalid
	23 FCB unavailable
	24 sharing buffer overflow
	25-31 reserved
	32 Network request not supported (DOS 3.1 + MS Networks)
	33 Remote computer not listening
	34 Duplicate name on network
	35 Network name not found
	36 Network busy
	37 Network device no longer exists
	38 Network BIOS command limit exceeded
	39 Network adapter hardware error
	3A Incorrect response from network
	3B Unexpected network error
	3C Incompatible remote adapter
	3D Print queue full
	3E Queue not full
	3F Not enough space to print file
	40 Network name was deleted
	41 Network: Access denied
	42 Network device type incorrect
	43 Network name not found
	44 Network name limit exceeded
	45 Network BIOS session limit exceeded
	46 Temporarily paused
	47 Network request not accepted
	48 Print/disk redirection paused (DOS 3.1 + MS Networks)
	49-4F reserved
	50 file exists
	51 reserved
	52 cannot make directory
	53 fail on INT 24h
Error Classes:
	01 out of resource
	02 temporary situation
	03 authorization (denied access)
	04 internal
	05 hardware failure
	06 system failure
	07 application program error
	08 not found
	09 bad format
	0A locked
	0B media error
	0C already exists
	0D unknown
Suggested Action:
	01 retry
	02 delayed retry
	03 prompt user
	04 abort after cleanup
	05 immediate abort
	06 ignore
	07 retry after user intervention
Error Locus:
	01 unknown or not appropriate
	02 block device
	03 network related
	04 serial device
	05 memory related
-----------------------------------------------------------
INT 21 - DOS 3.x - CREATE TEMPORARY FILE
	AH = 5Ah
	DS:DX = pointer to ASCIZ directory path name
	CX = file attribute
Return: CF = 1 if error
	    AX = Error Code if any
	DS:DX = path name
Note: The file created is not truly "temporary".  It MUST be removed by the
      user.
-----------------------------------------------------------
INT 21 - DOS 3.x - CREATE NEW FILE
	AH = 5Bh
	DS:DX = pointer to ASCIZ directory path name
	CX = file attribute
Return: CF = 1 if error
	    AX = Error Code if any
	DS:DX = path name
Note: Unlike function 3Ch, function 5Bh will fail if the file already exists.
-----------------------------------------------------------
INT 21 - DOS 3.x - LOCK/UNLOCK FILE ACCESS
	AH = 5Ch
	AL = 0 if lock
	     1 if unlock
	BX = file handle
	CX:DX = starting offset of region to lock
	SI:DI = size of region to lock
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - GET ADDRESS OF CRITICAL ERROR FLAG
	AX = 5D06h
Return: DS:SI = pointer to critical error flag
	CX = ???
	DX = ???
Note: this call also does a lot of other work in addition to returning the
      pointer
Note: setting CritErr flag allows use of functions 50h/51h from INT 28h under
      DOS 2.x by forcing use of correct stack
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - ???
	AH = 5Dh
	AL = subfunction
	     07h: ???
	     08h: (used by COMMAND.COM)
	     09h: (used by COMMAND.COM)
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET MACHINE NAME
	AX = 5E00h
	DS:DX -> buffer for ASCIIZ name
Return: CF = 1 if error
	    AX = Error Code
	CH = 0 if name not defined
	CL = NETBIOS name number
	DS:DX -> pointer to identifier if CH <> 0
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - SET PRINTER SETUP
	AX = 5E02h
	BX = Redirection list index
	CX = length of setup string <= 64
	DS:SI -> string buffer
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET PRINTER SETUP
	AX = 5E03h
	BX = Redirection list index
	ES:DI -> string buffer
Return: CF = 1 if error
	    AX = Error Code
	CX = length of setup string <= 64
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET REDIRECTION LIST ENTRY
	AX = 5F02h
	BX = Redirection list index
	DS:SI -> 16 char local device name buffer
	ES:DI -> 128 char network name buffer
Return: CF = 1 if error
	    AX = Error Code
	BH = Device status flag (BIT 0 = 0 if valid)
	BL = device type (03 if printer, 04 if drive)
	CX = stored parameter value
Note: DX and BP are destroyed by this call!
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - REDIRECT DEVICE
	AX = 5F03h
	BL = device type
		03 = printer device
		04 = file device
	CX = stored parameter value
	DS:SI -> source device name
	ES:DI -> destination ASCIIZ network path + ASCIIZ password
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - CANCEL REDIRECTION
	AX = 5F04h
	DS:SI -> device name or network path
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - RESOLVE PATH STRING TO FULLY QUALIFIED PATH STRING
	AH = 60h
	DI:SI = relative path strings
	ES:DI = buffer for fully qualified name
Return: buffer filled with qualified name; may return error code, unknown.
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - UNUSED
	AH = 61h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS 3.x - GET PSP ADDRESS
	AH = 62h
Return: BX = segment address of PSP
-----------------------------------------------------------
INT 21 - DOS 2.25 only - GET LEAD BYTE TABLE
	AH = 63h
	AL = subfunction
	     0 = get system lead byte table
	     1 = set/clear interim console flag
		DL = 1/0 to set/clear interim console flag
	     2 = get interim console flag
Return: DS:SI -> lead byte table (AL = 0)
	DL = interim console flag (AL = 2)
-----------------------------------------------------------
INT 21 - DOS 3.3 Internal - ???
	AH = 64h
-----------------------------------------------------------
INT 21 - DOS 3.3 - GET EXTENDED COUNTRY INFORMATION
	AH = 65h
	AL = info ID (1 - 6)
	BX = code page (-1=global code page)
	DX = country ID (-1=current country)
	ES:DI = pointer to country information buffer
	CX = size of buffer
Return: AX = error code if carry set, otherwise
	CX = size of country information returned
	ES:DI = pointer to country information:
	       1 BYTE info ID
	       if info ID <> 1
		  1 DWORD pointer to information
	       if info ID == 1
		  1 WORD size
		  1 WORD country ID
		  1 WORD code page
		 34 BYTE see function 38h
-----------------------------------------------------------
INT 21 - DOS 3.3 - GET/SET GLOBAL CODE PAGE TABLE
	AH = 66h
	AL = 00h get global code page
	     Return: AX = error code if carry flag set
		     BX = active code page
		     DX = system code page
	   = 01h set global page
	     BX = active code page
		 437  US
		 860  Portugal
		 863  Canada (French)
		 865  Norway/Denmark
	     DX = system code page (active page at boot time)
	     Return: AX = error code if carry flag set
-----------------------------------------------------------
INT 21 - DOS 3.3 - SET HANDLE COUNT
	AH = 67h
	BX = desired number of handles (max 255)
Return: Carry clear if ok
	Carry set if error (and error code in AX)
-----------------------------------------------------------
INT 21 - DOS 3.3 - COMMIT FILE, WRITE ALL BUFFERED DATA TO DISK
	AH = 68h
	BX = file handle
Return: carry flag set on error (and error code in AX)
-----------------------------------------------------------
INT 21 - DoubleDos - INSTALLATION CHECK
	AX = E400h
Return: AL <> 0 if DoubleDos is active
-----------------------------------------------------------
INT 21 - DoubleDos - TURN OFF TASK SWITCHING
	AH = EAh
Return: task switching turned off
-----------------------------------------------------------
INT 21 - DoubleDos - TURN ON TASK SWITCHING
	AH = EBh
Return: task switching turned on
-----------------------------------------------------------
INT 21 - DoubleDos - GET VIRTUAL SCREEN ADDRESS
	AH = ECh
Return: ES = segment of virtual screen
Note: Screen address can change if task-switching is on!!
-----------------------------------------------------------
INT 21 - DoubleDos - GIVE AWAY TIME TO OTHER TASKS
	AH = EEh
	AL = number of 55ms time slices to give away
Return: returns after giving away time slices
-----------------------------------------------------------
INT 21 - CED - INSTALLABLE COMMANDS
	AH = FFh
	   AL = 0 add installable command
	     BL = mode - bit 0 = 1 callable from DOS prompt
			 bit 1 = 1 callable from application
	     DS:SI pointer to CR-terminated command name
	     ES:DI pointer to FAR routine entry point
	   AL = 1 remove installable command
	     DS:SI pointer to CR-terminated command name
	   AL = 2 reserved, may be used to test for CED installation
Return: CF set on error
	    AX = 01h invalid function
		 02h command not found (subfunction 1 only)
		 08h insufficient memory (subfunction 0 only)
		 0Eh bad data (subfunction 0 only)
	AH = 0FFh if CED not installed
-----------------------------------------------------------
INT 22 - DOS - TERMINATE ADDRESS
   FAR (DWORD) address of routine to be executed when program "returns to DOS".
   Should NEVER be called directly.
-----------------------------------------------------------
INT 23 - DOS - CONTROL "C" EXIT ADDRESS
   Automatically called from keyboard scanner when CTRL-C or CTRL-BREAK is
   detected. Normally aborts program and returns to DOS, but may be changed.
-----------------------------------------------------------
INT 24 - DOS - FATAL ERROR HANDLER ADDRESS
   Automatically called upon detection of unrecoverable I/O error.
   Normally points to routine in resident part of COMMAND.COM that prints
   "Abort, Retry, Ignore?" message and takes the reply, but may be overridden
   if desired.

Provides the following values in registers on entry to interrupt handler:
	AH: bit 7 = 0 disk I/O error
		  = 1 other error -- if block device, bad FAT
				  -- if char device, code in DI
	    bit 6  unused
	    bit 5 = 1 if Ignore allowed, 0 if not (DOS 3.2 ???)
	    bit 4 = 1 if Retry allowed, 0 if not (DOS 3.2 ???)
	    bit 3 = 1 if Fail allowed, 0 if not (DOS 3.2+)
	    bit 2 \ disk area of error  00 = DOS area  01 = FAT
	    bit 1 /                     10 = root dir  11 = data area
	    bit 0 = 1 if write, 0 if read
	AL = drive number if AH bit 7 = 1, otherwise undefined
	BP:SI = address of device header for which error occurred
	    block device if high bit of BP:SI+4 = 1
	low byte of DI:
	   00h write-protect error
	   01h unknown unit
	   02h drive not ready
	   03h unknown command
	   04h data error (bad CRC)
	   05h bad request structure length
	   06h seek error
	   07h unknown media type
	   08h sector not found
	   09h printer out of paper
	   0Ah write fault
	   0Bh read fault
	   0Ch general failure
	   0Dh (DOS 3.x) sharing violation
	   0Eh (DOS 3.x) lock violation
	   0Fh (DOS 3.x) invalid disk change
	   10h (DOS 3.x) FCB unavailable
	   11h (DOS 3.x) sharing buffer overflow
Handler must return
	AL = 00 ignore error
	   = 01 retry operation
	   = 02 terminate program through INT 22h
	   = 03 fail system call in progress (DOS 3.2+)
-----------------------------------------------------------
INT 25 - DOS - ABSOLUTE DISK READ (except COMPAQ DOS 3.31 >32M partition)
	AL = Drive number (0=A, 1=B, etc)
	DS:BX = Disk Transfer Address (buffer)
	CX = Number of sectors to read
	DX = First relative sector to read
Return: CF = 1 if error
	    AL = error code issued to INT 24h in low half of DI
	    AH = 80h if attachment failed to respond
		 40h if seek operation failed
		 20h if controller failed
		 10h if data error (bad CRC)
		 08h if DMA failure
		 04h if requested sector not found
		 03h if write-protected disk
		 02h if bad address mark
		 01h if bad command
Note: ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 25 - COMPAQ DOS 3.31 - ABSOLUTE DISK READ (>32M hard-disk partition)
	AL = Drive number (0=A, 1=B, etc)
	CX = FFFFh
	DS:BX = Packet address
		  DWORD sector number
		  WORD  number of sectors to read
		  DWORD transfer address
Return: same as above???
Note: partition is potentially >32M (and requires this form of the call) if
      bit 1 of device attribute word in device driver is set
-----------------------------------------------------------
INT 26 - DOS - ABSOLUTE DISK WRITE (except COMPAQ DOS 3.31 >32M partition)
	AL = Drive number (0=A, 1=B, etc)
	DS:BX = Disk Transfer Address (buffer)
	CX = Number of sectors to write
	DX = First relative sector to write
Return: CF = 1 if error
	    AL = error code issued to INT 24h in low half of DI
	    AH = same error codes as for INT 25h
Note: ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 26 - COMPAQ DOS 3.31 - ABSOLUTE DISK WRITE (>32M hard-disk partition)
	AL = Drive number (0=A, 1=B, etc)
	CX = FFFFh
	DS:BX = Packet address
		  DWORD sector number
		  WORD  number of sectors to write
		  DWORD transfer address
Return: same as above???
Note: partition is potentially >32M (and requires this form of the call) if
      bit 1 of device attribute word in device driver is set
-----------------------------------------------------------
INT 27 - DOS - TERMINATE BUT STAY RESIDENT
	CS = current program segment
	DX = last program byte + 1
Return: never
-----------------------------------------------------------
INT 28 - DOS Internal - KEYBOARD BUSY LOOP
   This interrupt is called from inside the "get input from keyboard" routine
   in DOS, if and only if it is safe to use INT 21 to access the disk at that
   time.  It is used primarily by the PRINT.COM routines and TSR programs, but
   any number of other routines could be chained to it by saving the original
   vector, and calling it with a FAR call (or just JMPing to it) at the end of
   the new routine.

   The INT 28h handler may invoke any INT 21h function except functions 00h
   through 0Ch (and 50h/51h under DOS 2.xx unless DOS CritErr flag is set).

   Until some program installs its own routine, this interrupt vector simply
   points to an IRET opcode.
-----------------------------------------------------------
INT 29 - DOS Internal - FAST PUTCHAR
   This interrupt is called from the DOS output routines if output is going to
   a device rather than a file, and the device driver's attribute word has
   bit 3 (04h) set to "1".
-----------------------------------------------------------
INT 2A - Microsoft Networks - NETWORK INSTALLATION CHECK
	AH = 00h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2A - Microsoft Networks - CHECK DIRECT I/O
	AX = 0300h
	DS:SI -> ASCIIZ disk device name
Return: CF == 0 if allowed
-----------------------------------------------------------
INT 2A - Microsoft Networks - EXECUTE NETBIOS
	AH = 04h
	AL = 0 for error retry, 1 for no retry
	ES:BX -> NCB
Return: AX = 0 for no error
	AH = 1, AL = error code
-----------------------------------------------------------
INT 2A - Microsoft Networks - GET NETWORK RESOURCE INFORMATION
	AX = 0500h
Return: AX = reserved
	BX = number of network names
	CX = number of commands
	DX = number of sessions
-----------------------------------------------------------
INT 2A - NETBIOS 1.10 - NETWORK PRINT-STREAM CONTROL
	AH = 06h
	???
Return: ???
-----------------------------------------------------------
INT 2A - ???
	AH = 20h
	AL = 01h
	???
Return: ???
Note: intercepted by DESQview 2.0
-----------------------------------------------------------
INT 2A - Microsoft Networks? - ???
	AH = 82h
Return: ???
Note: Called by the INT 21h function dispatcher in DOS 3.10
-----------------------------------------------------------
INT 2B - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2C - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2D - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2E - DOS Internal - EXECUTE COMMAND
	ES:SI -> counted CR-terminated command string

The top-level command.com executes the command; all registers are destroyed
as in EXEC.
-----------------------------------------------------------
INT 2F notes
	AH identifies which program is to handle the interrupt
	   00-7F reserved for DOS
	   C0-FF reserved for applications
	AL is the function code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - INSTALLATION CHECK
	AX = 0100h
Return: AL =
	    FFh installed
	    01h not installed, not OK to install
	    00h not installed, OK to install
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - SUBMIT FILE
	AX = 0101h
	DS:DX -> packet of one byte level and DWORD file pointer
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - REMOVE FILE
	AX = 0102h
	DS:DX -> file name (wildcards allowed)
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - REMOVE ALL FILES
	AX = 0103h
Return: CF = 1 if error
	    AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - HOLD QUEUE/GET STATUS
	AX = 0104h
Return: CF = 1 if error
	    AX = Error Code
		01h function invalid
		02h file not found
		03h path not found
		04h too many open files
		05h access denied
		08h queue full
		09h spooler busy
		0Ch name too long
		0Fh drive invalid
	DX = Error count
	DS:SI -> print queue (null-string terminated
		 list of 64-byte ASCIZ file names)
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - RESTART QUEUE
	AX = 0105h
Return: Flag CF = 1 if error
	AX = Error Code if any
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN - INSTALLATION CHECK
	AX = 0600h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN - ???
	AX = 0601h
	???
Return: ???
-----------------------------------------------------------
INT 2F - Multiplexor - SHARE - ???
	AH = 10h
	AL =
	    0       returns immediately
	    nonzero sets flag in DOS, returns AX=0001 and CF=1
Note: the above are without SHARE loaded, I have to check with SHARE...
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal - ???
	AH = 11h
	???
Note: identical to AH=10h in PC-DOS 3.10 without SHARE loaded
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal - ???
	AH = 12h
	???
Note: also reads value of word on top of stack immediately before invocation
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - INSTALLATION CHECK
	AX = B700h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - ???
	AX = B701h
	???
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - VERSION CHECK
	AX = B702h
	???
-----------------------------------------------------------
INT 2F - Multiplexor - Network - INSTALLATION CHECK
	AX = B800h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - Network - GET CURRENT POST ADDRESS
	AX = B803h
Return: ES:BX = post address
-----------------------------------------------------------
INT 2F - Multiplexor - Network - SET NEW POST ADDRESS
	AX = B804h
	ES:BX = new post address
-----------------------------------------------------------
INT 2F - Multiplexor - Network - VERSION CHECK
	AX = B809h
	???
-----------------------------------------------------------
INT 30 -> (NOT A VECTOR!) FAR JuMP instruction for CP/M-style calls
INT 31
-----------------------------------------------------------
INT 32 -> not used
-----------------------------------------------------------
INT 33 - Microsoft Mouse
-----------------------------------------------------------
INT 34 - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 35 - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 36 - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 37 - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 38 - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 39 - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 3A - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 3B - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 3C - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 3D - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 3E - Turbo C - Floating Point emulation
-----------------------------------------------------------
INT 3F - Overlay manager interrupt (Microsoft LINK.EXE)
-----------------------------------------------------------
INT 40 -> Relocated (by fixed disk) Floppy Handler (original INT 13h)
-----------------------------------------------------------
INT 41 -> Fixed Disk Params (XT,AT,XT2,XT286,PS except ESDI disks)
	dw      cylinders
	db      heads
	dw      0
	dw      write pre-comp
	db      0
	db      0 "control byte"
	db      0, 0, 0
	dw      landing zone
	db      sectors/track
	db      0
-----------------------------------------------------------
INT 42 -> Relocated (by EGA) Video Handler (original INT 10h) (EGA,VGA,PS)
-----------------------------------------------------------
INT 43 -> EGA Initialization Params (EGA,VGA,PS)
-----------------------------------------------------------
INT 44 -> EGA/PCjr fonts (EGA,VGA,CONV,PS)
-----------------------------------------------------------
INT 45 -> reserved
-----------------------------------------------------------
INT 46 -> Secondary Fixed Disk Params (see INT 41h) (AT,XT286,PS except ESDI)
-----------------------------------------------------------
INT 47 -> reserved
-----------------------------------------------------------
INT 48 -> PCjr Cordless Keyboard Translation
-----------------------------------------------------------
INT 49 -> PCjr Non-keyboard Scan Code Translation Table
-----------------------------------------------------------
INT 4A -> AT User Alarm (AT,CONV,PS)
-----------------------------------------------------------
INT 4B -> reserved
-----------------------------------------------------------
INT 4C -> reserved
-----------------------------------------------------------
INT 4D -> reserved
-----------------------------------------------------------
INT 4E -> reserved
-----------------------------------------------------------
INT 4F -> reserved
-----------------------------------------------------------
INT 50-57 -> IRQ0-IRQ7 relocated by DESQview
-----------------------------------------------------------
INT 58 -> reserved
-----------------------------------------------------------
INT 59 - GSS Computer Graphics Interface (GSS*CGI)
	DS:DX = Pointer to block of 5 array pointers
Return: CF = 0
	    AX = return code
	CF = 1
	    AX = error code
Note:   INT 59 is the means by which GSS*CGI language bindings communicate
	with GSS*CGI device drivers and the GSS*CGI device driver controller.
	also used by the IBM Graphic Development Toolkit
-----------------------------------------------------------
INT 5A - Cluster adapter BIOS entry address
	???
-----------------------------------------------------------
INT 5B -> reserved
-----------------------------------------------------------
INT 5C - NETBIOS INTERFACE
	ES:BX -> pointer to Network Control Block
Return: AL = Error Code (0 if none)

struct ncb {
	unsigned char ncb_command;
	unsigned char ncb_retcode;
	unsigned char ncb_lsn;
	unsigned char ncb_num;
	char far *ncb_buffer;
	unsigned short ncb_length;
	char ncb_callname[16];
	char ncb_name[16];
	unsigned char ncb_rto;
	unsigned char ncb_sto;
	int (far *ncb_post)();
	unsigned char ncb_lana_num;
	unsigned char ncb_cmd_cplt;
	char ncb_reserve[14];
};

Command codes:
#define NCB_NOWAIT 0x80
#define NCB_RESET 0x32
#define NCB_CANCEL 0x35
#define NCB_ADAPTER_STATUS 0x33
#define NCB_UNLINK 0x70
#define NCB_ADD_NAME 0x30
#define NCB_ADD_GROUP_NAME 0x36
#define NCB_DELETE_NAME 0x31
#define NCB_CALL 0x10
#define NCB_LISTEN 0x11
#define NCB_HANG_UP 0x12
#define NCB_SEND 0x14
#define NCB_CHAIN_SEND 0x17
#define NCB_RECEIVE 0x15
#define NCB_RECEIVE_ANY 0x16
#define NCB_SESSION_STATUS 0x34
#define NCB_SEND_DATAGRAM 0x20
#define NCB_SEND_BROADCAST_DATAGRAM 0x22
#define NCB_RECEIVE_DATAGRAM 0x21
#define NCB_RECEIVE_BROADCAST_DATAGRAM 0x23

struct name {
	char nm_name[16];
	unsigned char nm_num;
	unsigned char nm_status;
};

struct astatus {
	unsigned char as_id[6];
	unsigned char as_jumpers;
	unsigned char as_post;
	unsigned char as_major;
	unsigned char as_minor;
	unsigned short as_interval
	unsigned short as_crcerr;
	unsigned short as_algerr;
	unsigned short as_colerr;
	unsigned short as_abterr;
	unsigned long as_tcount;
	unsigned long as_rcount;
	unsigned short as_retran;
	unsigned short as_xresrc;
	char as_res0[8];
	unsigned short as_ncbfree;
	unsigned short as_ncbmax;
	unsigned short as_ncbx;
	char as_res1[4];
	unsigned short as_sespend;
	unsigned short as_msp;
	unsigned short as_sesmax;
	unsigned short as_bufsize;
	unsigned short as_names;
	struct name as_name[16];
};

Note: Sytek PCnet card uses DMA 3.
-----------------------------------------------------------
INT 5C - TOPS INTERFACE
	ES:BX -> Network Control Block
Note: TOPS card uses DMA 1, 3 or none.
-----------------------------------------------------------
INT 5D -> reserved
-----------------------------------------------------------
INT 5E -> reserved
-----------------------------------------------------------
INT 5F -> reserved
-----------------------------------------------------------
INT 60 -> reserved for user interrupt
-----------------------------------------------------------
INT 61 -> reserved for user interrupt
-----------------------------------------------------------
INT 62 -> reserved for user interrupt
-----------------------------------------------------------
INT 63 -> reserved for user interrupt
-----------------------------------------------------------
INT 64 -> reserved for user interrupt
-----------------------------------------------------------
INT 65 -> reserved for user interrupt
-----------------------------------------------------------
INT 66 -> reserved for user interrupt
-----------------------------------------------------------
INT 67 - LIM EMS - GET MANAGER STATUS
	AH = 40h
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested by application
Note: this call can be used only after establishing that the EMS driver
      is in fact present
-----------------------------------------------------------
INT 67 - LIM EMS - GET PAGE FRAME SEGMENT
	AH = 41h
Return: AH = 00h function successful
	    BX = segment of page frame
	AH = error code (see AH=40h above)
-----------------------------------------------------------
INT 67 - LIM EMS - GET NUMBER OF PAGES
	AH = 42h
Return: AH = 00h function successful
	    BX = number of unallocated pages
	    DX = total number of pages
	AH = error code (see AH=40h above)
-----------------------------------------------------------
INT 67 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY
	AH = 43h
	BX = number of logical pages to allocate
Return: AH = status
	    00h function successful
		DX = handle
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    85h no more handles available
	    87h more pages requested than physically exist
	    88h more pages requested than currently available
	    89h zero pages requested
-----------------------------------------------------------
INT 67 - LIM EMS - MAP MEMORY
	AH = 44h
	AL = physical page number (0-3)
	BX = logical page number
	DX = handle
Return: AH = status
	    00h function successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Ah invalid logical page number
	    8Bh illegal physical-page number
-----------------------------------------------------------
INT 67 - LIM EMS - RELEASE HANDLE AND MEMORY
	AH = 45h
	DX = EMM handle
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    86h error in save or restore of mapping context
-----------------------------------------------------------
INT 67 - LIM EMS - GET EMM VERSION
	AH = 46h
Return: AH = status
	    00h successful
		AL = EMM version number
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - SAVE MAPPING CONTEXT
	AH = 47h
	DX = handle
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Ch page-mapping hardware state save area is full
	    8Dh save of mapping context failed
-----------------------------------------------------------
INT 67 - LIM EMS - RESTORE MAPPING CONTEXT
	AH = 48h
	DX = handle
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Eh restore of mapping context failed
-----------------------------------------------------------
INT 67 - LIM EMS - reserved
	AH = 49h
Note: defined in EMS 3.0, but undocumented in EMS 3.2
-----------------------------------------------------------
INT 67 - LIM EMS - reserved
	AH = 4Ah
Note: defined in EMS 3.0, but undocumented in EMS 3.2
-----------------------------------------------------------
INT 67 - LIM EMS - GET NUMBER OF EMM HANDLES
	AH = 4Bh
Return: AH = status
	    00h successful
		BX = number of EMM handles
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - GET PAGES OWNED BY HANDLE
	AH = 4Ch
	DX = EMM handle
Return: AH = status
	    00h successful
		BX = number of logical pages
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - GET PAGES FOR ALL HANDLES
	AH = 4Dh
	ES:DI = pointer to array to receive information
Return: AH = status
	    00h successful
		BX = number of active EMM handles
		array filled with 2-word entries, consisting of a handle
		  and the number of pages allocated to that handle
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - GET OR SET PAGE MAP
	AH = 4Eh
	AL = 00h if getting mapping registers
	     01h if setting mapping registers
	     02h if getting and setting mapping registers at once
	     03h if getting size of page-mapping array
	DS:SI = pointer to array holding information (AL=01/02)
	ES:DI = pointer to array to receive information (AL=00/02)
Return: AH = status
	    00h successful
		AL = bytes in page-mapping array (subfunction 03h only)
		array pointed to by ES:DI receives mapping info (AL=00/02)
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction parameter
	    A3h contents of source array corrupted (EMS 4.0?)
Note: this function was designed to be used by multitasking operating systems
      and should not ordinarily be used by appplication software.
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP
	AH = 4Fh
	AL = subfunction
	    00h get partial page map
	       DS:SI = pointer to structure containing list of segments whose
		       mapping contexts are to be saved
	       ES:DI = pointer to array to receive page map
	    01h set partial page map
	       DS:SI = pointer to structure containing saved partial page map
	    02h get size of partial page map
	       BX = number of mappable segments in the partial map to be saved
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Bh one of specified segments is not mappable
	    8Fh undefined subfunction parameter
	    A3h contents of partial page map corrupted or count of mappable
		segments exceeds total number of mappable segments in system
	AL = size of partial page map for subfunction 02h
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
	AH = 50h
	AL = subfunction
	    00h
	    01h
	DX = handle
	CX = number of entries in array
	DS:SI = pointer to mapping array
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Ah one or more logical pages are invalid
	    8Bh one or more physical pages are invalid
	    8Fh invalid subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - REALLOCATE PAGES
	AH = 51h
	DX = handle
	BX = number of pages to be allocated to handle
Return: BX = actual number of pages allocated to handle
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    87h more pages requested than present in system
	    88h more pages requested than currently available
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES
	AH = 52h
	AL = subfunction
	    00h get handle attributes
	    01h set handle attributes
	       BL = new attribute (see returned AL)
	    02h get attribute capability
	DX = handle
Return: AL = attribute (for subfunction 00h)
	    00h handle is volatile
	    01h handle is nonvolatile
	AL = attribute capability (for subfunction 02h)
	    00h only volatile handles supported
	    01h both volatile and non-volatile supported
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Fh undefined subfunction
	    90h undefined attribute type
	    91h feature not supported
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE NAME
	AH = 53h
	AL = subfunction
	    00h get handle name
	       ES:DI = pointer to 8-byte handle name array
	    01h set handle name
	       DS:SI = pointer to 8-byte handle name
	DX = handle
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Fh undefined subfunction
	    A1h duplicate handle name
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET HANDLE DIRECTORY
	AH = 54h
	AL = subfunction
	    00h get handle directory
	       ES:DI = pointer to buffer for handle directory
	    01h search for named handle
	       DS:SI = pointer to 8-byte name
	    02h get total number of handles
Return: AL = number of entries in handle directory (subfunction 00h)
	DX = value of named handle (subfunction 01h)
	BX = total number of handles (subfunction 02h)
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction
	    A0h no such handle name
	    A1h a handle found had no name
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP
	AH = 55h
	AL = subfunction
	    00h physical page numbers provided by caller
	    01h segment addresses provided by caller
	DX = handle
	DS:SI = pointer to structure containing map and jump address
Return: (at target address unless error)
	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    83h invalid handle
	    84h undefined function requested
	    8Ah invalid logical page number encountered
	    8Bh invalid physical page number encountered
	    8Fh invalid subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL
	AH = 56h
	AL = subfunction
	    00h physical page numbers provided by caller
	       DX = handle
	       DS:SI = pointer to structure containing page map and call address
	    01h segment addresses provided by caller
	       DX = handle
	       DS:SI = pointer to structure containing page map and call address
	    02h get page map stack space required
Return: (if successful, the target address is called.  Use a RETF to return and
	 restore mapping context)
	BX = stack space required (subfunction 02h)
	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    83h invalid handle
	    84h undefined function requested
	    8Ah invalid logical page number encountered
	    8Bh invalid physical page number encountered
	    8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION
	AH = 57h
	AL = subfunction
	    00h move memory region
	    01h exchange memory region
	DS:SI = pointer to structure describing source and destination
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    83h invalid handle
	    84h undefined function requested
	    8Ah invalid logical page number encountered
	    8Fh undefined subfunction
	    92h successful, but a portion of the source region has been
		overwritten
	    93h length of source or destination region exceeds length of region
		allocated to either source or destination handle
	    94h conventional and expanded memory regions overlap
	    95h offset within logical page exceeds size of logical page
	    96h region length exceeds 1M
	    97h source and destination EMS regions have same handle and overlap
	    98h memory source or destination type undefined
	    A2h attempted to wrap around 1M conventional address space
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY
	AH = 58h
	AL = subfunction
	    00h get mappable physical address array
	       ES:DI = pointer to buffer to be filled with array
	    01h get number of entries in m.p.a. array
Return: CX = number of entries in array
	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    84h undefined function requested
	    8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION
	AH = 59h
	AL = subfunction
	    00h get hardware configuration array
	       ES:DI = pointer to buffer to be filled with array
	    01h get unallocated raw page count
Return: BX = unallocated raw pages (subfunction 01h)
	DX = total raw pages (subfunction 01h)
	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    84h undefined function requested
	    8Fh undefined subfunction
	    A4h access denied by operating system
Note: subfunction 00h is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES
	AH = 5Ah
	AL = subfunction
	    00h allocate standard pages
	    01h allocate raw pages
	BX = number of pages to allocate
Return: DX = handle
	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    84h undefined function requested
	    85h no more handles available
	    87h insufficient memory pages in system
	    88h insufficient memory pages available
	    8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET
	AH = 5Bh
	AL = subfunction
	    00h get alternate map register set
	    01h set alternate map register set
	       BL = new alternate map register set number
	       ES:DI = pointer to map register context save area if BL=0
	    02h get alternate map save array size
	    03h allocate alternate map register set
	    04h deallocate alternate map register set
	       BL = number of alternate map register set
Return: BL = current active alternate map register set number if nonzero (AL=0)
	ES:DI = pointer to a map register context save area if BL=0 (AL=0)
	DX = array size in bytes (subfunction 02h)
	BL = number of alternate map register set; zero if not supported (AL=3)
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction
	    9Ah specified alternate map register set not supported
	    9Bh all alternate map register sets currently allocated
	    9Ch alternate map register sets not supported
	    9Dh undefined or unallocated alternate map register set
	    A3h source array corrupted
	    A4h operating system denied access
Note: this function is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS
	AH = 5Bh
	AL = subfunction
	    05h allocate DMA register set
	    06h enable DMA on alternate map register set
	       BL = DMA register set number
	       DL = DMA channel number
	    07h disable DMA on alternate map register set
	       BL = DMA register set number
	    08h deallocate DMA register set
	       BL = DMA register set number
Return: BL = DMA register set number; zero if not supported (subfunction 05h)
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction
	    9Ah specified DMA register set not supported
	    9Bh all DMA register sets currently allocated
	    9Ch alternate DMA sets not supported
	    9Dh undefined or unallocated DMA register set
	    9Eh dedicated DMA channels not supported
	    9Fh specified dedicated DMA channel not supported
	    A3h source array corrupted
	    A4h operating system denied access
Note: this function is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT
	AH = 5Ch
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS
	AH = 5Dh
	AL = subfunction
	    00h enable OS Function Set
	    01h disable OS Function Set
	    02h return access key (resets memory manager, returns access key at
		next invocation)
	BX,CX = access key returned by first invocation
Return: BX,CX = access key, returned only on first invocation of function
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction
	    A4h operating system denied access
-----------------------------------------------------------
INT 67 - LIM EMS ??? - GET PHYSICAL WINDOW ARRAY
	AH = 60h
	???
Return: ???
-----------------------------------------------------------
INT 68 -> unused
-----------------------------------------------------------
INT 69 -> unused
-----------------------------------------------------------
INT 6A -> unused
-----------------------------------------------------------
INT 6B -> unused
-----------------------------------------------------------
INT 6C - system resume vector (CONVERTIBLE)
       - DOS 3.2 Realtime Clock update
-----------------------------------------------------------
INT 6D -> unused
-----------------------------------------------------------
INT 6E -> unused
-----------------------------------------------------------
INT 6F -> unused
-----------------------------------------------------------
INT 70 thru 77 - AT/XT286/PS50+ Vectored Hardware Lines
	IRQ8    real-time clock
	IRQ9    LAN adapter 1 (rerouted to INT 0Ah by BIOS)
	IRQ10   reserved
	IRQ11   reserved
	IRQ12   PS50+ mouse interrupt
	IRQ13   80287 error (rerouted to INT 2 by BIOS)
	IRQ14   fixed disk
	IRQ15   reserved
-----------------------------------------------------------
INT 78 -> not used
-----------------------------------------------------------
INT 79 -> not used
-----------------------------------------------------------
INT 7A -> not used
-----------------------------------------------------------
INT 7B -> not used
-----------------------------------------------------------
INT 7C -> not used
-----------------------------------------------------------
INT 7D -> not used
-----------------------------------------------------------
INT 7E -> not used
-----------------------------------------------------------
INT 7F -> not used
-----------------------------------------------------------
INT 80 -> reserved for BASIC
-----------------------------------------------------------
INT 81 -> reserved for BASIC
-----------------------------------------------------------
INT 82 -> reserved for BASIC
-----------------------------------------------------------
INT 83 -> reserved for BASIC
-----------------------------------------------------------
INT 84 -> reserved for BASIC
-----------------------------------------------------------
INT 85 -> reserved for BASIC
-----------------------------------------------------------
INT 86 -> Relocated (by NETBIOS) INT 18
-----------------------------------------------------------
INT 86-F0 -> used by BASIC while in interpreter
-----------------------------------------------------------
INT E0 - CP/M-86 function calls
-----------------------------------------------------------
INT E4 - Logitech Modula v2.0 - MonitorEntry
	AX = 05h
	BX = priority
-----------------------------------------------------------
INT E4 - Logitech Modula v2.0 - MonitorExit
	AX = 06h
-----------------------------------------------------------
INT F1 - reserved for user interrupt
-----------------------------------------------------------
INT F2 - reserved for user interrupt
-----------------------------------------------------------
INT F3 - reserved for user interrupt
-----------------------------------------------------------
INT F4 - reserved for user interrupt
-----------------------------------------------------------
INT F5 - reserved for user interrupt
-----------------------------------------------------------
INT F6 - reserved for user interrupt
-----------------------------------------------------------
INT F7 - reserved for user interrupt
-----------------------------------------------------------
INT F8 - INTERVAL TIMER (10 MSEC) [TANDY?]
-----------------------------------------------------------
INT F9 - reserved for user interrupt
-----------------------------------------------------------
INT FA - USART READY (RS-232C) [TANDY?]
-----------------------------------------------------------
INT FB - USART Rx READY (keyboard) [TANDY?]
-----------------------------------------------------------
INT FC - reserved for user interrupt
-----------------------------------------------------------
INT FD - reserved for user interrupt
-----------------------------------------------------------
INT FE - destroyed by return from protected mode on PC/AT
-----------------------------------------------------------
INT FF - destroyed by return from protected mode on PC/AT
-----------------------------------------------------------
