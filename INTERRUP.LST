Interrupt List		Release 90.5		Last change 10/14/90
This compilation is Copyright (c) 1989, 1990 Ralf Brown
---------------------------------------------
Please redistribute the following files unmodified as a group, in an archive
named INTER590:
	INTERRUP.1ST	the read-me file, containing credits, availability info
	INTERRUP.A	INT 00 through INT 1F \
	INTERRUP.B	INT 20 through INT 27  \ total 418 pages at 60 lines
	INTERRUP.C	INT 28 through INT 5F  / per page, 452 with INTPRINT -p
	INTERRUP.D	INT 60 through INT FF /
	INTERRUP.PRI	a brief introduction to interrupts
	INTPRINT.COM	a simple formatter that also generates the list summary
	INTPRINT.DOC	instructions for INTPRINT
	INTPRINT.C	source code for INTPRINT
	MEMORY.LST	format of the BIOS data area
---------------------------------------------
If you notice any mistakes or omissions, please let me know!  It is only with
YOUR help that the list can continue to grow at the current rate.  Please send
all changes to me rather than distributing a modified version of the list.

Please read the file INTERRUP.1ST before asking me any questions.  You may find
that it's already been addressed.

	 Ralf Brown

ARPA: ralf@cs.cmu.edu
UUCP: {ucbvax,harvard}!cs.cmu.edu!ralf
BIT:  ralf%cs.cmu.edu@cmuccvma
FIDO: Ralf Brown 1:129/3.1
	or post a message to the DR_DEBUG echo
CIS:  >INTERNET:ralf@cs.cmu.edu 

I reply to all e-mail submissions and inquiries, but some of my replies bounce
because of bad return paths.  If you don't get a response from me within a
reasonable period of time, send it again with a better return path (starting at
harvard or ucbvax for UUCP, from the ARPA Internet for others).
---------------------------------------------
See INTERRUP.1ST for the key to system abbreviations and a list of the
trademarks mentioned here.
---------------------------------------------
DISCLAIMER:  I verify the information contained in this list to the best of my
ability, but I cannot be held responsible for any problems caused by use or
misuse of the information, especially for those functions not officially 
documented.  If it is marked "internal", you should check it carefully to make
sure it works the same way in your version of the software (and please let me
know whether or not it works the same way).  Information marked with "???" is
known to be incomplete or guesswork.
---------------------------------------------
The use of -> instead of = signifies that the indicated register or register
pair contains a pointer to the specified item, rather than the item itself
---------------------------------------------
INT 00 - internal hardware - DIVIDE ERROR
   Automatically called at end of DIV or IDIV operation that results in error
   or overflow.   Normally set by DOS to display an error message and abort
   the program.
Notes:	on an 8086/8088, the return address points to the following instruction
	on an 80286+, the return address points to the divide instruction
SeeAlso: INT 04
---------------------------------------------
INT 01 - internal hardware - SINGLE-STEP
   generated at end of each machine instruction if TF bit in FLAGS is set
Notes:	this is what makes the T command of DEBUG work for single-stepping
	not generated after MOV to segment register or POP of segment register
	  (unless you have a very early 8088 with a microcode bug)
SeeAlso: INT 03
---------------------------------------------
INT 01 - 80386+ internal hardware - DEBUGGING EXCEPTIONS
   Instruction address breakpoint fault - will return to execute instruction
   Data address breakpoint trap - will return to following instruction
   General detect fault, debug registers in use
   Task-switch breakpoint trap
---------------------------------------------
INT 02 - external hardware - NMI (NON-MASKABLE INTERRUPT)
   Generated by NMI signal in hardware.  This signal has various uses:

   Breakout switch on hardware debuggers
   Parity error: all except Jr and CONV
   Coprocessor interrupt: all except Jr and CONV
   Keyboard interrupt: Jr, CONV
   I/O channel check: CONV, PS50+
   Disk-controller power-on request: CONV
   System suspend: CONV
   Real-time clock: CONV
   System watch-dog timer, time-out interrupt: PS50+
   DMA timer time-out interrupt: PS50+
---------------------------------------------
INT 03 - ONE-BYTE INTERRUPT
   generated by opcode CCh
Notes:	generally used to set breakpoints for debuggers
	also used by Turbo Pascal versions 1,2,3 when {$U+} specified
SeeAlso: INT 01
---------------------------------------------
INT 04 - internal hardware - OVERFLOW
   Generated by INTO instruction if OF flag is set.  If flag is not set, INTO
   is effectively a NOP.
Note:	used to trap any arithmetic errors before the erroneous results
	  propagate further through the computation
SeeAlso: INT 00
---------------------------------------------
INT 05 - PRINT-SCREEN KEY
   automatically called by keyboard scanner when print-screen key is pressed
Notes:	normally executes routine to print the screen, but may call any routine
	  that can safely be executed from inside the keyboard scanner
	status and result byte for default handler is at address 0050:0000
	  00h not active
	  01h PrtSc in progress
	  FFh last PrtSc encountered error
---------------------------------------------
INT 05 - internal hardware - BOUND CHECK FAILED (80186+)
   Generated by BOUND instruction when the value to be tested is less than the
   indicated lower bound or greater than the indicated upper bound.  Returning
   from this interrupt re-executes the failing BOUND instruction.
---------------------------------------------
INT 06 - internal hardware - UNDEFINED OPCODE (80286+)
---------------------------------------------
INT 07 - internal hardware - NO MATH UNIT AVAILABLE (80286+)
   automatically called if a coprocessor instruction is encountered when no
   coprocessor is installed
Note:	can be used to emulate a numeric coprocessor in software
SeeAlso: INT 09"MATH UNIT PROTECTION"
---------------------------------------------
INT 08 - IRQ0 - TIMER INTERRUPT
   Generated 18.2 times per second, this interrupt is used to keep the
   time-of-day clock updated.  Programs which need to be invoked regularly
   should use INT 1C unless they need to reprogram the timer while still
   keeping the time-of-day clock running at the proper rate.
SeeAlso: INT 1C, INT 50
---------------------------------------------
INT 08 - internal hardware - DOUBLE FAULT (80286+ protected mode)
   Called when multiple exceptions occur on one instruction, or an exception
   occurs in an exception handler.  If an exception occurs in the double fault
   handler, the CPU goes into SHUTDOWN mode (which circuitry in the PC/AT
   converts to a reset).
---------------------------------------------
INT 09 - IRQ1 - KEYBOARD INTERRUPT
   Generated when data is received from the keyboard.  This is normally a scan
   code, but may also be an ACK or NAK of a command on AT-class keyboards.
SeeAlso: INT 15/AH=4Fh, INT 15/AH=85h, INT 16, INT 1B, INT 51
---------------------------------------------
INT 09 - internal hardware - MATH UNIT PROTECTION FAULT (80286,80386 protected)
SeeAlso: INT 07"NO MATH UNIT"
---------------------------------------------
INT 09 - internal hardware - RESERVED BY Intel (80486 protected mode)
Note:	this exception has been moved to INT 0D
SeeAlso: INT 09"MATH", INT 0D
---------------------------------------------
INT 0A - IRQ2 - EGA VERTICAL RETRACE
Notes:	the TOPS and PCnet adapters use this interrupt request line by default
	DOS 3.2 revectors IRQ2 to a stack-switching routine
	on ATs and above, the physical data line for IRQ2 is labeled IRQ9 and
	  connects to the slave 8259.  The BIOS redirects the interrupt for
	  IRQ9 back here.
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 52, INT 71
---------------------------------------------
INT 0A - IRQ2 - Tandy 1000 HARD DISK
SeeAlso: INT 52
---------------------------------------------
INT 0A - IRQ2 - ROLAND MPU MIDI INTERFACE
Note:	newer Roland cards and MIDI interfaces by other manufacturers use
	  a jumper-selectable IRQ, but software and hardware generally defaults
	  to IRQ2
SeeAlso: INT 52
---------------------------------------------
INT 0A - internal hardware - INVALID TASK STATE SEGMENT (80286+ protected-mode)
---------------------------------------------
INT 0B - IRQ3 - COM2 INTERRUPT
Notes:	the TOPS and PCnet adapters use this interrupt request line as an
	  alternate
	on PS/2's, COM2 through COM8 share this interrupt on many PC's, COM4
	  shares this interrupt
SeeAlso: INT 0C, INT 53
---------------------------------------------
INT 0B - internal hardware - NOT PRESENT (80286+ protected-mode)
   Generated when loading a segment register if the segment descriptor
   indicates that the segment is not currently in memory.  May be used to
   implement virtual memory.
SeeAlso: INT 0E"hardware"
---------------------------------------------
INT 0C - IRQ4 - COM1 INTERRUPT
Note:	on many PC's, COM3 shares this interrupt
SeeAlso: INT 0B, INT 54
---------------------------------------------
INT 0C - internal hardware - STACK FAULT (80286+)
   Generated on stack overflow/underflow in protected mode.
   Generated on accessing a word operand at SS:FFFFh in real mode.

Note:	the 80286 will shut down in real mode if SP=1 before a push.  On the
	  PC AT and compatibles, external circuitry generates a reset on
	  shutdown.
---------------------------------------------
INT 0D - IRQ5 - FIXED DISK (PC), LPT2 (AT/PS)
Note:	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 0E, INT 55
---------------------------------------------
INT 0D - IRQ5 - Tandy 1000 60 Hz RAM REFRESH
SeeAlso: INT 55
---------------------------------------------
INT 0D - internal hardware - GENERAL PROTECTION VIOLATION (80286+)
   Called in real mode when an instruction attempts to access a word operand
     located at offset FFFFh or a PUSH MEM or POP MEM instruction contains an
     invalid bit encoding in the second byte, or an instruction exceeds the
     maximum length allowed (10 bytes for 80286, 15 bytes for 80386)
   Called on 80486 protected-mode floating-point protection fault
SeeAlso: INT 09"80486", INT 0C"STACK"
---------------------------------------------
INT 0E - IRQ6 - DISKETTE INTERRUPT
Note:	generated by floppy disk controller on completion of an operation
SeeAlso: INT 0D, INT 56
---------------------------------------------
INT 0E - internal hardware - PAGE FAULT (80386+ native mode)
   used to implement virtual memory
SeeAlso: INT 0B"hardware"
---------------------------------------------
INT 0F - IRQ7 - PRINTER INTERRUPT
   Generated by the LPT1 printer adapter when printer becomes ready.
Notes:	most printer adapters do not reliably generate this interrupt.
	the 8259 interrupt controller generates an interrupt corresponding to
	  IRQ7 when an error condition occurs
SeeAlso: INT 57
---------------------------------------------
INT 10 - internal hardware - COPROCESSOR ERROR (80286+)
Notes:	generated by the CPU when the -ERROR pin is asserted by the coprocessor
	AT's and clones usually wire the coprocessor to use IRQ13, but not all
	  get it right
SeeAlso: INT 09"hardware", INT 75
---------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE
	AH = 00h
	AL = mode (graphics mode if graphics resolution listed)
		 text  pixel graphic colors disp scrn  system
		 resol	box  resoltn	    page addr
	   00h = 40x25	8x8	       B&W     8 B800 CGA
	       = 40x25	8x14	       B&W     8 B800 ATI VIP
	   01h = 40x25	8x8		16     8 B800 CGA
	       = 40x25	8x14		16     8 B800 ATI VIP
	   02h = 80x25	8x8	       B&W     4 B800 CGA
	       = 80x25	8x8	       B&W     8 B800 EGA,MCGA,VGA
	       = 80x25	8x14	       B&W     8 B800 ATI VIP
	   03h = 80x25	8x8		16     4 B800 CGA
	       = 80x25	8x8		16     8 B800 EGA,MCGA,VGA
	   04h = 40x25	8x8   320x200	 4     1 B800 CGA
	   05h = 40x25	8x8   320x200 4 gray   1 B800 CGA
	   06h = 80x25	8x8   640x200  B&W     1 B800 CGA
	   07h = 80x25	9x14	      mono     1 B000 MDA,Hercules
	       = 80x25			       8      EGA,VGA
	       = 80x25	9x14	      mono	 B000 ATI VIP
	   08h = 20x25	8x8   160x200	16	 B800 PCjr,Tandy 1000
	       = 132x25 8x8		16	 B800 ATI EGA/VGA Wonder **
	       = 132x25 8x8	      mono	 B000 ATI EGA/VGA Wonder **
	   09h = 40x25	8x8   320x200	16	 B800 PCjr,Tandy 1000
	   0Ah = 80x25	8x8   640x200	 4	 B800 PCjr,Tandy 1000
	   0Bh = reserved (used internally by EGA BIOS)
	   0Ch = reserved (used internally by EGA BIOS)
	   0Dh = 40x25	8x8   320x200	16     8 A000 EGA,VGA
	   0Eh = 80x25	8x8   640x200	16     4 A000 EGA,VGA
	   0Fh = 80x25	8x14  640x350 mono     2 A000 EGA,VGA
	   10h = 80x25	8x14  640x350 4or16    2 A000 EGA,VGA
	   11h = 80x30	8x16  640x480 mono	 A000 VGA,MCGA,ATI EGA,ATI VIP
	   12h = 80x30	8x16  640x480  16/256k	 A000 VGA,ATI VIP
	       = 80x30	8x16  640x480  16/64	 A000 ATI EGA Wonder
	   13h = 40x25	8x8   320x200 256/256k	 A000 VGA,MCGA,ATI VIP
	   14h = 80x25	8x8   640x200		      Lava Chrome II EGA
	       =	      640x400	16	      Tecmar VGA/AD
	   15h = 80x25	8x14  640x350		      Lava Chrome II EGA
	   16h = 80x25	8x14  640x350		      Lava Chrome II EGA
	       =	      800x600	16	      Tecmar VGA/AD
	   17h = 80x34	8x14  640x480		      Lava Chrome II EGA
	       = 132x25				      Tecmar VGA/AD
	   18h = 132x44 8x8	      mono	      Tseng Labs EVA
	       = 132x44 8x8	      16/256   2 B000 Tseng ET4000 chipset
	       = 80x34	8x14  640x480		      Lava Chrome II EGA
	       =	     1024x768	16	      Tecmar VGA/AD
	   19h = 132x25 8x14	      mono	      Tseng Labs EVA
	       = 132x25 8x14	      16/256   4 B000 Tseng ET4000 chipset
	   1Ah = 132x28 8x13	      mono	      Tseng Labs EVA
	       = 132x28 8x13	      16/256   4 B000 Tseng ET4000 chipset
	       =	      640x350  256	      Tecmar VGA/AD
	   1Bh =	      640x400  256	      Tecmar VGA/AD
	   1Ch =	      640x480  256	      Tecmar VGA/AD
	   1Dh =	      800x600  256	      Tecmar VGA/AD
	   21h = 80x43	8x8   720x348 mono	      DESQview 2.x+Hercules ***
	   22h = 132x44 8x8			      Tseng Labs EVA
	       = 132x44 8x8	      16/256   2 B800 Tseng ET4000 chipset
	       = 132x44 8x8			      Ahead Systems EGA2001
	       = 132x43				      Allstar Peacock (VGA)
	       = 132x44 		16	      Orchid Prodesigner VGA
	       = 80x43	8x8   720x348 mono	      DESQview 2.x+Hercules ***
	   23h = 132x25 6x14			      Tseng Labs EVA
	       = 132x25 8x14	      16/256   4 B800 Tseng ET4000 chipset
	       = 132x25 8x14			      Ahead Systems EGA2001
	       = 132x25 8x8		16	 B800 ATI EGA Wonder,ATI VIP
	       = 132x28				      Allstar Peacock (VGA)
	       = 132x28			16	      Orchid Prodesigner VGA
	   24h = 132x28 6x13			      Tseng Labs EVA
	       = 132x28 8x13	      16/256   4 B800 Tseng ET4000 chipset
	       = 132x25				      Allstar Peacock (VGA)
	       = 132x25 		16	      Orchid Prodesigner VGA
	   25h = 80x60	8x8   640x480		      Tseng Labs EVA
	       = 80x60	8x8   640x480 16/256   1 A000 Tseng ET4000 chipset
	       =	      640x480	16	      VEGA VGA
	       = 80x60	8x8   640x480	16	 A000 Orchid Prodesigner VGA
	   26h = 80x60	8x8			      Tseng Labs EVA
	       = 80x60	8x8	      16/256   2 B800 Tseng ET4000 chipset
	       = 80x60	8x8   640x480		      Ahead Systems EGA2001
	       = 80x60				      Allstar Peacock (VGA)
	       = 80x60	 		16	      Orchid ProDesigner VGA
	   27h =	      720x512	16	      VEGA VGA
	       =	      720x512	16	      Genoa
	       = 132x25 8x8	      mono	 B000 ATI EGA Wonder,ATI VIP
	   28h = ???x???			      VEGA VGA
	   29h =	      800x600	16	      VEGA VGA
	       = 100x37 8x16  800x600	16	 A000 Orchid
	       =	      800x600	16	 A000 STB,Genoa,Sigma
	       =	      800x600	16	      Allstar Peacock (VGA)
	       = 100x37 8x16  800x600 16/256   1 A000 Tseng ET4000 chipset
	   2Ah = 100x40 			      Allstar Peacock (VGA)
	       = 100x40 8x16		16	      Orchid Prodesigner VGA
	       = 100x40 8x15	      16/256   4 B800 Tseng ET4000 chipset
	   2Dh =	      640x350  256	      VEGA VGA
	       =	      640x350 256/256k	 A000 Orchid, Genoa, STB
	       = 80x25	8x14  640x350 256/256k 1 A000 Tseng ET4000 chipset
	   2Eh =	      640x480  256	      VEGA VGA
	       = 80x30	8x16  640x480 256/256k	 A000 Orchid
	       =	      640x480 256/256k	 A000 STB,Genoa,Sigma
	       = 80x30	8x16  640x480 256/256k 1 A000 Tseng ET4000 chipset
	   2Fh =	      720x512  256	      VEGA VGA
	       =	      720x512  256	      Genoa
	       = 80x25	8x16  640x400 256/256k 1 A000 Tseng ET4000 chipset
	   30h =	      800x600  256	      VEGA VGA
	       = 100x37 8x16  800x600 256/256k	 A000 Orchid 
	       =	      800x600 256/256k	 A000 STB,Genoa,Sigma
	       =	      720x350	 2	      3270 PC
	       =	      800x600  256	      Cardinal
	       =	      ???x???		 B800 AT&T 6300
	       = 100x37 8x16  800x600 256/256k 1 A000 Tseng ET4000 chipset
	   33h = 132x44 8x8		16	 B800 ATI EGA Wonder,ATI VIP
	   36h =	      960x720	16	      VEGA VGA
	       =	      960x720	16	      STB
	   37h =	     1024x768	16	      VEGA VGA
	       = 128x48 8x16 1024x768	16	 A000 Orchid
	       =	     1024x768	16	 A000 STB,Genoa,Sigma
	       = 132x44 8x8	      mono	 B800 ATI EGA Wonder,ATI VIP
	   38h =	     1024x768  256	      STB VGA/EM-16 Plus (1MB)
	       = 128x48 8x16 1024x768 256/256k 1 A000 Tseng ET4000 chipset
	   40h = 80x25	8x16  640x400	 2     1 B800 AT&T 6300, AT&T VDC600
	       = 80x25	8x16  640x400	 2     1 B800 Compaq Portable
	       = 80x43				      VEGA VGA, Tecmar VGA/AD
	       = 80x43				      Video7 V-RAM VGA
	       = 80x43				      Tatung VGA
	   41h =	      640x200	16     1      AT&T 6300
	       = 132x25 			      VEGA VGA
	       = 132x25				      Tatung VGA
	       = 132x25				      Video7 V-RAM VGA
	   42h = 80x25	8x16  640x400	16	      AT&T 6300, AT&T VDC600
	       = 132x43 			      VEGA VGA
	       = 132x43				      Tatung VGA
	       = 132x43				      Video7 V-RAM VGA
	   43h = unsupported  640x200 of 640x400 viewport  AT&T 6300
	       = 80x60				      VEGA VGA
	       = 80x60				      Tatung VGA
	       = 80x60				      Video7 V-RAM VGA
	   44h = disable VDC and DEB output	      AT&T 6300
	       = 100x60 			      VEGA VGA
	       = 100x60 			      Tatung VGA
	       = 100x60				      Video7 V-RAM VGA
	   45h = 132x28				      Tatung VGA
	       = 132x28				      Video7 V-RAM VGA
	   46h = 100x40 8x15  800x600	 2	      AT&T VDC600
	   47h = 100x37 8x16  800x600	16	      AT&T VDC600
	   48h = 80x50	8x8   640x400	 2	 B800 AT&T 6300, AT&T VDC600
	   49h = 80x30	8x16  640x480		      Lava Chrome II EGA
	   4Dh = 120x25 			      VEGA VGA
	   4Eh = 120x43 			      VEGA VGA
	   4Fh = 132x25 			      VEGA VGA
	   50h = 132x25 9x14	      mono	      Ahead Systems EGA2001
	       = 80x30	8x16  640x480	16	      Paradise EGA-480
	       = 80x43		      mono	      VEGA VGA
	       =	      640x480 mono???	      Taxan 565 EGA
	       = 80x34				      Lava Chrome II EGA
	       = 132x25 8x14		16     8 B800 OAK Technologies VGA-16
	   51h = 80x30	8x16			      Paradise EGA-480
	       = 80x30				      Lava Chrome II EGA
	       = 80x34	8x14  640x480	16	      ATI EGA Wonder
	       = 132x25 	      mono	      VEGA VGA
	       = 132x43 8x8		16     5 B800 OAK Technologies VGA-16
	   52h = 132x44 9x8	      mono	      Ahead Systems EGA2001
	       = 132x43 	      mono	      VEGA VGA
	       = 94x29	8x14  752x410	16	      ATI EGA Wonder
	       = 80x60				      Lava Chrome II EGA
	       = 100x75	8x8   800x600	16     1 A000 OAK Technologies VGA-16
	   53h = 100x40 8x14  800x560	16	      ATI EGA Wonder,ATI VIP
	       = 132x43 			      Lava Chrome II EGA
	   54h = 132x43 8x8			      Paradise EGA-480
	       = 132x43 7x9	      16/256k	 B800 Paradise VGA
	       = 132x43 8x9	      16/256k	 B800 Paradise VGA on multisync
	       = 132x43				      Taxan 565 EGA
	       = 132x43				      AST VGA Plus
	       = 132x43				      Hewlett-Packard D1180A
	       = 132x43 7x9		16	      AT&T VDC600
	       = 132x25 			      Lava Chrome II EGA
	       = 100x42 8x14  800x600	16	 A000 ATI EGA Wonder, VGA Wondr
	   55h = 132x25 8x14			      Paradise EGA-480
	       = 132x25 7x16	      16/256k	 B800 Paradise VGA
	       = 132x25 8x16	      16/256k	 B800 Paradise VGA on multisync
	       = 132x25				      Taxan 565 EGA
	       = 132x25				      AST VGA Plus
	       = 132x25				      Hewlett-Packard D1180A
	       = 132x25 7x16		16	      AT&T VDC600
	       = 80x66	8x8	      16/256k	 A000 ATI VIP
	       = 94x29	8x14  752x410		      Lava Chrome II EGA
	       = 128x48 8x16 1024x768 16/256k	 A000 ATI VGA Wonder v4+  *!
	   56h = 132x43 8x8	      3???     2 B000 NSI Smart EGA+
	       = 132x43 7x9		 4	 B000 Paradise VGA
	       = 132x43 8x9		 4	 B000 Paradise VGA on multisync
	       = 132x43 	      mono	      Taxan 565 EGA
	       = 132x43 7x9		 2	      AT&T VDC600
	   57h = 132x25 8x14	      3???     4 B000 NSI Smart EGA+
	       = 132x25 7x16		 4	 B000 Paradise VGA
	       = 132x25 8x16		 4	 B000 Paradise VGA on multisync
	       = 132x25 	      mono	      Taxan 565 EGA
	       = 132x25 7x16		 2	      AT&T VDC600
	   58h = 100x75 8x8   800x600 16/256k	 A000 Paradise VGA
	       = 100x75 8x8   800x600	16	      AT&T VDC600
	       = 80x33	8x14		16	 B800 ATI EGA Wonder,ATI VIP
	       =	      800x600	16	      AST VGA Plus, Compaq VGA
	       =	      800x600	16	      Dell VGA
	       =	      800x600	16	      Hewlett-Packard D1180A
	   59h = 100x75 8x8   800x600	 2	 A000 Paradise VGA
	       = 100x75 8x8   800x600	 2	      AT&T VDC600
	       = 80x66	8x8	      16/256k	 A000 ATI VIP
	       =	      800x600	 2	      AST VGA Plus, Compaq VGA
	       =	      800x600	 2	      Dell VGA
	       =	      800x600	 2	      Hewlett-Packard D1180A
	   5Bh =	      800x600	16	      Maxxon, SEFCO TVGA, Imtec
	       =	      640x350  256	      Genoa 6400
	       = 80x30	8x16			 B800 ATI VGA Wonder (undoc)
	   5Ch =	      640x400  256	      Logix, ATI Prism Elite
	       =	      640x400  256	      Maxxon, SEFCO TVGA, Imtec
	       =	      640x400  256	      Zymos Poach
	       =	      640x480  256	      Genoa 6400
	   5Dh =	      640x480  256	      Logix, ATI Prism Elite
	       =	      640x480  256	      Maxxon, SEFCO TVGA, Imtec
	       =	      640x480  256	      Zymos Poach
	   5Eh =	      640x400  256	      Paradise VGA,VEGA VGA
	       =	      640x400  256	      AST VGA Plus
	       =	      640x400  256	      Compaq VGA, Dell VGA
	       = 80x25	8x16  640x400  256	      AT&T VDC600
	       =	      800x600	16	      Logix, ATI Prism Elite
	       =	      800x600  256	      Genoa 6400
	       =	      800x600  256	      Zymos Poach
	   5Fh =	      640x480  256	      Paradise VGA
	       =	      640x480  256	      AST VGA Plus
	       =	      640x480  256	      Compaq VGA, Dell VGA
	       =	      640x480  256	      Hewlett-Packard D1180A
	       = 80x30	8x16  640x480  256	      AT&T VDC600 (512K)
	       =	     1024x768	16	      Logix, ATI Prism Elite
	       =	     1024x768	16	      Maxxon, Genoa 6400, Imtec
	       =	     1024x768	16	      Zymos Poach
	   60h = 80x???       ???x400		      Corona/Cordata BIOS 4.10+
	       =	      752x410		      VEGA VGA
	       =	      752x410	16	      Tatung VGA
	       =	      752x410	16	      Video7 V-RAM VGA
	       =	      640x400  256	      Ahead B
	   61h =	      ???x400		      Corona/Cordata BIOS 4.10+
	       =	      720x540		      VEGA VGA
	       =	      720x540	16	      Tatung VGA
	       =	      720x540	16	      Video7 V-RAM VGA
	       =	      640x400  256	 A000 ATI VGA Wonder
	       =	      640x480  256	      Ahead B
	   62h =	      800x600		      VEGA VGA
	       =	      800x600	16	      Tatung VGA
	       =	      800x600	16	      Video7 V-RAM VGA
	       =	      640x480  256	 A000 ATI VGA Wonder
	       =	      800x600  256	      Ahead B
	   63h =	     1024x768	 2	      Video7 V-RAM VGA
	       =	      800x600  256	 A000 ATI VGA Wonder
	       =	     1024x768  256	      Ahead B (1MB)
	   64h =	     1024x768	 4	      Video7 V-RAM VGA
	   65h =	     1024x768	16	      Video7 V-RAM VGA
	       =	     1024x768	16	 A000 ATI VGA Wonder
	   66h =	      640x400  256	      Tatung VGA
	       =	      640x400  256	      Video7 V-RAM VGA
	   67h =	      640x480  256	      Video7 V-RAM VGA
	       =	     1024x768	 4	 A000 ATI VGA Wonder
	   69h =	      720x540  256	      Video7 V-RAM VGA
	   6Ah =	      800x600	16	      VESA standard interface
	       =	      800x600	16	      Ahead B, Genoa 6400
	       =	      800x600	16	      Zymos Poach
	       = 100x42 8x14  800x600		 A000 ATI VGA Wonder (undoc)
	   70h =	      800x600	16	      Cardinal
	       = extended mode set (see AX=0070h)     Everex Micro Enhancer EGA
	   71h = 100x35 8x16  800x600 16of64	 A000 NSI Smart EGA+
	       =	      960x720	16	      Cardinal
	   72h =	     1024x768	16	      Cardinal
	   74h =	      640x400	 2	 B800 Toshiba 3100 AT&T mode
	       =	     1024x768	16	      Ahead B
	   78h =	      640x400  256	      STB VGA/EM-16 Plus
	       =	      640x400  256	      Cardinal
	   79h =	      640x480  256	      Cardinal
	   7Ah =	      720x540  256	      Cardinal
	   7Ch =	      512x512	16	      Genoa
	   7Dh =	      512x512  256	      Genoa
	   7Eh = special mode set (see AX=007Eh)      Paradise VGA, AT&T VDC600
	   7Fh = special function set (see AX=007Fh)  Paradise VGA, AT&T VDC600
	   82h = 80x25		       B&W	      AT&T VDC overlay mode *
	   83h = 80x25				      AT&T VDC overlay mode *
	   86h =	      640x200  B&W	      AT&T VDC overlay mode *
	   C0h =	      640x400  2/prog pallet  AT&T VDC overlay mode *
	   C4h = disable output 		      AT&T VDC overlay mode *
	   D0h =	      640x400	 2	 B800 DEC VAXmate AT&T mode

 *  for AT&T VDC overlay modes, BL contains the DEB mode, which may be 06h,
	  40h, or 44h
 ** for ATI EGA Wonder, mode 08h is only valid if SMS.COM is loaded resident.
      SMS maps mode 08h to mode 27h if the byte at location 0040:0063 is 0B4h,
      otherwise to mode 23h, thus selecting the appropriate (monochrome or
      color) 132x25 character mode.
    for ATI VGA Wonder, mode 08h is the same, and only valid if VCONFIG loaded
      resident
 *** DESQview intercepts calls to change into these two modes (21h is page 0,
      22h is page 1) even if there is no Hercules graphics board installed
 *! ATI BIOS v4-1.00 has a text-scrolling bug in this mode

Notes:	IBM standard modes do not clear the screen if the high bit of AL is set
	the Tseng ET4000 chipset is used by the Orchid Prodesigner II, Diamond
	  SpeedSTAR VGA, Groundhog Graphics Shadow VGA
SeeAlso: AX=0070h,007Eh,6F05h
---------------------------------------------
INT 10 - VIDEO - Everex Micro Enhancer EGA - EXTENDED MODE SET
	AX = 0070h
	BL = mode (graphics mode if graphics resolution listed)
		 text  pixel graphic color disp scrn  monitor
		 resol	box  resoltn	   page addr
	   00h =	     640x480  16	      multisync'ing
	   01h =	     752x410  16	      multisync'ing
	   02h =	     800x600  16	      multisync'ing
	   03h = 80x34				      multisync'ing
	   04h = 80x60				      multisync'ing
	   05h = 94x29				      multisync'ing
	   06h = 94x51				      multisync'ing
	   07h = reserved
	   08h = reserved
	   09h = 80x44				      EGA
	   0Ah = 132x25 			      EGA
	   0Bh = 132x44 			      EGA
	   0Ch = 132x25 			      CGA
	   0Dh = 80x44				      mono
	   0Eh = 132x25 			      mono
	   0Fh = 132x44 			      mono
	   10h = reserved
	   11h =	    1280x350   4
	   12h =	    1280x600   4
	   13h =	     640x350 256
	   14h =	     640x400 256
	   15h =	     512x480 256
	   20h =	    1024x768  16	      (Everex 678 only)
	   30h =	     640x480 256	      (Everex 678 only)
	   31h =	     800x600 256	      (Everex 678 only)
---------------------------------------------
INT 10 - VIDEO - Paradise VGA, AT&T VDC600 - SET SPECIAL MODE
	AX = 007Eh
	BX = The horizontal dimension of the mode desired
	CX = The vertical dimension of the mode desired
	     (both BX/CX in pixels for graphics modes, rows for alpha modes)
	DX = The number of colors of the mode desired
	     (use 0 for monochrome modes)
Return: BH = 7Eh if successful (Paradise VGA)
	AL = 7Eh if successful (AT&T VDC600)
SeeAlso: AH=00h,AX=0070h,007Fh,6F05h
---------------------------------------------
INT 10 - VIDEO - Paradise VGA, AT&T VDC600 - EXTENDED FUNCTIONS
	AX = 007Fh
	BH = 00h  set VGA operation
	BH = 01h  set non-VGA operation
	    color modes (0,1,2,3,4,5,6) will set non-VGA CGA operation.
	    monochrome mode 7 will set non-VGA MDA/Hercules operation.
	BH = 02h  query mode status
	    Return: BL = 00h if operating in VGA mode, 01h if non-VGA mode.
		    CH = total video RAM size in 64k byte units.
		    CL = video RAM used by the current mode.
	BH = 03h  lock current mode
	    allows current mode (VGA or non-VGA) to survive re-boot.
	BH = 04h  enter CGA mode (AT&T VDC600 only)
	BH = 05h  enter MDA mode (AT&T VDC600 only)
	BH = 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh  WRITE PARADISE REGISTERS 0,1,2,3,4,5
		(port 03CEh indices 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh)
	    BL = value to set in the paradise register.
	BH = 1Ah,1Bh,1Ch,1Dh,1Eh,1Fh READ PARADISE REGISTERS 0,1,2,3,4,5
		(port 03CEh indices 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh)
	    Return: BL = value of the paradise register.
		    BH = 7Fh if successful.
Return: AL = 7Fh if successful (AT&T VDC600)
SeeAlso: AX=007Eh
---------------------------------------------
INT 10 - VIDEO - SET CURSOR CHARACTERISTICS
	AH = 01h
	CH bits 0-4 = start line for cursor in character cell
	   bits 5-6 = blink attribute
		     (00=normal, 01=invisible, 10=slow, 11=fast on CGA/mono)
		     (00=normal, other=invisible on EGA/VGA)
	CL bits 0-4 = end line for cursor in character cell
Note:	buggy on EGA systems--BIOS remaps cursor shape in 43 line modes, but
	  returns unmapped cursor shape
BUG:	AMI 386 BIOS and AST Premier 386 BIOS will lock up the system if AL
	  is not equal to the current video mode
SeeAlso: AH=03h
---------------------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
	AH = 02h
	DH,DL = row, column (0,0 = upper left)
	BH = page number
	    0 in graphics modes
	    0-3 in modes 2&3
	    0-7 in modes 0&1
SeeAlso: AH=03h
---------------------------------------------
INT 10 - VIDEO - READ CURSOR POSITION
	AH = 03h
	BH = page number
	    0 in graphics modes
	    0-3 in modes 2&3
	    0-7 in modes 0&1
Return: DH,DL = row,column
	CH = cursor start line
	CL = cursor end line
SeeAlso: AH=01h,02h
---------------------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION (all but PS)
	AH = 04h
Return: AH = 00h light pen switch not activated
	   = 01h light pen values in registers
	    DH,DL = row,column of current position
	    CH = raster line (0-199) (EGA) old graphics modes
	    CX = (EGA) raster line (0-nnn) new graphics modes
	    BX = pixel column (0-319 or 0-639)
---------------------------------------------
INT 10 - VIDEO - SELECT DISPLAY PAGE
	AH = 05h
	AL = display page
	    0-7  for modes 0 & 1
	    0-3  for modes 2 & 3
SeeAlso: AH=0Fh
---------------------------------------------
INT 10 - PCjr VIDEO - CRT/CPU PAGE REGISTERS
	AH = 05h
	AL =
	    80h read CRT/CPU page registers
	    81h set CPU page register
		BL = new page register value
	    82h set CRT page register
		BH = new page register value
	    83h set both display registers
		BL = new CPU page register
		BH = new CRT page register
Return: BH = CRT page register
	BL = CPU page register
---------------------------------------------
INT 10 - VIDEO - GRAPHICS BITMAP BUFFER (Corona/Cordata BIOS v4.10+)
	AH = 05h
	AL =
	    00h set address of graphics bitmap buffer (video modes 60h,61h)
		BX = segment of buffer
	    0Fh get address of graphics bitmap buffer (video modes 60h,61h)
		Return: DX = segment of graphics bitmap buffer
---------------------------------------------
INT 10 - VIDEO - SCROLL PAGE UP
	AH = 06h
	AL = number of lines to scroll window (0 = blank whole window)
	BH = attributes to be used on blanked lines
	CH,CL = row,column of upper left corner of window to scroll
	DH,DL = row,column of lower right corner of window
Warning: some implementations have a bug which destroys BP
SeeAlso: AH=07h,72h,73h
---------------------------------------------
INT 10 - VIDEO - SCROLL PAGE DOWN
	AH = 07h
	AL = number of lines to scroll window (0 = blank whole window)
	BH = attributes to be used on blanked lines
	CH,CL = row,column of upper left corner of window to scroll
	DH,DL = row,column of lower right corner of window
Warning: some implementations have a bug which destroys BP
SeeAlso: AH=06h,72h,73h
---------------------------------------------
INT 10 - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
	AH = 08h
	BH = display page
Return: AL = character
	AH = attribute of character (alpha modes)
SeeAlso: AH=09h
---------------------------------------------
INT 10 - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
	AH = 09h
	AL = character
	BH = display page
	BL = attributes of character (alpha modes) or color (graphics modes)
	     if bit 7 set in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
Note:	all characters are displayed, including CR, LF, and BS
SeeAlso: AH=08h,0Ah
---------------------------------------------
INT 10 - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
	AH = 0Ah
	AL = character
	BH = display page - alpha mode
	BL = color of character (graphics mode, PCjr only)
	     if bit 7 set in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
	     (EGA) in graphics modes, replication count in CX works correctly
	     only if all character written are contains on the same row
Note:	all characters are displayed, including CR, LF, and BS
SeeAlso: AH=08h,09h
---------------------------------------------
INT 10 - VIDEO - SET COLOR PALETTE
	AH = 0Bh
	BH = 00h
	    BL = border color (0-15) (text modes)
		 border color and background color (graphics modes)
	    (EGA)
	    BL = border color (0-15) and high-intensity background color
		  (16-31??? maybe should be high nybble?)
	BH = 01h
	    BL = palette (0-3)
---------------------------------------------
INT 10 - VIDEO - WRITE DOT ON SCREEN
	AH = 0Ch
	AL = color of dot (0/1 in mode 6, 0-3 in modes 4 and 5)
	     if bit 7 set, new color will be XORed with current pixel
	BH = display page (ignored if mode only supports one page)
	CX = column
	DX = row
Note:	only valid in graphics modes
SeeAlso: AH=0Dh
---------------------------------------------
INT 10 - VIDEO - READ DOT ON SCREEN
	AH = 0Dh
	BH = display page (ignored if mode only supports one page)
	CX = column
	DX = row
Return: AL = color read
Note:	only valid in graphics modes
SeeAlso: AH=0Ch
---------------------------------------------
INT 10 - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
	AH = 0Eh
	AL = character
	BH = display page (alpha modes)
	BL = foreground color (graphics modes)
Note:	characters 07h (BEL), 08h (BS), 0Ah (LF), and 0Dh (CR) are interpreted
	  and do the expected things
SeeAlso: AH=02h,0Ah
---------------------------------------------
INT 10 - VIDEO - GET CURRENT VIDEO MODE
	AH = 0Fh
Return: AH = number of columns on screen
	AL = current video mode (see INT 10/AH=00h)
	BH = current active display page
Note:	if mode was set with bit 7 set ("no blanking"), the returned mode will
	also have bit 7 set
SeeAlso: AH=00h,05h
---------------------------------------------
INT 10 - VUIMG DISPLAY DRIVER (v2.20 and below)
	AX = 0F56h
	BX = 4756h
	CX = 4944h
	DL = function
	    01h installation check
		Return: AX = 5649h
			BX = 4443h
			CX = 5647h
			DH = 01h
	    02h get first video mode's parameters
		Return: AX = BIOS mode number
			BX = widht in pixels
			CX = height in pixels
			DX = number of colors
	    03h get next video mode's parameters
		Return: as for DL=02h
	    04h display line???
		ES:DI -> record (see below)
		???
		Return: ???

Format of record for DL=04h:
Offset	Size	Description
 00h	WORD	row number
 02h	WORD	starting column???
 04h	WORD	ending column???
	???
---------------------------------------------
INT 10 - VIDEO - SET PALETTE REGISTER (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1000h
	BL = palette register to set
	BH = color value to store
Note:	on MCGA, only BX = 0712h is supported
SeeAlso: AX=1002h,1007h
---------------------------------------------
INT 10 - VIDEO - SET BORDER COLOR REGISTER (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1001h
	BH = color value to store
SeeAlso: AX=1008h
---------------------------------------------
INT 10 - VIDEO - SET ALL PALETTE REGISTERS (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1002h
	ES:DX -> 17-byte palette register list (see below)
SeeAlso: AX=1000h,1009h

Format of palette register list:
Offset	Size	Description
 00h 16 BYTEs	values for palette registers 0-15
 10h	BYTE	value for border color register
---------------------------------------------
INT 10 - VIDEO - TOGGLE INTENSITY/BLINKING BIT (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1003h
	BL = 00h enable intensity
	   = 01h enable blink
---------------------------------------------
INT 10 - VIDEO - GET INDIVIDUAL PALETTE REGISTER (VGA)
	AX = 1007h
	BL = palette register number
Return: BH = palette register value
SeeAlso: AX=1000h,1009h
---------------------------------------------
INT 10 - VIDEO - READ OVERSCAN (BORDER COLOR) REGISTER (VGA)
	AX = 1008h
Return: BH = value
SeeAlso: AX=1001h
---------------------------------------------
INT 10 - VIDEO - READ ALL PALETTE REGISTERS AND OVERSCAN REGISTER (VGA)
	AX = 1009h
	ES:DX -> 17-byte buffer (see AX=1002h)
SeeAlso: AX=1002h,1007h
---------------------------------------------
INT 10 - VIDEO - SET INDIVIDUAL DAC REGISTER (EGA, VGA/MCGA)
	AX = 1010h
	BX = register number
	CH = new value for green (0-63)
	CL = new value for blue (0-63)
	DH = new value for red (0-63)
SeeAlso: AX=1012h,1015h
---------------------------------------------
INT 10 - VIDEO - SET BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)
	AX = 1012h
	BX = starting color register
	CX = number of registers to set
	ES:DX -> table of 3*CX bytes where each 3 byte group represents one
		 byte each of red, green and blue (0-63)
SeeAlso: AX=1010h,1017h
---------------------------------------------
INT 10 - VIDEO - SELECT VIDEO DAC COLOR PAGE (VGA)
	AX = 1013h
	BL = 00h Select paging mode
		BH = 00h Select 4 blocks of 64
		BH = 01h Select 16 blocks of 16
	BL = 01h Select Page
		BH = page number (00h to 03h) or (00h to 0Fh)
Note:	not valid in mode 13h
SeeAlso: AX=101Ah
---------------------------------------------
INT 10 - VIDEO - READ INDIVIDUAL DAC REGISTER (EGA, VGA/MCGA)
	AX = 1015h
	BL = palette register number
Return: DH = red value
	CH = green value
	CL = blue value
SeeAlso: AX=1010h,1017h
---------------------------------------------
INT 10 - VIDEO - READ BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)
	AX = 1017h
	BX = starting palette register
	CX = number of palette registers to read
	ES:DX -> buffer (3 * CX bytes in size) (see also AX=1012h)
Return: CX number of red, green and blue triples in buffer
SeeAlso: AX=1012h,1015h
---------------------------------------------
INT 10 - VIDEO - undocumented - SET PEL MASK (EGA, VGA/MCGA)
	AX = 1018h
	BL = new PEL value
SeeAlso: AX=1019h
---------------------------------------------
INT 10 - VIDEO - undocumented - READ PEL MASK (EGA, VGA/MCGA)
	AX = 1019h
Return:	BL = value read
SeeAlso: AX=1018h
---------------------------------------------
INT 10 - VIDEO - GET VIDEO DAC COLOR-PAGE STATE (VGA)
	AX = 101Ah
Return: BL = paging mode
	    00h four pages of 64
	    01h sixteen pages of 16
	BH = current page
SeeAlso: AX=1013h
---------------------------------------------
INT 10 - VIDEO - PERFORM GRAY-SCALE SUMMING (EGA, VGA/MCGA)
	AX = 101Bh
	BX = starting palette register
	CX = number of registers to convert
SeeAlso: AH=12h/BL=33h
---------------------------------------------
INT 10 - VIDEO - TEXT-MODE CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
	AH = 11h
	The following functions will cause a mode set, completely resetting
	the video environment, but without clearing the video buffer
	AL = 00h, 10h: load user-specified patterns
	    ES:BP -> user table
	    CX	  = count of patterns to store
	    DX	  = character offset into map 2 block
	    BL	  = block to load in map 2
	    BH	  = number of bytes per character pattern
	AL = 01h, 11h: load ROM monochrome patterns (8 by 14)
	    BL	  = block to load
	AL = 02h, 12h: load ROM 8 by 8 double-dot patterns
	    BL	  = block to load
	AL = 03h: set block specifier
	    BL	  = block specifier
		   (EGA/MCGA) bits 0,1 = block selected by chars with attribute
					 bit 3 = 0
			      bits 2,3 = block selected by chars with attribute
					 bit 3 = 1
		   (VGA) bits 0,1,4 = block selected by attribute bit 3 = 0
			 bits 2,3,5 = block selected by attribute bit 3 = 1
	AL = 04h, 14h: load ROM 8x16 character set (VGA)
	The routines called with AL=1xh are designed to be called only
	immediately after a mode set and are similar to the routines called
	with AL=0xh, except that:
	      Page 0 must be active.
	      Bytes/character is recalculated.
	      Max character rows is recalculated.
	      CRT buffer length is recalculated.
	      CRTC registers are reprogrammed as follows:
		     R09 = bytes/char-1 ; max scan line (mode 7 only)
		     R0A = bytes/char-2 ; cursor start
		     R0B = 0		; cursor end
		     R12 = ((rows+1)*(bytes/char))-1 ; vertical display end
		     R14 = bytes/char	; underline loc
			   (*** BUG: should be 1 less ***)
---------------------------------------------
INT 10 - VIDEO - GRAPHICS-MODE CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
	AH = 11h
	AL = 20h: set user 8 by 8 graphics characters (INT 1Fh)
	    ES:BP -> user table
	AL = 21h: set user graphics characters
	    ES:BP -> user table
	    CX	  = bytes per character
	    BL	  = row specifier
		   00h user set
		      DL = number of rows
		   01h 14 rows
		   02h 25 rows
		   03h 43 rows
	AL = 22h: ROM 8 by 14 set
	    BL = row specifier
	AL = 23h: ROM 8 by 8 double dot
	    BL = row specifier
	AL = 24h: load 8x16 graphics characters (VGA/MCGA)
	    BL = row specifier
Note:	these functions are meant to be called only after a mode set
---------------------------------------------
INT 10 - VIDEO - GET FONT INFORMATION (EGA, MCGA, VGA)
	AX = 1130h
	BH = pointer specifier
	    00h INT 1Fh pointer
	    01h INT 44h pointer
	    02h ROM 8 by 14 character font pointer
	    03h ROM 8 by 8 double dot font pointer
	    04h ROM 8 by 8 DD font (top half)
	    05h ROM alpha alternate (9 by 14) pointer
Return: ES:BP = specified pointer
	CX    = bytes/character
	DL    = character rows on screen
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA) - GET EGA INFO
	AH = 12h
	BL = 10h
Return: BH = 00h color mode in effect (I/O port 3Dxh)
  	     01h mono mode in effect (I/O port 3Bxh)
	BL = 00h  64k bytes memory installed
	     01h 128k bytes memory installed
	     02h 192k bytes memory installed
	     03h 256k bytes memory installed
	CH = feature bits
	CL = switch settings
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS,EGA,VGA,MCGA) - ALTERNATE PRTSC
	AH = 12h
	BL = 20h  select alternate print screen routine
SeeAlso: INT 05
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA) - SELECT VERTICAL RESOLUTION
	AH = 12h
	BL = 30h
	AL = vertical resolution
	     00h 200 scan lines
	     01h 350 scan lines
	     02h 400 scan lines
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - PALETTE LOADING
	AH = 12h
	BL = 31h
	AL = 00h enable default palette loading
	     01h disable default palette loading
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - VIDEO ADDRESSING
	AH = 12h
	BL = 32h
	AL = 00h enable video addressing
	     01h disable video addressing
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - GRAY-SCALE SUMMING
	AH = 12h
	BL = 33h
	AL = 00h enable gray scale summing
	     01h disable gray scale summing
Return: AL = 12h if function supported
SeeAlso: AX=101Bh
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA) - CURSOR EMULATION
	AH = 12h
	BL = 34h
	AL = 00h enable alphanumeric cursor emulation
	     01h disable alphanumeric cursor emulation
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS) - DISPLAY-SWITCH INTERFACE
	AH = 12h
	BL = 35h
	AL = 00h initial adapter video off
	     01h initial planar video on
	     02h switch active video off
	     03h switch inactive video on
	     80h *UNDOCUMENTED* set system board video active flag
	ES:DX -> buffer (128 byte save area if AL = 0, 2 or 3)
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, VGA) - VIDEO REFRESH CONTROL
	AH = 12h
	BL = 36h
	AL = 00h enable refresh
	     01h disable refresh
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNC SELECT (ATI,Tatung,Taxan) - ENHANCED FEATURES
	AH = 12h
	BH = 55h
	BL = subfunction
	    00h disabled enhanced features
	    01h enable enhanced features
	    02h get status
		Return: AL = status flags
			    bit 3: set if enhanced features enabled
			    bits 7-5 monitor type
				000 PS/2 mono
				001 PS/2 color
				010 multi-sync
				011 Taxan 650 25kHz
				100 RGB
				101 mono
				110 EGA
				111 Compaq internal
	    03h disable register trapping (CGA emulation)
	    04h enable register trapping
	    05h program mode described by table at ES:BP
	    06h get mode table
		AL = video mode
		Return: ES:BP -> table suitable for mode AL (and subfnc BL=05h)
			BP = FFFFh on error

Format of ATI VGA Wonder video mode table:
Offset	Size	Description
 00h	BYTE	number of columns
 01h	BYTE	maximum row (number of rows - 1)
 02h	BYTE	scan lines per row
 03h	WORD	video buffer size in bytes
 05h  4 BYTEs	values for Sequencer registers 1-4
 09h	BYTE	value for Miscellaneous Output register
 0Ah 25 BYTEs	values for CRTC registers 00h-18h
		00h horizontal total size (chars)
		01h horizontal displayed (chars)
		02h horizontal sync position (chars)
		03h horizontal sync width (chars)
		04h vertical total size (char rows)
		05h vertical total adjust (scan lines)
		06h vertical displayed (char rows)
		07h vertical sync position (char rows)
		08h interlace mode
		09h max scan line in row
		0Ah cursor start scan line
		0Bh cursor end scan line
		0Ch screen memory start (high)
		0Dh screen memory start (low)
		0Eh cursor address (high)
		0Fh cursor address (low)
		10h light pen (high)
		11h light pen (low)
 23h 20 BYTEs	default palette (values for Attribute Controller regs 00h-13h)
 37h  9 BYTEs	values for Graphics Controller registers 00h-08h
---------------------------------------------
INT 10 - VIDEO - WRITE STRING (AT,XT286,PS,EGA,VGA)
	AH = 13h
	AL = mode
	    bit 1: set if string contains alternating characters and attributes
	    bit 0: set in order to move cursor after write
	BL = attribute if AL bit 1 clear
	BH = display page number
	DH,DL = row,column of starting cursor position
	CX = length of string
	ES:BP -> start of string
Note:	recognizes CR, LF, BS, and bell
SeeAlso: AH=09h,0Ah
---------------------------------------------
INT 10 - VIDEO - LOAD USER-SPECIFIED LCD CHARACTER FONT (CONVERTIBLE)
	AX = 1400h
	ES:DI -> character font
	BH = number of bytes per character
	BL = 00h load main font (block 0)
	     01h load alternate font (block 1)
	CX = number of characters to store
	DX = character offset into RAM font area
SeeAlso: AH=11h,AX=1401h
---------------------------------------------
INT 10 - VIDEO - LOAD SYSTEM ROM DEFAULT LCD CHARACTER FONT (CONVERTIBLE)
	AX = 1401h
	BL = 00h load main font (block 0)
	     01h load alternate font (block 1)
SeeAlso: AH=11h,AX=1400h
---------------------------------------------
INT 10 - VIDEO - SET MAPPING OF LCD HIGH INTENSITY ATTRIBUTES (CONVERTIBLE)
	AX = 1402h
	BL = 00h ignore high intensity attribute
	     01h map high intensity to underscore
	     02h map high intensity to reverse video
	     03h map high intensity to selected alternate font
---------------------------------------------
INT 10 - VIDEO - GET PHYSICAL DISPLAY PARAMETERS (CONVERTIBLE)
	AH = 15h
Return: AX = alternate display adapter type
	    0000h none
	    5140h LCD
	    5153h CGA
	    5151h mono
	ES:DI -> parameter table (see below)
SeeAlso: AH=1Bh

Format of display parameter table:
Offset	Size	Description
 00h	WORD	monitor model number
 02h	WORD	vertical pixels per meter
 04h	WORD	horizontal pixels per meter
 06h	WORD	total vertical pixels
 08h	WORD	total horizontal pixels
 0Ah	WORD	horizontal pixel separation in micrometers
 0Ch	WORD	vertical pixel separation in micrometers
---------------------------------------------
INT 10 - VIDEO - SET SUPERIMPOSE MODE (Sperry PC)
	AH = 15h
	AL = superimpose mode
	    00h show graphics screen
	    01h show text screen
	    02h show text screen superimposed on graphics screen
---------------------------------------------
INT 10 - VIDEO - DISPLAY COMBINATION (PS,VGA/MCGA)
	AH = 1Ah
	AL = 00h read display combination code
		Return: BL = active display code (see below)
			BH = alternate display code
	     01h set display combination code
		BL = active display code (see below)
		BH = alternate display code
Return: AL = 1Ah if function was supported

Values for display combination code:
	00h no display
	01h monochrome adapter w/ monochrome display
	02h CGA w/ color display
	03h reserved
	04h EGA w/ color display
	05h EGA w/ monochrome display
	06h PGA w/ color display
	07h VGA w/ monochrome analog display
	08h VGA w/ color analog display
	09h reserved
	0Ah MCGA w/ digital color display
	0Bh MCGA w/ monochrome analog display
	0Ch MCGA w/ color analog display
	FFh unknown display type
---------------------------------------------
INT 10 - VIDEO - FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)
	AH = 1Bh
	BX = implementation type
	   = 0000h return funtionality/state information
	ES:DI -> 64 byte buffer for state information (see below)
Return: AL = 1Bh if function supported
	    ES:DI buffer filled with state information
SeeAlso: AH=15h

Format of state information:
Offset	Size	Description
 00h	DWORD	address of static funtionality table (see below)
 04h	BYTE	video mode in effect
 05h	WORD	number of columns
 07h	WORD	length of regen buffer in bytes
 09h	WORD	starting address of regen buffer
 0Bh	WORD	cursor position for page 0
 0Dh	WORD	cursor position for page 1
 0Fh	WORD	cursor position for page 2
 11h	WORD	cursor position for page 3
 13h	WORD	cursor position for page 4
 15h	WORD	cursor position for page 5
 17h	WORD	cursor position for page 6
 19h	WORD	cursor position for page 7
 1Bh	WORD	cursor type
 1Dh	BYTE	active display page
 1Eh	WORD	CRTC port address
 20h	BYTE	current setting of register (3?8)
 21h	BYTE	current setting of register (3?9)
 22h	BYTE	number of rows
 23h	WORD	bytes/character
 25h	BYTE	DCC of active display
 26h	BYTE	DCC of alternate display
 27h	WORD	number of colors supported in current mode
 29h	WORD	number of pages supported in current mode
 2Ah	BYTE	number of scan lines active
		(0,1,2,3) = (200,350,400,480)
 2Bh	BYTE	primary character block
 2Ch	BYTE	secondary character block
 2Dh	BYTE	miscellaneous flags
		bit 0 all modes on all displays on
		    1 gray summing on
		    2 monochrome display attached
		    3 default palette loading disabled
		    4 cursor emulation enabled
		    5 0 = intensity; 1 = blinking
		    6 reserved
		    7 reserved
 2Eh  3 BYTEs	reserved
 31h	BYTE	video memory available
		00h = 64K, 01h = 128K, 02h = 192K, 03h = 256K
 32h	BYTE	save pointer state flags
		bit 0 512 character set active
		    1 dynamic save area present
		    2 alpha font override active
		    3 graphics font override active
		    4 palette override active
		    5 DCC override active
		    6 reserved
		    7 reserved
 33h 13 BYTEs	reserved

Format of Static Functionality Table:
Offset	Size	Description
 00h	BYTE	modes supported #1
		bit 0 to bit 7 = 1 modes 0,1,2,3,4,5,6 supported
 01h	BYTE	modes supported #2
		bit 0 to bit 7 = 1 modes 8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh supported
 02h	BYTE	modes supported #3
		bit 0 to bit 3 = 1 modes 10h,11h,12h,13h supported
		bit 4 to bit 7 reserved
 03h  4 BYTEs	reserved
 07h	BYTE	scan lines supported
		bit 0 to bit 2 = 1 if scan lines 200,350,400 supported
 08h	BYTE	total number of character blocks available in text modes
 09h	BYTE	maximum number of active character blocks in text modes
 0Ah	BYTE	miscellaneous function flags #1
		bit 0 all modes on all displays function supported
		    1 gray summing function supported
		    2 character font loading function supported
		    3 default palette loading enable/disable supported
		    4 cursor emulation function supported
		    5 EGA palette present
		    6 color palette present
		    7 color paging function supported
 0Bh	BYTE	miscellaneous function flags #2
		bit 0 light pen supported
		    1 save/restore state function 1Ch supported
		    2 intensity blinking function supported
		    3 Display Combination Code supported
		  4-7 reserved
 0Ch	WORD	reserved
 0Eh	BYTE	save pointer function flags
		bit 0 512 character set supported
		    1 dynamic save area supported
		    2 alpha font override supported
		    3 graphics font override supported
		    4 palette override supported
		    5 DCC extension supported
		    6 reserved
		    7 reserved
 0Fh	BYTE	reserved
---------------------------------------------
INT 10 - VIDEO - SAVE/RESTORE VIDEO STATE (PS50+,VGA)
	AH = 1Ch
	AL = 00h return state buffer size
		Return: BX = number of 64 byte blocks needed
	     01h save video state
		ES:BX -> buffer
	     02h restore video state
		ES:BX -> buffer containing previously saved state
	CX = requested states
	     bit 0 video hardware
		 1 BIOS data areas
		 2 color registers and DAC state
	      3-15 reserved
Return: AL = 1Ch if function supported
---------------------------------------------
INT 10 - VIDEO - LOCATE 3270PC CONFIGURATION TABLE
	AX = 3000h
	CX = 0000h
	DX = 0000h
Return: CX:DX -> 3270PC configuration table (see below for format)
	CX:DX = 0000h:0000h if 3270PC Control Program not active

Format of 3270 PC configuration table:
Offset	Size	Description
 00h	BYTE	aspect ratio X
 01h	BYTE	aspect ratio Y
 02h	BYTE	monitor type
		00h = 5151 (mono) or 5272 (color)
		01h = 3295
		02h = 5151 or 5272 with XGA (???) graphics adapter
		03h = 5279 with 3270PC G adapter
		04h = 5379 model C01 with 3270PC GX adapter
		05h = 5379 model M01 with 3270PC GX adapter
		07h = non-3270PC with 3270 Workstation Program
		FFh = 3270PC Control Program not loaded
 03h	BYTE	reserved
 04h	BYTE	adapter ID
		00h = 5151/5272 adapter
		04h = 5151/5272 with XGA adapter
		30h = 3295 or 3270PC G/GX adapter
 05h	BYTE	reserved
 06h	BYTE	function flags 1
		bit 7: mono text, 1 page
		    6: color text, 1 page
		    5: color text, 4 pages
		    4: CGA color graphics
		    3: 720x350 two-color graphics
		    2: 360x350 four-color graphics
		    1: 720x350 eight-color graphics
 07h	BYTE	function flags 2
		bit 6: GPI graphics supported
 08h	WORD	segment address of Control Program Level table (see below)
 0Ah 10 BYTEs	reserved

Format of Control Program Level table:
Offset	Size	Description
 00h	WORD	02xxh = 3270PC Control Program v2.xx
		03xxh = 3270PC Control Program v3.xx
		04xxh = 3270 Workstation Program v1.xx
 02h	BYTE	Control Program ID (00h)
 03h 27 BYTEs	Control Program Descriptor ("IBM 3270 PC CONTROL PROGRAM")
---------------------------------------------
INT 10 - VIDEO - SET GRAPHICS MODE (Hercules GRAFIX)
	AH = 40h
SeeAlso: AH=41h
---------------------------------------------
INT 10 - VIDEO - SET TEXT MODE (Hercules GRAFIX)
	AH = 41h
SeeAlso: AH=40h
---------------------------------------------
INT 10 - VIDEO - CLEAR CURRENT PAGE (Hercules GRAFIX)
	AH = 42h
---------------------------------------------
INT 10 - VIDEO - SELECT DRAWING PAGE (Hercules GRAFIX)
	AH = 43h
	AL = page number (0,1)
SeeAlso: AH=45h
---------------------------------------------
INT 10 - VIDEO - SELECT DRAWING FUNCTION (Hercules GRAFIX)
	AH = 44h
	AL = drawing function
	    00h clear pixels
	    01h set pixels
	    02h invert pixels
---------------------------------------------
INT 10 - VIDEO - SELECT PAGE TO DISPLAY (Hercules GRAFIX)
	AH = 45h
	AL = page number (0,1)
SeeAlso: AH=43h
---------------------------------------------
INT 10 - VIDEO - DRAW ONE PIXEL (Hercules GRAFIX)
	AH = 46h
	DI = x (0-720)
	BP = y (0-347)
Note:	function 44h determines operation and function 43h which page to use
SeeAlso: AH=47h
---------------------------------------------
INT 10 - VIDEO - FIND PIXEL VALUE (Hercules GRAFIX)
	AH = 47h
	DI = x (0-720)
	BP = y (0-347)
Return: AL = 00h pixel clear
	AL = 01h pixel set
Note:	function 43h specifies which page is used
SeeAlso: AH=46h
---------------------------------------------
INT 10 - VIDEO - MOVE TO POINT (Hercules GRAFIX)
	AH = 48h
	DI = x (0-720)
	BP = y (0-347)
SeeAlso: AH=49h
---------------------------------------------
INT 10 - VIDEO - DRAW TO POINT (Hercules GRAFIX)
	AH = 49h
	DI = x (0-720)
	BP = y (0-347)
Note:	function 48h or 49h specify first point, 44h operation and 43h page to
	  use
SeeAlso: AH=43h,44h,48h
---------------------------------------------
INT 10 - VIDEO - BLOCK FILL (Hercules GRAFIX)
	AH = 4Ah
	DI = x coordinate of lower left corner
	BP = y coordinate of lower left corner
	BX = height in pixels
	CX = width in pixels
Note:	draws a solid rectangle
SeeAlso: AH=4Eh
---------------------------------------------
INT 10 - VIDEO - DISPLAY CHARACTER (Hercules GRAFIX)
	AH = 4Bh
	AL = character to display
	DI = x (0-720)
	BP = y (0-347)
Note:	unlike the other BIOS character functions character position is
	  specified in pixels rather than rows and columns
---------------------------------------------
INT 10 - FRIEZE v7+ - API
	AH = 4Bh
	CL = function
	    00h reserved
	    01h load window
		ES:BX -> ASCIZ filename from which to read
	    02h save window
		ES:BX -> ASCIZ filename to which to write
	    07h set window size
		ES:BX -> four-WORD structure with Xmin, Ymin, Xmax, Ymax
	    09h set patterns
		ES:BX -> 16-BYTE vector of screen->printer color correspondnces
	    0Ah get patterns
		ES:BX -> 16-BYTE buffer for color correspondences
	    0Bh set mode
		AL = mode
	    0Fh get window
		ES:BX -> four-WORD buffer for Xmin, Ymin, Xmax, Ymax
	    10h set print options
		ES:BX -> printer options in same format as FRIEZE cmdline
	    14h get version
		Return: AH = major version (00h if FRIEZE version before 7)
			AL = minor version
	    15h set parameters
		ES:BX -> parameter table (see below)
	    16h get parameters
		ES:BX -> buffer for parameter table (see below)
	    17h get printer resolution
		ES:BX -> 12-WORD table for six horizontal/vertical resol pairs
	    18h reserved (v8.0 only)
Return: AX = status
	    00h successful
	    01h user aborted printout with ESC
	    02h reserved
	    03h file read error
	    04h file write error
	    05h file not found
	    06h invalid header (not an image or wrong screen mode)
	    07h file close error
	    08h disk error
	    09h printer error
	    0Ah invalid function
	    0Bh can't create file
	    0Ch wrong video mode

Format of parameter table:
Offset	Size	Description
 00h	WORD	top margin (1/100 inch)
 02h	WORD	left margin (1/100 inch)
 04h	WORD	horizontal size (1/100 inch)
 06h	WORD	vertical size (1/100 inch)
 08h	WORD	quality/draft mode
		00h draft mode
		01h quality mode
		02h use horizontal/vertical resolution for output resolution
 0Ah	WORD	printer horizontal resolution (dots per inch)
 0Ch	WORD	printer vertical resolution (dots per inch)
 0Eh	WORD	reserved (FFFFh)
Note:	any field which should remain unchanged may be filled with FFFFh
---------------------------------------------
INT 10 - VIDEO - DRAW ARC (Hercules GRAFIX)
	AH = 4Ch
	AL = quadrant (1 = upper right, 2 = upper left, etc)
	DI = x coordinate of center
	BP = y coordinate of center
	BX = radius
SeeAlso: AH=4Dh
---------------------------------------------
INT 10 - VIDEO - DRAW CIRCLE (Hercules GRAFIX)
	AH = 4Dh
	DI = x of center
	BP = y of center
	BX = radius
SeeAlso: AH=4Ch
---------------------------------------------
INT 10 - VIDEO - FILL AREA (Hercules GRAFIX)
	AH = 4Eh
	DI = x coordinate of an interior point
	BP = y coordinate of an interior point
Notes:	fills convex polygonal areas
	the first fill makes the figure solid, the second erases it
SeeAlso: AH=4Ah
---------------------------------------------
INT 10 - VESA SuperVGA BIOS - GET SuperVGA INFORMATION
	AX = 4F00h
	ES:DI -> 256-byte buffer for SuperVGA information (see below)
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed

Format of SuperVGA information:
Offset	Size	Description
 00h  4 BYTEs	signature ('VESA')
 04h	WORD	VESA version number
 06h	DWORD	pointer to OEM name
 0Ah  4 BYTEs	capabilities
 0Eh	DWORD	pointer to list of supported VESA and OEM video modes
 12h 238 BYTEs	reserved
---------------------------------------------
INT 10 - VESA SuperVGA BIOS - GET SuperVGA MODE INFORMATION
	AX = 4F01h
	CX = SuperVGA video mode
	ES:DI -> 256-byte buffer mode information (see below)
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed

Format of mode information:
Offset	Size	Description
 00h	WORD	mode attributes
		bit 0: mode supported
		bit 1: optional information available
		bit 2: BIOS output supported
		bit 3: set if color, clear if monochrome
		bit 4: set if graphics mode, clear if text mode
 02h	BYTE	window A attributes
		bit 0: exists
		bit ???: readable
		bit ???: writable
 03h	BYTE	window B attributes (as for window A)
 04h	WORD	window granularity
 06h	WORD	window size
 08h	WORD	start segment of window A
 0Ah	WORD	start segment of window B
 0Ch	DWORD	-> FAR window positioning function (equivalent to AX=4F05h)
 10h	WORD	bytes per scan line
---remainder is optional for VESA modes, needed for OEM modes---
 12h	WORD	width in pixels
 14h	WORD	height in pixels
 16h	BYTE	width of character cell in pixels
 17h	BYTE	height if character cell in pixels
 18h	BYTE	number of memory planes
 19h	BYTE	number of bits per pixel
 1Ah	BYTE	number of banks
 1Bh	BYTE	memory model type
 1Ch	BYTE	size of bank in K
---------------------------------------------
INT 10 - VESA SuperVGA BIOS - SET SuperVGA VIDEO MODE
	AX = 4F02h
	BX = mode
		bit 15 set means don't clear video memory
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
SeeAlso: AX=4F03h

Values for VESA video mode
 100h	640x400x256
 101h	640x480x256
 102h	800x600x16
 103h	800x600x256
 104h	1024x768x16
 105h	1024x768x256
 106h	1280x1024x16
 107h	1280x1024x256
---------------------------------------------
INT 10 - VESA SuperVGA BIOS - GET CURRENT VIDEO MODE
	AX = 4F03h
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
	BX = video mode
SeeAlso: AX=4F02h
---------------------------------------------
INT 10 - VESA SuperVGA BIOS - SAVE/RESTORE SuperVGA VIDEO STATE
	AX = 4F04h
	DL = subfunction
	    00h get state buffer size
		Return: BX = number of 64-byte blocks needed
	    01h save video states
		ES:BX -> buffer
	    02h restore video states
		ES:BX -> buffer
	CX = flags for states to save/restore
	    bit 0: video hardware state
	    bit 1: video BIOS data state
	    bit 2: video DAC state
	    bit 3: SuperVGA state
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
---------------------------------------------
INT 10 - VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL
	AX = 4F05h
	BH = subfunction
	    00h select video memory window
		DX = window address in video memory (in granularity units)
	    01h get video memory window
		Return: DX = window address in video memory (in gran. units)
	BL = window number
	    00h window A
	    01h window B
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
---------------------------------------------
INT 10 - SCROLOCK.COM - INSTALLATION CHECK
	AH = 50h
Return: BX = 1954h if installed
	    AL = 00 if inactive, nonzero if active
Note:	SCROLOCK is a utility supplied with System Enhancement Associates' ARC
SeeAlso: AH=51h
---------------------------------------------
INT 10 - SCROLOCK.COM - ENABLE/DISABLE
	AH = 51h
	AL = state
	    00h disable
	    nonzero enable
Note:	SCROLOCK is a utility supplied with System Enhancement Associates' ARC
SeeAlso: AH=50h
---------------------------------------------
INT 10 - VIDEO - ATI EGA/VGA Wonder Super Switch - INSTALLATION CHECK
	AX = 5555h
Return: AX = AAAAh    if installed
	BX:CX -> ??? routine in SMS.COM resident portion
	      -> data area in VCONFIG
Note:	Super Switch (SMS.COM) is a video mode switch program supplied with
	  ATI EGA Wonder. It also maps video mode 08h to 27h or 23h
SeeAlso: INT 10/AH=00h

Format of data area:
Offset	Size	Description
 00h	DWORD	original INT 09 vector
 04h	DWORD	original INT 10 vector
 08h	DWORD	original INT 1C vector
 0Ch	WORD	screen saver state, 0=off, 1=on
 0Eh	WORD	blanking interval in clock ticks
---------------------------------------------
INT 10 - Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES
	AX = 6A00h
	BX = 0000h
	CX = 0000h
	DX = buffer length (may be 0)
	ES:DI -> buffer
Return: BX = number of bytes stored in buffer
	CX = bytes required for all descriptions (0 if no DGIS)
Note:	buffer contains descriptions and addresses of DGIS-compatible
	  display(s) and printer(s)
---------------------------------------------
INT 10 - DGIS - REDIRECT CHARACTER OUTPUT
	AX = 6A01h
	CX = 0000h
	ES:DI = address of device to send INT 10 output to
Return: CX = 0000h  output could not be redirected
	     else INT 10h output now routed to requested display
SeeAlso: AX=6A02h
---------------------------------------------
INT 10 - DGIS - INQUIRE INT 10 OUTPUT DEVICE
	AX = 6A02h
	ES:DI = 0000h:0000h
Return: ES:DI = 0000h:0000h  if current display is non-DGIS
		else address of the current DGIS INT 10 display
SeeAlso: AX=6A01h
---------------------------------------------
INT 10 - VIDEO - INSTALLATION CHECK (Video7 VGA,VEGA VGA)
	AX = 6F00h
Return: BX = 5637h ('V7') indicates Video7 VGA/VEGA VGA extensions are present
---------------------------------------------
INT 10 - VIDEO - GETINFO (Video7 VGA,VEGA VGA)
	AX = 6F01h
Return: AL = monitor type code (VEGA VGA only)
	AH = status register information
	     bit  0 = display enable
			0 = display enabled
			1 = vertical or horizontal retrace in progress
	     bit  1 = light pen flip flop set
	     bit  2 = light pen switch activated
	     bit  3 = vertical sync
	     bit  4 = monitor resolution
			0 = high resolution (>200 lines)
			1 = low resolution (<=200 lines)
	     bit  5 = display type
			0 = color
			1 = monochrome
	     bits6,7= diagnostic bits
Note:	bits 0-3 are the same as the EGA/VGA status register bits 0-3
---------------------------------------------
INT 10 - VIDEO - GET MODE AND SCREEN RESOLUTION (Video7 VGA, VEGA VGA)
	AX = 6F04h
Return: AL = current video mode (see AX=6F05h)
	BX = horizontal columns (text) or pixels (graphics)
	CX = vertical columns (text) or pixels (graphics)
SeeAlso: AX=6F05h
---------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE (Video7 VGA, VEGA EXTENDED EGA/VGA)
	AX = 6F05h
	BL = mode (graphics mode if graphics resolution listed)
		 text  pixel graphic color disp scrn  system
		 resol	box  resoltn	   page addr
	   00h-13h = standard IBM modes
	   40h = 80x43	8x8			     Video7/VEGA VGA
	   41h = 132x25 8x14			     Video7/VEGA VGA
	   42h = 132x43 8x8			     Video7/VEGA VGA
	   43h = 80x60	8x8			     Video7/VEGA VGA
	   44h = 100x60 8x8			     Video7/VEGA VGA
	   45h = 132x28 8x8			     Video7/VEGA VGA
	   60h =	     752x410  16	     Video7 VGA, VEGA VGA
	   61h =	     720x540  16	     Video7 VGA, VEGA VGA
	       =	     720x540  16	     Northgate
	   62h =	     800x600  16	     Video7 VGA, VEGA Ext EGA
	   63h =	    1024x768   2	     Video7 VGA
	   64h =	    1024x768   4	     Video7 VGA
	   65h =	    1024x768  16	     Video7 VGA, VEGA Ext EGA
	   66h =	     640x400 256	     Video7 VGA, VEGA Ext VGA
	       =	     640x400 256	     Northgate
	   67h =	     640x480 256	     Video7 VGA, VEGA Ext VGA
	   68h =	     720x540 256	     Video7 VGA, VEGA Ext VGA
	   69h =	     800x600 256	     Video7 VGA, VEGA Ext VGA
	   70h =	     752x410  16gray	     Video7 VGA, VEGA VGA
	   71h =	     720x540  16gray	     Video7 VGA, VEGA VGA
	   72h =	     800x600  16gray	     Video7 VGA
	   73h =	    1024x768   2gray	     Video7 VGA
	   74h =	    1024x768   4gray	     Video7 VGA
	   75h =	    1024x768  16gray	     Video7 VGA
	   76h =	     640x400 256gray	     Video7 VGA
	   77h =	     640x480 256gray	     Video7 VGA
	   78h =	     720x540 256gray	     Video7 VGA
	   79h =	     800x600 256gray	     (future)
SeeAlso: AH=00h,AX=0070h,AX=007Eh,AX=6F04h
---------------------------------------------
INT 10 - VIDEO - SELECT AUTOSWITCH MODE (V7VGA,VEGA VGA)
	AX = 6F06h
	BL = Autoswitch mode select
	     00h select EGA/VGA-only modes
	     01h select Autoswitched VGA/EGA/CGA/MGA modes
	     02h select 'bootup' CGA/MGA modes
	BH = enable/disable (00h enable, 01h = disable selection)
---------------------------------------------
INT 10 - VIDEO - GET VIDEO MEMORY CONFIGURATION (V7VGA,VEGA VGA)
	AX = 6F07h
Return: AL = 6Fh
	AH = bits 0-6 = number of 256K blocks of video memory
	     bit 7    = DRAM/VRAM (0: DRAM, 1: VRAM)
	BH = chip revision (SR8F) (S/C Chip in VEGA VGA)
	BL = chip revision (SR8E) (G/A Chip in VEGA VGA)
	CX = 0000h
SeeAlso: AH=12h/BL=10h
---------------------------------------------
INT 10 - VIDEO - GET VIDEO RAM ADDRESS (TANDY 1000)
	AH = 70h
Return: AX  = segment address of the following
	[BX] = offset address of green plane
	[CX] = segment address of green plane
	[DX] = segment address of red/blue plane
	       (red offset = 0, blue offset = 4000)
SeeAlso: AH=71h
---------------------------------------------
INT 10 - VIDEO - GET INCRAM ADDRESSES (TANDY 1000)
	AH = 71h
Return: AX  = segment address of the following
	[BX] = segment address of INCRAM
	[CX] = offset address of INCRAM
SeeAlso: AH=70h
---------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN RIGHT (TANDY 1000)
	AH = 72h
	AL = number of columns blanked at left of window
	     00h = blank entire window
	BH = attributes to be used on blank columns
	CH,CL = row, column of upper left corner of window
	DH,DL = row, column of lower right corner
SeeAlso: AH=06h,07h,73h
--------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN LEFT (TANDY 1000)
	AH = 73h
	AL = number of columns blanked at right of window
	     00h = blank entire window
	BH = attributes to be used on blank columns
	CH,CL = row, column of upper left corner of window
	DH,DL = row, column of lower right corner
SeeAlso: AH=06h,07h,72h
---------------------------------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - SET ??? HANDLER
	AH = 80h
	DX = 4456h ('DV')
	ES:DI -> FAR subroutine to be called on ???
Return: DS = segment of DESQview data structure for video buffer
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
	the subroutine seems to be called when the DESQview menu is accessed;
	  on entry, AL = 3 or 4
---------------------------------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - GET ???
	AH = 81h
	DX = 4456h ('DV')
Return: ES = segment of DESQview data structure for video buffer
	    BYTE ES:[0] = current window number in DV 2.0x
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
---------------------------------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - GET CURRENT WINDOW INFO
	AH = 82h
	DX = 4456h ('DV')
Return: DS = segment in DESQview for data structure
	     in DV 2.00,
		  BYTE DS:[0] = window number
		  WORD DS:[1] = segment of other data structure
		  WORD DS:[3] = segment of window's object handle
	ES = segment of DESQview data structure for video buffer
	AL = current window number
	AH = ???
	BL = direct screen writes
	    00h program does not do direct writes
	    01h program does direct writes, so shadow buffer not usable
	BH = ???
	CL = current video mode
	CH = ???
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SELECT EXTERNAL MONITOR
	AX = BF00h
Note:	all registers preserved and the internal monitor is blanked
	the external monitor becomes the active monitor
SeeAlso: AX=BF01h
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SELECT INTERNAL MONITOR
	AX = BF01h
Note:	all registers preserved and the external monitor is blanked
	the internal monitor becomes the active monitor
SeeAlso: AX=BF00h
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SET MASTER MODE OF CURRENT CTRLR
	AX = BF02h
	BH = master mode
	    04h CGA
	    05h EGA
	    07h MDA
SeeAlso: AX=BF03h
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - GET ENVIRONMENT
	AX = BF03h
	BX = 0000h
Return: BH = active monitor
	    00h = external
	    01h = internal
	BL = master mode
	    00h = switchable VDU not present
	    04h = CGA
	    05h = EGA
	    07h = MDA
	CH = 00h (reserved)
	CL = switchable VDU mode supported
	    bit  0   = CGA supported
	    bits 1,2 = reserved (1)
	    bit  3   = MDA supported
	    bits 4-7 = reserved (1)
	DH = internal monitor type
	    00h = none
	    01h = Dual-mode monitor
	    02h = 5153 RGB monitor
	    03h = Compaq Color monitor
	    04h = 640x400 flat panel
	DL = external monitor type
	    00h = none
	    01h = dual-mode monitor
	    02h = 5153 RGB monitor
	    03h = Compaq Color monitor
	    04h = 640x400 flat panel
SeeAlso: AH=1Ah, AX=BF00h,BF01h,BF02h
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SET MODE SWITCH DELAY
	AX = BF04h
	BH = 00h enable delay
	     01h disable delay
---------------------------------------------
INT 10 - VIDEO - MSHERC.COM - INSTALLATION CHECK???
	AH = EFh
Return: DL = video adapter type
	    00h original Hercules
	    01h ???  \ one is probably Hercules Plus, the other
	    02h ???  / Hercules InColor
	    FFh non-Hercules 
	DH = ???
Note:	MSHERC.COM is a support program for the Microsoft Quick languages which
	  makes their graphics libraries compatible with a Hercules card by
	  adding video modes 08h and 88h, and supporting text in the new
	  graphics modes.  While in mode 08h or 88h, INT 10 supports the
	  Hercules card much like a CGA.
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ ONE REGISTER
	AH = F0h
	BL = register number
	BH = 00h
	DX = group index
	    Pointer/data chips
	       00h CRT Controller (25 reg) 3B4h mono modes, 3D4h color modes
	       08h Sequencer (5 registers) 3C4h
	       10h Graphics Controller (9 registers) 3CEh
	       18h Attribute Controller (20 registers) 3C0h
	    Single registers
	       20h Miscellaneous Output register 3C2h
	       28h Feature Control register (3BAh mono modes, 3DAh color modes)
	       30h Graphics 1 Position register 3CCh
	       38h Graphics 2 Position register 3CAh
Return: BL = data
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F1h,F2h
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE ONE REGISTER
	AH = F1h
	DX = group index (see AH=F0h)
	    if single register:
		BL = value to write
	    otherwise
		BL = register number
		BH = value to write
Return: BL = data
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F0h,F3h
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER RANGE
	AH = F2h
	CH = starting register number
	CL = Number of registers (>1)
	DX = group index
	     00h CRTC (3B4h mono modes, 3D4h color modes)
	     08h Sequencer 3C4h
	     10h Graphics Controller 3CEh
	     18h Attribute Controller 3C0h
	ES:BX -> buffer, CL bytes
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F0h,F3h
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE REGISTER RANGE
	AH = F3h
	CH = starting register
	CL = number of registers (>1)
	DX = group index (see AH=F2h)
	ES:BX -> buffer, CL bytes
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F1h,F2h
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER SET
	AH = F4h
	CX = number of registers to read (>1)
	ES:BX -> table of records (see below)
Return: register values in table filled in
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F0h,F2h,F5h

Format of entries in table of register records:
Offset	Size	Description
 00h	WORD	group index
		Pointer/data chips
		   00h CRTC (3B4h mono modes, 3D4h color modes)
		   08h Sequencer 3C4h
		   10h Graphics Controller 3CEh
		   18h Attribute Controller 3C0h
		Single registers
		   20h Miscellaneous Output register 3C2h
		   28h Feature Control register (3BAh mono modes, 3DAh color)
		   30h Graphics 1 Position register 3CCh
		   38h Graphics 2 Position register 3CAh
 02h	BYTE	register number (0 for single registers)
 03h	BYTE	register value
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE REGISTER SET
	AH = F5h
	CX = number of registers to write (>1)
	ES:BX -> table of records (see AH=F4h)
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F1h,F3h,F4h
--------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - REVERT TO DEFAULT REGISTERS
	AH = F6h
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F7h
--------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - DEFINE DEFAULT REGISTER TABLE
	AH = F7h
	DX = port number
	   Pointer/data chips
	      00h CRTC (3B4h mono modes, 3D4h color modes)
	      08h Sequencer 3C4h
	      10h Graphics Controller 3CEh
	      18h Attribute Controller 3C0h
	   Single registers
	      20h Miscellaneous Output register 3C2h
	      28h Feature Control register (3BAh mono modes, 3DAh color modes)
	      30h Graphics 1 Position register 3CCh
	      38h Graphics 2 Position register 3CAh
	ES:BX -> table of one-byte entries, one byte to be written to each
		 register
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F6h
--------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - INTERROGATE DRIVER
	AH = FAh
	BX = 0000h
Return: BX = 0000h if mouse driver not present
	ES:BX -> EGA Register Interface version number, if present:
	    byte 0 = major release number
	    byte 1 = minor release number
Note:	also present in OS/2 compatibility box
--------------------------------------------
INT 10 - FASTBUFF.COM - INSTALLATION CHECK
	AH = FAh
Return: AX = 00FAh if installed
	    ES = segment of resident code
Note:	FASTBUFF.COM is a keyboard speedup/screen blanking utility by David
	  Steiner
--------------------------------------------
INT 10 - VIDEO (TopView) - GET VIDEO BUFFER
	AH = FEh
	ES:DI = segment:offset of assumed video buffer
Return: ES:DI = segment:offset of actual video buffer
Notes:	if no multitasker is installed, ES:DI is returned unchanged
	TopView requires a call to AH=FFh to notify if that the screen has
	  changed; DESQview will check for changes itself until the first call
	  to AH=FFh
SeeAlso: INT 15/AX=1024h, INT 21/AH=2Bh"DESQview"
---------------------------------------------
INT 10 - VIDEO (TopView) - UPDATE REAL SCREEN FROM VIDEO BUFFER
	AH = FFh
	CX = number of sequential characters that have been modified
	DI = offset of first character that has been modified
	ES = segment of video buffer
Notes:	avoid CX=0000h
	DESQview will discontinue the automatic screen updating initiated by
	  AH=FEh after this call
---------------------------------------------
INT 11 - 80486 internal hardware - ALIGNMENT CHECK
   Bit AC in the EFLAGS register enables this interrupt on a memory reference
     on a mis-aligned address when in privilege mode 3.
---------------------------------------------
INT 11 - EQUIPMENT DETERMINATION
Return: AX = equipment flag bits
	    0	  diskette installed
	    1	  8087 present
	    2	  mouse installed (PS2 only)
	    2,3   number of 16K banks of RAM on motherboard (PC only)
		  number of 64K banks of RAM on motherboard (XT only)
		  always = 11 on AT and above
	    4,5   initial video mode
		  01 = 40x25 color
		  10 = 80x25 color
		  11 = 80X25 IBM monochrome
	    6,7   number of diskette drives (only if bit 0 = 1)
		  00 = 1, 01 = 2, 10 = 3, 11 = 4
	    8	  0 = DMA present
		  1 = no DMA on system (PCjr, some Tandy 1000s, 1400LT)
	    9-11  number of RS232 cards
	    12	  game I/O attached
	    13	  serial printer installed (PCjr)
		  internal modem installed (PC/Convertible)
	    14,15 number of printers
---Compaq and many other 386/486 machines--
	EAX bit 23: page tables set so that Weitek coprocessor addressable in
			real mode
	    bit 24: Weitek math coprocessor present
SeeAlso: INT 12
---------------------------------------------
INT 11 - BACK&FORTH API
	AX = FFFEh
	CX = FFFEh
	BX = function
	    00h installation check
		Return: AX = 0001h BNFHIGH and BNFLOW both loaded
			   = 0003h only BNFHIGH loaded
			   else neither loaded
	    01h ???
		Return: DX:AX -> ???
	    02h ???
	    03h ???
	    04h ???
	    05h ??? switches current PSP segment and stack if BNFLOW has not
		    yet announced itself installed
	    06h ???
		Return: AX = ???
---------------------------------------------
INT 12 - MEMORY SIZE
Return: AX = number of contiguous 1K blocks of memory
SeeAlso: INT 11
---------------------------------------------
INT 13 - DISK - RESET DISK SYSTEM
	AH = 00h
	DL = drive (if bit 7 is set both hard disks and floppy disks reset)
Note:	forces controller to recalibrate drive heads (seek to track 0)
SeeAlso: AH=0Dh, INT 21/AH=0Dh
---------------------------------------------
INT 13 - DISK - STATUS OF DISK SYSTEM
	AH = 01h
Return: AH = status of last disk operation
	    00h = successful completion
	    01h = bad command
	    02h = address mark not found
	    03h = write attempted on write-protected disk
	    04h = sector not found
	    05h = reset failed (hard disk)
	    06h = diskette changed
	    07h = parameter act. failed (hard disk)
	    08h = DMA overrun (floppy disk)
	    09h = DMA across 64K boundary
	    0Ah = bad sector detected (hard disk)
	    0Bh = bad track detected (hard disk)
	    0Ch = unsupported track
	    0Dh = invalid number of sectors on format (hard disk)
	    0Eh = control data address mark detected (hard disk)
	    0Fh = DMA arbitration error (hard disk)
	    10h = bad CRC/ECC
	    11h = data ECC corrected (hard disk)
	    20h = controller failure
	    40h = seek failed
	    80h = time out
	    AAh = drive not ready (hard disk)
	    BBh = undefined error (hard disk)
	    CCh = write fault (hard disk)
	    E0h = status register error (hard disk)
	    FFh = sense operation failed (hard disk)
---------------------------------------------
INT 13 - DISK - READ SECTORS INTO MEMORY
	AH = 02h
	AL = number of sectors to read
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors/track for drive)
	DH = head
	DL = drive
	ES:BX -> buffer to fill
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors read
Notes:	results undefined if attempting to read zero sectors
	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=03h,AH=0Ah
---------------------------------------------
INT 13 - DISK - WRITE SECTORS FROM MEMORY
	AH = 03h
	AL = number of sectors to write
	CH = track (if hard disk, bits 8,9 in high bits of CL)
	CL = sector (if hard disk, high two bits are high bits of track #)
	DH = head
	DL = drive
	ES:BX -> buffer
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors written
Notes:	results undefined if attempting to write zero sectors
	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=02h,AH=0Bh
---------------------------------------------
INT 13 - DISK - VERIFY SECTORS
	AH = 04h
	AL = number of sectors to verify
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors per track for drive)
	DH = head
	DL = drive
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors verified
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=02h
---------------------------------------------
INT 13 - FLOPPY - FORMAT TRACK
	AH = 05h
	AL = number of sectors to create on this track
	CH = track
	CL = sector (01h to number of sectors per track for drive)
	DH = head
	DL = drive
	ES:BX -> array of 4-byte address fields
		BYTE	track
		BYTE	head
		BYTE	sector
		BYTE	bytes/sector  0=128, 1=256, 2=512, 3=1024
Return: CF set if error occurred
	AH = status code (see AH=01h)
---------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK
	AH = 05h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer
		the first 2*(sectors/track) bytes contain F,N for each sector
		   F = 00 for good sector, 80h for bad sector
		   N = sector number
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number (01h to number of sectors per track for drive)
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=06h,07h,1Ah
---------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)
	AH = 06h
	AL = interleave value
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
---------------------------------------------
INT 13 - FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)
	AH = 07h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer (see AH=05h)
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Note:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=1Ah
---------------------------------------------
INT 13 - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
	AH = 08h
	DL = drive number
Return: CF set on error
	AH = status code (see AH=01h)
	BL = drive type (see AH=17h) (AT/PS2 floppies only)
	DL = number of consecutive acknowledging drives
	DH = maximum value for head number
	CL = maximum value for sector number (bits 0-5)
	CH = maximum value for cylinder number (highest bits in bits 6,7 of CL)
	ES:DI -> drive parameter table
SeeAlso: INT 1E, INT 41
---------------------------------------------
INT 13 - FIXED DISK - INITIALIZE TWO FIXED DISK BASE TABLES (XT,AT,XT286,PS)
	AH = 09h
Return: CF set on error
	AH = status code (see AH=01h)
	INT 41h points to table for drive 0
	INT 46h points to table for drive 1
---------------------------------------------
INT 13 - FIXED DISK - READ LONG (XT,AT,XT286,PS)
	AH = 0Ah
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors per track for drive)
	ES:BX -> buffer to fill
Return: CF set on error
	AH = status code (see AH=01h)
	AL = number of sectors read
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=02h,AH=0Bh
---------------------------------------------
INT 13 - FIXED DISK - WRITE LONG (XT,AT,XT286,PS)
	AH = 0Bh
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors per track for drive)
	ES:BX -> buffer containing data
Return: CF set on error
	AH = status code (see AH=01h)
	AL = number of sectors written
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=03h,AH=0Ah
---------------------------------------------
INT 13 - FIXED DISK - SEEK TO CYLINDER (XT,AT,XT286,PS)
	AH = 0Ch
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
Return: CF set on error
	AH = status code (see AH=01h)
---------------------------------------------
INT 13 - FIXED DISK - ALTERNATE DISK RESET (XT,AT,XT286,PS)
	AH = 0Dh
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
Note:	not for PS/2 ESDI drives
SeeAlso: AH=00h, INT 21/AH=0Dh
---------------------------------------------
INT 13 - FIXED DISK - READ SECTOR BUFFER (XT,PS)
	AH = 0Eh
	ES:BX -> buffer
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	transfers controller's sector buffer.  No data is read from the drive
	used for diagnostics only on PS/2 systems
SeeAlso: AH=0Ah
---------------------------------------------
INT 13 - FIXED DISK - WRITE SECTOR BUFFER (XT,PS)
	AH = 0Fh
	ES:BX -> buffer
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	should be called before formatting to initialize the controller's
	  sector buffer.
	used for diagnostics only on PS/2 systems
SeeAlso: AH=0Bh
---------------------------------------------
INT 13 - FIXED DISK - TEST FOR DRIVE READY (XT,AT,XT286,PS)
	AH = 10h
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
---------------------------------------------
INT 13 - FIXED DISK - RECALIBRATE DRIVE (XT,AT,XT286,PS)
	AH = 11h
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
SeeAlso: AH=19h
---------------------------------------------
INT 13 - FIXED DISK - CONTROLER RAM DIAGNOSTIC (XT,PS)
	AH = 12h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=13h,AH=14h
---------------------------------------------
INT 13 - FIXED DISK - DRIVE DIAGNOSTIC (XT,PS)
	AH = 13h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=12h,AH=14h
---------------------------------------------
INT 13 - FIXED DISK - CONTROLLER DIAGNOSTICS (XT,AT,XT286,PS)
	AH = 14h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=12h,AH=13h
---------------------------------------------
INT 13 - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
	AH = 15h
	DL = drive ID
Return: CF set on error
	AH = disk type
	    00h = disk not there
	    01h = floppy, no change detection present
	    02h = floppy with change detection
	    03h = fixed disk
	       CX:DX = number of 512-byte sectors
SeeAlso: AH=17h
---------------------------------------------
INT 13 - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
	AH = 16h
	DL = drive to check
Return: AH = disk change status
	    00h = no disk change
	    06h = disk changed
---------------------------------------------
INT 13 - DISK - SET TYPE (AT,XT2,XT286,CONV,PS)
	AH = 17h
	AL = disk type
	    00h = no disk
	    01h = regular disk in regular drive
	    02h = regular disk in high-capacity drive
	    03h = high-capacity disk in high-capacity drive
	    04h = 720K disk in 720K drive
	DL = drive ID
Note:	I assume that 05h and 06h are 720K in 1.44M and 1.44M in 1.44M
SeeAlso: AH=15h
---------------------------------------------
INT 13 - DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
	AH = 18h
	DL = drive number
	CH = lower 8 bits of number of tracks
	CL = sectors per track (bits 0-5)
	     top 2 bits of number of tracks (bits 6,7)
Return: AH = 00h  requested combination supported
	     01h  function not available
	     0Ch  not supported or drive type unknown
	     80h  there is no disk in the drive
	ES:DI -> 11-byte parameter table
SeeAlso: AH=05h,AH=07h,AH=17h
---------------------------------------------
INT 13 - FIXED DISK - PARK HEADS (XT286,PS)
	AH = 19h
	DL = drive
Return: CF set on error
	AH = status (see AH=01h)
SeeAlso: AH=11h
---------------------------------------------
INT 13 - ESDI FIXED DISK - FORMAT UNIT (PS)
	AH = 1Ah
	AL = defect table count
	CL = format modifiers
	    bit 4: generate periodic interrupt
	    bit 3: perform surface analysis
	    bit 2: update secondary defect map
	    bit 1: ignore secondary defect map
	    bit 0: ignore primary defect map
	DL = drive
	ES:BX -> defect table
Return: CF set on error
	AH = status (see AH=01h)
Note:	if periodic interrupt selected, INT 15h/AH=0Fh is called after each
	  cylinder is formatted
SeeAlso: AH=07h, INT 15/AH=0Fh
---------------------------------------------
INT 13 - ESDI FIXED DISK - GET MANUFACTURING HEADER
	AH = 1Bh
	AL = number of record
	DL = drive
	ES:BX -> buffer for manufacturing header (defect list)
Return: CF set on error
	    AH = status
Note:	manufacturing header format (Defect Map Record format) can be found
	  in IBM 70MB, 115MB Fixed Disk Drives Technical Reference
---------------------------------------------
INT 13 - ESDI FIXED DISK - GET DEVICE CONFIGURATION
	AX = 1C0Ah
	DL = drive
	ES:BX -> buffer for device configuration (drive physical parameter)
Return: CF set on error
	    AH = status
Note:	device configuration format can be found in IBM ESDI Fixed Disk Drive
	  Adapter/A Technical Reference
---------------------------------------------
INT 13 - ESDI FIXED DISK - GET ADAPTER CONFIGURATION
	AX = 1C0Bh
	ES:BX -> buffer for adapter configuration
Return: CF set on error
	    AH = status
SeeAlso: AX=1C0Ch
---------------------------------------------
INT 13 - ESDI FIXED DISK - GET POS INFORMATION
	AX = 1C0Ch
	ES:BX -> POS information
Return: CF set on error
	    AH = status
SeeAlso: AX=1C0Bh
---------------------------------------------
INT 13 - ESDI FIXED DISK - TRANSLATE RBA TO ABA
	AX = 1C0Eh
	CH = low 8 bits of cylinder number
	CL = sector number, high two bits of cylinder number in bits 6 and 7
	DH = head number
	DL = drive number
	ES:BX -> ABA number
Return: CF set on error
	    AH = status
Note:	ABA (absolute block address) format can be found in IBM ESDI Adapter
	  Technical Reference by using it's Device Configuration Status Block
---------------------------------------------
INT 13 - IBMCACHE.SYS - CACHE STATUS
	AH = 1Dh
	AL = subfunction
	    01h get status record
		DL = drive???
		Return: ES:BX -> status record
			CF set on error
			    AH = error code
	    02h set cache status
		ES:BX -> status record
		DL = drive???
		Return: CF set on error

Format of status record:
Offset	Size	Description
 00h	DWORD	total number of read requests
 04h	DWORD	total number of hits
 08h	DWORD	number of physical disk reads
 0Ch	DWORD	total number of sectors requested by physical disk reads
 10h  6 bytes	???
 16h	DWORD	pointer to start of error list
 1Ah	DWORD	pointer to end of error list
 1Eh	WORD	???
 20h	BYTE	using extended memory if nonzero
 21h	BYTE	???
 22h  4 BYTEs	ASCII version number
 26h	WORD	cache size in K
 28h	WORD	sectors per page

Format of error list:
Offset	Size	Description
 00h	DWORD	relative block address of bad page
 04h	BYTE	drive
 05h	BYTE	sector bit-map
 06h	WORD	next error
---------------------------------------------
INT 13 - DISK - ??? (Western Digital "Super BIOS")
	AH = 20h
	???
Return: ???
Note:	seems to return some kind of status
---------------------------------------------
INT 13 - QCACHE - DISMOUNT
	AX = 20FFh
Return: ???
---------------------------------------------
INT 13 - QCACHE - FLUSH CACHE
	AH = 21h
Return: ???
SeeAlso: AH=25h,AH=2Eh
---------------------------------------------
INT 13 - QCACHE - ENABLE/DISABLE CACHE
	AH = 22h
	AL = 00h disable cache
	     01h enable cache
---------------------------------------------
INT 13 - QCACHE - SET SECTORS
	AH = 24h
	BX = number of sectors
Return: ???
---------------------------------------------
INT 13 - QCACHE - SET FLUSH INTERVAL
	AH = 25h
	BC = interval
Return: ???
SeeAlso: AH=21h,AH=2Eh
---------------------------------------------
INT 13 - QCACHE - INSTALLATION CHECK
	AH = 27h
	BX = 0000h
Return: BX nonzero if installed
---------------------------------------------
INT 13 - QCACHE - SET BUFFER SIZE
	AH = 2Ah
	AL = buffer size
Return: ???
---------------------------------------------
INT 13 - QCACHE - SET BUFFERED WRITES
	AH = 2Ch
	AL = state
	    00h disable
	    01h enable
Return: ???
SeeAlso: AH=2Dh
---------------------------------------------
INT 13 - QCACHE - SET BUFFERED READ
	AH = 2Dh
	AL = state
	    00h disable
	    01h enable
Return: ???
SeeAlso: AH=2Ch
---------------------------------------------
INT 13 - QCACHE - SET FLUSH COUNT
	AH = 2Eh
	BX = flush count
Return: ???
SeeAlso: AH=21h,AH=25h
---------------------------------------------
INT 13 - QCACHE - GET INFO
	AH = 30h
	AL = what to get
	    00h system info
	    01h drive info
	DS:DX -> buffer for info
Return: ???
---------------------------------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 81h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 82h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 83h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 84h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 85h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - HyperDisk 4.01 - ???
	AX = 8EEDh
	???
Return: ???
Note:	HyperDisk is a shareware disk cache by Roger Cross
SeeAlso: AX=8EEEh,AX=8EEFh,AH=EEh
---------------------------------------------
INT 13 - HyperDisk 4.01 - ???
	AX = 8EEEh
Return: CF set
	AX = CS of HyperDisk resident code
	???
SeeAlso: AX=8EEDh,AX=8EEFh,AH=EEh
---------------------------------------------
INT 13 - HyperDisk 4.01 - ???
	AX = 8EEFh
	???
Return: CF set
	AX = CS of HyperDisk resident code
	???
SeeAlso: AX=8EEDh,AX=8EEEh,AH=EEh
---------------------------------------------
INT 13 - Super PC Kwik - GET RESIDENT CODE SEGMENT
	AH = A0h
	SI = 4358h
	???
Return: AX = segment of resident code
	???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - Super PC Kwik - FLUSH CACHE
	AH = A1h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - Super PC Kwik - ???
	AH = A2h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - Super PC Kwik - ???
	AH = B0h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
---------------------------------------------
INT 13 - SWBIOS - SET 1024 CYLINDER FLAG
	AH = EEh
	DL = drive number (80h, 81h)
Return: CF clear
	   AH = 00h
Notes:	the following INT 13 call will interpret the cylinder number as 1024
	  less than the desired cylinder
	flag cleared by all INT 13 calls except AH=EEh
	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
SeeAlso: AH=F9h,AH=FEh
---------------------------------------------
INT 13 - HyperDisk 4.01 - ???
	AH = EEh
	???
Return: ???
SeeAlso: AX=8EEDh,AX=8EEEh,AX=8EEFh
---------------------------------------------
INT 13 - SWBIOS - INSTALLATION CHECK
	AH = F9h
	DL = drive number (80h,81h)
Return: CF clear 
	    DX = configuration word
		bit 15 set if other SWBIOS extensions available
	CF set on error
Note:	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
SeeAlso: AH=EEh
---------------------------------------------
INT 13 - SWBIOS - GET EXTENDED CYLINDER COUNT
	AH = FEh
	DL = drive number (80h, 81h)
Return: CF clear
	DX = number of cylinders beyond 1024 on drive
Notes:	standard INT 13/AH=08h will return a cylinder count truncated to 1024
	BIOS without this extension would return count modulo 1024
	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
SeeAlso: AH=EEh
---------------------------------------------
INT 14 - SERIAL I/O - INITIALIZE USART
	AH = 00h
	AL = initializing parameters
	    7 - 6 - 5	   4 - 3     2	  1 - 0
	    -BAUD RATE-    PARITY   STOP   WORD
				    BITS  LENGTH
	    000  110 bd    00 none  0: 1   00: 5
	    001  150 bd    01 odd   1: 2   01: 6
	    010  300 bd    11 even	   10: 7
	    011  600 bd 		   11: 8
	    100 1200 bd
	    101 2400 bd
	    110 4800 bd
	    111 9600 bd (4800 on PCjr)
	DX = port number (0-3)
Return: AH = RS-232 status code bits
	    0: data ready
	    1: overrun error
	    2: parity error
	    3: framing error
	    4: break detected
	    5: transmission buffer register empty
	    6: transmission shift register empty
	    7: time out--if set, other bits invalid
	AL = modem status bits
	    0: delta Clear-To-Send
	    1: delta Data-Set-Ready
	    2: trailing edge of ring detected
	    3: change in receive line signal detected
	    4: Clear-To-Send
	    5: Data-Set-Ready
	    6: ring detected
	    7: receive line signal detected
SeeAlso: AH=05h,AH=82h,AH=8Ch
---------------------------------------------
INT 14 - FOSSIL (Fido/Opus/Seadog Standard Interface Level) - INITIALIZE
	AH = 00h
	AL = initializing parameters
	    7 - 6 - 5	   4 - 3     2	  1 - 0
	    -BAUD RATE-    PARITY   STOP   WORD
				    BITS  LENGTH
	    000 19200 bd   00 none  0: 1  00: 5
	    001 38400 bd   01 odd   1: 2  01: 6
	    010   300 bd   11 even	  10: 7
	    011   600 bd		  11: 8
	    100  1200 bd
	    101  2400 bd
	    110  4800 bd
	    111  9600 bd (4800 on PCjr)
	DX = port number (0-3 or FFh if only performing non-I/O setup)
Return: AH = RS-232 status code bits
	    0: RDA - input data is available in buffer
	    1: OVRN - data has been lost
	    5: THRE - room is available in output buffer
	    6: TSRE - output buffer empty
	AL = modem status bits
	    3: always 1
	    7: DCD - carrier detect
SeeAlso: AH=05h,AH=82h
---------------------------------------------
INT 14 - SERIAL I/O - TRANSMIT CHARACTER
	AH = 01h
	AL = character
	DX = port number (0-3)
Return: AX = port status (see AH=00h)
SeeAlso: AH=02h,AH=0Bh,AH=89h
---------------------------------------------
INT 14 - SERIAL I/O - RECEIVE CHARACTER
	AH = 02h
	DX = port number (0-3)
Return: AL = character received
	AH = RS-232 status code (see AH=00h)
Note:	will timeout if DSR is not asserted, even if function 03h returns
	  data ready
SeeAlso: AH=01h,AH=84h
---------------------------------------------
INT 14 - FOSSIL - RECEIVE CHARACTER WITH WAIT
	AH = 02h
	DX = port number (0-3)
Return: AL = character received
	AH = 00h
---------------------------------------------
INT 14 - SERIAL I/O - GET USART STATUS
	AH = 03h
	DX = port number (0-3)
Return: AX = port status code (see AH=00h)
SeeAlso: AH=81h
---------------------------------------------
INT 14 - SERIAL I/O - EXTENDED INITIALIZE (CONVERTIBLE,PS)
	AH = 04h
	AL = break status
	    00h if break
	    01h if no break
	BH = parity
	    00h no parity
	    01h odd parity
	    02h even parity
	    03h stick parity odd
	    04h stick parity even
	BL = number of stop bits
	    00h one stop bit
	    01h two stop bits (1.5 if 5 bit word length)
	CH = word length
	    00h 5 bits
	    01h 6 bits
	    02h 7 bits
	    03h 8 bits
	CL = bps rate
	    00h 110
	    01h 150
	    02h 300
	    03h 600
	    04h 1200
	    05h 2400
	    06h 4800
	    07h 9600
	    08h 19200
	DX = port number
Return: AX = port status code (see AH=00h)
SeeAlso: AH=00h
---------------------------------------------
INT 14 - FOSSIL - INITIALIZE DRIVER
	AH = 04h
	DX = port number
	optionally BX=4F50h
		   ES:CX -> byte to be set upon ^C
Return: AX = 1954h (if successful)
	BL = maximum function number supported (excluding 7Eh and above)
	BH = revision of FOSSIL supported
	DTR is raised
Note:	the word at offset 6 in the interrupt handler contains 1954h, and the
	  following byte contains the maximum function number supported
---------------------------------------------
INT 14 - SERIAL I/O - EXTENDED COMMUNICATION PORT CONTROL (CONVERTIBLE,PS)
	AH = 05h
	AL = 00h read modem control register
	      Return: BL = modem control register (see below)
		      AH = status
	AL = 01h write modem control register
	      BL = modem control register
		  bit 0: data terminal ready
		  bit 1: request to send
		  bit 2: OUT1
		  bit 3: OUT2
		  bit 4: LOOP
		  bits 5-7 reserved
	      Return: AX = status
	DX = port number
SeeAlso: AH=00h
---------------------------------------------
INT 14 - FOSSIL - DEINITIALIZE DRIVER
	AH = 05h
	DX = port number
Return: none
	DTR is not affected
SeeAlso: AH=00h,AH=8Dh
---------------------------------------------
INT 14 - FOSSIL - RAISE/LOWER DTR
	AH = 06h
	DX = port
	AL = DTR state to be set
	    00h = lower
	    01h = raise
SeeAlso: AH=1Ah
---------------------------------------------
INT 14 - FOSSIL - RETURN TIMER TICK PARAMETERS
	AH = 07h
Return: AL = timer tick interrupt number
	AH = ticks per second on interrupt number in AL
	DX = approximate number of milliseconds per tick
SeeAlso: AH=16h
---------------------------------------------
INT 14 - FOSSIL - FLUSH OUTPUT BUFFER WAITING TILL ALL OUTPUT IS DONE
	AH = 08h
	DX = port number
SeeAlso: AH=09h
---------------------------------------------
INT 14 - FOSSIL - PURGE OUTPUT BUFFER THROWING AWAY ALL PENDING OUTPUT
	AH = 09h
	DX = port number
SeeAlso: AH=08h,AH=0Ah,AH=88h
---------------------------------------------
INT 14 - FOSSIL - PURGE INPUT BUFFER THROWING AWAY ALL PENDING INPUT
	AH = 0Ah
	DX = port number
SeeAlso: AH=09h,AH=85h
---------------------------------------------
INT 14 - FOSSIL - TRANSMIT NO WAIT
	AH = 0Bh
	AL = character
	DX = port number
Return: AX = 0000h character not accepted
	   = 0001h character accepted
SeeAlso: AH=01h
---------------------------------------------
INT 14 - FOSSIL - NON-DESTRUCTIVE READ AHEAD
	AH = 0Ch
	DX = port number
Return: AX = FFFFh character not available
	AX = 00xxh character xx available
---------------------------------------------
INT 14 - FOSSIL - KEYBOARD READ WITHOUT WAIT
	AH = 0Dh
Return: AX = FFFFh character not available
	   = xxyyh standard IBM-style scan code
SeeAlso: AH=0Eh
---------------------------------------------
INT 14 - FOSSIL - KEYBOARD READ WITH WAIT
	AH = 0Eh
Return: AX = xxyyh standard IBM-style scan code
SeeAlso: AH=0Dh
---------------------------------------------
INT 14 - FOSSIL - ENABLE/DISABLE FLOW CONTROL
	AH = 0Fh
	AL = bit mask describing flow control requested
	    0: xon/xoff on transmit (watch for xoff while sending)
	    1: CTS/RTS (CTS on transmit/RTS on receive)
	    2: reserved
	    3: xon/xoff on receive (send xoff when buffer near full)
	    4-7: all 1
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - EXTENDED ^C/^K CHECKING AND TRANSMIT ON/OFF
	AH = 10h
	AL = bit mask
	    0: enable/disable ^C/^K checking
	    1: enable/disable the transmitter
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - SET CURRENT CURSOR LOCATION
	AH = 11h
	DH = row
	DL = column
Note:	this is the same as INT 10/AH=02h
SeeAlso: AH=12h
---------------------------------------------
INT 14 - FOSSIL - READ CURRENT CURSOR LOCATION
	AH = 12h
Return: DH = row
	DL = column
Note:	this is the same as INT 10/AH=03h
SeeAlso: AH=11h
---------------------------------------------
INT 14 - FOSSIL - SINGLE CHARACTER ANSI WRITE TO SCREEN
	AH = 13h
	AL = character
Note:	should not be called if it is unsafe to call DOS
SeeAlso: AH=15h
---------------------------------------------
INT 14 - FOSSIL - ENABLE OR DISABLE WATCHDOG PROCESSING
	AH = 14h
	AL = 01h enable watchdog
	     00h disable watchdog
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - WRITE CHARACTER TO SCREEN USING BIOS SUPPORT ROUTINES
	AH = 15h
	AL = character
SeeAlso: AH=13h
---------------------------------------------
INT 14 - FOSSIL - INSERT/DELETE FUNCTION FROM TIMER TICK CHAIN
	AH = 16h
	AL = function
	    00h = delete
	    01h = add
	ES:DX -> routine to call
Return: AX = 0000h successful
	     0001h unsuccessful
SeeAlso: AH=07h
---------------------------------------------
INT 14 - FOSSIL - REBOOT SYSTEM
	AH = 17h
	AL = method
	    00h = cold boot
	    01h = warm boot
---------------------------------------------
INT 14 - FOSSIL - READ BLOCK
	AH = 18h
	CX = maximum number of characters to transfer
	DX = port number
	ES:DI -> user buffer
Return: AX = number of characters transfered
SeeAlso: AH=19h,AH=83h,AX=FF02h
---------------------------------------------
INT 14 - FOSSIL - WRITE BLOCK
	AH = 19h
	CX = maximum number of characters to transfer
	DX = port number
	ES:DI -> user buffer
Return: AX = number of characters transfered
SeeAlso: AH=18h,AH=86h
---------------------------------------------
INT 14 - FOSSIL - BREAK BEGIN OR END
	AH = 1Ah
	AL = 00h stop sending 'break'
	     01h start sending 'break'
	DX = port number
SeeAlso: AH=06h,AH=8Ah,AH=FAh
---------------------------------------------
INT 14 - FOSSIL - RETURN INFORMATION ABOUT THE DRIVER
	AH = 1Bh
	DX = port number
	CX = size of user buffer
	ES:DI -> user buffer for driver info (see below)
Return: AX = number of characters transferred

Format of driver info:
Offset	Size	Description
 00h	WORD	size of structure in bytes
 02h	BYTE	FOSSIL spec driver conforms to
 03h	BYTE	revision level of this specific driver
 04h	DWORD	pointer to ASCIZ identification string
 08h	WORD	size of the input buffer
 0Ah	WORD	number of bytes left in buffer
 0Ch	WORD	size of the output buffer
 0Eh	WORD	number of bytes left in buffer
 10h	BYTE	width of screen
 11h	BYTE	length of screen
 12h	BYTE	actual baud rate, computer to modem
---------------------------------------------
INT 14 - FOSSIL - INSTALL AN EXTERNAL APPLICATION FUNCTION
	AH = 7Eh
	AL = code assigned to external application
	ES:DX -> entry point
Return: AX = 1954h
	BL = code assigned to application (same as input AL)
	DH = 00h failed
	     01h successful
SeeAlso: AH=7Fh
---------------------------------------------
INT 14 - FOSSIL - REMOVE AN EXTERNAL APPLICATION FUNCTION
	AH = 7Fh
	AL = code assigned to external application
	ES:DX -> entry point
Return: AX = 1954h
	BL = code assigned to application (same as input AL)
	DH = 00h failed
	     01h successful
SeeAlso: AH=7Eh
---------------------------------------------
INT 14 - COURIERS.COM - INSTALLATION CHECK
	AH = 80h
Return: AH = E8h if loaded
Note:	COURIERS is a TSR utility by PC Magazine
---------------------------------------------
INT 14 - VIDEO FOSSIL - RETURN VFOSSIL INFORMATION
	AX = 8100h
	ES:DI -> buffer for VFOSSIL information (see below)
Return: AX = 1954h if installed
SeeAlso: AX=8101h

Format of VFOSSIL information:
Offset	Size	Description
 00h	WORD	size of information in bytes, including this field
 02h	WORD	VFOSSIL major version
 04h	WORD	VFOSSIL revision level
 06h	WORD	highest VFOSSIL application function supported
---------------------------------------------
INT 14 - VIDEO FOSSIL - OPEN VFOSSIL
	AX = 8101h
	CX = length of buffer for application function table in bytes
	ES:DI -> application function table (see below)
Return: AX = 1954h if installed
	    BH = highest VFOSSIL application function supported
Note:	the number of initialized pointers in the application function table
	  will never exceed CX/4; if the buffer is large enough, BH+1 pointers
	  will be initialized
SeeAlso: AX=8102h

Format of application function table:
Offset	Size	Description
 00h	DWORD	-> function to query current video mode (VioGetMode)
 04h	DWORD	-> function to set video mode (VioSetMode)
 08h	DWORD	-> function to query hardware config (VioGetConfig)
 0Ch	DWORD	-> function to write data in TTY mode (VioWrtTTY)
 10h	DWORD	-> function to get current ANSI state (VioGetANSI)
 14h	DWORD	-> function to set new ANSI state (VioSetANSI)
 18h	DWORD	-> function to get curr cursor position (VioGetCurPos)
 1Ch	DWORD	-> function to set cursor position (VioSetCurPos)
 20h	DWORD	-> function to get cursor shape (VioGetCurType)
 24h	DWORD	-> function to set cursor shape (VioSetCurType)
 28h	DWORD	-> function to scroll screen up (VioScrollUp)
 2Ch	DWORD	-> function to scroll screen down (VioScrollDn)
 30h	DWORD	-> function to read cell string from screen (VioReadCellStr)
 34h	DWORD	-> function to read char string from screen (VioReadCharStr)
 38h	DWORD	-> function to write a cell string (VioWrtCellStr)
 3Ch	DWORD	-> function to write char string, leaving attr (VioWrtCharStr)
 40h	DWORD	-> function to write char string,const attr (VioWrtCharStrAttr)
 44h	DWORD	-> function to replicate an attribute (VioWrtNAttr)
 48h	DWORD	-> function to replicate a cell (VioWrtNCell)
 4Ch	DWORD	-> function to replicate a character (VioWrtNChar)

Format of video mode data structure:
Offset	Size	Description
 00h	WORD	length of structure including this field
 02h	BYTE	mode characteristics
		bit 0: clear if MDA, set otherwise
		bit 1: graphics mode
		bit 2: color disabled (black-and-white)
 03h	BYTE	number of colors supported (1=2 colors, 4=16 colors, etc)
 04h	WORD	number of text columns
 06h	WORD	number of text rows
 08h	WORD	reserved
 0Ah	WORD	reserved
 0Ch	DWORD	reserved

Format of video configuration data:
Offset	Size	Description
 00h	WORD	structure length including this field
 02h	WORD	adapter type
		00h monochrome/printer
		01h CGA
		02h EGA
		03h VGA
		07h 8514/A
 04h	WORD	display type
		00h monochrome
		01h color
		02h enhanced color
		09h 8514
 06h	DWORD	adapter memory size

Format of cursor type record:
Offset	Size	Description
 00h	WORD	cursor start line
 02h	WORD	cursor end line
 04h	WORD	cursor width (always 01h)
 06h	WORD	cursor attribute (FFFFh = hidden)

Call VioGetMode with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video mode data structure (see above)
Return: AX = error code (00h, 74h, 17Eh, 1B4h)
	    0000h successful
	    0074h internal VIO failure
	    0163h unsupported mode
	    0166h invalid row value
	    0167h invalid column value
	    017Eh buffer too small
	    01A5h invalid VIO parameter
	    01B4h invalid VIO handle

Call VioSetMode with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video mode data structure (see above)
Return: AX = error code (00h, 74h, 163h, 17Eh, 1A5h, 1B4h) (see above)

Call VioGetConfig with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video configuration data buffer (see above)
Return: AX = error code (00h, 74h, 17Eh, 1B4h) (see above)

Call VioWrtTTY with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	length of string
		DWORD	pointer to character string to be written to screen
Return: AX = error code (00h, 74h, 1B4h) (see above)
Notes:	write wraps at end of line and terminates if it reaches end of screen
	in ANSI mode, ANSI control sequences are interpreted, and this func is
	  not required to be reentrant; in non-ANSI mode, the function is
	  reentrant and may be called from within an MSDOS function call

Call VioGetANSI with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD which will be set to 00h if ANSI is off
			or 01h if ANSI is on
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetANSI with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD indicating new state of ANSI
			00h off
			01h on
Return: AX = error code (00h, 74h, 1A4h, 1B4h) (see above)

Call VioGetCurPos with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD to hold current cursor column (0-based)
		DWORD	pointer to WORD to hold current cursor row (0-based)
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetCurPos with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	cursor column
		WORD	cursor row
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	if either coordinate is invalid, the cursor is not moved

Call VioGetCurType with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to cursor type record (see above)
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetCurType with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to cursor type record (see above)
Return: AX = error code (00h, 74h, 1A4h, 1B4h) (see above)

Call VioScrollUp with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to char/attr cell for filling emptied rows
		WORD	number or rows to scroll (FFFFh = clear area)
		WORD	right column of scroll area
		WORD	bottom row of scroll area
		WORD	left column of scroll area
		WORD	top row of scroll area
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)

Call VioScrollDn with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to char/attr cell for filling emptied rows
		WORD	number or rows to scroll (FFFFh = clear area)
		WORD	right column of scroll area
		WORD	bottom row of scroll area
		WORD	left column of scroll area
		WORD	top row of scroll area
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)

Call VioReadCellStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start reading
		WORD	row at which to start reading
		DWORD	pointer to WORD containing length of buffer in bytes
			on return, WORD contains number of bytes actually read
		DWORD	pointer to buffer for cell string
Return: AX = error code (00h, 74h, 166h ,167h, 1B4h) (see above)

Call VioReadCharStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start reading
		WORD	row at which to start reading
		DWORD	pointer to WORD containing length of buffer in bytes
			on return, WORD contains number of bytes actually read
		DWORD	pointer to buffer for character string
Return: AX = error code (00h, 74h, 166h ,167h, 1B4h) (see above)

Call VioWrtCellStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of cell string in bytes
		DWORD	pointer to cell string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtCharStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of character string
		DWORD	pointer to character string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtCharStrAttr with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to attribute to be applied to each character
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of character string
		DWORD	pointer to character string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNAttr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write attribute
		DWORD	pointer to display attribute to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNCell with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write cell
		DWORD	pointer to cell to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNChar with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write character
		DWORD	pointer to character to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen
---------------------------------------------
INT 14 - VIDEO FOSSIL - CLOSE VFOSSIL
	AX = 8102h
Return: AX = 1954h
Note:	terminates all operations; after this call, the video FOSSIL may either
	  be removed from memory or reinitialized
SeeAlso: AX=8101h,AX=8103h
---------------------------------------------
INT 14 - VIDEO FOSSIL - UNINSTALL
	AX = 8103h
Return:	AX = 1954h
Note:	this is an extension to the VFOSSIL spec by Bob Hartman's VFOS_IBM
---------------------------------------------
INT 14 - COURIERS.COM - CHECK IF PORT BUSY
	AH = 81h
	AL = port number (1-4)
Return: AH = 00h port available
	     01h port exists but already in use
	     02h port nonexistent
Note:	COURIERS is a TSR utility by PC Magazine
SeeAlso: AH=83h,AH=8Dh
---------------------------------------------
INT 14 - COURIERS.COM - CONFIGURE PORT
	AH = 82h
	AL = port number (1-4)
	BX = speed (bps)
	CX = bit flags
	    bit 0: enable input flow control
	    bit 1: enable output flow control
	    bit 2: use X.PC protocol (not yet implemented)
SeeAlso: AH=00h,AH=8Ch
---------------------------------------------
INT 14 - COURIERS.COM - START INPUT
	AH = 83h
	ES:BX -> circular input buffer
	CX = length of buffer 
		(should be at least 128 bytes if input flow control enabled)
SeeAlso: AH=18h,AH=87h,AH=8Dh,AH=A5h
---------------------------------------------
INT 14 - COURIERS.COM - READ CHARACTER
	AH = 84h
Return: ZF set if no characters available
	ZF clear
	   AL = character
	   AH = modem status bits
		bit 7: set on input buffer overflow
SeeAlso: AH=02h,AH=86h,AH=89h
---------------------------------------------
INT 14 - COURIERS.COM - FLUSH PENDING INPUT
	AH = 85h
SeeAlso: AH=0Ah,AH=88h
---------------------------------------------
INT 14 - COURIERS.COM - START OUTPUT
	AH = 86h
	ES:BX -> output buffer
	CX = length of output buffer
SeeAlso: AH=19h,AH=83h,AH=A4h
---------------------------------------------
INT 14 - COURIERS.COM - OUTPUT STATUS
	AH = 87h
Return: AX = number of unsent characters
---------------------------------------------
INT 14 - COURIERS.COM - ABORT OUTPUT
	AH = 88h
SeeAlso: AH=09h,AH=85h
---------------------------------------------
INT 14 - COURIERS.COM - SEND SINGLE CHARACTER
	AH = 89h
	CL = character to send
SeeAlso: AH=01h,AH=84h
---------------------------------------------
INT 14 - COURIERS.COM - SEND BREAK
	AH = 8Ah
SeeAlso: AH=89h,AH=FAh
---------------------------------------------
INT 14 - COURIERS.COM - SET SPEED
	AH = 8Ch
	BX = speed in bps
SeeAlso: AH=00h,AH=82h
---------------------------------------------
INT 14 - COURIERS.COM - DECONFIGURE PORT
	AH = 8Dh
SeeAlso: AH=82h
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - CONNECT TO PORT
	AH = A0h
	???
Return: ???
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - DISCONNECT FROM PORT
	AH = A1h
	???
Return: ???
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - WRITE BLOCK
	AH = A4h
	CX = length
	DH = session number (00h)
	ES:BX -> buffer
Return: CX = number of bytes sent
SeeAlso: AH=19h,AH=86h
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - READ BLOCK
	AH = A5h
	CX = length
	DH = session number (00h)
	ES:BX -> buffer
Return: CX = number of bytes read
SeeAlso: AH=18h,AH=83h,AX=FF02h
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - SEND SHORT BREAK
	AH = A6h
	DH = session number (00h)
SeeAlso: AH=1Ah,AH=8Ah,AH=FAh
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - READ STATUS
	AH = A7h
	???
Return: ???
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - INSTALLATION CHECK
	AX = AF00h
	BX = AAAAh
Return: AX = AF01h if installed
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - ENABLE/DISABLE "ENTER COMMAND MODE" CHARACTER
	AH = B0h
	AL = 00h disable
	   = 01h enable
---------------------------------------------
INT 14 - 3com BAPI SERIAL I/O - ENTER COMMAND MODE
	AH = B1h
---------------------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - INSTALLATION CHECK
	AX = F4FFh
	DX = port (00h-03h)
Return: CF clear if present
	    AX = 0000h
	CF set if not present
	    AX <> 0000h
---------------------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - REGAIN CONTROL
	AH = F9h
	DX = port (00h-03h)
---------------------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - SEND BREAK
	AH = FAh
	DX = port (00h-03h)
SeeAlso: AH=1Ah,AH=8Ah
---------------------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - SET OUTGOING MODEM SIGNALS
	AH = FBh
	AL = modem control register
	    bit 0: data terminal ready
		1: request to send
		2: OUT1
		3: OUT2
		4: loopback
	    bits 5-7 unused
	DX = port (00h-03h)
---------------------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - READ CHARACTER, NO WAIT
	AH = FCh
	DX = port (00h-03h)
Return: AH = RS232 status bits (see AH=00h)
	AL = character
SeeAlso: AH=02h,AH=0Ch
---------------------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - READ STATUS
	AX = FD02h
Return: CX = number of characters available
---------------------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - BUFFERED READ
	AX = FF02h
	CX = length
	DX = port (00h-03h)
	ES:BX -> buffer
Return: CX = number of characters read
SeeAlso: AH=18h,AH=83h,AH=A5h
---------------------------------------------
INT 15 - CASSETTE - TURN ON MOTOR (PC,Jr)
	AH = 00h
Return: CF set on error, AH = 86h if no cassette present
---------------------------------------------
INT 15 - Amstrad PC1512 - GET AND RESET MOUSE COUNTS
	AH = 00h
Return: CX = signed X count
	DX = signed Y count
---------------------------------------------
INT 15 - VMiX v2+ - INSTALLATION CHECK???
	AH = 00h
Return: DX = 0798h???
---------------------------------------------
INT 15 - CASSETTE - TURN OFF MOTOR (PC,Jr)
	AH = 01h
Return: CF set on error, AH = 86h if no cassette present
---------------------------------------------
INT 15 - Amstrad PC1512 - WRITE DATA TO NON-VOLATILE RAM
	AH = 01h
	AL = NVRAM location (00h to 3Fh)
	BL = NVRAM data value
Return: AH = return code
	    00h OK
	    01h address bad
	    02h write error
SeeAlso: AH=02h"Amstrad"

Format of NVRAM:
Offset	Size	Description
 00h	BYTE	time of day: seconds
 01h	BYTE	alarm time: seconds
 02h	BYTE	time of day: minutes
 03h	BYTE	alarm time: minutes
 04h	BYTE	time of day: hours
 05h	BYTE	alarm time: hours
 06h	BYTE	day of week, 1 = Sunday
 07h	BYTE	day of month
 08h	BYTE	month
 09h	BYTE	year mod 100
 0Ah	BYTE	RTC status register A
		bit 7: set if date/time being updated
		    6-4: time base speed, default 010 = 32768 Hz
		    3-0: interrupt rate selection, default 0110 = 1024 Hz
 0Bh	BYTE	RTC status register B
		bit 7: clear if normal update, set if abort update
		    6: periodic interrupt enable
		    5: alarm interrupt enable
		    4: update end interrupt enable
		    3: square wave enable
		    2: date mode (clear = BCD, set = binary)
		    1: 24-hour format
		    0: daylight saving time enable
 0Ch	BYTE	RTC status register C (read-only)
		bit 7: IRQF flag
		    6: PF flag
		    5: AF flag
		    4: UF flag
 0Dh	BYTE	RTC status register D
		bit 7: battery good
 0Eh  6 BYTEs	time and date machine last used
 14h	BYTE	user RAM checksum
 15h	WORD	Enter key scancode/ASCII code
 17h	WORD	Forward delete key scancode/ASCII code
 19h	WORD	Joystick fire button 1 scancode/ASCII code
 1Bh	WORD	Joystick fire button 2 scancode/ASCII code
 1Dh	WORD	mouse button 1 scancode/ASCII code
 1Fh	WORD	mouse button 2 scancode/ASCII code
 21h	BYTE	mouse X scaling factor
 22h	BYTE	mouse Y scaling factor
 23h	BYTE	initial VDU mode and drive count
 24h	BYTE	initial VDU character attribute
 25h	BYTE	size of RAM disk in 2K blocks
 26h	BYTE	initial system UART setup byte
 27h	BYTE	initial external UART setup byte
 28h 24 BYTEs	available for user application
Note:	bytes 00h-0Dh are the same on the IBM AT as they are used/updated by
	  the clock chip
---------------------------------------------
INT 15 - VMiX - I/O CHANNEL OBJECT MANAGER
	AH = 01h
	STACK: WORD  object ID of requestor
	       DWORD pointer to name of requested method
	       WORD  arg1
	       WORD  arg2
	       WORD  arg3
	       WORD  arg4
Return: DX:AX??? -> IRP structure or 0000h:0000h 
---------------------------------------------
INT 15 - CASSETTE - READ DATA BLOCKS (PC,Jr)
	AH = 02h
	CX = count of bytes
	ES:BX -> data area
Return: CF set on error
	AH = status
	    01h CRC error
	    02h bad tape signals
	    04h no data
	    80h invalid command
	    86h no cassette present
	DX = count of bytes read
	ES:BX = pointer past last byte read
---------------------------------------------
INT 15 - Amstrad PC1512 - READ DATA FROM NON-VOLATILE RAM
	AH = 02h
	AL = NVRAM location (00h to 3Fh)
Return: AH = return code
	    00h OK
	    01h address bad
	    02h checksum error
	AL = NVRAM data value
SeeAlso: AH=01h"Amstrad"
---------------------------------------------
INT 15 - VMiX - MEMORY OBJECT MANAGER
	AH = 02h
	STACK:	WORD	object ID of requestor
		DWORD	pointer to name of requested method
		WORD	arg1
		WORD	arg2
		WORD	arg3
		WORD	arg4
		WORD	arg5
Return: DX:AX??? = pointer to memory block
---------------------------------------------
INT 15 - CASSETTE - WRITE DATA BLOCKS (PC,Jr)
	AH = 03h
	CX = count of bytes to write
	ES:BX -> data area
Return: CF set on error
	   AH = status (see AH=02h)
	ES:BX = pointer past last byte written
	CX = 0
---------------------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU COLOR PLANE WRITE REGISTER
	AH = 03h
	AL = value (I,R,G,B bits)
SeeAlso: AH=04h"Amstrad"
---------------------------------------------
INT 15 - VMiX - PROMPTED CONSOLE INPUT
	AH = 03h
	STACK:	DWORD	pointer to ASCII prompt
		WORD	field outline character
		WORD	length of input field
		DWORD	address of pointer to input buffer
		WORD	number of characters input
Return: AX = length of input (input buffer is padded with blanks)
---------------------------------------------
INT 15 - SYSTEM - BUILD ABIOS SYSTEM PARAMETER TABLE (PS)
	AH = 04h
	ES:DI -> results buffer length 20h for System Parameter Table
	DS = segment containing ABIOS RAM extensions (zero if none)
Return: AH = 00h success: results at ES:DI
	CF set on failure
SeeAlso: AH=05h"ABIOS",C1h

Format of ABIOS System Parameter Table:
Offset	Size	Description
 00h	DWORD	FAR address of ABIOS Common Start Routine
 04h	DWORD	FAR address of ABIOS Interrupt Routine
 08h	DWORD	FAR address of ABIOS Time-out Routine
 0Ch	WORD	number of bytes of stack required by this ABIOS implementation
 0Eh 16 BYTEs	reserved
 1Eh	WORD	number of entries in initialisation table
---------------------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU COLOR PLANE READ REGISTER
	AH = 04h
	AL = value (RDSEL1 and RDSEL0)
SeeAlso: AH=03h"Amstrad",05h"Amstrad"
---------------------------------------------
INT 15 - VMiX - VPRINTF
	AH = 04h
	STACK:	DWORD	control string
		DWORD	array of arguments
---------------------------------------------
INT 15 - SYSTEM - BUILD ABIOS INITIALISATION TABLE (PS)
	AH = 05h
	ES:DI -> results buffer length (18h * Number_of_Entries)
	DS = segment containing ABIOS RAM extensions (zero if none)
Return: AH = 00h success: results at ES:DI
	CF set on failure
SeeAlso: AH=04h"ABIOS",C1h

Format of one entry of ABIOS Initialisation Table:
Offset	Size	Description
 00h	WORD	device ID
 02h	WORD	number of Logical IDs
 04h	WORD	Device Block length (zero for ABIOS patch or extension)
 06h	DWORD	-> init routine for Device Block and Function Transfer Table
 0Ah	WORD	request block length
 0Ch	WORD	Function Transfer Table length (zero for a patch)
 0Eh	WORD	Data Pointers length (in Common Data Area)
 10h	BYTE	secondary device ID (hardware level this ABIOS ver supports)
 11h	BYTE	revision (device driver revision level this ABIOS supports)
 12h  6 BYTEs	reserved
---------------------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU GRAPHICS BORDER REGISTER
	AH = 05h
	AL = value (I,R,G,B bits)
SeeAlso: AH=04h"Amstrad"
---------------------------------------------
INT 15 - VMiX - GET PROCESS ID OF CURRENT PROCESS
	AH = 05h
Return: AX = process ID
---------------------------------------------
INT 15 - Amstrad PC1512 - GET ROS VERSION NUMBER
	AH = 06h
Return: BX = version number
---------------------------------------------
INT 15 - VMiX - GET POINTER TO PROCESS CONTROL BLOCK
	AH = 06h
	STACK:	WORD	process ID
Return: DX:AX??? -> process control block
---------------------------------------------
INT 15 - VMiX - GET POINTER TO OBJECT CONTROL BLOCK
	AH = 07h
	STACK:	WORD	object type
Return: DX:AX??? -> object control block
---------------------------------------------
INT 15 - VMiX - GET CHANNEL CONTROL BLOCK
	AH = 08h
	STACK:	WORD	channel ID
Return: DX:AX??? -> channel control block
---------------------------------------------
INT 15 - VMiX - GET ID OF QUEUED ELEMENT
	AH = 09h
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	subqueue ID
Return: AX = ID
---------------------------------------------
INT 15 - VMiX - GET ID OF NEXT QUEUED ELEMENT
	AH = 0Ah
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	ID of current element in queue chain
Return: AX = ID of next element
---------------------------------------------
INT 15 - VMiX - GET TOTAL NUMBER OF ACTIVE PROCESSES
	AH = 0Bh
Return: AX = number of active processes
---------------------------------------------
INT 15 - VMiX - GET POINTER TO PROCESS TSS STACK
	AH = 0Ch
	STACK:	WORD	process ID
Return: DX:AX??? -> TSS stack store
---------------------------------------------
INT 15 - VMiX - START A CHILD PROCESS JOB SHELL
	AH = 0Dh
	STACK:	DWORD	ASCIZ string starting with requested I/O channel and
			followed by standard VMiX shell command string
Return: AX = status
SeeAlso: AH=0Eh"VMIX"
---------------------------------------------
INT 15 - VMiX - TERMINATE PROCESS
	AH = 0Eh
	STACK:	WORD	process ID
Return: AX = status
SeeAlso: AH=0Dh"VMIX"
---------------------------------------------
INT 15 - SYSTEM - FORMAT UNIT PERIODIC INTERRUPT (PS ESDI drives only)
	AH = 0Fh
	AL = phase code
	    00h reserved
	    01h surface analysis
	    02h formatting
Return: CF clear if formatting should continue, set if it should terminate
Note:	called during ESDI drive formatting after each cylinder is completed
SeeAlso: INT 13/AH=1Ah
---------------------------------------------
INT 15 - VMiX - GET KEY FIELD OF QUEUED ELEMENT
	AH = 0Fh
	STACK:	WORD	queue ID (0 = process queue, 1 = object q, 3 = type q)
		WORD	ID of element in queue chain
Return: AX = key
---------------------------------------------
INT 15 - VMiX - EXECUTE FUNCTION IN PROTECTED MODE
	AH = 10h
	STACK:	DWORD	pointer to function
	      N	WORDs	function args
Return: ???
---------------------------------------------
INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME
	AX = 1000h
Return: after other processes run
Note:	under DESQview, if the process issuing this call has hooked INT 08h,
	  the current time-slice is set to expire at the next clock tick rather
	  than immediately
---------------------------------------------
INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = 1001h
	BX = number of bytes to allocate
Return: ES:DI -> block of memory or 0000h:0000h (DV 2.26+)
Note:	use SETERROR (AX=DE15h) to avoid a user prompt if there is insufficient
	  common memory
SeeAlso: AX=1002h,AX=DE0Ch,AX=DE15h
---------------------------------------------
INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = 1002h
	ES:DI -> previously allocated block
Return: block freed
SeeAlso: AX=1001h,DE0Dh
---------------------------------------------
INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN
	AX = 1003h
	BH = attribute
	BL = character
	DX = segment of object handle for window
Note:	BX=0 does not display anything, it only positions the hardware cursor
---------------------------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 04h thru 12h
Return: pops up "Programming error" window in DV 2.x
---------------------------------------------
INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1013h
	ES:DI -> FAR service routine
Return: BX = bit mask indicating which bit was allocated
	     0000h if no more bits available
SeeAlso: AX=1014h,AX=1015h
Note:	only a few TopView/DESQview API calls are allowed during a hardware
	  interrupt; if other calls need to be made, the interrupt handler
	  must schedule a 2nd-level interrupt with "SETBIT" (AX=1015h)
---------------------------------------------
INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1014h
	BX = bit mask from INT 15/AX=1013h
SeeAlso: AX=1013h,AX=1015h
---------------------------------------------
INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS
	AX = 1015h
	BX = bit mask for interrupts to post
Return: indicated routines will be called: (DV 2.0x) at next task switch
					   (DV 2.2x) immediately
SeeAlso: AX=1013h,AX=1014h
Notes:	this is one of the few TopView calls which are allowed from a hardware
	  interrupt handler
	the handler will be called with ES containing the segment of the handle
	  of the next task to be executed; on return, ES must be the segment of
	  a task handle
---------------------------------------------
INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE
	AX = 1016h
	ES:DI = possible object handle
Return: BX = FFFFh if ES:DI is a valid object handle
	     0000h if ES:DI is not
SeeAlso: AX=DE14h
---------------------------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AX = 1017h
Return: pops up "Programming error" window in DV 2.x
---------------------------------------------
INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION
	AX = 1018h
	BH = column
	BL = row
	ES = segment of object handle for window below which to search
	     0000h = start search with topmost window
Return: ES = segment of object handle for window which is visible at the
	       indicated position, or covered by indicated window
	   = 0000h no window
SeeAlso: AX=1023h,AX=1024h
---------------------------------------------
INT 15 - TopView - "SOUND" - MAKE TONE
	AX = 1019h
	BX = frequency in Hertz (0000h = silence)
	CX = duration in clock ticks (18.2 ticks/sec)
Return: immediately, tone continues to completion
Notes:	if another tone is already playing, the new tone does not start until
	  completion of the previous one.  Up to 32 tones may be queued before
	  the process is blocked until a note completes.
	in DV 2.00, the lowest tone allowed is 20 Hz
	if CX = 0, the current note is cancelled; if BX = 0 as well, all queued
	  notes are also cancelled
---------------------------------------------
INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK
	AX = 101Ah
Return: stack switched
Notes:	this call may not be nested; a second call must be preceded by a call
	  to "USTACK" (AX=1025h)
	while TopView requires many API calls to be executed while on the
	  task's internal stack, DESQview allows those calls to be executed
	  regardless of the current stack
SeeAlso: AX=1025h
---------------------------------------------
INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION
	AX = 101Bh
Return: task-switching temporarily disabled
Notes:	will not task-switch until "ENDC" (AX = 101Ch) called unless task
	  voluntarily releases the CPU (upon regaining the CPU, task-switching
	  will again be disabled)
	suspends the caller until DOS is free
SeeAlso: AX=101Ch,AX=DE13h,AX=DE1Ch
---------------------------------------------
INT 15 - TopView - "ENDC" - END CRITICAL REGION
	AX = 101Ch
Return: task-switching enabled
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=DE13h,AX=DE1Bh
---------------------------------------------
INT 15 - TopView - "STOP" - STOP TASK
	AX = 101Dh
	ES = segment of object handle for task to be stopped
	     (== handle of main window for that task)
Return: indicated task will not get any CPU time until restarted with AX=101Eh
Note:	once a task has been stopped, additional "STOP"s are ignored
BUG:	in DV 2.00, this function is ignored unless the indicated task is the
	  current task
SeeAlso: AX=101Eh,102Bh
---------------------------------------------
INT 15 - TopView - "START" - START TASK
	AX = 101Eh
	ES = segment of object handle for task to be started
	     (== handle of main window for that task)
Return: indicated task is started up again
Note:	once a task has been started, additional "START"s are ignored
SeeAlso: AX=101Dh,102Bh
---------------------------------------------
INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW
	AX = 101Fh
	BX = bit fields
	     bits 0-12: number of characters to display
	     bits 13,14: which mouse button may be pressed to remove window
			 00 = either
			 01 = left
			 10 = right
			 11 = either
	     bit 15: beep if 1
	DS:DI -> text of message
	CH = width of error window (0 = default)
	CL = height of error window (0 = default)
	DX = segment of object handle
Return: BX = status: 1 = left button, 2 = right, 27 = ESC pressed
Note:	window remains on-screen until ESC or indicated mouse button is pressed
---------------------------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.0x
	AX = 1020h
Return: pops up "Programming error" window in DV 2.0x
---------------------------------------------
INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK
	AX = 1021h
	BX = segment of object handle for task to interrupt (not self)
	DX:CX -> FAR routine to jump to next time task is run
Return: nothing
Notes:	the FAR routine is entered with the current ES, DS, SI, DI, and BP
	  values, using the task's internal stack (see AX=101Ah); only SS:SP
	  needs to be preserved
	multiple PGMINTs to a single task are processed last-in first-out
	if the other task is in a DOS or DV API call, the interruption will
	  occur on return from that call
---------------------------------------------
INT 15 - TopView - "GETVER" - GET VERSION
	AX = 1022h
	BX = 0
Return: BX nonzero, TopView or compatible loaded
	(BL = major version, BH = minor version)
Notes:	TaskView returns BX = 0001h, DESQview 2.0 returns BX = 0A01h
---------------------------------------------
INT 15 - TopView - "POSWIN" - POSITION WINDOW
	AX = 1023h
	BX = segment of object handle for parent window within which to
	     position the window (0 = full screen)
	ES = segment of object handle for window to be positioned
	DL = bit flags
	     bits 0,1: horizontal position
		00 = current
		01 = center
		10 = left
		11 = right
	     bits 2,3: vertical position
		00 = current
		01 = center
		10 = top
		11 = bottom
	     bit 4: don't redraw screen if set
	     bits 5-7 not used
	CH = number of columns to offset from position specified by DL
	CL = number of rows to offset from position specified by DL
Return: nothing
---------------------------------------------
INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO
	AX = 1024h
	BX = segment of object handle for window
	      (0 = use default)
Return: ES:DI -> virtual screen
	CX = size of virtual screen in bytes
	DL = 00h text screen
	     01h graphics screen
SeeAlso: INT 10/AH=FEh
---------------------------------------------
INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK
	AX = 1025h
Return: stack switched back
Notes:	call only after having switched to internal stack with AX=101Ah
	while TopView requires many API calls to be executed while on the
	  task's private stack, DESQview allows those calls to be executed
	  regardless of the current stack
SeeAlso: AX=101Ah
---------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 26h thru 2Ah
Return: pops up "Programming error" window in DV 2.x
---------------------------------------------
INT 15 - DESQview 2.0 (TopView???) - "POSTTASK" - AWAKEN TASK
	AX = 102Bh
	BX = segment of object handle for task
Return: nothing
Note:	forces a task which is waiting on its objectq to continue by placing
	  the handle for the task on the objectq
SeeAlso: AX=101Dh,AX=101Eh
---------------------------------------------
INT 15 - DESQview 2.0 (TopView???) - START NEW APPLICATION IN NEW PROCESS
	AX = 102Ch
	ES:DI -> contents of .PIF/.DVP file (see below)
	BX = size of .PIF/.DVP info
Return: BX = segment of object handle for new task
	     0000h on error

Format of .PIF/.DVP file:
Offset	Size	Description
 00h	WORD	reserved (0)
 02h 30 BYTEs	blank-padded program title
 20h	WORD	maximum memory to allocate to partition in K
 22h	WORD	minimum memory required in K
 24h 64 BYTEs	ASCIZ program pathname
 64h	BYTE	default drive letter ('A',...)
 65h 64 BYTEs	ASCIZ default directory name
 A5h 64 BYTEs	ASCIZ program parameters
 E5h	BYTE	initial screen mode (0-7) (see also offset 189h)
 E6h	BYTE	number of text pages used
 E7h	BYTE	number of first interrupt to save
 E8h	BYTE	number of last interrupt to save
 E9h	BYTE	rows in virtual screen buffer
 EAh	BYTE	columns in virtual screen buffer
 EBh	BYTE	initial window position, row
 ECh	BYTE	initial window position, column
 EDh	WORD	system memory in K
 EFh 64 BYTEs	ASCIZ shared program name
12Fh 64 BYTEs	ASCIZ shared program data file
16Fh	BYTE	flags1
		bit 7: writes text directly to screen
		bit 6: runs in foreground only
		bit 5: uses math coprocessor
		bit 4: accesses system keyboard buffer directly
		bits 3-1: reserved (0)
		bit 0: swappable
170h	BYTE	flags2
		bit 6: uses command-line parameters in field at A5h
		bit 5: swaps interrupt vectors
---information unique to .DVP files---
171h  2 BYTEs	keys to use on open menu
173h	WORD	size of script buffer in bytes
175h	WORD	automatically give up CPU after this many tests for keyboard
		input in one clock tick (default 0 = never)
177h	BYTE	nonzero = "uses own colors"
178h	BYTE	nonzero if application swappable
179h  3 BYTEs	reserved (0)
17Ch	BYTE	nonzero to automatically close on exit
17Dh	BYTE	nonzero if copy-protect floppy is required
---information unique to DESQview 2.0+---
17Eh	BYTE	.DVP version number
		00h DESQview 1.2+
		01h DESQview 2.0+
		02h DESQview 2.2+
17Fh	BYTE	reserved (0)
180h	BYTE	initial number of rows in physical window
181h	BYTE	initial number of columns in physical window
182h	WORD	maximum expanded memory to allow, in K
184h	BYTE	flags3
		bit 7: automatically assign window position
		bit 5: maximum memory value has been specified
		bit 4: disallow "Close" command
		bit 3: foreground-only when doing graphics
		bit 2: don't virtualize
185h	BYTE	keyboard conflict level (0-4 for DV<2.26, 00h-0Fh for DV2.26+)
186h	BYTE	number of graphics pages used
187h	WORD	extra system memory size
189h	BYTE	initial screen mode (FFh = default) (overrides offset E5h)
---information unique to DESQview 2.2+---
18Ah	BYTE	serial port usage
		FFh uses all serial ports
		00h no serial ports
		01h only COM1
		02h only COM2
18Bh	BYTE	flags4
		bit 7: automatically close application on exit if .COM or .EXE
			specified
		bit 6: swappable if not using serial ports
		bit 5: start program with window hidden (v2.26+)
		bit 4: start program in background (v2.26+)
		bit 3: virtualize text
		bit 2: virtualize graphics
		bit 1: share CPU when foreground
		bit 0: share EGA when foreground and zoomed
18Ch	BYTE	protection level for 386 machines
18Dh 19 BYTEs	reserved (0)
---------------------------------------------
INT 15 - DESQview 2.0 - KEYBOARD MOUSE CONTROL
	AX = 102Dh
	BL = subfunction
	     00h determine whether using keyboard mouse
		Return: BL = 00h using real mouse
			     01h using keyboard mouse
	     01h turn keyboard mouse on
	     02h turn keyboard mouse off
---------------------------------------------
INT 15 - TopView commands
	AH = 11h
	AL = various (except 17h)
Note:	in DESQview 2.x, these function calls are identical to AH=DEh, so
	  see those below
SeeAlso: AH=DEh
---------------------------------------------
INT 15 - VMiX - EXECUTE SHELL SYSTEM COMMANDS
	AH = 11h
	STACK:	DWORD	pointer to ASCIZ string containing a VMiX shell
			request (max len = 127)
Return: AX = status
---------------------------------------------
INT 15 - DESQview 2.2+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = 1117h
	BX = 0000h	get current mapping context without setting
	     nonzero	set new mapping context
Return: BX = mapping context in effect before call
	interrupts enabled
Notes:	this function differs from AX = DE17h for DESQview v2.20 through 2.25
	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	caller need not be running under DESQview, but must ensure that the
	  stack in use will not be mapped out by the call
---------------------------------------------
INT 15 - DESQview - XDV.COM - INSTALLATION CHECK
	AX = 11DEh
Return: CF clear if installed
	    AX = segment at which XDV is located
---------------------------------------------
INT 15 - VMiX - PUT PROCESS TO SLEEP
	AH = 12h
	STACK:	WORD	process ID
Return: AX = status
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE
	AH = 12h
	BH = 00h
	BL = which handle to return
	    00h handle in DWORD on top of stack
	    01h current task's window handle
	    02h given task's mailbox handle (task's handle on stack)
	    03h current task's mailbox handle
	    04h given task's keyboard handle (task's handle on stack)
	    05h current task's keyboard object handle
	    06h given task's OBJECTQ handle (task's handle on stack)
	    07h current task's OBJECTQ handle
	    08h   \
	      thru > return 0000:0000 under DV < 2.26
	    10h   /
	    0Ch (2.26+) task owning object with handle in DWORD on top of stack
	    0Dh (2.26+) task handle of owner (parent) of current task
Return: DWORD on top of stack is object handle
Note:	BL=0Ch,0Dh returns 00000000h if the object is not open (keyboard,
	  mailbox, panel, pointer, and timer objects) or is an orphan (task,
	  window)
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT
	AH = 12h
	BH = 01h
	BL = object type to create
	    00h (DV 2.0x only) handle is DWORD on top of stack
	    01h (DV 2.0x only) use task's window handle
	    02h (DV 2.0x only) given task's mailbox (task's handle on stack)
	    03h (DV 2.0x only) current task's mailbox
	    04h (DV 2.0x only) given task's keyboard (task's handle on stack)
	    05h (DV 2.0x only) current task's keyboard object
	    08h WINDOW class
	    09h MAILBOX class
	    0Ah KEYBOARD class
	    0Bh TIMER object (counts down 32-bit time in 10ms increments)
	    0Fh POINTER object
	    10h PANEL object
	STACK: (if window object or WINDOW class)
	       DWORD address to jump to (no new task if high word == 0)
	       DWORD (reserved) 0 = non-task window, FFFFh = task window
	       DWORD bytes for task's private stack (FFFFh == default of 0100h)
	       DWORD bytes system memory for input buffer for READ/READN
			(0 == none, -1 == default--same as logical window size)
	       DWORD window size, columns
	       DWORD window size, rows
	       DWORD length of window title
	       DWORD address of window title
Return: DWORD on top of stack is new object handle
Notes:	if a new task is created, it is started with
	  AX = BX = SI = DI = BP = 0
	  DX:CX = handle of parent task
	  DS = ES = SS = segment of private stack (and new task's handle)
	new windows are orphans, inherit the colors/hidden status of the
	  creating task's window, and are placed in the upper left hand corner
	  of the screen but not automatically redrawn
	new keyboards are closed, and have all object bits cleared except for
	  the hardware cursor bit
SeeAlso: AH=12h/BH=02h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT
	AH = 12h
	BH = 02h
	BL = object
	    00h handle in DWORD on top of stack
		window: close window and free
		timer: free timer
		panel: free panel object
		pointer: free pointer
	    01h task's window handle - kills task, never returns
	    02h given task's mailbox (task's handle on top of stack)
	    03h current task's mailbox
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's keyboard object
Notes:	when a window is freed, its keyboard and pointer objects are freed;
	  task windows also free any mailbox, objectq, and panel objects held
	  by the task and any child tasks
	if the keyboard being freed is the default keyboard for a task, this
	  call is equivalent to CLOSE
	panel and pointer objects are automatically closed if open
SeeAlso: AH=12h/BH=01h,AH=12h/BH=0Dh
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY
	AH = 12h
	BX = 0300h
	STACK: DWORD handle of panel object
Return: STACK: DWORD length of directory (always multiple of 14 bytes)
	       DWORD address of directory
Note:	a null string is returned if the object is not open

Format of panel file:
Offset	Size	Description
 00h  2 BYTEs	C0h C3h
 02h	BYTE	number of panels in file
 03h	for each panel in file:
	    8 BYTEs  blank-padded panel name
	      DWORD  panel offset in file
	      WORD   panel length
	data for panels (each consists of one or more window/query/manager
	streams)
	    first byte of each panel must be 1Bh, fifth byte must be E5h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDR" - GET HANDLE OF MESSAGE SENDER
	AH = 12h
	BH = 03h
	BL = object
	    00h mailbox handle in DWORD on top of stack
	    02h sender of last msg read from mailbox (task's handle on stack)
	    03h sender of last msg read from current task's mailbox
Return: DWORD on stack is task handle of message sender
SeeAlso: AH=12h/BH=00h
---------------------------------------------
INT 15 - DESQview 2.26+ - "CONNECT" - CONNECT TWO WINDOWS
	AH = 12h
	BH = 03h
	BL = window to be connected
	    00h handle of window to be attached in DWORD on top of stack
	    01h attach current task's main window
	STACK: DWORD handle of window to attach to or 00000000h to detach
Return: ???
Notes:	when two windows are connected, both will move if the user moves either
	multiple windows may be attached to a single window, but each window
	  may only be attached to one window at a time
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - WAIT FOR TIMER TO EXPIRE
	AH = 12h
	BX = 0400h
	STACK: DWORD timer's handle
Return: after timer expires
	STACK: DWORD time in 1/100 sec after midnight when timer expired
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - READ NEXT LOGICAL LINE OF WINDOW
	AH = 12h
	BH = 04h
	BL = window to read from
	    00h handle is DWORD on top of stack
	    01h use calling task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent task of current task
Return: STACK:	DWORD number of bytes read
		DWORD address of buffer
Notes:	reading starts at the current logical cursor position; the cursor is
	  updated to point at the character following the last one read
	any translucent blanks (FFh) which are visible on screen are changed
	  to the character which is seen through them
	the string produced by the read is placed in an input buffer which may
	  be reused by the next READ or READN of a window
	window stream opcodes D8h and D9h determine whether the read returns
	  characters or attributes
SeeAlso: AH=12h/BH=05h"WINDOW",AH=12h/BH=12h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD FROM OBJECT
	AH = 12h
	BH = 04h
	BL = object
	    00h handle is DWORD on top of stack
		mailbox: wait for and get next message
		keyboard: wait for and get pointer to next input buffer
		pointer: wait for and get next message
	    02h get next message from mailbox (task's handle on top of stack)
	    03h get next message from current task's mailbox
	    04h get the next input from keyboard (handle on top of stack)
	    05h get the next input from task's default keyboard
	    06h wait for input from any object in OBJECTQ (handle on stack)
	    07h wait for input from any object in task's default OBJECTQ
Return: STACK: (if objectq) DWORD handle of object with input
	       (otherwise)  DWORD number of bytes
			    DWORD address
Notes:	for a keyboard in keystroke mode, the input buffer is a single byte
	  containing the character code as returned by the BIOS; the BIOS scan
	  code is available via the STATUS call if the character is zero
	for a keyboard in field mode, the input buffer format is determined
	  by the field table header for the window the keyboard is attached to
	keyboard input buffers and mailbox message buffers may be invalidated
	  by the next READ, ERASE, CLOSE, or FREE message to the same object
SeeAlso: AH=12h/BH=05h"OBJECT"

Format of pointer message:
Offset	Size	Description
 00h	WORD	row
 02h	WORD	column
 04h	BYTE	status
		bit 6: set when press/release mode active and button released
		bits 7-2: number of clicks-1 if multiple-click mode active
		bits 1,0: button pressed (00=none,01=button1,10=button2)
 05h	BYTE	field number or zero (APILEVEL >= 2.00 only)
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW
	AH = 12h
	BX = 0400h
	STACK: DWORD handle of panel object
	       DWORD window's handle (or 0 for current task's window)
	       DWORD length of panel name
	       DWORD pointer to panel name
Return: STACK: DWORD handle of keyboard or 0
	       DWORD handle of window which was used
Notes:	status of APPLY may be checked with STATUS message
	panel MUST have the following format
	  first byte must be 1Bh (i.e. must start with a stream)
	  first opcode in stream must be E5h
	    single byte arg of opcode is interpreted thus:
	      bits 7,6	11 means create new window
			10 means create new field table for existing window
			01 means use existing window and field table
	      bit 5 if set, panel contains a field table 
			(creates a new keyboard and puts it in field mode)
	      bit 4 if set, panel contains input fields
	      bit 3 if set, panel contains select fields but no input fields
	if the panel contains input or select fields, a keyboard handle is
	  returned; either the window's current open keyboard or a
	  newly-created keyboard object.  The caller should read that keyboard
	  to obtain input from the panel.
--------------------------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE TO OBJECT
	AH = 12h
	BH = 05h
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer to end at a specified time
		keyboard: add input buffer to queue
		pointer: move pointer icon to specified position
	    02h send message by value/status=0 to mbox (task's handle on stack)
	    03h send message by value/status=0 to current task's mailbox
	    04h add input buffer to KEYBOARD queue (handle on top of stack)
	    05h add input buffer to task's default KEYBOARD queue
	    06h add an object to OBJECTQ (handle on top of stack)
	    07h add an object to task's default OBJECTQ
	STACK: (if mailbox)  DWORD length
			     DWORD address
	       (if keyboard) DWORD status (scan code in keystroke mode)
			     DWORD length (should be 1 in keystroke mode)
			     DWORD address
	       (if objectq)  DWORD handle of object to add
	       (if timer)    DWORD 1/100ths seconds since midnight (actually
				   only accurate to 1/18 sec)
	       (if pointer)  DWORD column relative to origin of window
			     DWORD row relative to origin of window
Notes:	under DV 2.2+, failed mailbox writes may return CF set (see AX=DE15h)
	the data and status written to a keyboard object must match the format
	  returned by the keyboard object in the current mode
	the pointer position is scaled according to the current scaling factors
SeeAlso: AH=12h/BH=04h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO WINDOW
	AH = 12h
	BH = 05h
	BL = window to write to
	    00h DWORD on top of stack is window handle
	    01h write string to task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK: DWORD object handle if handle passed on stack
	       DWORD total length of string (high word == 0)
	       DWORD address of string to display
Return: indicated actions performed
	a. non-control characters are displayed (opcodes DEh and DFh control
	   whether the attributes are left or changed to the current attrib)
	b. CR/LF/BS/Tab cause the usual cursor movement
	c. ESC starts a data structure with additional commands if following
	   byte is less than 20h; otherwise, it is written to the window
	STACK:	DWORD handle of new window if window stream opcode E6h
		else nothing

Data Structure:
	MAGIC  DB  1Bh
	MODE   DB  ?   ; 00h, 01h, 10h, 14h-1Fh legal
	LENGTH DW  ?   ; length of remainder in bytes
	var-length fields follow, each an OPCODE followed by
	     zero or more args

MODE 00h (set or display values) "WINDOW STREAM"
    Opcodes:args
	00h  display 20h blanks with the default attribute
	01h-1Fh display OPCODE blanks with the default attribute
	20h  display char with default attribute 20h times
	     BYTE char to repeat
	21h-3Fh display char with default attribute OPCODE-20h times
	     BYTE char to repeat
	40h  display 20h blanks with specified attribute
	     BYTE attribute of blanks
	41h-5Fh display OPCODE-40h blanks with specified attribute
	     BYTE attribute of blanks
	60h  display next 20h characters
	     20h BYTES characters to display
	61h-7Fh display next OPCODE-60h characters
	     N BYTES characters to display
	80h-87h  display N blanks with default attribute
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	88h-8Fh display N copies of the character
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE character to repeat
	90h-97h  display N blanks with specified attribute
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE attribute
	98h-9FH  display string at logical cursor pos
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     N BYTES string to display
	A0h  set logical cursor row
	     BYTE row number (0 is top)
	A1h  set logical cursor column
	     BYTE column number (0 is leftmost)
	A2h  set top edge of scrolling region
	     BYTE row
	A3h  set left edge of scrolling region
	     BYTE column
	A4h  set row of physical window position
	     BYTE line
	A5h  set column of physical window position
	     BYTE column
	A6h  set height of physical window
	     BYTE #rows
	A7h  set width of physical window
	     BYTE #columns
	A8h  set viewport row
	     BYTE row
	A9h  set viewport column
	     BYTE column
	AAh  set virtual screen height [contents of window unpredictable after]
	     BYTE rows
	ABh  set virtual screen width [contents of window unpredictable after]
	     BYTE columns
	ACh-AEh  unused
	AFh  set compatible/preferred video modes
	     BYTE compatibility/preference mask
		bit 7	compatible with monochrome
		bit 6	compatible with color text, EGA/VGA graphics
		bit 5	compatible with medium-resolution CGA graphics
		bit 4	compatible with high-resolution CGA graphics
		bit 3	prefer monochrome
		bit 2	prefer color text, EGA/VGA graphics
		bit 1	prefer medium-resolution CGA graphics
		bit 0	prefer high-resolution CGA graphics
	B0h  move logical cursor down
	     BYTE #rows (signed, negative values move up)
			[if #rows=0 and hardware cursor owner, update hw crsr]
	B1h  move logical cursor right
	     BYTE #cols (signed, negative values move left)
			[if #cols=0 and hardware cursor owner, update hw crsr]
	B2h  shift top edge of scrolling region
	     BYTE #rows (signed)
	B3h  shift left edge of scrolling region
	     BYTE #cols (signed)
	B4h  shift physical window down
	     BYTE #lines (signed)
	B5h  shift physical window right
	     BYTE #columns (signed)
	B6h  expand physical window vertically
	     BYTE #lines (signed)
	B7h  expand physical window horizontally
	     BYTE #columns (signed)
	B8h  adjust viewport row
	     BYTE #rows (signed)
	B9h  adjust viewport column
	     BYTE #columns (signed)
	BAh  adjust virtual screen height [contents of window unpredict after]
	     BYTE #rows to increase (signed)
	BBh  adjust virtual screen width [contents of window unpredictbl after]
	     BYTE #cols to increase (signed)
	BCh-BFh  reserved (currently unused)
	C0h  set logical cursor position
	     BYTE row number (0 is top border)
	     BYTE column number (0 is left border)
	C1h  set top left corner of scrolling region
	     BYTE row
	     BYTE column
	C2h  set physical window pos
	     BYTE upper left row (no top border if 0)
	     BYTE upper left column (no left border if 0)
	C3h  set current window size
	     BYTE #rows
	     BYTE #cols
	C4h  set upper left corner of viewport (portion of virtual screen
	     displayed in window)
	     BYTE row
	     BYTE column
	C5h  set size of virtual screen [contents unpredictable afterwards]
	     BYTE #rows
	     BYTE #cols
	C6h  unused
	C7h  unused
	C8h  set logical cursor relative to current position
	     BYTE number of rows to move down (signed)
	     BYTE number of columns to move right (signed)
		  [if #rows=#cols=0 and hardware cursor owner, update hw cursr]
	C9h  shift top left corner of scrolling region
	     BYTE #rows (signed)
	     BYTE #cols (signed)
	CAh  set window pos relative to current position
	     BYTE number of rows to shift down (signed)
	     BYTE number of columns to shift right (signed)
	CBh  set window size relative to current size
	     BYTE number of rows to expand (signed)
	     BYTE number of cols to expand (signed)
	CCh  shift viewport relative to current position
	     BYTE rows to shift (signed)
	     BYTE cols to shift (signed)
	CDh  resize virtual screen
	     BYTE #rows to expand (signed)
	     BYTE #cols to expand (signed)
	CEh  scroll text when using E8h-EBh/F8h-FBh opcodes (default)
	CFh  scroll attributes when using  E8h-EBh/F8h-FBh opcodes
	D0h  allow window frame to extend beyond screen
	D1h  always display a complete frame, even if window extends beyond 
	     edge of screen
	D2h  allow DV to change logical colors on video mode switch (default)
	D3h  application changes logical attributes
	D4h  window is visible [must redraw to actually make visible]
	D5h  window is hidden [must redraw to actually remove]
	D6h  window has frame (default)
	D7h  window unframed [must redraw to actually remove frame]
	D8h  READ/READN will read characters from window (default)
	D9h  READ/READN will read attributes from window
	DAh  use logical attributes, which may be remapped
		attributes
		   1 normal text
		   2 highlighted normal text
		   3 help text
		   4 highlighted help text
		   5 error message
		   6 highlighted error message
		   7 emphasized text
		   8 marked text
		   9-16 are reverse video versions of 1-8
	DBh  use physical attributes for characters
	DCh  enable special actions for control characters (default)
	DDh  disable special control char handling, all chars displayable by
	     BIOS TTY call
	DEh  write both character and attribute (default)
	DFh  write character only, leave attribute untouched
	E0h  repeat following commands through E1h opcode
	     BYTE number of times to repeat (00h means 256 times)
	E1h  end of commands to repeat, start repeating them
	E2h  set current output color
	     BYTE color
	E3h  clear virtual screen from scroll origin to end using current color
	E4h  redraw window
	E5h  select menu style
	     BYTE style (normally 18h)
		bits 5,4 = 01 use two-letter menu entries for remainder of
		  this stream
	E5h  (panel file only)
	     BYTE modifier
		bits 7,6 = 11 panel stream creates new window
			 = 10 panel defines new field table for existing window
			 = 01 panel stream uses existing window & field table
		bit 5 = 1 stream contains a field table (create kyboard object)
		bit 4 = 1 stream defines input fields (create keyboard object)
		bit 3 = 1 stream defines select fields but not input fields
		bit 2 = 1 stream defines exclusive input window (DV 2.2)
		bit 1 reserved
		bit 0 reserved
	E6h  create new window and perform rest of manipulations in new window
	     BYTE number of rows
	     BYTE number of columns
	     Return: DWORD object handle of new window returned on stack at end
	E7h  no operation
	E8h  scroll area up (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	E9h  scroll area down (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	EAh  scroll area left (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	EBh  scroll area right (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	ECh  set logical attributes for window contents
	     BYTE video modes command applies to
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	     BYTE which attributes to set
		bit 7  if set, copy single following byte to indicated attribs
		bits 4-6  # of first attribute to change - 1
		bits 0-3  # of consecutive attributes to change
	     N BYTEs new attributes
	EDh  set logical attributes for window frame
	     BYTE video modes command applies to (see opcode ECh)
	     BYTE which attributes to set
		bit 7  if set, copy single following byte to indicated attrs
		bits 4-6  # of first attribute to change - 1
		bits 0-3  # of consecutive attributes to change
	     N BYTEs new attributes
		  attributes
		       1 = top left corner
		       2 = top right corner
		       3 = bottom left corner
		       4 = bottom right corner
		       5 = top edge
		       6 = bottom edge
		       7 = left edge
		       8 = right edge
	EEh  set characters for window frame
	     BYTE video modes command applies to (see opcode ECh)
	     BYTE which characters to set
		bit 7  if set, copy single following byte to indicated chars
		bits 4-6  # of first char to change - 1
		bits 0-3  # of consecutive chars to change
	     N BYTEs new chars (same relative position as attributes above)
	EFh  set window name
	     BYTE length of name (should be in range 0 to logical screen width)
	     N BYTEs name
	F0h  clear input field to blanks
	     BYTE field number
	F1h  fill input field with character
	     BYTE field number
	     BYTE char
	F2h  set color of input field
	     BYTE field number (1-N)
	     BYTE attribute
	F3h  set initial contents of input field
	     BYTE field number (1-N)
	     N BYTEs enough chars to exactly fill field as defined by op FFh
	F4h  position cursor to start of specific input field
	     BYTE field number (1-N)
	F5h  change field table entry
	     BYTE field number
	     7-8 BYTEs field table entry (see opcode FFh below)
	F6h  set field type
	     BYTE field number
	     BYTE type
			00h inactive
			40h output field
			80h input field
			C0h deselected field
			C2h selected field
	F7h  "broadcast write"	write data to fields with program output bit
		set in field table entry, in field number order
	     N BYTEs (total length of all program output fields)
	F8h  scroll field up a line
	     BYTE field number
	F9h  scroll field down a line
	     BYTE field number
	FAh  scroll field left
	     BYTE field number
	FBh  scroll field right
	     BYTE field number
	FCh  set field table header
	     BYTE number of fields (must be <= existing number of fields)
	     BYTE screen behavior bits
		bit 7  reserved
		bit 6  set if menu items may be selected via keyboard
		bit 5  set if left mouse button may terminate entry
		bit 4  set if right mouse button may terminate entry
		bit 3  if set, select fields return contents or blanks rather
			than 'Y' or 'N'
		bit 2  if set, modified bits reset on return to application
		bits 0,1 = 00 no data returned on read of keyboard
			   01 data returned as array of chars containing
				all fields packed together, with no field
				numbers
			   10 data returned as numbered variable-length
				records for all fields
			   11 data returned as numbered variable-length
				records for the fields which were modified
	     BYTE current input field (updated by DESQview)
	     BYTE current select field (updated by DESQview)
	     BYTE attribute for select fields when they are pointed at
	     BYTE attribute for select fields which have been selected
	FDh  reset modified bit for all fields
	FEh  reset selected and modified bits for all fields
	FFh  set up input fields
	     6 BYTEs table header (see opcode FCh above)
	     the field table entries, one for each field
		 BYTE start row    \
		 BYTE start column  \ if menu selection and start is to
		 BYTE end row	    / right or below end, select from kbd only
		 BYTE end column   /
		 BYTE field type
		    bits 7,6 = 00 inactive (non-entry) field
			       01 echos keystrokes input to make menu selection
			       10 fill-in field
			       11 select field
		    bit 5  field can be filled by broadcast write (F7h opcode)
		    bit 4  reserved
		    bit 3  reserved
		    bit 2  reserved
		    bit 1  set if field selected
		    bit 0  set if field modified
		 BYTE modifier
		      if type is fill-in, then bit flags to determine behavior
			  bit 7  if set, automatically enter CR when field full
			  bit 6  move to next field when current field is full
			  bit 5  if set, enter text from right end (for numbers)
			  bit 4  if set, force input to uppercase
			  bit 3  if set, clear old contents on first keystroke
			  bit 2  if set, input returned when cursor moves out
				 of modified field (API level 2.02+)
			  bit 1  reserved
			  bit 0  reserved
		      if select field, first key to press to activate
			  00h if have to point-&-click or is an extended-ASCII
			      keystroke (only if two-key menus enabled)
		 BYTE (select field only) normal color of field
		 BYTE second key for select field.  This byte is present iff
		      two-letter menu entries selected with opcode E5h, and
		      in that case is present regardless of field type
	     Note: DESQview uses and updates the actual copy of the information
	       which is contained in the stream.  Thus this info must remain
	       intact until after the data entry is complete.

MODE 01h "QUERY STREAM" (valid only for those opcodes listed here)
	A0h return logical cursor row in next byte
	A1h return logical cursor column in next byte
	A2h return top row of scrolling region in next byte
	A3h return left column of scrolling region in next byte
	A4h return row of physical window origin in next byte
	A5h return column of physical window origin in next byte
	A6h return height of physcial window in next byte
	A7h return width of physical window in next byte
	A8h return row of viewport origin in next byte
	A9h return column of viewport origin in next byte
	AAh return height of virtual screen in next byte
	ABh return width of virtual screen in next byte
	AFh return current video mode in next byte
	C0h return current logical cursor position in next two bytes
	C1h return top left corner of scrolling region in next two bytes
	C2h return current window position in next two bytes
	C3h return current window size in next two bytes
	C4h return current viewport origin in next two bytes
	C5h return current virtual screen size in next two bytes
	D0h \ overwritten with D0h if frames may fall off screen edge
	D1h /		       D1h if frames always displayed entirely
	D2h \ overwritten with D2h if DESQview controls color palette
	D3h /		       D3h if application changes color palette
	D4h \ overwritten with D4h if window visible
	D5h /		       D5h if window hidden
	D6h \ overwritten with D6h if window has frame
	D7h /		       D7h if window unframed
	D8h \ overwritten with D8h if reading characters from window
	D9h /		       D9h if reading attributes from window
	DAh \ overwritten with DAh if using logical attributes
	DBh /		       DBh if using physical attributes
	DCh \ overwritten with DCh if TTY control char interpretation on
	DDh /		       DDh if TTY control char interpretation off
	DEh \ overwritten with DEh if writing both characters and attributes
	DFh /		       DFh if leaving attributes untouched
	E2h return current color in next byte
	ECh get logical attributes for window contents
	    BYTE execute call if currently in specified video mode
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 # consecutive attributes
	    N BYTEs buffer to hold attributes
	EDh get logical attributes for window frame
	    BYTE execute call if currently in video mode (see opcode ECh)
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 # consecutive attributes
	    N BYTEs buffer to hold attributes
	EEh get characters for window frame
	    BYTE execute call if currently in video mode (see opcode ECh)
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first char to get - 1
		bits 0-3 # consecutive chars
	    N BYTEs buffer to hold chars
	EFh return first N characters of current window name
	    BYTE    max length of returned name
	    N BYTEs buffer to hold window name
	F3h return contents of specified field
	    BYTE field number
	    N BYTEs buffer to hold field contents (size exactly equal to field
		    size)
	F5h get field table entry
	    BYTE field number
	    7-8 BYTEs buffer to hold field table entry
	       Notes: DV < 2.26 always returns 7 bytes
		      DV 2.26+ w/ APILEVEL < 2.26 returns 8 bytes iff field
			table is using 8-byte entries and eighth byte after
			F5h is E7h (NOP); otherwise, 7 bytes are returned
		      DV 2.26+ w/ APILEVEL > 2.26 returns 7 or 8 bytes
			depending on the field table entry size
	F6h get type of a field
	    BYTE field number
	    BYTE type
	FCh get field table header
	    6 BYTEs buffer to store header

MODE 10h "MANAGER STREAM" (valid only for opcodes listed here)
	00h allow window to be moved horizontally
	01h allow window to be moved vertically
	02h allow window to change width
	03h allow window to change height
	04h allow window to be scrolled horizontally
	05h allow window to be scrolled vertically
	06h allow "Close Window" menu selection for application
	07h allow "Hide Window" menu selection for application
	08h allow application to be suspended ("Rearrange/Freeze")
	0Eh allow "Scissors" menu
	10h allow DESQview main menu to be popped up
	11h allow "Switch Windows" menu
	12h allow "Open Window" menu
	13h allow "Quit" menu selection
	20h-33h opposite of 00h-13h, disallow specified action
	40h notify if horizontal position of window changes
	41h notify if vertical position of window changes
	42h notify if width of window changes
	43h notify if height of window changes
	44h notify if window scrolled horizontally
	45h notify if window scrolled vertically
	46h notify if window is closed--program has to clean up and exit itself
	47h notify if window is hidden
	48h notify if "?" on main menu selected
	49h notify if pointer message sent to window
	4Ah notify if window is placed in foreground
	4Bh notify if window is placed in background
	4Ch notify if video mode changes
	4Dh notify if "Scissors" menu "Cut" option selected
	4Eh notify if "Scissors" menu "Copy" option selected
	4Fh notify if "Scissors" menu "Paste" option selected
	50h notify if DESQview main menu about to pop up
	51h notify if DESQview main menu popped down
	60h-71h  opposite of 40h-51h: don't notify on specified event
	84h attach window to parent task's window (both move together)
	85h detach window from parent task's window (may move independently)
	86h disable background operation for application
	87h enable running in background
	88h set minimum size of physical window
	    BYTE rows
	    BYTE columns
	89h set maximum size of physical window
	    BYTE rows
	    BYTE cols
	8Ah set primary asynchronous notification routine
	    DWORD address of routine, 0000h:0000h means none (see also below)
	8Bh set async notification parameter
	    DWORD 32-bit value passed to 8Ah async routine in DS:SI
	ACh (DV2.2+) perform regular select field attribute processing
	ADh (DV2.2+) protect attributes in selected field from being lost
	AEh make window default notify window for owning app (API level 2.00+)
	AFh set selected field marker character
	    BYTE character to display at left edge of selected fields
	BCh set standard field processing mode 
	BDh set alternate field processing mode (enables cursor pad for menus)
	BEh disables changing reverse logical attributes with ECh opcode
	BFh enables changing reverse logical attributes with ECh opcode
	C0h make current window topmost in system
	C1h force current process into foreground
	C2h make current window topmost in process
	C3h position mouse pointer relative to origin of current field
	    BYTE rows below upper left corner of field
	    BYTE columns to right of upper left corner of field
	C4h position mouse pointer relative to origin of given field
	    BYTE field number
	    BYTE rows below upper left corner of field
	    BYTE columns to right of upper left corner of field
	C5h orphan current window (also hides it)
		Note: must be last in stream; all subsequent commands ignored
	C6h show all windows for this process
	C7h hide all windows for this process
	C8h suspend process and hide all its windows
	C9h force current process into background
	CAh make current window bottom-most in process
	CBh cancel current window manager operation, remove DV menu, give 
	    control to topmost application
	CCh orphan window and give it to the system for use as paste data
	CEh reorder windows
	    DWORD pointer to null-terminated list of words
		  each word is segment of object handle for a window
	FFh no operation

MODES 14h to 1Fh "USER STREAMS"
	normally NOPs, but may be defined by SETESC message to invoke FAR
	routines, one for each mode number
	  on entry to handler,
		DS:SI -> first byte of actual stream (not header)
		CX = #bytes in stream
		ES:DI = window's handle

Asynchronous notification routine defined by manager stream 8Ah called with:
	ES:DI = handle of window
	DS:SI is 32-bit value set by 8Bh manager stream opcode
	   mailbox contains message indicating event
	      Opcode
	       40h  horizontal movement
		   DWORD object handle of window
		   BYTE  new row
		   BYTE  new col
	       41h  vertical movement
		   DWORD object handle of window
		   BYTE  new row
		   BYTE  new col
	       42h  horizontal size change
		   DWORD object handle of window
		   BYTE  new rows
		   BYTE  new cols
	       43h  vertical size change
		   DWORD object handle of window
		   BYTE  new rows
		   BYTE  new cols
	       44h  scrolled horizontally
		   DWORD object handle of window
		   BYTE  mouse row within window
		   BYTE  mouse column within window
		   BYTE  field mouse is on, 0 if none
		   BYTE  amount moved: >0 right, <0 left, 0 done
	       45h  scrolled vertically
		   DWORD object hande of window
		   BYTE  mouse row within window
		   BYTE  mouse column within window
		   BYTE  field mouse is on, 0 if none
		   BYTE  amount moved: >0 down, <0 up, 0 done
	       46h  window close request
		   DWORD object handle of window
		   BYTE  mouse pointer row
		   BYTE  mouse pointer column
		   BYTE  field mouse is on, 0 if none
	       47h  application's windows hidden
	       48h  Help for Program selected
		   DWORD object handle of window
		   BYTE  mouse pointer row
		   BYTE  mouse pointer column
		   BYTE  field mouse is on, 0 if none
	       49h  pointer message sent to window
		   DWORD pointer handle which received message
	       4Ah  switched to window from another ("raise")
	       4Bh  switched away from the window ("lower")
	       4Ch  video mode changed
		   BYTE new BIOS video mode
	       4Dh  Scissors/cUt selected
		   DWORD object handle of window
		   BYTE  row of upper left corner
		   BYTE  column of upper left corner
		   BYTE  field number ul corner is in, 0=none
		   DWORD handle of orphaned window created with
			 copy of data from specified region
		   BYTE  height of region
		   BYTE  width of region
	       4Eh  Scissors/Copy selected
		   DWORD object handle of window
		   BYTE  row of upper left corner
		   BYTE  column of upper left corner
		   BYTE  field number ul corner is in, 0=none
		   DWORD handle of orphaned window created with
			 copy of data from specified region
		   BYTE  height of region
		   BYTE  width of region
	       4Fh  Scissors/Paste selected
		   DWORD object handle of window
		   BYTE  row of upper left corner
		   BYTE  column of upper left corner
		   BYTE  field number ul corner is in, 0=none
		   DWORD handle of orphaned window with data
		   BYTE  height of region
		   BYTE  width of region
			Note: orphaned data window should be adopted or freed
				when done
	       50h  main menu about to pop up
	       51h  main menu popped down
Return: all registers unchanged
---------------------------------------------
INT 15 - DESQview 2.2+ - SEND MESSAGE - "SETPRI" - SET PRIORITY WITHIN OBJECTQ
	AH = 12h
	BH = 06h
	BL = object
	    00h object handle in DWORD on top of stack
		mailbox, keyboard, pointer, or timer
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's default keyboard
	STACK: DWORD new priority of object in task's OBJECTQ 
Notes:	initially all objects have the same default value.  Should only make 
	  relative adjustments to this default value.
	when changing priorities, all objects already on the objectq are
	  reordered
SeeAlso: AH=12h/BH=07h
---------------------------------------------
INT 15 - DESQview 2.2+ - SEND MESSAGE - "GETPRI" - GET PRIORITY WITHIN OBJECTQ
	AH = 12h
	BH = 07h
	BL = object
	    00h object handle in DWORD on top of stack
		mailbox, keyboard, pointer, or timer
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's default keyboard
Return: STACK: DWORD object priority
Note:	initially all objects have the same default value.  Should only make 
	  relative adjustments to this default value.
SeeAlso: AH=12h/BH=06h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE
	AH = 12h
	BH = 08h
	BL = object
	    00h handle in DWORD on top of stack
		window: total character positions in window
		timer: elapsed time since timer started
		pointer: number of messages queued to pointer object
		panel: number of panels in panel file
		keyboard: number of input buffers queued
	    01h total chars in current task's default window
	    02h number of messages in task's mailbox (task's handle on stack)
	    03h number of messages in current task's mailbox
	    04h number of input buffers queued in task's kbd (handle on stack)
	    05h number of input buffers queued for current task's default kbd
	    06h number of objects queued in OBJECTQ (task's handle on stack)
	    07h number of objects queued in current task's OBJECTQ
	    0Ch (DV 2.26+) total chars in window owning handle on top of stack
	    0Dh (DV 2.26+) total chars in parent task's window
Return: DWORD on top of stack is result
Note:	for panel objects, a count of zero is returned if no panel file is open
	  for the object
SeeAlso: AH=12h/BH=04h,AH=12h/BH=09h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH
	AH = 12h
	BH = 09h
	BL = object
	    00h handle in DWORD on top of stack
		window: get chars/line
		timer: get 1/100 seconds remaining before timer expires
	    01h get number of chars/line in current task's default window
	    0Ch (DV 2.26+) get chars/line in window owning handle on top of stk
	    0Dh (DV 2.26+) get chars/line in parent task's window
Return: DWORD on top of stack is length
SeeAlso: AH=12h/BH=08h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - WRITE CHARS AND ATTRIBS TO WINDOW
	AH = 12h
	BH = 0Ah
	BL = window to write to
	    00h window handle is DWORD on top of stack
	    01h current task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK:	DWORD count of attributes
		DWORD address of attribute string
		DWORD count of characters
		DWORD address of character string
Notes:	if one string is longer than the other, the shorter one will be reused
	  until the longer one is exhausted
	the cursor is left just after the last character written
SeeAlso: AH=12h/BH=0Bh"WINDOW"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SEND MAILBOX MESSAGE/STAT BY VALUE
	AH = 12h
	BH = 0Ah
	BL = mailbox to write to
	    00h handle is DWORD on top of stack
	    02h default mailbox of task whose handle is on top of stack
	    03h current task's default mailbox
	STACK:	DWORD	status (low byte)
		DWORD	length of message
		DWORD	address of message
Notes:	the message is copied into either system or common memory
	insufficient memory normally causes the process to be aborted; under
	  DESQview 2.2+, failed writes may return CF set instead (see AX=DE15h)
SeeAlso: AH=12h/BH=0Bh"MAILBOX"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS
	AH = 12h
	BH = 0Ah
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer for specified interval
		pointer: set control flags
		keyboard: set control flags
	    04h set control flags on KEYBOARD object (handle on top of stack)
	    05h set control flags on task's default KEYBOARD object
	STACK: (if timer)   DWORD duration in 1/100 seconds
	       (otherwise)  DWORD bits to set
SeeAlso: AH=12h/BH=0Bh"OBJECT"

For keyboard objects, the bits have the following significance:
	bit 15 reserved, can't be set
	bit 14 unused
	bit 13 reserved, can't be set
	bit 12-6 unused
	bit 5  (DV 2.2+) exclusive input
	bit 4  filter all keys (used with handler established by SETESC)
		if 0, only keys that would normally be displayed are filtered
	bit 3  program continues executing while input in progress
	bit 2  insert mode active for field mode
	bit 1  hardware cursor displayed when task is hardware cursor owner
		must be set if keyboard in field mode and field table includes
		input fields
	bit 0  keyboard is in field mode rather than keystroke mode

For pointer objects, the bits have the following significance:
	bit 15 reserved, can't be set
	bit 14-8 unused
	bit 7  mouse pointer is hidden while in window
	bit 6  get messages even if window not topmost
	bit 5  get messages even if window not foreground
	bit 4  multiple clicks separated by less than 1/3 second are counted
		and returned in a single message
	bit 3  pointer position is relative to screen origin, not window origin
	bit 2  send message on button release as well as button press
	bit 1  (DV 2.23+) send message with row=FFFFh and col=FFFFh whenever
		pointer leaves the window
	bit 0  send message only on button activity, not movement
	       DV-specific, and INT 15h/AX=DE0Fh must have been called first
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - WRITE ATTRIBUTES TO WINDOW
	AH = 12h
	BH = 0Bh
	BL = window to write attributes to
	    00h handle is DWORD on top of stack
	    01h current task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK:	DWORD number of attributes to write
		DWORD address of attributes
Note:	the attributes are written starting at the current cursor position; the
	  cursor is left just after the last position written
SeeAlso: AH=12h/BH=0Ah"WINDOW"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - SEND MAILBOX MESSAGE/STAT BY REF
	AH = 12h
	BH = 0Bh
	BL = mailbox to write to
	    00h handle is DWORD on top of stack
	    02h default mailbox of task whose handle is on top of stack
	    03h current task's default mailbox
	STACK:	DWORD	status (low byte)
		DWORD	length of message
		DWORD	address of message
Notes:	only a pointer to the message is stored, but the write may still fail
	  due to insufficient memory
	under DV 2.2+, failed mailbox writes may return CF set (see AX=DE15h)
SeeAlso: AH=12h/BH=0Ah"MAILBOX"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - REMOVE OBJECT FROM OBJECTQ
	AH = 12h
	BH = 0Bh
	BL = OBJECTQ from which to remove all copies of a particular object
	    06h OBJECTQ of task whose handle is on top of stack
	    07h task's default OBJECTQ
	STACK:	DWORD	handle of object to remove
Note:	should be sent whenever an object is erased or closed
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS
	AH = 12h
	BH = 0Bh
	BL = object
	    00h handle is DWORD on top of stack
		pointer: reset control flags
		keyboard: reset control flags
	    04h clear control flags on KEYBOARD object (handle on top of stack)
	    05h clear control flags on task's default KEYBOARD object
	STACK:	DWORD	which bits to clear (see AH=12h/BH=0Ah"OBJECT")
SeeAlso: AH=12h/BH=0Ah"OBJECT"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT
	AH = 12h
	BH = 0Ch
	BL = object
	    00h handle is DWORD on top of stack
		window:   fill with given character from scroll origin to end
		keyboard: attach to a window
		timer:	  open
		pointer:  start taking input for window
		panel:	  associate with a panel file
	    01h fill task's default window with given char from scrl org to end
	    02h open given task's mailbox for input (task's handle on stack)
	    03h open current task's mailbox
	    04h attach a KEYBOARD to a window (handle on top of stack)
	    05h attach task's default KEYBOARD to a window
	    06h open a task's OBJECTQ (task's handle on top of stack)
	    07h open current task's OBJECTQ
	    0Ch (DV 2.26+) fill def window of task owning handle on top of stck
	    0Dh (DV 2.26+) fill default window of parent of current task
	 STACK: (if window)   DWORD character to fill with
		(if keyboard) DWORD handle of window to attach to
		(if pointer)  DWORD handle of window to attach to
		(if panel)    DWORD length of filename or resident panel
			      DWORD address of filename or resident panel
		(otherwise)   nothing
Notes:	if first byte of panel file name is 1Bh, then the "name" IS a panel
	if first two bytes of panel file "name" are C0hC3h, then the "name" IS
	  the panel file
	result code of open may be retrieved with STATUS message
	logical cursor is left at scroll origin after filling window
	the task opening a mailbox becomes its owner, and the only task allowed
	  to read the mailbox
	messages are only sent to a pointer object when the mouse is positioned
	  in the window to which the pointer has been attached
	there is no need to explicitly open a timer object, as ADDTO and WRITE
	  messages automatically open the timer
SeeAlso: AH=12h/BH=0Dh,AH=12h/BH=14h"LOCK"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT
	AH = 12h
	BH = 0Dh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	  close
		keyboard: detach from window and discard queued input
		pointer:  stop taking input
		panel:	  close
		mailbox:  close, unlock, and discard any pending messages
	    02h close given task's mailbox (task's handle on top of stack)
	    03h close task's default mailbox
	    04h close KEYBOARD object (handle on top of stack)
	    05h close task's default KEYBOARD
	    06h close givent task's OBJECTQ (task's handle on top of stack)
	    07h close current task's OBJECTQ
Notes:	when an OBJECTQ is closed, each object in the OBJECTQ is sent an
	  ERASE message (AH=12h/BH=0Eh)
	when a panel object is closed, the panel file and any panels currently
	  in use are freed; window and keyboard objects created by APPLY are
	  not affected, but field mode input ceases
	open but idle timer objects consume a small amount of CPU time
SeeAlso: AH=12h/BH=0Ch,AH=12h/BH=0Eh,AH=12h/BH=14h"LOCK"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT
	AH = 12h
	BH = 0Eh
	BL = object
	    00h handle is DWORD on top of stack
		window:   clear from scroll origin to end of window
		keyboard: discard input
		timer:	  cancel current interval
		pointer:  discard all pending messages
		mailbox:  discard all pending messages
	    01h clear task's default window from scroll origin to end
	    02h discard all queued messages in mailbox (handle on top of stack)
	    03h discard all queued messages in current task's default mailbox
	    04h discard all input queued to KEYBOARD (handle on top of stack)
	    05h discard all input queued to task's default KEYBOARD
	    06h remove all objects from OBJECTQ (task's handle on top of stack)
	    07h remove all objects from current task's OBJECTQ
	    0Ch (DV 2.26+) clear window of task owning handle on top of stack
	    0Dh (DV 2.26+) clear default window of parent of current task
Note:	when an OBJECTQ is erased, each object in the OBJECTQ is also erased
SeeAlso: AH=12h/BH=02h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS
	AH = 12h
	BH = 0Fh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	 is it running?
		pointer: return status of last message
		panel:	 verify success of last OPEN or APPLY
	    02h return status of last msg READ from mailbox (handle on stack)
	    03h return status of last msg READ from task's default mailbox
	    04h get status of last msg from task's KEYBOARD (task handle on stk)
	    05h get status of last msg from task's default KEYBOARD
	    06h return whether OBJECTQ is open or not (handle on top of stack)
	    07h return whether task's default OBJECTQ is open or not
Return: DWORD on top of stack is status
Notes:	if object is a panel object, the status indicates the error code:
	  00h successful
	  14h panel name not in panel directory
	  15h not enough memory to apply panel
	  16h invalid panel format
	  17h panel file already open
	  81h-92h  DOS error codes+80h			\  codes > 80h indicate
	  95h not enough memory to open panel file	 > that the panel was
	  98h null panel file name			/  not opened
	if object is a timer, the status is:
	  00000000h open but not running
	  40000000h open and running
	  80000000h closed
	if object is an OBJECTQ, the status is:
	  00000000h open
	  80000000h closed
	if object is a keyboard in keystroke mode, the status is the extended
	  character code (scan code) of teh last keystroke
	if object is a keyboard in field mode, the status indicates the reason
	  for the last return from the field manager
	  00h Enter key pressed
	  01h Button 1 or keystroke selection
	  02h Button 2
	  03h validation
	  04h auto Enter on field
	  1Bh Escape pressed
	  46h ^Break pressed
	  other: extended code for key terminating input
	the status of mailbox messages sent by the window manager is always 80h
	the status of a pointer message is the same as the status field in the
	  message
SeeAlso: AH=12h/BH=04h"READ"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS
	AH = 12h
	BH = 10h
	BL = object
	    00h handle is DWORD on top of stack
		window: return TRUE if logical cursor past end of window
		mailbox: ???
	    01h returns TRUE if logical cursor past end of task's def window
	    02h return ??? for task's mailbox (task's handle on top of stack)
	    03h return ??? for current task's mailbox
	    0Ch (DV 2.26+) check log crsr of window owning handle on top of stk
	    0Dh (DV 2.26+) check log cursor of window of parent task
Return: DWORD on top of stack is status
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR
	AH = 12h
	BH = 11h
	BL = window for which to move cursor
	    00h window's handle is DWORD on top of stack
	    01h task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK: DWORD column
	       DWORD row
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETNAME" - ASSIGN NAME TO MAILBOX
	AH = 12h
	BH = 11h
	BL = mailbox to name
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD length of name
	       DWORD address of name
SeeAlso: AX=DE0Eh
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR
	AH = 12h
	BX = 1100h
	STACK: DWORD object handle for pointer object
	       DWORD number of colums to scale pointer position to
	       DWORD number of rows to scale pointer position to
SeeAlso: AH=12h/BX=1200h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES
	AH = 12h
	BH = 12h
	BL = window to read from
	    00h handle is DWORD on top of stack
	    01h read next N chars or attributes on task's default window
	    0Ch (DV 2.26+) read window of task owning handle on top of stack
	    0Dh (DV 2.26+) read default window of parent of current task
	STACK: DWORD count
Return: STACK: DWORD width of screen line
	       DWORD address
	       DWORD count actually read
Notes:	reading starts at the current logical cursor position; the cursor is
	  updated to point at the character following the last one read
	any translucent blanks (FFh) which are visible on screen are changed
	  to the character which is seen through them
	the string produced by the read is placed in an input buffer which may
	  be reused by the next READ or READN of a window
	window stream opcodes D8h and D9h determine whether the read returns
	  characters or attributes
SeeAlso: AH=12h/BH=04h"WINDOW",AH=12h/BH=05h"WINDOW"
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR
	AH = 12h
	BX = 1200h
	STACK: DWORD object handle for pointer
Return: STACK: DWORD pointer pos scaled as if window were this many colums wide
	       DWORD pointer pos scaled as if window were this many rows high
SeeAlso: AH=12h/BX=1100h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW
	AH = 12h
	BH = 13h
	BL = window object
	    00h DWORD on top of stack is handle for window to redraw
	    01h redraw task's default window
	    0Ch (DV 2.26+) redraw window of task owning handle on top of stack
	    0Dh (DV 2.26+) redraw default window of parent of current task
SeeAlso: AH=12h/BH=0Eh
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON
	AH = 12h
	BX = 1300h
	STACK: DWORD object handle for pointer
	       DWORD character to use for pointer
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS
	AH = 12h
	BH = 14h
	BL = message modifier
	    00h handle is DWORD on top of stack
	    01h define user stream
	    04h intercept keystrokes from KEYBOARD to a window (handle on stack)
	    05h intercept keystrokes from task's default KEYBOARD to a window
	STACK: (if window)   DWORD user stream number (14h-1Fh)
			     DWORD address of FAR user stream handler
	       (if keyboard) DWORD address of FAR filter function

The keyboard filter function is called when the keyboard is in field mode.  On
entry,
	AL = character
	AH = 00h or extended ASCII code if AL = 00h
	BL = field number
	CH = cursor column
	CL = cursor row
	DL = field type modifier (sixth item in field table entry)
	DH = seventh item in field table entry
	ES:SI = window's handle
	DS:DI -> field table entry for field containing the cursor
The filter function should return
	AH = 00h use keystroke
	     01h ignore keystroke
	     FFh beep and ignore keystroke
Note: the filter function is not allowed to make INT 15, DOS, or BIOS calls
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "LOCK" - REQUEST EXCLUSIVE ACCESS TO RESOURCE
	AH = 12h
	BH = 14h
	BL = object
	    00h mailbox handle is DWORD on top of stack
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
Note:	release exclusive access by sending CLOSE message to mailbox
	access may be requested multiple times, and requires multiple CLOSEs
SeeAlso: AH=12h/BH=0Dh
---------------------------------------------
INT 15 - DESQview 2.2+ - SEND MESSAGE - "SETFLAGS" - SET OBJECT FLAGS
	AH = 12h
	BH = 15h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
	STACK: DWORD flags
		if mailbox:
			bit 0: all mail messages in common memory
			bit 1: allow write even if closed
			bit 2: don't erase messages when mailbox closed
		if keyboard:
			bit 5: exclusive input when keyboard in use for input
Return: nothing
Notes:	only available if the API level has been set to at least 2.20
	equivalent to performing SUBFROM and ADDTO calls on the object
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=0Bh,AH=12h/BH=16h
---------------------------------------------
INT 15 - DESQview 2.2+ - SEND MESSAGE - "GETFLAGS" - GET OBJECT FLAGS
	AH = 12h 
	BH = 16h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
Return: STACK: DWORD current control flags
Note:	only available if the API level has been set to at least 2.20
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=0Bh,AH=12h/BH=15h
---------------------------------------------
INT 15 - VMiX - WAKE PROCESS
	AH = 13h
	STACK:	WORD	process ID
Return: AX = status
---------------------------------------------
INT 15 - VMiX - CLEAR WINDOW
	AH = 14h
	STACK:	WORD	top left corner of window
		WORD	bottom right corner of window
Return: AX = status
---------------------------------------------
INT 15 - VMiX - SET BANNER WINDOW MESSAGE
	AH = 15h
	STACK:	DWORD	pointer to ASCIZ banner	message
Return: AX = status
---------------------------------------------
INT 15 - VMiX - SET ROOT WINDOW SIZE AND HOME CURSOR
	AH = 16h
	STACK:	DWORD	pointer to I/O Request Packet
		WORD	top left corner of window
		WORD	bottom right corner of window
Return: AX = status
---------------------------------------------
INT 15 - VMiX - GET CONSOLE WINDOW COLORS
	AH = 17h
Return: AH = foreground color
	AL = background color
SeeAlso: AH=18h
---------------------------------------------
INT 15 - VMiX - SET CONSOLE COLORS
	AH = 18h
	STACK:	WORD	new background/foreground colors
Return: AX = color
SeeAlso: AH=17h
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 19h
	STACK: WORD ???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Ah
	STACK: 3 WORDs ???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Bh
	STACK: 5 WORDs ???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Ch
	STACK: 5 WORDs ???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Dh
	???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Eh
	STACK: WORD ???
Return: ???
---------------------------------------------
INT 15 - DOS 3.x PRINT.COM - DISABLE CRITICAL REGION FLAG (AT,XT286,PS50+)
	AX = 2000h
SeeAlso: AX=2001h
---------------------------------------------
INT 15 - DOS 3.x PRINT.COM - SET CRITICAL REGION FLAG (AT,XT286,PS50+)
	AX = 2001h
	ES:BX -> byte which is to be incremented while in a DOS call
SeeAlso: AX=2000h
---------------------------------------------
INT 15 - OS HOOK - SETUP SYSREQ ROUTINE (AT,XT286,PS50+)
	AX = 2010h
	???
Return: ???
SeeAlso: AX=2011h
---------------------------------------------
INT 15 - OS HOOK - COMPLETION OF SYSREQ FUNCTION (AT,XT286,PS50+)
	AX = 2011h
	???
Return: ???
SeeAlso: AX=2010h
---------------------------------------------
INT 15 - SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)
	AH = 21h
	AL = subfunction
	    00h read POST log
	    01h write POST log
		BH = device ID
		BL = error code
Return: CF set on error
	AH = status (00h OK, 01h list full, 80h invalid cmd, 86h unsupported)
	if function 00h:
	   BX = number of error codes stored
	   ES:DI -> error log
Note:	the log is a series of words, the first byte of which identifies the
	  error code and the second the device.
---------------------------------------------
INT 15 - SYSTEM - READ/MODIFY PROFILES (CONVERTIBLE)
	AH = 40h
	AL = subfunction
	    00h get system profile in CX and BX
	    01h set system profile from CX and BX
	    02h get internal modem profile in BX
	    03h set internal modem profile from BX
---------------------------------------------
INT 15 - SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
	AH = 41h
	AL = condition type
	    bits 0-2: condition to wait for
		     0 any external event
		     1 compare and return if equal
		     2 compare and return if not equal
		     3 test and return if not zero
		     4 test and return if zero
	    bit 3:    reserved
	    bit 4:    1=port address, 0=user byte
	    bits 5-7: reserved
	BH = condition compare or mask value
	BL = timeout value times 55 milliseconds
	    00h means no timeout
	DX = I/O port address if AL bit 4 set
	ES:DI -> user byte if AL bit 4 clear
---------------------------------------------
INT 15 - SYSTEM - REQUEST POWER OFF (CONVERTIBLE)
	AH = 42h
	AL = 00h to use system profile
	     01h to force suspend regardless of system profile
---------------------------------------------
INT 15 - SYSTEM - READ SYSTEM STATUS (CONVERTIBLE)
	AH = 43h
Return: AL = status bits
	    bit 0: LCD detached
	    bit 1: reserved
	    bit 2: RS232/parallel adapter powered on
	    bit 3: internal modem powered on
	    bit 4: power activated by alarm
	    bit 5: standby power lost
	    bit 6: external power in use
	    bit 7: power low
---------------------------------------------
INT 15 - SYSTEM - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)
	AH = 44h
	AL = 00h to power off
	     01h to power on
---------------------------------------------
INT 15 - OS HOOK - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)
	AH = 4Fh
	AL = scan code
	CF set
Return: CF set
	   AL = scan code
	CF clear
	   scan code should be ignored
Note:	called by INT 9 handler to translate scan codes
SeeAlso: INT 09
---------------------------------------------
INT 15 - OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)
	AH = 80h
	BX = device ID
	CX = process type
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
SeeAlso: AH=81h,82h
---------------------------------------------
INT 15 - OS HOOK - DEVICE CLOSE (AT,XT2,XT286,PS)
	AH = 81h
	BX = device ID
	CX = process type
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
SeeAlso: AH=80h,82h
---------------------------------------------
INT 15 - OS HOOK - DEVICE PROGRAM TERMINATE (AT,XT2,XT286,PS)
	AH = 82h
	BX = device ID
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
Note:	closes all devices opened with function 80h
SeeAlso: AH=80h,81h
---------------------------------------------
INT 15 - SYSTEM - EVENT WAIT (AT,XT286,CONV,PS)
	AH = 83h
	AL = subservice
	    00h = set interval
	    01h = cancel
	ES:BX -> event flag (bit 7 set when interval expires)
	CX:DX = number of microseconds to wait (only accurate to 977 us)
Return: CF set if function already busy
Note:	the resolution of the wait period is 977 microseconds on most systems
	  because most BIOSes use the 1/1024 second fast interrupt from the AT
	  real-time clock chip which is available on INT 70
SeeAlso: AH=86h, INT 70
---------------------------------------------
INT 15 - SYSTEM - READ JOYSTICK (AT,XT2,XT286,PS)
	AH = 84h
	DX = subservice
	    0000h get switch settings
		Return: AL = switch settings (bits 7-4)
	    0001h read joystick inputs
		Return: AX = A(x) value
			BX = A(y) value
			CX = B(x) value
			DX = B(y) value
---------------------------------------------
INT 15 - OS HOOK - SYSTEM REQUEST KEY PRESSED (AT,XT2,XT286,CONV,PS)
	AH = 85h
	AL = 00h press
	   = 01h release
Return: CF set on error
	AH = status
Note:	called by keyboard decode routine
SeeAlso: INT 09
---------------------------------------------
INT 15 - SYSTEM - WAIT (AT,XT2,XT286,CONV,PS)
	AH = 86h
	CX,DX = number of microseconds to wait (only accurate to 977 us)
Return: CF clear: after wait elapses
	CF set: immediately due to error
Note:	the resolution of the wait period is 977 microseconds on most systems
	  because most BIOSes use the 1/1024 second fast interrupt from the AT
	  real-time clock chip which is available on INT 70
SeeAlso: AH=83h, INT 70
---------------------------------------------
INT 15 - EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
	AH = 87h
	CX = number of words to move
	ES:SI -> global descriptor table (see below)
Return: CF set on error
	AH = status
	    00h source copied into destination
	    01h parity error
	    02h interrupt error
	    03h address line 20 gating failed
SeeAlso: AH=88h

Format of global descriptor table:
Offset	Size	Description
 00h 16 BYTEs	zeros
 10h	WORD	source segment length in bytes (2*CX-1 or greater)
 12h  3 BYTEs	24-bit linear source address, low byte first
 15h	BYTE	source segment access rights (93h)
 16h	WORD	zero
 18h	WORD	destination segment length in bytes (2*CX-1 or greater)
 1Ah  3 BYTEs	24-bit linear destination address, low byte first
 1Dh	BYTE	destination segment access rights (93h)
 1Eh 18 BYTEs	zeros
---------------------------------------------
INT 15 - EXTENDED MEMORY - GET MEMORY SIZE (AT,XT286,PS)
	AH = 88h
Return: AX = memory size in K
SeeAlso: AH=87h
Note:	TSRs which wish to allocate extended memory to themselves often hook
	  this call, and return a reduced memory size.	They are then free to
	  use the memory between the new and old sizes at will.
---------------------------------------------
INT 15 - SYSTEM - SWITCH TO VIRTUAL MODE (AT,XT286,PS50+)
	AH = 89h
	BL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)
	BH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)
	DS:SI -> GDT for protected mode
	       offset 0h  null descriptor
		      8h  GDT descriptor
		     10h  IDT descriptor
		     18h  DS
		     20h  ES
		     28h  SS
		     30h  CS
		     38h  uninitialized, used to build descriptor for BIOS CS
	CX = offset into protected-mode CS to jump to
Return: CF set on error
	   AH = 0FFh  error enabling address line 20
	in protected mode at specified address if successful
SeeAlso: INT 67/AX=DE0Ch
---------------------------------------------
INT 15 - OS HOOK - DEVICE BUSY LOOP (AT,XT2,XT286,CONV,PS)
	AH = 90h
	AL = type code
	    00h disk
	    01h diskette
	    02h keyboard
	    03h PS/2 pointing device
	    80h network
	    FCh disk reset
	    FDh diskette motor start
	    FEh printer
	ES:BX -> request block for type codes 80h through BFh
Return: CF set if wait time satisfied
	CF clear if driver must perform wait
Note:	type codes are allocated as follows:
	  00-7F non-reentrant devices; OS must arbitrate access
	  80-BF reentrant devices; ES:BX points to a unique control block
	  C0-FF wait-only calls, no complementary INT 15/AH=91h call
SeeAlso: AH=91h
---------------------------------------------
INT 15 - OS HOOK - SET FLAG AND COMPLETE INTERRUPT (AT,XT2,XT286,CONV,PS)
	AH = 91h
	AL = type code (see AH=90h)
	ES:BX -> request block for type codes 80h through BFh
Return: AH = 00h
SeeAlso: AH=90h
---------------------------------------------
INT 15 - SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
	AH = C0h
Return: CF set if BIOS doesn't support call
	CF clear on success
	    ES:BX -> ROM table (see below)
Note:	the 1/10/86 XT BIOS returns an incorrect value for the feature byte

Format of ROM configuration table:
Offset	Size	Description
 00h	WORD	number of bytes following
 02h	BYTE	model (see below)
 03h	BYTE	submodel (see below)
 04h	BYTE	BIOS revision: 0 for first release, 1 for 2nd, etc.
 05h	BYTE	features:
		bit 7 = DMA channel 3 used by hard disk BIOS
		bit 6 = 2nd 8259 installed
		bit 5 = Real-Time Clock installed
		bit 4 = INT 15h/AH=4Fh called upon INT 9h
		bit 3 = wait for external event supported
		bit 2 = extended BIOS area allocated at 640K
		bit 1 = bus is Micro Channel instead of ISA
		bit 0 reserved
 06h	WORD	reserved (0)
 08h	WORD	reserved (0)
 0Ah		AWARD copyright notice here

Values for model/submodel/revision:
Model  Submdl  Rev	BIOS date	System
 FFh	*	*	04/24/81	PC (original)
 FFh	*	*	10/19/81	PC (some bugfixes)
 FFh	*	*	10/27/82	PC (HD, 640K, EGA support)
 FEh	*	*	08/16/82	PC XT
 FEh	*	*	11/08/82	PC XT and Portable
 FDh	*	*	06/01/83	PCjr
 FCh	*	*	01/10/84	AT models 068,099 6 MHz 20MB
 FCh	00h	01h	06/10/85	AT model  239	  6 MHz 30MB
 FCh	00h	<> 01h	  ???		7531/2 Industrial AT
 FCh	01h	00h	11/15/85	AT models 319,339 8 MHz, Enh Keyb, 3.5"
 FCh	01h	???	  ???		Compaq 286/386
 FCh	02h	00h	04/21/86	PC XT-286
 FCh	04h	00h	02/13/87     ** PS/2 Model 50
 FCh	04h	03h	04/18/88	PS/2 Model 50Z
 FCh	05h	00h	02/13/87     ** PS/2 Model 60
 FCh	06h	???	  ???		7552 "Gearbox"
 FCh	09h	02h	06/28/89	PS/2 Model 30-286
 FCh	81h	00h	01/15/88	Phoenix 386 BIOS v1.10 10a
 FBh	00h	01h	01/10/86	PC XT, Enh Keyb, 3.5" support
 FBh	00h	02h	05/09/86	PC XT
 FAh	00h	00h	09/02/86	PS/2 Model 30
 FAh	00h	01h	12/12/86	PS/2 Model 30
 FAh	01h	00h	  ???		PS/2 Model 25
 F9h	00h	00h	09/13/85	PC Convertible
 F8h	00h	00h	03/30/87     ** PS/2 Model 80 16MHz
 F8h	01h	00h	10/07/87	PS/2 Model 80 20MHz
 F8h	04h	02h	04/11/88	PS/2 Model 70 20MHz, type 2 system brd
 F8h	04h	03h	03/17/89	PS/2 Model 70 20MHz, type 2 system brd
 F8h	09h	???	  ???		PS/2 Model 70 16MHz, type 1 system brd
 F8h	09h	02h	04/11/88	PS/2 Model 70 some models
 F8h	09h	03h	03/17/89	PS/2 Model 70 some models
 F8h	0Ch	00h	11/02/88	PS/2 Model 55SX
 F8h	0Dh	???	  ???		PS/2 Model 70 25MHz, type 3 system brd
 F8h	1Bh	00h	10/02/89	PS/2 Model 70-486
 9Ah	*	*	  ???		Compaq XT/Compaq Plus
 30h	???	???	  ???		Sperry PC
 2Dh	*	*	  ???		Compaq PC/Compaq Deskpro

    * This BIOS call is not implemented in these early versions.
      Read Model byte at F000h:FFFEh and BIOS date at F000h:FFF5h.
   ** These BIOS versions require the DASDDRVR.SYS patches.
---------------------------------------------
INT 15 - SYSTEM - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)
	AH = C1h
Return: CF set on error
	CF clear if successful
	    ES = segment of data area
SeeAlso: AH=04h"ABIOS"
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - ENABLE/DISABLE
	AX = C200h
	BH = 00h disable
	     01h enable
Return: CF set on error
	AH = status
	    00h successful
	    01h invalid function
	    02h invalid input
	    03h interface error
	    04h need to resend
	    05h no device handler installed
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - RESET
	AX = C201h
Return: CF set on error
 	    AH = status (see AX=C200h)
	CF clear if successful
	    BH = device ID
SeeAlso: INT 33/AX=0000h
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET SAMPLING RATE
	AX = C202h
	BH = sampling rate
	    00h 10/second
	    01h 20/second
	    02h 40/second
	    03h 60/second
	    04h 80/second
	    05h 100/second
	    06h 200/second
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: INT 33/AX=001Ch
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET RESOLUTION
	AX = C203h
	BH = resolution
	    00h one count per mm
	    01h two counts per mm
	    02h four counts per mm
	    03h eight counts per mm
Return: CF set on error
	    AH = status (see AX=C200h)
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET TYPE
	AX = C204h
Return: CF set on error
	    AH = status (see AX=C200h)
	CF clear if successful
	    BH = device ID
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - INITIALIZE
	AX = C205h
	BH = data package size (1 - 8 bytes)
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: AX=C201h
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET/SET SCALING FACTOR
	AX = C206h
	BH = subfunction
	    00h return device status
		Return: BL = status
			   bit 0: right button pressed
			   bit 1: reserved
			   bit 2: left button pressed
			   bit 3: reserved
			   bit 4: 0 if 1:1 scaling, 1 if 2:1 scaling
			   bit 5: device enabled
			   bit 6: 0 if stream mode, 1 if remote mode
			   bit 7: reserved
			CL = resolution (see AX=C203h)
  			DL = sample rate, reports per second
	    01h set scaling at 1:1
 	    02h set scaling at 2:1
Return: CF set on error
	    AH = status (see AX=C200h)
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET DEVICE HANDLER ADDR
	AX = C207h
	ES:BX = user device handler
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: INT 33/AX=000Ch
--------------------------------------------
INT 15 - SYSTEM - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)
	AH = C3h
	AL = 00h disable
	     01h enable
		BX = timer counter
Return: CF set on error
	CF clear if successful
Note:	the watchdog timer generates an NMI
---------------------------------------------
INT 15 - SYSTEM - PROGRAMMABLE OPTION SELECT (PS50+)
	AH = C4h
	AL = 00h return base POS register address
	     01h enable slot
		 BL = slot number
	     02h enable adapter
Return: CF set on error
	DX = base POS register address (if function 00h)
---------------------------------------------
INT 15 - EISA SYSTEM ROM - READ SLOT CONFIGURATION INFORMATION
	AX = D800h
	CL = slot number (including embedded and virtual)
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		80h invalid slot number
		82h EISA CMOS corrupt
		83h empty slot
		86h invalid BIOS-FW function call
		87h invalid system configuration
	AL bit flags
	    bit 7: set if duplicate IDs
		6: set if product ID readable
	      4,5: slot type (00=expansion, 01=embedded, 10=virtual device)
	      0-3: duplicate ID number if bit 7 set
	BH = major revision level of configuration utility
	BL = minor revision level of configuration utility
	CX = checksum of configuration file
	DH = number of device functions
	DL = combined function information byte
	SI:DI = 4-byte compressed ID (DI = bytes 0&1, SI = bytes 2&3)
Note:	call with AL=80h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D801h,AX=D804h
---------------------------------------------
INT 15 - EISA SYSTEM ROM - READ FUNCTION CONFIGURATION INFORMATION
	AX = D801h
	CH = function number to read
	CL = slot number (including embedded and virtual)
	DS:SI -> 320-byte buffer for standard configuration data block
Return: CF clear if successful
	    AH = 00h
	    DS:SI buffer filled
	CF set on error
	    AH = error code
		80h invalid slot number
		81h invalid function number
		82h EISA CMOS corrupt
		83h empty slot
		86h invalid BIOS-FW function call
		87h invalid system configuration
	BX destroyed
Note:	call with AL=81h if using 32-bit CS addressing mode instead of 16-bit
---------------------------------------------
INT 15 - EISA SYSTEM ROM - CLEAR NONVOLATILE MEMORY (EISA CMOS)
	AX = D802h
	BH = EISA config utility major revision level
	BL = EISA config utility minor revision level
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		84h error clearing CMOS
		86h invalid BIOS-FW function call
		88h config utility version not supported
Note:	call with AL=82h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D803h
---------------------------------------------
INT 15 - EISA SYSTEM ROM - WRITE NONVOLATILE MEMORY
	AX = D803h
	CX = length of data structure (0000h = empty slot)
		includes two bytes for config file checksum
	DS:SI -> configuration data
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		84h error clearing CMOS
		85h EISA CMOS is full
		86h invalid BIOS-FW function call
Note:	call with AL=83h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D802h
---------------------------------------------
INT 15 - EISA SYSTEM ROM - READ PHYSICAL SLOT
	AX = D804h
	CL = slot number (including embedded and virtual)
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		80h invalid slot number
		83h empty slot
		86h invalid BIOS-FW function call
	SI:DI = 4-byte compressed ID (DI = bytes 0&1, SI = bytes 2&3)
Note:	call with AL=84h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D800h
---------------------------------------------
INT 15 - EISA SYSTEM ROM - 32-bit CS ADDRESSING MODE CALLS
	AH = D8h
	AL = 80h to 84h
	other registers as appropriate for AL=00h to 04h
Return: as appropriate for AL=00h to 04h
Note:	these functions are identical to AX=D800h to D804h, except that they
	  should be called when using 32-bit CS addressing mode (pointers use
	  ESI rather than SI as offset) instead of 16-bit addressing mode
SeeAlso: AX=D800h, AX=D801h, AX=D802h, AX=D803h, AX=D804h
---------------------------------------------
INT 15 - DESQview - GET PROGRAM NAME
	AX = DE00h
Return: AX = offset into DESQVIEW.DVO of current program's record (see below)
SeeAlso: AX=DE07h

Format of program entry in DESQVIEW.DVO:
Offset	Size	Description
 00h	BYTE	length of name
 01h  N BYTEs	name
      2 BYTEs	keys to invoke program (second = 00h if only one key used)
	WORD	??? seems always to be 0000h
	BYTE	end flag: 00h for all but last entry, which is FFh
---------------------------------------------
INT 15 - DESQview - UPDATE "OPEN WINDOW" MENU
	AX = DE01h
Return: nothing
Note:	reads DESQVIEW.DVO, disables Open menu if file not in current directory
---------------------------------------------
INT 15 - DESQview 1.x only - SET ??? FLAG FOR CURRENT WINDOW
	AX = DE02h
Return: nothing
Note:	this call is a NOP in DV 2.x
SeeAlso: AX=DE03h
---------------------------------------------
INT 15 - DESQview 1.x only - GET ??? FOR CURRENT WINDOW
	AX = DE03h
Return: AX = ??? for current window
	BX = ??? for current window
Note:	this call is a NOP in DV 2.x
SeeAlso: AX=DE02h
---------------------------------------------
INT 15 - DESQview - GET AVAILABLE COMMON MEMORY
	AX = DE04h
Return: BX = bytes of common memory available
	CX = largest block available
	DX = total common memory in bytes
SeeAlso: AX=DE05h,DE06h
---------------------------------------------
INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY
	AX = DE05h
Return: BX = K of memory available
	CX = largest block available
	DX = total conventional memory in K
SeeAlso: AX=DE04h,DE06h
---------------------------------------------
INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY
	AX = DE06h
Return: BX = K of expanded memory available
	CX = largest block available
	DX = total expanded memory in K
SeeAlso: AX=DE04h,DE05h
---------------------------------------------
INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER
	AX = DE07h
Return: AX = number of program as it appears on the "Switch Windows" menu
Note:	this API call may be made from a hardware interrupt handler
SeeAlso: AX=DE00h
---------------------------------------------
INT 15 - DESQview - GET ???
	AX = DE08h
Return: AX = 0000h if ??? is not set to the current task
	     0001h if ??? is set to the current task
---------------------------------------------
INT 15 - DESQview - UNIMPLEMENTED
	AX = DE09h
Return: nothing (NOP in DV 1.x and 2.x)
---------------------------------------------
INT 15 - DESQview 2.x - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE
	AX = DE0Ah
	BL = character
Return: character displayed, next call will display in next position (which
	wraps back to the start of the line if off the right edge of screen)
Notes:	displays character on bottom line of *physical* screen, regardless
	  of current size of window (even entirely hidden)
	does not know about graphics display modes, just pokes the characters
	  into display memory
	this API call may be made from a hardware interrupt handler
SeeAlso: AX=1003h
---------------------------------------------
INT 15 - DESQview 2.x - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED
	AX = DE0Bh
	BL = API level major version number
	BH = API level minor version number
Return: AX = maximum API level (AL = major, AH = minor)
Notes:	if the requested API level is greater than the version of DESQview, a
	  "You need a newer version" error window is popped up
	the API level defaults to 1.00, and is inherited by child tasks
	some early copies of DV 2.00 return AX=0200h instead of 0002h
---------------------------------------------
INT 15 - DESQview 2.x - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = DE0Ch
	BX = number of bytes
Return: ES:DI -> allocated block or 0000h:0000h (DV 2.26+)
Note:	use SETERROR (AX=DE15h) to avoid a user prompt if there is insufficient
	  system memory
SeeAlso: AX=1001h,AX=DE0Dh,AX=DE15h
---------------------------------------------
INT 15 - DESQview 2.x - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = DE0Dh
	ES:DI -> previously allocated block
Return: nothing
SeeAlso: AX=1002h,AX=DE0Ch
---------------------------------------------
INT 15 - DESQview 2.x - "FINDMAIL" - FIND MAILBOX BY NAME
	AX = DE0Eh
	ES:DI -> name to find
	CX = length of name
Return: BX = 0000h not found
	     0001h found
		DS:SI = object handle
SeeAlso: AH=12h/BH=11h
---------------------------------------------
INT 15 - DESQview 2.x - ENABLE DESQview EXTENSIONS
	AX = DE0Fh
Return: AX and BX destroyed (seems to be bug, weren't saved&restored)
Notes:	sends a manager stream with opcodes AEh, BDh, and BFh to task's window
	enables an additional mouse mode
---------------------------------------------
INT 15 - DESQview 2.x - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM
	AX = DE10h
	BH = scan code
	BL = character
Return: nothing
Notes:	a later read will get the keystroke as if it had been typed by the user
	multiple pushes are read last-in first-out
	if a script exists for the pushed key in the current application, the
	  script will be executed
	early copies of DV 2.00 destroy AX, BX, ES, and DI
SeeAlso: INT 16/AH=05h
---------------------------------------------
INT 15 - DESQview 2.x - ENABLE/DISABLE AUTOMATIC JUSTIFICATION OF WINDOW
	AX = DE11h
	BL = 00h      viewport will not move automatically
	     nonzero  viewport will move to keep cursor visible (default)
Return: nothing
---------------------------------------------
INT 15 - DESQview 2.01+ - "CSTYLE" - SET "C"-COMPATIBLE CONTROL CHAR INTERPRET
	AX = DE12h
	BX = 0000h    select normal style (linefeed only moved down)
	     nonzero  select C style (linefeed moves to start of next line)
Return: nothing
Note:	set on a per-task basis, and inherited from the parent task
---------------------------------------------
INT 15 - DESQview 2.2+ - GET CRITICAL NESTING COUNT
	AX = DE13h
Return: BX = number of calls to BEGINC or ENTERC (see INT 15/AX=101Bh,DE1Ch)
	     without matching ENDC (see INT 15/AX=101Ch)
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,101Ch,DE1Bh,DE1Ch
---------------------------------------------
INT 15 - DESQview 2.2+ - GET OBJECT TYPE
	AX = DE14h
	ES:DI -> object
Return: BL = 00h not an object
	     08h window or task
	     09h mailbox
	     0Ah keyboard
	     0Bh timer
	     0Ch objectq
	     0Fh pointer
	     10h panel
SeeAlso: AX=1016h
---------------------------------------------
INT 15 - DESQview 2.2+ - SET ERROR HANDLING
	AX = DE15h
	BL = 00h post system error on all error conditions
	     01h return carry flag set on calls to ADDTO, SUBFROM, and WRITE
		 messages sent to mailboxes which fail due to lack of system
		 or common memory
	     02h (v2.26+) same as 01h, but return null pointer for GETMEM
		 calls which fail due to lack of system memory
Return: nothing
SeeAlso: AX=DE16h
---------------------------------------------
INT 15 - DESQview 2.2+ - GET ERROR HANDLING
	AX = DE16h
Return: BL = 00h always post system error
	     01h return carry flag set on failed mailbox writes
	     02h return CF set on failed mailbox writes and NULL on failed
		 GETMEM calls
SeeAlso: AX=DE15h
---------------------------------------------
INT 15 - DESQview 2.20-2.25 - reserved
	AX = DE17h
Return: pops up "Programming error" window
Note:	AX = 1117h is NOT identical to this call under DESQview 2.20 thru 2.25
---------------------------------------------
INT 15 - DESQview 2.26+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = DE17h
	BX = 0000h	get current mapping context without setting
	     nonzero	set new mapping context
Return: BX = mapping context in effect before call
Notes:	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	caller need not be running under DESQview
	this API call may be made from a hardware interrupt handler
---------------------------------------------
INT 15 - DESQview 2.2+ internal - ???
	AX = DE18h
	BP = function number
	    high byte must be 10h
	    low byte is function
		00h set ???
		    BL = ???  (00h-10h, video mode???)
		    BH = value to store
		03h set ???
		    BL = ??? (stored in driver)
		0Ah get ???
		    ES:DI -> 18-byte buffer to hold ???
Note:	calls video driver (NOP for Hercules driver,probably CGA and MCGA also)
---------------------------------------------
INT 15 - DESQview 2.23+ - "GETCOMMON" - ALLOCATE "COMMON" MEMORY
	AX = DE19h
	BX = number of bytes to allocate
Return: AX = 0000h successful
		ES:DI -> allocated block
	     nonzero insufficient memory
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=DE0Ch,AX=DE15h,AX=DE1Ah
---------------------------------------------
INT 15 - DESQview 2.23+ - "PUTCOMMON" - DEALLOCATE "COMMON" MEMORY
	AX = DE1Ah
	DS:SI -> previously allocated block
Note:	this function may be called from within a hardware interrupt handler
SeeAlso: AX=DE0Dh,DE19h
---------------------------------------------
INT 15 - DESQview 2.23+ internal - DECREMENT CRITICAL NESTING COUNT
	AX = DE1Bh
Return: nothing
SeeAlso: AX=101Ch,AX=DE13h,AX=DE1Ch
---------------------------------------------
INT 15 - DESQview 2.23+ - "ENTERC" - INCREMENT CRITICAL NESTING COUNT
	AX = DE1Ch
Return: nothing
Notes:	similar to AX=101Bh, but begins the critical region without ensuring
	  that DOS is free
	the official documentation states that this call should be paired with
	  "ENDC" (AX=101Ch); no mention is made of AX=DE1Bh
	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=101Ch,AX=DE13h,AX=DE1Bh
---------------------------------------------
INT 15 - DESQview 2.23+ - "PUTKEY" - FAKE USER KEYSTROKES
	AX = DE1Dh
	DX = segment of handle for task to receive keystroke
	BL = character
	BH = scan code
Return: AX = 0000h if successful
	   nonzero if receiver's keyboard buffer was full
Notes:	the key is treated as though the user had pressed it, ignoring any
	  script which may be bound to the key, and using the current field
	  table if the keyboard object is in field processing mode
	multiple PUTKEYs are seen in the order in which they are executed
SeeAlso: AX=DE10h
---------------------------------------------
INT 15 - DESQview 2.23+ - "SCRNINFO" - GET TRUE VIDEO PARAMETERS
	AX = DE1Eh
Return:	CL = actual number of rows on screen
	CH = actual number of columns on screen
	BL = actual video mode (may differ from INT 10/AH=0Fh return) (v2.26+)
Note:	this API call may be made from a hardware interrupt handler
SeeAlso: INT 10/AH=0Fh
---------------------------------------------
INT 15 - DESQview 2.23+ - "DOSUSER" - GET HANDLE OF TASK CURRENTLY USING DOS
	AX = DE1Fh
Return: BX = segment of task handle or 0000h if no tasks are using DOS
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=DE13h
---------------------------------------------
INT 15 - DESQview 2.26+ - "DISPATCHINT" - INTERRUPT ANOTHER TASK
	AX = DE20h
	BX = segment of handle of task to interupt
	DX:CX -> FAR interrupt routine
Return: nothing
Notes:	unlike "PGMINT" (AX=1021h), DISPATCHINT may be applied to the task
	  making the DISPATCHINT call
	multiple "DISPATCHINT" calls are processed in the order in which they
	  were executed
	the FAR routine is entered with the current ES, DS, SI, DI, and BP
	  values, using the task's internal stack (see AX=101Ah); only SS:SP
	  needs to be preserved
	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=1021h
---------------------------------------------
INT 15 - DESQview 2.26+ - "ASSERTVIR" - CONTROL 386 SCREEN VIRTUALIZATION
	AX = DE21h
	BX = 0000h turn off
	     nonzero turn on
Return: BX = old state of virtualization
Note:	this API call may be made from within a hardware interrupt handler
---------------------------------------------
INT 15 - DESQview 2.26+ - "PROCESSMEM" - GET TASK MEMORY STATUS
	AX = DE22h
	DX = segment of task handle
Return: DX = total amount of memory in paragraphs
	BX = amount of system memory in paragraphs
	CX = largest block of system memory available in paragraphs
	AX = flags
	    bit 0: system memory resides in shared memory
		1: process's memory is swapped out
		2: process's system memory is swapped out
Notes:	if the task handle is a child task, the returned values will be for the
	  process containing the task, rather than the task itself
	if the process's system memory is swapped out, BX,CX,DX remain
	  unchanged, because the memory usage cannot be determined
SeeAlso: AX=DE04h,AX=DE05h,AX=DE06h
---------------------------------------------
INT 16 - KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
	AH = 00h
Return: AH = scan code
	AL = character
Note:	on extended keyboards, this function discards any extended keystrokes,
	  returning only when a non-extended keystroke is available
SeeAlso: AH=01h,10h
---------------------------------------------
INT 16 - KEYBOARD - CHECK BUFFER, DO NOT CLEAR
	AH = 01h
Return: ZF clear if character in buffer
	    AH = scan code
	    AL = character
	ZF set if no character in buffer
SeeAlso: AH=00h,11h
---------------------------------------------
INT 16 - KEYBOARD - GET SHIFT STATUS
	AH = 02h
	AL = shift status bits
	    0 = right shift key depressed
	    1 = left shift key depressed
	    2 = CTRL depressed
	    3 = ALT depressed
	    4 = SCROLL LOCK active
	    5 = NUM LOCK active
	    6 = CAPS LOCK active
	    7 = INSERT state active
SeeAlso: AH=12h
---------------------------------------------
INT 16 - KEYBOARD - SET DELAYS (Jr,AT model 339,XT286,PS)
	AH = 03h
	AL = subfunction
	    00h reset typematic (PCjr)
	    01h increase initial delay (PCjr)
	    02h increase continuing delay (PCjr)
	    03h increase both delays (PCjr)
	    04h turn off typematic (PCjr)
	    05h Set typematic rate (AT or PS/2)
	BH = 00h - 03h for delays of 250ms, 500ms, 750ms, or 1s
	BL = 00h - 1Fh for typematic rates of 30cps down to 2cps
---------------------------------------------
INT 16 - KEYBOARD - KEYCLICK (Jr,CONV)
	AH = 04h
	AL = 00h click off
	     01h click on
---------------------------------------------
INT 16 - KEYBOARD - WRITE TO KEYBOARD BUFFER (AT model 339,XT2,XT286,PS)
	AH = 05h
	CH = scan code
	CL = character
Return: AL = 01h if buffer full
SeeAlso: AH=71h, INT 15/AX=DE10h
---------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
	AH = 10h
Return: AH = scan code
	AL = character
Note:	unlike AH=00h, this function does not discard extended keystrokes
SeeAlso: AH=00h,11h
---------------------------------------------
INT 16 - KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
	AH = 11h
Return: ZF clear if keystroke available
	    AH = scan code \ meaningless if ZF = 1
	    AL = character /
	ZF set if kbd buffer empty
SeeAlso: AH=01h,10h
---------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS)
	AH = 12h
Return: AL = shift flags (same as for AH=02h)
	   bit 7: Ins ON
	   bit 6: CapsLock ON
	   bit 5: NumLock ON
	   bit 4: ScrollLock ON
	   bit 3: Either ALT key down
	   bit 2: Either CTRL key down
	   bit 1: Left shift key down
	   bit 0: Right shift key down
	AH
	   bit 7: SysReq key down
	   bit 6: CapsLock key down
	   bit 5: NumLock key down
	   bit 4: ScrollLock key down
	   bit 3: Right Alt key down
	   bit 2: Right Ctrl key down
	   bit 1: Left Alt key down
	   bit 0: Left Ctrl key down
Notes:	AL bit 3 set only for left Alt key on many machines
	AH bits 7 through 4 always clear on a Compaq SLT/286
SeeAlso: AH=02h
---------------------------------------------
INT 16 - Microsoft Word internal - MICROSOFT WORD COOPERATION WITH TSR
	AX = 5500h
Return: AX = 4D53h if keyboard TSR present
Notes:	during startup, Microsoft Word tries to communicate with any TSRs
	  that are present through this call.
	If the return is not 4D53h, Word installs its own INT 9h and INT 16h
	  handlers, otherwise it assumes that the TSR will handle the keyboard.
---------------------------------------------
INT 16 - PC Tools v5.1+ BACKTALK - UNHOOK
	AX = 6969h
	BX = 6968h
Return: resident code unhooked, but not removed from memory
---------------------------------------------
INT 16 - PC Tools v5.1+ BACKTALK - INSTALLATION CHECK
	AX = 6969h
	BX = 6969h
	DX = 0000h
Return: DX nonzero if installed
	    BX = CS of resident code
	    DX = PSP segment of resident code
	    DS:SI -> ASCIZ identification string "CPoint Talk"
---------------------------------------------
INT 16 - MS Windows - ???
	AH = 6Fh
	???
Return: ???
---------------------------------------------
INT 16 - FAKEY.COM - INSTALLATION CHECK
	AH = 70h
Return: AX = 1954h if installed
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
---------------------------------------------
INT 16 - FAKEY.COM - PUSH KEYSTROKES
	AH = 71h
	CX = number of keystrokes
	DS:SI -> array of words containing keystrokes to be returned by AH=00h
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
SeeAlso: AH=05h,72h
---------------------------------------------
INT 16 - FAKEY.COM - CLEAR FAKED KEYSTROKES
	AH = 72h
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
SeeAlso: AH=71h
---------------------------------------------
INT 16 - FAKEY.COM - PLAY TONES
	AH = 73h
	CX = number of tones to play
	DS:SI -> array of tones (see below)
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates

Format of tone array entries:
Offset	Size	Description
 00h	WORD	divisor for timer channel 2
 02h	WORD	duration in clock ticks
---------------------------------------------
INT 16 - pcANYWHERE - SET TICK COUNT FOR SCANNING
	AH = 75h
	AL = number of ticks between checks for new screen changes
---------------------------------------------
INT 16 - pcANYWHERE - SET ERROR CHECKING TYPE
	AH = 76h
	AL = error checking type
	    00h none
	    01h fast
	    02h slow
---------------------------------------------
INT 16 - pcANYWHERE - LOG OFF
	AH = 77h
	AL = mode
	    00h wait for another call
	    01h leave in Memory Resident Mode
	    02h leave in Automatic Mode
	    FFh leave in current operating mode
---------------------------------------------
INT 16 - WATCH.COM - INSTALLATION CHECK
	AX = 7761h ('wa')
Return: AX = 5741h ('WA') if installed
Note:	WATCH.COM is part of the "TSR" package by Kim Kokkonen
---------------------------------------------
INT 16 - PC Magazine PUSHDIR.COM - INSTALLATION CHECK
	AX = 7788h
	BX = 7789h
Return: AX = 7789h
	BX = 7788h
	DS:SI -> signature string
---------------------------------------------
INT 16 - pcANYWHERE - CHECK STATUS
	AH = 79h
Return: AX = status
	    FFFFh if resident and active
	    FFFEh if resident but not active
	    FFFDh if in Memory Resident mode
	    FFFCh if in Automatic mode
	    other value if not resident
---------------------------------------------
INT 16 - pcANYWHERE - CANCEL SESSION
	AH = 7Ah
---------------------------------------------
INT 16 - pcANYWHERE - SUSPEND
	AX = 7B00h
SeeAlso: AX=7B01h
---------------------------------------------
INT 16 - pcANYWHERE - RESUME
	AX = 7B01h
SeeAlso: AX=7B00h
---------------------------------------------
INT 16 - pcANYWHERE - GET PORT CONFIGURATION
	AH = 7Ch
Return: AH = port number
	AL = baud rate
	    00h = 50 baud
	    01h = 75 baud
	    02h = 110 baud
	    03h = 134.5 baud
	    04h = 150 baud
	    05h = 300 baud
	    06h = 600 baud
	    07h = 1200 baud
	    08h = 1800 baud
	    09h = 2000 baud
	    0Ah = 2400 baud
	    0Bh = 4800 baud
	    0Ch = 7200 baud
	    0Dh = 9600 baud
	    0Eh = 19200 baud
---------------------------------------------
INT 16 - pcANYWHERE - GET/SET TERMINAL PARAMETERS
	AH = 7Dh
	AL = subfunction
	    00h set terminal parameters
	    01h get terminal parameters
	    02h get configuration header and terminal parameters
	DS:CX -> terminal parameter block
---------------------------------------------
INT 16 - pcANYWHERE - COMMUNICATIONS I/O THROUGH PORT
	AH = 7Eh
	AL = subfunction
	    01h port input status
		Return AX = 0 if no characer ready,
		       AX = 1 if character ready
	    02h port input character
		Return AL = received character
	    03h port output character in CX
	    11h hang up phone
---------------------------------------------
INT 16 - pcANYWHERE - SET KEYBOARD/SCREEN MODE
	AH = 7Fh
	AL = subfunction
	    00h enable remote keyboard only
	    01h enable host keyboard only
	    02h enable both keyboards
	    08h display top 24 lines
	    09h display bottom 24 lines
	    10h Hayes modem
	    11h other modem
	    12h direct connect
---------------------------------------------
INT 16 - MAKEY.COM - INSTALLATION CHECK
	AH = 80h
Return: AX = 1954h if installed
Note:	MAKEY is a utility by System Enhancement Associates
---------------------------------------------
INT 16 - PTxxx.COM - (xxx=CGA,EGA,VGA,HER...) CALL GATE FOR GRAPHICS
	AH = AAh
	Various registers set up by high level language.
Return: Graphics performed
Note:	PT stands for Paint Tools which is a graphics library for Turbo Pascal,
	  Modula 2 and others from DataBiten in Sweden. The library is
	  installed as a memory resident driver.
---------------------------------------------
INT 16 - Compaq 386 - SET CPU SPEED
	AH = F0h
	AL = speed
	    00h equivalent to 6 MHz 80286 (COMMON)
	    01h equivalent to 8 MHz 80286 (FAST)
	    02h full 16 MHz (HIGH)
	    03h toggles between 8 MHz-equivalent and speed set by system board
		switch (AUTO or HIGH)
	    08h full 16 MHz except 8 MHz-equivalent during floppy disk access
	    09h specify speed directly
		CX = speed value, 1 (slowest) to 50 (full), 3 ~= 8088
SeeAlso: AH=F1h
---------------------------------------------
INT 16 - PE.EXE - INSTALLATION CHECK
	AX = F0F0h
Return: AX = 0F0Fh if installed
	    ES:DI -> data block
Note:	PE is a TSR screen grabber included with ASMED, an integrated
	  environment for TASM and MASM

Format of data block:
Offset	Size	Description
 00h	DWORD	pointer to program tag (counted ASCII string)
 04h	WORD	???
 06h	DWORD	pointer to ???
 0Ah  4 BYTEs	???
 0Eh	DWORD	???
	more???
---------------------------------------------
INT 16 - Compaq 386 - READ CURRENT CPU SPEED
	AH = F1h
Return:	AL = speed code (see AH=F0h)
	     if AL = 09h, CX = speed code
SeeAlso: AH=F0h
---------------------------------------------
INT 16 - Compaq 386 - DETERMINE ATTACHED KEYBOARD TYPE
	AH = F2h
Return: AL = type
	    00h if 11-bit AT keyboard is in use
	    01h if 9-bit PC keyboard is in use 
---------------------------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFADh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFAEh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFAFh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFB0h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFB1h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - ???
	AX = FFB2h
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - ???
	AX = FFB3h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - ???
	AX = FFB4h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - GET/SET ???
	AX = FFB5h
	BX = ??? (000Fh to 0019h)
	DX = 0000h get, nonzero = set
	ES:DI -> 16-byte buffer with new values or to receive old values
---------------------------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - ???
	AX = FFB6h
	???
Return: AH = ???
	AL = ???
---------------------------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - SET ???
	AX = FFB7h
	DS:SI -> 10-byte buffer with ???
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFB8h
	BH = subfunction
	    00h get
		Return: BL = old value of ???
	    nonzero set
		BL = new value for ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFB9h
	???
Return: AX = ???
	CX = ???
	DS:SI -> ???
	ES:DI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFBAh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFBBh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - RESTORE ORIGINAL SCREEN???
	AX = FFBCh
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - POP DOWN???
	AX = FFBDh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFBEh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFBFh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC0h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC1h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC2h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC3h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC4h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - CHECK WHETHER DESKTOP LOADED RESIDENT
	AX = FFC5h
Return: BL = nonzero if loaded resident
	   = 00h if nonresident
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - SET ???
	AX = FFC6h
	BL = new value for ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC7h
	???
Return: ???
Note:	screen swapping???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - GET ???
	AX = FFC8h
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC9h
	SI = ???
	CX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFCAh
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFCBh
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - DISPLAY ASCIZ STRING
	AX = FFCCh
	DS:SI -> ASCIZ string
Return: AX = ???
	CX = ???
	ES:DI -> address past last character displayed
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFCDh
	DS:DX -> ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - SET ??? DELAYS
	AX = FFCEh
	CX = ???
Return: nothing???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFCFh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD0h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD1h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD2h
	BX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD3h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - CREATE/OPEN/DELETE FILE
	AX = FFD4h
	BH = 3Ch create file
		CX = file attributes
	     3Dh open file
	     41h delete file
	BL = access mode
	     00h read only
	     01h write only
	     02h read/write
	DS:SI -> ASCIZ filename
Return: BX = file handle
	    0000h on error
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD5h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD6h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD7h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - SAFE CREATE FILE
	AX = FFD8h
	DS:BX -> ASCIZ filename
Return: BX = file handle
	    0000h on error
Note:	pops up confirmation menu if file already exists
	only available when popped up???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD9h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFDAh
	DS:SI -> ???
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFDBh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - UNHOOK
	AX = FFDCh
Return: interrupt vectors 09h, 16h, 1Ch, and 21h restored to original values
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - INSTALLATION CHECK
	AX = FFDDh
	BX = 0000h
Return: CX = 5555h 
	DX = 5555h if PCShell installed in resident mode
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - REQUEST POP-UP
	AX = FFDDh
	BX = 0001h
SeeAlso: AX=FFDDh/BX=0003h
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - GET ???
	AX = FFDDh
	BX = 0002h
Return: AL = 
	    00h ???
	    01h ???
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - REQUEST POP-UP
	AX = FFDDh
	BX = 0003h
SeeAlso: AX=FFDDh/BX=0001h
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0004h
	???
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0005h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0006h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0007h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0008h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v6.0 PCShell API - GET ???
	AX = FFDDh
	BX = 0009h
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFDEh
	DS:DX -> ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFDFh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE0h
	CX = ???
	DX = ???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - BEEP
	AX = FFE1h
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE2h
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE3h
	BL = ???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE4h
	DX = segment of ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE5h
	DS:SI -> wildcard filename???
	DX = ???
Return: AX = ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE6h
	DS:SI -> ???
Return: AX = ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE7h
	BX = segment of ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - DISPLAY NUMBER
	AX = FFE8h
	CX = number
	DH = attribute
	DS:SI -> destination for ASCII number
Return: DS:SI buffer filled in with alternating characters and attributes
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE9h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - DISPLAY COUNTED STRING
	AX = FFEAh
	DS:SI -> counted string (count byte followed by string)
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFEBh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFECh
	DS:SI -> FAR routine to ???
	BX = ???
Return: AX = ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFEDh
Return: AX = ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFEEh
	SI = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - INSTALLATION CHECK
	AX = FFEFh
	CX = 0000h
Return: CX = ABCDh if PC Tools DESKTOP.EXE installed
	    BX = segment of resident portion
	    AX = ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF0h
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ALTERNATE INSTALLATION CHECK
	AX = FFF1h
	BX = 0000h  leave ??? flag as is
	    nonzero set ??? flag
Return: CX = 5555h if installed
	DX = 5555h
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF2h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF3h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF4h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - GET SCREEN ATTRIBUTE ARRAY
	AX = FFF5h
Return: ES:BX -> array of screen attributes 
		00h	BYTE  normal characters on desktop menu
		01h	BYTE  highlighted characters on desktop menu
		02h	BYTE 
		03h	BYTE
		etc.
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF6h
	DS = ???
	BX = ???
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF7h
	SI = ???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF8h
	DS:SI -> ???
	BX = ???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF9h
	ES:BX -> FAR routine to ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFFAh
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFFBh
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - GET ???
	AX = FFFCh
Return: ES:BX = ???
	DS:DX = original INT 9 vector
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFFDh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - SHOW MOUSE CURSOR
	AX = FFFEh
SeeAlso: AX=FFFFh, INT 33/AX=0001h
---------------------------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - HIDE MOUSE CURSOR
	AX = FFFFh
SeeAlso: AX=FFFEh, INT 33/AX=0002h
---------------------------------------------
INT 17 - PRINTER - OUTPUT CHARACTER
	AH = 00h
	AL = character
	DX = printer port (0-3)
Return: AH = status bits
	    0 = time out
	    1 = unused
	    2 = unused
	    3 = I/O error
	    4 = selected
	    5 = out of paper
	    6 = acknowledge
	    7 = not busy
---------------------------------------------
INT 17 - PRINTER - INITIALIZE
	AH = 01h
	DX = printer port (0-3)
Return: AH = status (see AH=00h)
---------------------------------------------
INT 17 - PRINTER - GET STATUS
	AH = 02h
	DX = printer port (0-3)
Return: AH = status (see AH=00h)
---------------------------------------------
INT 17 - INSET - INSTALLATION CHECK
	AH = 02h
	DX = 0000h
	CX = 07C3h (1987d)
Return: CX = 07C2h (1986d) if installed
Note:	INSET is a text/graphics integration program
---------------------------------------------
INT 17 - FLASHUP.COM - INSTALLATION CHECK
	AH = 60h
Return: AL = 60h
	DX = CS of resident code
Note:	FLASHUP.COM is part of Flash-Up Windows by The Software Bottling Co.
	FLASHUP also hooks INT 10 and received commands via INT 10/AH=09h,0Ah
	  consisting of an 80h followed by the actual command
---------------------------------------------
INT 17 - SPEEDSCR.COM - INSTALLATION CHECK
	AH = 61h
Return: AL = 61h
	DX = CS of resident code
Note:	SPEEDSCR.COM is by The Software Bottling Co.
---------------------------------------------
INT 17 - INSET - EXECUTE COMMAND STRING
	AX = CD00h
	DS:DX -> ASCIZ command string (max 80 bytes)
Return: CX = 07C2h (1986d)
Note:	user interface menus pop up after last command, unless that command
	exits INSET
---------------------------------------------
INT 17 - INSET - GET IMAGE SIZE
	AX = CD01h
	DS:DX -> ASCIZ name of image file
Return: AX = height in 1/720th inch
	BX = width in 1/720th inch
	CX = 07C2h (1986d)
---------------------------------------------
INT 17 - INSET - INITIALIZE
	AX = CD02h
Return: CX = 07C2h (1986d)
Note:	all open files are closed and the printer is reset
SeeAlso: AX=CD04h
---------------------------------------------
INT 17 - INSET - EXECUTE INSET MENU WITHIN OVERRIDE MODE
	AX = CD03h
Return: CX = 07C2h (1986d)
---------------------------------------------
INT 17 - INSET - INITIALIZE LINKED MODE
	AX = CD04h
	ES:DI -> FAR routine for linked mode
Return: CX = 07C2h
Note:	calling sequence for linked-mode routine
	AL = 00h send character in BL to printer
	   = 01h send CX bytes from DS:DX to printer
	   = 02h move print head to horizontal starting position of image
	return code for linked-mode routine:
	AX = 0000h success
	   = 0001h failure
SeeAlso: AX=CD02h,AX=CD08h
---------------------------------------------
INT 17 - INSET - START MERGING IMAGE INTO TEXT
	AX = CD05h
	DS:DX -> ASCIZ name of PIX file
	CX = left margin of text in 1/720th inch
Return: AH = printer type
	    00h page-oriented (multiple images may be placed side-by-side)
	    01h line-oriented (use AX=CD06h for vertical paper movement)
	CX = 07C2h (1986d)
SeeAlso: AX=CD07h
---------------------------------------------
INT 17 - INSET - GRAPHICS LINE FEED
	AX = CD06h
Return: AH = completion status
	    00h image complete
	    01h image incomplete
	CX = 07C2h (1986d)
SeeAlso: AX=CD09h
---------------------------------------------
INT 17 - INSET - FLUSH GRAPHICS FROM MERGE BUFFER
	AX = CD07h
Return: CX = 07C2h
SeeAlso: AX=CD05h
---------------------------------------------
INT 17 - INSET - CANCEL LINK MODE
	AX = CD08h
Return: CX = 07C2h
SeeAlso: AX=CD04h
---------------------------------------------
INT 17 - INSET - ALTER GRAPHICS LINE SPACING
	AX = CD09h
	CX = line spacing in 1/720th inch
Return: CX = 07C2h
Note:	not yet implemented, line spacing is currently fixed at 1/6 inch
SeeAlso: AX=CD06h
---------------------------------------------
INT 17 - INSET - GET SETUP
	AX = CD0Ah
	DS:DX -> buffer for IN.SET data
Return: CX = 07C2h
---------------------------------------------
INT 17 - INSET - START GETTING SCALED IMAGE
	AX = CD0Bh
	DS:SI -> ASCIZ pathname of .PIX file
	BX = number of bitplanes
	CX = number of rows in output bitmap
	DX = number of columns in output bitmap
Return: AX = status
	    0000h OK
	    FFFFh error	
Note:	image is returned in strips by repeated calls to AX=CD0Ch
---------------------------------------------
INT 17 - INSET - GET NEXT IMAGE STRIP
	AX = CD0Ch
Return:	AX = status
	    0000h OK but not complete
	    0001h OK and image complete
	    FFFFh error
	DS:SI -> buffer (max 4K) for bit map strip 
	CX = start row
	DX = number of rows
	BX = offset in bytes between bit planes
Note:	buffer may be overwritten by subsequent calls
SeeAlso: AX=CD0Bh
---------------------------------------------
INT 18 - TRANSFER TO ROM BASIC
   causes transfer to ROM-based BASIC (IBM-PC)
   often reboots a compatible; often has no effect at all
---------------------------------------------
INT 19 - DISK BOOT
   causes reboot of disk system (no memory test performed, interrupt vectors
   preserved).	Because interrupt vectors are preserved, this interrupt usually
   causes a system hang if any TSRs have hooked vectors from 00h through 1Ch,
   particularly INT 08.

   Usually, the BIOS will try to read sector 1, head 0, track 0 from drive A:
   to 0000h:7C00h.  If this fails, and a hard disk is installed, the BIOS will
   read sector 1, head 0, track 0 of the first hard disk.  This sector should
   contain a master bootstrap loader and a partition table.  After loading the
   master boot sector at 0000h:7C00h, the master bootstrap loader is given
   control.  It will scan the partition table for an active partition, and will
   then load the operating system's bootstrap loader (contained in the first
   sector of the active partition) and give it control.

Notes:	to accomplish a warm boot equivalent to Ctrl-Alt-Del, store 1234h in
	  0040h:0072h and jump to FFFFh:0000h.	For a cold boot equivalent to
	  a reset, store 0000h at 0040h:0072h before jumping.
	VDISK.SYS hooks this interrupt to allow applications to find out how
	  much extended memory has been used by VDISKs (the three bytes at
	  offset 2Ch in the INT 19 handler's segment contain the linear address
	  of the first free extended memory).

Format of hard disk master boot sector:
Offset	Size	Description
 00h 446 BYTEs	Master bootstrap loader code
1BEh 16 BYTEs	partition record for partition 1 (see below)
1CEh 16 BYTEs	partition record for partition 2
1DEh 16 BYTEs	partition record for partition 3
1EEh 16 BYTEs	partition record for partition 4
1FEh	WORD	signature, AA55h indicates valid boot block

Format of partition record:
Offset	Size	Description
 00h	BYTE	boot indicator (80h = active partition)
 01h	BYTE	partition start head
 02h	BYTE	partition start sector (bits 0-5)
 03h	BYTE	partition start track (bits 8,9 in bits 6,7 of sector)
 04h	BYTE	operating system indicator (see below)
 05h	BYTE	partition end head
 06h	BYTE	partition end sector (bits 0-5)
 07h	BYTE	partition end track (bits 8,9 in bits 6,7 of sector)
 08h	DWORD	sectors preceding partition
 0Ch	DWORD	length of partition in sectors

Values for operating system indicator:
 00h empty
 01h DOS 12-bit FAT
 02h XENIX file system
 03h XENIX /usr file system (obsolete???)
 04h DOS 16-bit FAT
 05h DOS 3.3+ extended partition
 06h DOS Large File System
 07h QNX
 08h AIX bootable partition
 09h AIX data partition
 51h Disk Manager
 52h CP/M ???
 56h GB ???
 61h SpeedStor
 63h SysV/386
 64h Novell NetWare
 75h PC/IX
 80h Minix v1.3 and below
 81h Minix v1.5+
 DBh CP/M
 E1h SpeedStor 12-bit FAT extended partition
 E4h SpeedStor 16-bit FAT extended partition
 FFh BBT ???
---------------------------------------------
INT 1A - CLOCK - GET TIME OF DAY
	AH = 00h
Return: CX:DX = clock count
	AL = 00h if clock was read or written (via AH=0,1) since the previous
		 midnight
	     Otherwise, AL > 0
Note:	IBM and many clone BIOSes set the flag for AL rather than incrementing
	  it, leading to loss of a day if two consecutive midnights pass
	  without a request for the time (e.g. if the system is on but idle)
SeeAlso: AH=02h,INT 21/AH=2Ch
---------------------------------------------
INT 1A - CLOCK - SET TIME OF DAY
	AH = 01h
	CX:DX = clock count
Return: time of day set
SeeAlso: AH=03h,INT 21/AH=2Dh
---------------------------------------------
INT 1A - CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 02h
Return: CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
SeeAlso: AH=00h
---------------------------------------------
INT 1A - CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 03h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
	DL = 01h if daylight savings, 00h if standard time
Return: CMOS clock set
SeeAlso: AH=01h
---------------------------------------------
INT 1A - CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 04h
Return: DL = day in BCD
	DH = month in BCD
	CL = year in BCD
	CH = century (19h or 20h)
SeeAlso: AH=05h,INT 21/AH=2Ah
---------------------------------------------
INT 1A - CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 05h
	DL = day in BCD
	DH = month in BCD
	CL = year in BCD
	CH = century (19h or 20h)
Return: CMOS clock set
SeeAlso: AH=04h,INT 21/AH=2Bh
---------------------------------------------
INT 1A - CLOCK - SET ALARM (AT,XT286,CONV,PS)
	AH = 06h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
Return: CF set if alarm already set or clock inoperable
	INT 4Ah will be called when alarm goes off, every 24 hours until reset
SeeAlso: AH=07h,INT 4A
---------------------------------------------
INT 1A - CLOCK - RESET ALARM (AT,XT286,CONV,PS)
	AH = 07h
Return: alarm disabled
SeeAlso: AH=06h
---------------------------------------------
INT 1A - CLOCK - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE)
	AH = 08h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
---------------------------------------------
INT 1A - CLOCK - READ RTC ALARM TIME AND STATUS (CONV,PS30)
	AH = 09h
Return: CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
	DL = alarm status
	    00h alarm not enabled
	    01h alarm enabled but will not power up system
	    02h alarm will power up system
---------------------------------------------
INT 1A - CLOCK - READ SYSTEM-TIMER DAY COUNTER (XT2,PS)
	AH = 0Ah
Return: CF set on error
	CX = count of days since Jan 1,1980
SeeAlso: AH=0Bh
---------------------------------------------
INT 1A - CLOCK - SET SYSTEM-TIMER DAY COUNTER (XT2,PS)
	AH = 0Bh
	CX = count of days since Jan 1,1980
Return: CF set on error
	CF clear if successful
SeeAlso: AH=0Ah
---------------------------------------------
INT 1A - WORD PERFECT 5.0 Third Party Interface - INSTALLATION CHECK
	AX = 3601h
Return: DS:SI = routine to monitor keyboard input, immediately preceded by the
		ASCIZ string "WPCORP\0"
Notes:	WordPerfect 5.0 will call this interrupt at start up to determine if a
	  third party product wants to interface with it.  The third party
	  product must intercept this interrupt and return the address of a
	  keyboard monitor routine.
	Before checking for keyboard input, and after every key entered by the
	  user, Word Perfect will call the routine whose address was provided
	  in DS:SI with the following parameters:
		Entry:	AX = key code or 0
			BX = WordPerfect state flag
		Exit:	AX = 0 or key code
			BX = 0 or segment address of buffer with key codes
	See the "WordPerfect 5.0 Developer's Toolkit" for further information.
---------------------------------------------
INT 1A - PCjr - SET UP SOUND MULTIPLEXOR
	AH = 80h
	AL = 00h source is 8253 channel 2
	     01h source is cassette input
	     02h source is I/O channel "Audio IN"
	     03h source is sound generator chip
---------------------------------------------
INT 1A - AT&T 6300 - READ TIME AND DATE
	AH = FEh
Return: BX = day count (0 = Jan 1, 1984)
	CH = hour
	CL = minute
	DH = second
	DL = hundredths
SeeAlso: AH=FFh,INT 21/AH=2Ah,2Ch
---------------------------------------------
INT 1A - AT&T 6300 - SET TIME AND DATE
	AH = FFh
	BX = day count (0 = Jan 1, 1984)
	CH = hour
	CL = minute
	DH = second
	DL = hundredths
Return: ???
SeeAlso: AH=FEh,INT 21/AH=2Bh,2Dh
---------------------------------------------
INT 1B - CTRL-BREAK KEY
   This interrupt is called when the keyboard scanner of the IBM
   machines detects CTRL and BREAK pressed at the same time. It
   normally points to a short routine in DOS which sets the
   Ctrl-C flag, thus invoking INT 23h the next time DOS checks
   for Ctrl-C.
SeeAlso: INT 23
---------------------------------------------
INT 1C - CLOCK TICK
   This interrupt is called (in the IBM) at the end of each time-update
   operation by the time-of-day routines.
Notes:	points to an IRET by default
	preferred interrupt to chain when a program needs to be invoked
	  regularly
SeeAlso: INT 08
---------------------------------------------
INT 1D - (NOT a vector!) 6845 VIDEO INIT TABLES

Format of video init tables:
Offset	Size	Description
 00h 16 BYTEs	table for modes 0 and 1		\
 10h 16 BYTEs	table for modes 2 and 3		 \  each table contains values
 20h 16 BYTEs	table for modes 4, 5, and 6	 /  for first sixteen 6485 regs
 30h 16 BYTEs	table for mode 7		/
 40h	WORD	size of video RAM for modes 0 and 1
 42h	WORD	size of video RAM for modes 2 and 3
 44h	WORD	size of video RAM for modes 4 and 5
 46h	WORD	size of video RAM for modes 6 and 7
 48h  8 BYTEs	number of colums in each of modes 0 through 7
 50h  8 BYTEs	video controller mode byte for each mode
---------------------------------------------
INT 1E - (NOT a vector!) DISKETTE PARAMS (BASE TABLE)
	default parameters at F000h:EFC7h in PC and most compatibles
SeeAlso: INT 41

Format of diskette parameters:
Offset	Size	Description
 00h	BYTE	4-bit step rate & 4-bit head unload times
 01h	BYTE	7-bit head load time & 1-bit DMA flag
 02h	BYTE	motor off time in clock ticks (36 to 38 typical)
 03h	BYTE	sector size in bytes (0->128, 1->256, 2->512, 3->1024)
 04h	BYTE	last sector number (8 or 9 typical)
 05h	BYTE	inter-sector gap size on read/write (42 typical)
 06h	BYTE	data transfer length (255 typical)
 07h	BYTE	inter-sector gap size on format (80 typical)
 08h	BYTE	sector fill on format (F6h typical)
 09h	BYTE	head-settle time ms (typical 25, 1.10->0, 2.10->15, 3.10->1)
 0Ah	BYTE	motor start-up time (1/8 secs) (typical 4, 2.10->2)
---------------------------------------------
INT 1F - (NOT a vector!) GRAPHICS SET 2
	pointer to bitmaps for high 128 chars (eight bytes per character)
---------------------------------------------
Interrupt List, part 2 of 4
This compilation is Copyright (c) 1989,1990 Ralf Brown
---------------------------------------------
INT 20 - Minix - SEND/RECEIVE MESSAGE
	AX = process ID of other process
	BX -> message
	CX = 1 send
	     2 receive
	     3 send&receive
Note:	the message contains the system call number (numbered as in V7 
	  Unix(tm)) and the call parameters
---------------------------------------------
INT 20 - DOS - PROGRAM TERMINATION
returns to DOS--identical to INT 21/AH=00h
Note:	IBM and Microsoft recommend using INT 21/AH=4Ch for DOS 2+
SeeAlso: INT 21/AH=00h, INT 21/AH=4Ch
---------------------------------------------
INT 21 - DOS - PROGRAM TERMINATION
	AH = 00h
Return: never
Note:	execution continues at address pointed to by INT 22 after DOS performs
	  whatever cleanup it needs to do
SeeAlso: AH=4Ch,INT 20,INT 22
---------------------------------------------
INT 21 - DOS - KEYBOARD INPUT
	AH = 01h
Return: AL = character read
Note:	^C/^Break are checked, and INT 23h executed if read
	character is echoed to standard output
SeeAlso: AH=06h,AH=07h,AH=08h,AH=0Ah
---------------------------------------------
INT 21 - DOS - DISPLAY OUTPUT
	AH = 02h
	DL = character to send to standard output
Note:	^C/^Break are checked, and INT 23h executed if pressed
SeeAlso: AH=06h,AH=09h
---------------------------------------------
INT 21 - DOS - AUX INPUT
	AH = 03h
Return: AL = character read
SeeAlso: AH=04h,INT 14/AH=02h
---------------------------------------------
INT 21 - DOS - AUX OUTPUT
	AH = 04h
	DL = character to send
SeeAlso: AH=03h,INT 14/AH=01h
---------------------------------------------
INT 21 - DOS - PRINTER OUTPUT
	AH = 05h
	DL = character to print
SeeAlso: INT 17/AH=00h
---------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
	AH = 06h
	DL = character <> FFh
SeeAlso: AH=02h,AH=09h
---------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER INPUT
	AH = 06h
	DL = FFh
Return: ZF set	 = no character
	ZF clear = character recieved
		  AL = character
Notes:	character is echoed to STDOUT if received.
	^C/^Break are NOT checked
SeeAlso: AH=0Bh
---------------------------------------------
INT 21 - DOS - DIRECT STDIN INPUT, NO ECHO
	AH = 07h
Note:	same as function 06h for input but char not echoed
SeeAlso: AH=01h,AH=06h,AH=08h,AH=0Ah
---------------------------------------------
INT 21 - DOS - KEYBOARD INPUT, NO ECHO
	AH = 08h
Return: AL = character
Note:	same as function 07h, but ^C/^Break are checked
SeeAlso: AH=01h,AH=06h,AH=07h,AH=0Ah,AH=64h
---------------------------------------------
INT 21 - DOS - PRINT STRING
	AH = 09h
	DS:DX -> string terminated by "$"
Note:	^C/^Break checked, and INT 23h called if pressed
SeeAlso: AH=02h,AH=06h"OUTPUT"
---------------------------------------------
INT 21 - DOS - BUFFERED KEYBOARD INPUT
	AH = 0Ah
	DS:DX -> buffer
Notes:	first byte of buffer must contain maximum length
	on entry, second byte contains actual length of previous line which may
	  be recalled with the DOS line-editing commands
	on return the second byte contains actual length, third and
	  subsequent bytes contain the input line
---------------------------------------------
INT 21 - DOS - CHECK STANDARD INPUT STATUS
	AH = 0Bh
Return: AL = FFh if character available
	     00h if no character
Note:	^C/^Break checked, and INT 23h called if pressed
SeeAlso: AH=06h"INPUT"
---------------------------------------------
INT 21 - DOS - CLEAR KEYBOARD BUFFER
	AH = 0Ch
	AL must be 01h, 06h, 07h, 08h, or 0Ah.
Notes:	flushes all typeahead input, then executes function specified by AL
	  (effectively moving it to AH and repeating the INT 21 call).
	if AL contains a value not in the list above, the keyboard buffer is
	  flushed and no other action is taken.
SeeAlso: AH=01h,AH=06h"INPUT",AH=07h,AH=08h,AH=0Ah
---------------------------------------------
INT 21 - DOS - DISK RESET
	AH = 0Dh
Note:	flushes all disk buffers
SeeAlso: INT 13/AH=00h, INT 2F/AX=1120h
---------------------------------------------
INT 21 - DOS - SELECT DISK
	AH = 0Eh
	DL = new default drive number (0 = A, 1 = B, etc.)
Return: AL = number of logical drives
Notes:	under Novell NetWare, the return value is always 32, the number of
	  drives that NetWare supports
	under DOS 3+, the return value is the greatest of 5, the value of
	  LASTDRIVE= in CONFIG.SYS, and the number of drives actually present
	otherwise, the return value is the highest drive actually present
SeeAlso: AH=19h, AH=DBh
---------------------------------------------
INT 21 - DOS - OPEN DISK FILE
	AH = 0Fh
	DS:DX -> FCB (see below)
Return: AL = 00h file found
	     FFh file not found
Note:	(DOS 3+) file opened in compatibility mode
SeeAlso: AH=3Dh

Format of File Control Block:
Offset	Size	Description
 -7	BYTE	extended FCB if FFh
 -6   5 BYTEs	reserved
 -1	BYTE	file attribute if extended FCB
 00h	BYTE	drive number (0 = default, 1 = A, etc)
 01h  8 BYTEs	blank-padded file name 
 09h  3 BYTEs	blank-padded file extension
 0Ch	WORD	current block number
 0Eh	WORD	logical record size
 10h	DWORD	file size
 14h	WORD	date of last write (see AX=5700h)
 16h	WORD	time of last write (see AX=5700h)
 18h  8 BYTEs	reserved (see below)
 20h	BYTE	record within current block
 21h	DWORD	random access record number (if record size is > 64 bytes, high
		byte is omitted)
Note:	to use an extended FCB, you must specify the address of the FFh flag at
	  offset -7, rather than the address of the drive number field

Format of reserved field for DOS 1.x:
Offset	Size	Description
 18h	BYTE	bit 7: set if logical device
		bit 6: set if open???
		bits 5-0: disk number or logical device ID
 19h	WORD	absolute current cluster number
 1Bh	WORD	starting cluster number
 1Dh	WORD	relative current cluster number
 1Fh	BYTE	unused???

Format of reserved field for DOS 2.x:
Offset	Size	Description
 18h	BYTE	bit 7: set if logical device
		bit 6: set if open???
		bits 5-0: ???
 19h	WORD	starting cluster number
 1Bh	WORD	???
 1Dh	BYTE	???
 1Eh	BYTE	???
 1Fh	BYTE	???

Format of reserved field for DOS 3.x:
Offset	Size	Description
 18h	BYTE	number of system file table entry for file
 19h	BYTE	attributes
		bits 7,6: 00 = SHARE.EXE not loaded, disk file
			  01 = SHARE.EXE not loaded, character device
			  10 = SHARE.EXE loaded, remote file
			  11 = SHARE.EXE loaded, local file
		bits 5-0: low six bits of device attribute word
---SHARE.EXE loaded, local file---
 1Ah	WORD	starting cluster of file
 1Ch	WORD	offset within SHARE of sharing record (see AH=52h)
 1Eh	BYTE	file attribute
 1Fh	BYTE	???
---SHARE.EXE loaded, remote file---
 1Ah	WORD	number of sector containing directory entry
 1Ch	WORD	relative cluster within file of last cluster accessed
 1Eh	BYTE	absolute cluster number of last cluster accessed
 1Fh	BYTE	???
---SHARE.EXE not loaded---
 1Ah	BYTE	(low byte of device attribute word AND 0Ch) OR open mode
 1Bh	WORD	starting cluster of file
 1Dh	WORD	number of sector containing directory entry
 1Fh	BYTE	number of directory entry within sector
Note:	if FCB opened on character device, DWORD at 1Ah is set to the address
	  of the device driver header, then the BYTE at 1Ah is overwritten.
---------------------------------------------
INT 21 - DOS - CLOSE DISK FILE
	AH = 10h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = 00h directory update successful
	     FFh file not found in directory
SeeAlso: AH=3Eh
---------------------------------------------
INT 21 - DOS - SEARCH FIRST USING FCB
	AH = 11h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h file found
		[DTA] = unopened FCB for file that was found
	    FFh file not found
SeeAlso: AH=1Ah,AH=4Eh, INT 2F/AX=111Bh
---------------------------------------------
INT 21 - DOS - SEARCH NEXT USING FCB
	AH = 12h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h file found
		[DTA] = unopened FCB for file that was found
	    FFh file not found
SeeAlso: AH=1Ah,AH=4Fh, INT 2F/AX=111Ch
---------------------------------------------
INT 21 - DOS - DELETE FILE via FCB
	AH = 13h
	DS:DX -> FCB (see AH=0Fh) with filename field filled with template for
		 deletion ('?' wildcard allowed, but not '*')
Return: AL = status
	    00h file found
	    FFh file not found
Note:	deletes everything in the current directory (including subdirectories)
	  and sets the first byte of the name to 00h (entry never used)
	  instead of E5h if called on an extended FCB with filename
	  '???????????' and bits 0-4 of the attribute set (bits 1 and 2 for
	  DOS 1).  This may have originally been an optimization to minimize
	  directory searching after a mass deletion, but can corrupt the
	  filesystem under DOS 2+ because subdirectories are removed without
	  deleting the files they contain.
SeeAlso: AH=41h, INT 2F/AX=1113h
---------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK FILE READ
	AH = 14h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful read
	    01h end of file
	    02h data transfer area too small
	    03h partial record, EOF
SeeAlso: AH=3Fh, INT 2F/AX=1108h
---------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK RECORD WRITE
	AH = 15h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful write
	    01h disk full
	    02h data transfer area too small
SeeAlso: AH=40h, INT 2F/AX=1109h
---------------------------------------------
INT 21 - DOS - CREATE A DISK FILE
	AH = 16h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful creation
	    FFh directory full
Note:	if file already exists, it is truncated to zero length
SeeAlso: AH=3Ch
---------------------------------------------
INT 21 - DOS - RENAME FILE via FCB
	AH = 17h
	DS:DX -> FCB (see AH=0Fh)
	FCB contains new name starting at byte 17h.
Return: AL = status
	    00h file found
	    FFh file not found
SeeAlso: AH=56h, INT 2F/AX=1111h
---------------------------------------------
INT 21 - DOS internal - UNUSED
	AH = 18h
Return: AL = 00h
---------------------------------------------
INT 21 - DOS - GET DEFAULT DISK NUMBER
	AH = 19h
Return: AL = current drive number (letter - 'A')
SeeAlo: AH=0Eh
---------------------------------------------
INT 21 - DOS - SET DISK TRANSFER AREA ADDRESS
	AH = 1Ah
	DS:DX -> disk transfer buffer
SeeAlso: AH=2Fh
---------------------------------------------
INT 21 - DOS - GET ALLOCATION TABLE INFORMATION FOR DEFAULT DRIVE
	AH = 1Bh
Return: DS:BX -> FAT ID byte for default drive
	DX = number of allocation units on disk
	AL = number of sectors per allocation unit (cluster)
	CX = number of bytes per sector
Note:	under DOS 1.x, DS:BX points at an actual copy of the FAT
SeeAlso: AH=1Ch,AH=36h
---------------------------------------------
INT 21 - DOS - GET ALLOCATION TABLE INFORMATION FOR SPECIFIC DRIVE
	AH = 1Ch
	DL = drive number to check (0=default, 1=A, etc)
Return: DS:BX -> FAT ID byte for specified drive
	DX = number of allocation units on disk
	AL = number of sectors per allocation unit (cluster)
	CX = number of bytes per sector
Note:	under DOS 1.x, DS:BX points at an actual copy of the FAT
SeeAlso: AH=1Bh,AH=36h
---------------------------------------------
INT 21 - DOS internal - UNUSED
	AH = 1Dh
Return: AL = 00h
---------------------------------------------
INT 21 - DOS internal - UNUSED
	AH = 1Eh
Return: AL = 00h
---------------------------------------------
INT 21 - DOS internal - GET DEFAULT DRIVE PARAMETER BLOCK
	AH = 1Fh
Return: AL = 00h No Error
	     FFh Error
	DS:BX -> drive parameter block (see below for DOS 1.x, AH=32h others)
Note:	for DOS 2+, this just invokes function 32h with DL = 00h
SeeAlso: AH=32h

Format of Eagle MSDOS 1.25 drive parameter block:
Offset	Size	Description
 00h	BYTE	entry number
 01h	BYTE	physical drive number
 02h	WORD	bytes per sector
 04h	BYTE	number of sectors per cluster - 1
 05h	BYTE	???
 06h	WORD	starting sector number of first FAT
 08h	BYTE	number of copies of FAT
 09h	WORD	number of directory entries
 0Bh	WORD	number of first data sector
 0Dh	WORD	number of clusters on disk
 0Fh	BYTE	sectors per FAT
 10h	WORD	starting sector of directory
 12h	WORD	address of allocation table
---------------------------------------------
INT 21 - DOS internal - UNUSED
	AH = 20h
Return: AL = 00h
---------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD READ
	AH = 21h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful read
	    01h end of file
	    02h data transfer area too small
	    03h partial record, EOF
SeeAlso: AH=3Fh
---------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD WRITE
	AH = 22h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful write
	    01h disk full
	    02h data transfer area too small
SeeAlso: AH=40h
---------------------------------------------
INT 21 - DOS - GET FILE SIZE
	AH = 23h
	DS:DX -> unopened FCB (see AH=0Fh) with filename and record size
		 fields initialized
Return: AL = status
	    00h file found
	    FFh file not found
Note:	FCB's random-record field set to number of records (rounded up)
SeeAlso: AH=42h
---------------------------------------------
INT 21 - DOS - SET RANDOM RECORD FIELD
	AH = 24h
	DS:DX -> open FCB (see AH=0Fh)
Return: Random Record Field of FCB is set to be same as Current Block
	and Current Record.
SeeAlso: AH=42h
---------------------------------------------
INT 21 - DOS - SET INTERRUPT VECTOR
	AH = 25h
	AL = interrupt number
	DS:DX = new vector to be used for specified interrupt
SeeAlso: AH=35h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - RESET 386/DOS-EXTENDER DATA STRUCTURES 
	AX = 2501h
Return: CF clear
Note:	Phar Lap uses INT 21/AH=25h as the entry point for all 386/DOS-Extender
	  system calls.  Only available when directly using 386/DOS-Extender,
	  or when using a product that was created using 386-DOS/Extender
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET PROTECTED-MODE INTERRUPT VECTOR
	AX = 2502h
	CL = interrupt number
Return: ES:EBX -> 48-bit address of protected-mode interrupt handler
	CF clear
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET REAL-MODE INTERRUPT VECTOR
	AX = 2503h
	CL = interrupt number
Return: EBX = 32-bit address of real-mode interrupt handler
	CF clear
SeeAlso: AX=2502h,2504h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - SET PROTECTED-MODE INTERRUPT VECTOR
	AX = 2504h
	CL = interrupt number
	DS:EDX -> 48-bit address of protected-mode interrupt handler
Return: CF clear
SeeAlso: AX=2502h,2505h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - SET REAL-MODE INTERRUPT VECTOR
	AX = 2505h
	CL = interrupt number
	EBX = 32-bit address of real-mode interrupt handler
Return: CF clear
SeeAlso: AX=2503h,2504h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - SET INT TO ALWAYS GAIN CONTRL IN PROT MODE
	AX = 2506h
	CL = interrupt number
	DS:EDX -> 48-bit address of protected-mode interrupt handler
Return: CF clear
Note:	This function modifies both the real-mode low-memory interrupt
	  vector table and the protected-mode Interrupt Descriptor Table (IDT)
	Interrupts occurring in real mode are resignaled in protected mode.
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - SET REAL- & PROTECTED-MODE INT VECTORS
	AX = 2507h
	CL = interrupt number
	DS:EDX -> 48-bit address of protected-mode interrupt handler
	EBX = 32-bit address of real-mode interrupt handler
Return: CF clear
Note:	interrupts are disabled until both vectors have been modified
SeeAlso: AX=2504h,2505h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET SEGMENT LINEAR BASE ADDRESS
	AX = 2508h
	BX = segment selector
Return: CF clear if successful
	    ECX = linear base address of segment
	CF set if invalid segment selector
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - CONVERT LINEAR TO PHYSICAL ADDRESS
	AX = 2509h
	EBX = linear address to convert
Return: CF clear if successful
	    ECX = physical address (carry flag clear)
	CF set if linear address not mapped in page tables
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - MAP PHYSICAL MEMORY AT END OF SEGMENT
	AX = 250Ah
	ES = segment selector in the Local Descriptor Table (LDT) of segment
	     to modify
	EBX = physical base address of memory to map (multiple of 4K)
	ECX = number of physical 4K pages to map
Return: CF clear if successful
	    EAX = 32-bit offset in segment of mapped memory
	CF set on error
	    EAX = error code
		08h insufficient memory to create page tables
		09h invalid segment selector
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET HARDWARE INTERRUPT VECTORS
	AX = 250Ch
Return: CF clear
	AL = base interrupt vector for IRQ0-IRQ7
	AH = base interrupt vector for IRQ8-IRQ15
	BL = interrupt vector for BIOS print screen function
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET REAL-MODE LINK INFORMATION
	AX = 250Dh
Return: CF clear
	EAX = 32-bit address of real-mode 386/DOS-Extender proc that will call
	      through from real mode to a protected-mode routine
	EBX = 32-bit real-mode address of intermode call data buffer
	ECX = size in bytes of intermode call data buffer
	ES:EDX -> protected-mode address of intermode call data buffer
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE
	AX = 250Eh
	EBX = 32-bit address of real-mode procedure to call
	ECX = number of two-byte words to copy from protected-mode stack
	      to real-mode stack
Return: CF clear if successful
	    all segment registers unchanged
	    all general registers contain values set by real-mode procedure
	    all other flags set as they were left by real-mode procedure
	CF set on error
	    EAX = error code
		01h not enough real-mode stack space
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - CONVERT PROTECTED-MODE ADDRESS TO MS-DOS
	AX = 250Fh
	ES:EBX -> 48-bit protected-mode address to convert
	ECX = length of data, in bytes
Return: CF clear if successful
	    ECX = 32-bit MS-DOS address
	CF set on error
	    ECX destroyed
SeeAlso: AX=2510h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE, REGISTERS
	AX = 2510h
	EBX = 32-bit address of real-mode procedure to call
	ECX = number of two-byte words to copy to protected-mode stack to
	      real-mode stack
	DS:EDX -> pointer to parameter block (see below)
Return: CF clear if successful
	    all segment registers unchanged,
	    EDX unchanged
	    all other general registers contain values set by real-mode proc
	    all other flags are set as they were left by real-mode procedure
	    real-mode register values are returned in the parameter block
	CF set on error
	    EAX = error code
		01h not enough real-mode stack space
SeeAlso: AX=250Fh

Format of parameter block:
Offset	Size	Description
 00h	WORD	real-mode DS value
 02h	WORD	real-mode ES value
 04h	WORD	real-mode FS value
 06h	WORD	real-mode GS value
 08h	DWORD	real-mode EAX value
 0Ch	DWORD	real-mode EBX value
 10h	DWORD	real-mode ECX value
 14h	DWORD	real-mode EDX value
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - ISSUE REAL-MODE INTERRUPT
	AX = 2511h
	DS:EDX -> pointer to parameter block (see below)
Return: all segment registers unchanged
	EDX unchanged
	all other registers contain values set by the real-mode int handler
	the flags are set as they were left by the real-mode interrupt handler
	real-mode register values are returned in the parameter block
SeeAlso: AX=2503h,2505h

Format of parameter block:
Offset	Size	Description
 00h	WORD	interrupt number
 02h	WORD	real-mode DS value
 04h	WORD	real-mode ES value
 06h	WORD	real-mode FS value
 08h	WORD	real-mode GS value
 0Ah	DWORD	real-mode EAX value
 0Eh	DWORD	real-mode EDX value
Note: all other real-mode values set from protected-mode registers
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - LOAD PROGRAM FOR DEBUGGING
	AX = 2512h
	DS:EDX -> pointer to ASCIIZ program name
	ES:EBX -> pointer to parameter block (see below)
	ECX = size in bytes of LDT buffer
Return: CF clear if successful
	    EAX = number of segment descriptors in LDT
	CF set on error
	    EAX = error code
		02h file not found or path invalid
		05h access denied
		08h insufficient memory
		0Ah environment invalid
		0Bh invalid file format
		80h LDT too small

Format of parameter block:
Offset	Size	Description
Input:
 00h	DWORD	32-bit offset of environment string
 04h	WORD	segment of environment string
 06h	DWORD	32-bit offset of command-tail string
 0Ah	WORD	segment of command-tail string
 0Ch	DWORD	32-bit offset of LDT buffer (size in ECX)
 10h	WORD	segment of LDT buffer
Output:
 12h	WORD	real-mode paragraph address of PSP (see also AH=26h)
 14h	WORD	real/protected mode flag
		0000h  real mode
		0001h  protected mode
 16h	DWORD	initial EIP value
 1Ah	WORD	initial CS value
 1Ch	DWORD	initial ESP value
 20h	WORD	initial SS value
 22h	WORD	initial DS value
 24h	WORD	initial ES value
 26h	WORD	initial FS value
 28h	WORD	initial GS value
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - ALIAS SEGMENT DESCRIPTOR
	AX = 2513h
	BX = segment selector of descriptor in GDT or LDT
	CL = access-rights byte for alias descriptor
	CH = use-type bit (USE16 or USE32) for alias descriptor
Return: CF clear if successful
	    AX = segment selector for created alias
	CF set on error
	    EAX = error code
		08h insufficient memory (can't grow LDT)
		09h invalid segment selector in BX
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - CHANGE SEGMENT ATTRIBUTES
	AX = 2514h
	BX = segment selector of descriptor in GDT or LDT
	CL = new access-rights byte 
	CH = new use-type bit (USE16 or USE32)
Return: CF clear if successful
	CF set on error
	    EAX = error code
		09h invalid selector in BX
SeeAlso: AX=2515h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET SEGMENT ATTRIBUTES
	AX = 2515h
	BX = segment selector of descriptor in GDT or LDT
Return: CF clear if successful
	    CL = access-rights byte for segment
	    CH = use-type bit (USE16 or USE32)
	ECX<16-31> destroyed
	CF set on error
	    EAX = error code
		09h invalid segment selector in BX
SeeAlso: AX=2514h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - FREE ALL MEMORY OWNED BY LDT
	AX = 2516h
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET INFO ON DOS DATA BUFFER
	AX = 2517h
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - SPECIFY HANDLER FOR MOVED SEGMENTS
	AX = 2518h
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - GET ADDITIONAL MEMORY ERROR INFO
	AX = 2519h
Return: CF clear
	EAX = error code
	    0000h  no error
	    0001h  out of physical memory
	    0002h  out of swap space (unable to grow swap file)
	    0003h  out of LDT entries and unable to grow LDT
	    0004h  unable to change extended memory allocation mark
	    FFFFFFFFh	paging disabled
Note:	VMM is the Virtual Memory Manager option
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - LOCK PAGES IN MEMORY
	AX = 251Ah
	EDX = number of 4k pages to lock
	if BL = 00h
	    ECX = linear address of first page to lock
	if BL = 01h
	    ES:ECX -> pointer to first page to lock
Return: CF clear if successful
	CF set on error
	    EAX = error code
		08h insufficient memory
		09h invalid address range
SeeAlso: AX=251Bh
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - UNLOCK PAGES
	AX = 251Bh
	EDX = number of pages to unlock
	if BL = 00h
	    ECX = linear address of first page to unlock
	if BL = 01h
	    ES:ECX -> pointer to first page to unlock
Return: CF clear if successful
	CF set on error
	    EAX = error code
		09h invalid address range
SeeAlso: AX=251Ah
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - READ PAGE-TABLE ENTRY
	AX = 251Dh
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - WRITE PAGE-TABLE ENTRY
	AX = 251Eh
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - EXHANGE TWO PAGE-TABLE ENTRIES
	AX = 251Fh
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - GET MEMORY STATISTICS
	AX = 2520h
	DS:EDX -> pointer to buffer at least 100 bytes in size (see below)
	BL = 0 (don't reset VM stats), 1 (reset VM stats)
Return: carry flag clear    

Format of VM stats buffer:
Offset	Size	Description
 00h	DWORD	VM status
		0001h VM subsystem is present
		0000h VM not present
 04h	DWORD	"nconvpg" number of conventional memory pages available
 08h	DWORD	"nbimpg" number of Compaq built-in memory pages available
 0Ch	DWORD	"nextpg" total number of extended memory pages
 10h	DWORD	"extlim" extender memory pages limit
 14h	DWORD	"aphyspg" number of physical memory pages allocated to appl
 18h	DWORD	"alockpg" number of locked pages owned by application
 1Ch	DWORD	"sysphyspg" number physical memory pages allocated to system
 20h	DWORD	"nfreepg" number of free physical pages; approx if EMS VCPI
 24h	DWORD	linear address of beginning of application address space
 28h	DWORD	linear address of end of application address space
 2Ch	DWORD	number of seconds since last time VM stats were reset
 30h	DWORD	number of page faults since last time
 34h	DWORD	number of pages written to swap file since last time
 38h	DWORD	number of reclaimed pages (page faults on swapped pages)
 3Ch	DWORD	number of virtual pages allocated to the application
 40h	DWORD	size in pages of swap file
 44h	DWORD	number of system pages allocated with EMS calls
 48h	DWORD	minimum number of conventional memory pages
 4Ch	DWORD	maximum size in bytes to which swap file can be increased
 50h	DWORD	"vmflags" bit 0 = 1 if page fault in progress
 54h 16 BYTEs	reserved for future expansion (set to zero)
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S EXTENDED MEMORY USAGE
	AX = 2521h
	EBX = max 4k pages of physical extended memory which program may use
Return: CF clear if successful
	   EBX = maximum limit in pages
	   ECX = minimum limit in pages
	CF set on error
	    EAX = error code
		08h insufficient memory or -nopage switch used
SeeAlso: AX=2522h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - SPECIFY ALTERNATE PAGE-FAULT HANDLER
	AX = 2522h
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - SPECIFY OUT-OF-SWAP-SPACE HANDLER
	AX = 2523h
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - INSTALL PAGE-REPLACEMENT HANDLERS
	AX = 2524h
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S CONVENTIONAL MEM USAGE
	AX = 2525h
	EBX = limit in 4k pages of physical conventional memory which program 
	      may use
Return: CF clear if successful
	    EBX = maximum limit in pages
	    ECX = minimum limit in pages
	CF set on error
	    EAX = error code
		08h insufficient memory or -nopage switch used
SeeAlso: AX=2521h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET CONFIGURATION INFORMATION
	AX = 2526h
	???
Return: ???
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - ALLOCATE MS-DOS MEMORY BLOCK
	AX = 25C0h
	BX = number of 16-byte paragraphs of MS-DOS memory requested
Return: CF clear if successful
	    AX = real-mode paragraph address of memory
	CF set on error
	    AX = error code
		07h MS-DOS memory control blocks destroyed
		08h insufficient memory
	    BX = size in paragraphs of largest available memory block
SeeAlso: AX=25C1h,25C2h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - RELEASE MS-DOS MEMORY BLOCK
	AX = 25C1h
	CX = real-mode paragraph address of memory block to free
Return: CF clear if successful
	    EAX destroyed
	CF set on error
	    AX = error code
		07h MS-DOS memory control blocks destroyed
		09h invalid memory block address in CX
SeeAlso: AX=25C0h,25C2h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - MODIFY MS-DOS MEMORY BLOCK
	AX = 25C2h
	BX = new requested block size in paragraphs
	CX = real-mode paragraph address of memory block to modify
Return: CF clear if successful
	    EAX destroyed
	CF set on error
	    AX = error code
		07h MS-DOS memory control blocks destroyed
		08h insufficient memory
		09h invalid memory block address in CX
	    BX = size in paragraphs of largest available memory block
SeeAlso: AX=25C0h,25C1h
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - EXECUTE PROGRAM
	AX = 25C3h
	ES:EBX -> pointer to parameter block (see below)
	DS:EDX -> pointer to ASCIIZ program filename
Return: CF clear if successful
	    all registers unchanged
	CF set on error
	    EAX = error code
		01h function code in AL is invalid ???
		02h file not found or path invalid
		05h access denied
		08h insufficient memory to load program
		0Ah environment invalid
		0Bh invalid file format

Format of parameter block:
Offset	Size	Description
 00h	DWORD	32-bit offset of environment string
 04h	WORD	segment selector of environment string
 06h	DWORD	32-bit offset of command-tail string
 0Ah	WORD	segment selector of command-tail string
---------------------------------------------
INT 21 - DOS - CREATE PSP
	AH = 26h
	DX = segment number at which to set up PSP
Return: current PSP is copied to specified segment
Notes:	new PSP is updated with memory size information; INTs 22h, 23h, 24h
	  taken from interrupt vector table
	(DOS 2+) DOS assumes that the caller's CS is the segment of the PSP to
	  copy
SeeAlso: AH=50h,AH=51h,AH=55h,AH=62h,AH=67h

Format of PSP:
Offset	Size	Description
 00h  2 BYTEs	program exit point (INT 20h instruction)
 02h  	WORD	memory size in paragraphs
 04h	BYTE	unused
 05h  5 BYTEs	CP/M entry point (FAR jump to 000C0h)
		BUG: (DOS 2+) PSPs created by INT 21/AH=4Bh point at 000BEh
 06h	WORD	CP/M compatibility--size of first segment for .COM files
 0Ah	DWORD	terminate address (old INT 22h)
 0Eh	DWORD	break address (old INT 23h)
 12h	DWORD	critical error handler (old INT 24h)
 16h	WORD	parent PSP segment
 18h 20 BYTEs	DOS 2+ open file table, FFh = unused
 2Ch	WORD	DOS 2+ environment segment (see below)
 2Eh	DWORD	DOS 2+ process's SS:SP on entry to last INT 21 call
 32h	WORD	DOS 3+ max open files
 34h	DWORD	DOS 3+ open file table address
 38h	DWORD	DOS 3+ pointer to previous PSP (default FFFFFFFFh in 3.x)
		used by SHARE in DOS 3.3
 3Ch 20 BYTEs	unused by DOS versions <= 4.01
 50h  3 BYTEs	DOS function dispatcher (FAR routine)--CDh 21h CBh
 53h  9 BYTEs	unused
 5Ch 16 BYTEs	FCB #1 (see AH=0Fh), filled in from first commandline argument
		(when opened, overwrites following FCB)
 6Ch 20 BYTEs	FCB #2 (see AH=0Fh), filled in from second commandline argument
		(when opened, overwrites part of command tail)
 80h 128 BYTEs	command tail / default DTA buffer
		command tail is BYTE for length of tail, N BYTEs for the tail,
		followed by a BYTE containing 0Dh
Notes:	in DOS versions 3.0 and up, the limit on simultaneously open files may
	  be increased by allocating memory for a new open file table, filling
	  it with FFh, copying the first 20 bytes from the default table, and
	  adjusting the pointer and count at 34h and 32h.  However, DOS
	  versions through  at least 3.30 will only copy the first 20 file
	  handles into a child PSP (including the one created on EXEC).
	network redirectors based on the original MS-Net implementation use
	  values of 80h-FEh in the open file table to indicate remote files

Format of environment block:
Offset	Size	Description
 00h  N BYTEs	first environment variable, ASCIZ string of form "var=value"
      N BYTEs	second environment variable, ASCIZ string
	...
      N BYTEs	last environment variable, ASCIZ string of form "var=value"
	BYTE	00h
---DOS 3+---
	WORD	number of strings following environment (normally 1)
      N BYTEs	ASCIZ full pathname of program owning this environment
		other strings may follow
---------------------------------------------
INT 21 - DOS - RANDOM BLOCK READ
	AH = 27h
	DS:DX -> FCB (see AH=0Fh)
	CX = number of records to be read
Return: AL = status
	    00h successful read
	    01h end of file
	    02h data transfer area too small
	    03h partial record, EOF
SeeAlso: AH=3Fh
---------------------------------------------
INT 21 - DOS - RANDOM BLOCK WRITE
	AH = 28h
	DS:DX -> FCB (see AH=0Fh)
	CX = number of records to be written
	     if zero, truncate file to current random file position
Return: AL = status
	    00h successful write
	    01h disk full
	    02h data transfer area too small
SeeAlso: AH=40h
---------------------------------------------
INT 21 - DOS - PARSE FILENAME
	AH = 29h
	DS:SI -> string to parse
	ES:DI -> buffer to fill with unopened FCB (see AH=0Fh)
	AL = bit mask to control parsing
	    0 = 0: parsing stops if file separator found
		1: leading separators ignored
	    1 = 0: drive number in FCB set to default drive if not present
		   in string
		1: drive number in FCB not changed
	    2 = 0: filename in FCB set to blanks if no filename in string
		1: filename in FCB not changed if string does not contain
		   a filename
	    3 = 0: extension in FCB set to blanks if no extension in string
		1: extension left unchanged
Return: AL = 00h no wildcards in name or extension
	     01h wildcards appeared
	     FFh drive specifier invalid
	DS:SI -> first byte after parsed string
	ES:DI buffer filled with unopened FCB
Notes:	asterisks expanded to question marks in the FCB
	all processing stops when a filename terminator is encountered
	cannot be used with filespecs which include a path (DOS 2+)
---------------------------------------------
INT 21 - DOS - GET CURRENT DATE
	AH = 2Ah
Return: DL = day
	DH = month
	CX = year
	AL = day of the week (0=Sunday, 1=Monday, etc.)
SeeAlso: AH=2Bh"DOS",AH=2Ch,AH=E7h,INT 1A/AH=04h
---------------------------------------------
INT 21 - DOS - SET CURRENT DATE
	AH = 2Bh
	DL = day
	DH = month
	CX = year
Return: AL = 00h if no error
	   = FFh if bad value sent to routine
Note:	DOS 3.3+ also sets CMOS clock
SeeAlso: AH=2Ah,AH=2Dh,INT 1A/AH=05h
---------------------------------------------
INT 21 - DESQview - INSTALLATION CHECK
	AH = 2Bh
	AL = subfunction (DV v2.00+)
	    01h get version
		Return: BX = version (BH = major, BL = minor)
		Note: early copies of v2.00 return 0002h
	    02h get shadow buffer info, and start shadowing
		Return: BH = rows in shadow buffer
			BL = columns in shadow buffer
			DX = segment of shadow buffer
	    04h get shadow buffer info
		Return: BH = rows in shadow buffer
			BL = columns in shadow buffer
			DX = segment of shadow buffer
	    05h stop shadowing
	CX = 4445h ('DE')
	DX = 5351h ('SQ')
Return: AL = FFh if DESQview not installed
Note:	in DESQview v1.x, there were no subfunctions; this call only identified
	whether or not DESQview was loaded
SeeAlso: INT 10/AH=FEh,FFh
---------------------------------------------
INT 21 - PC Tools v5.1 PC-CACHE - INSTALLATION CHECK
	AH = 2Bh
	CX = 4358h ('CX')
Return: AL = FFh if PC-CACHE not installed
	AL = 00h if installed
	    CX = 6378h ('cx')
	    BX = ???
	    DX = ???
---------------------------------------------
INT 21 - TAME v2.10 - INSTALLATION CHECK
	AX = 2B01h
	CX = 5441h ('TA')
	DX = 4D45h ('ME')
Return: AL = 02h if installed
	ES:DX -> data area in TAME-RES (see below)
Note:	TAME is a shareware program by David G. Thomas which gives up CPU time
	  to other partitions under a multitasker when the current partition's
	  program incessantly polls the keyboard or system time

Format of TAME 2.10-2.20 data area:
Offset	Size	Description
 00h	BYTE	data structure minor version number (01h in TAME 2.20)
 01h	BYTE	data structure major version number (07h in TAME 2.20)
 02h	DWORD	number of task switches
 06h	DWORD	number of keyboard polls
 0Ah	DWORD	number of time polls
 0Eh	DWORD	number of times DESQview told program runs only in foreground
 12h	DWORD	original INT 10h
 16h	DWORD	original INT 14h
 1Ah	DWORD	original INT 15h
 1Eh	DWORD	original INT 16h
 22h	DWORD	original INT 17h
 26h	DWORD	original INT 21h
 2Ah	DWORD	original INT 28h
 2Eh	WORD	offset of TAME INT 10h handler
 30h	WORD	offset of TAME INT 14h handler
 32h	WORD	offset of TAME INT 15h handler
 34h	WORD	offset of TAME INT 16h handler
 36h	WORD	offset of TAME INT 17h handler
 38h	WORD	offset of TAME INT 21h handler
 3Ah	WORD	offset of TAME INT 28h handler
 3Ch	WORD	X in /max:X,Y or /freq:X,Y
 3Eh	WORD	Y in /max:X,Y or /freq:X,Y
 40h	WORD	number of polls remaining before next task switch
 42h	WORD	/KEYIDLE value
 44h	BYTE	flags for interrupts already grabbed by TAME
		bit 0: INT 10h
		    1: INT 14h
		    2: INT 15h
		    3: INT 16h
		    4: INT 17h
		    5: INT 21h
		    6: INT 28h
 45h	BYTE	flags for interrupts which may be acted on (same bits as above)
 46h	BYTE	TAME enabled (01h) or disabled (00h)
 47h	BYTE	/TIMEPOLL (01h) or /NOTIMEPOLL (00h)
 48h	BYTE	/NOTIMER (01h) or /TIMER (00h)
 49h	BYTE	window or task number for this task
 4Ah	BYTE	multitasker type ???
		01h DESQview
		02h DoubleDOS
		03h TopView
		???
 4Bh	BYTE	type of task switching selected
		bit 0: DESQview???
		    1: DoubleDOS???
		    2: TopView???
		    3: KeySwitch
		    4: HLT instruction
 4Ch	BYTE	???
 4Dh	BYTE	flags
		bit 1: /FREQ instead of /MAX
 4Eh	BYTE	/FG: value
 4Fh	BYTE	task switches left until next FGONLY DESQview API call
 50h	BYTE	???

Format of TAME 2.30 data area:
Offset	Size	Description
 00h	BYTE	data structure minor version number (02h in TAME 2.30)
 01h	BYTE	data structure major version number (0Ah in TAME 2.30)
 02h	DWORD	number of task switches
 06h	DWORD	number of keyboard polls
 0Ah	DWORD	number of time polls
 0Eh	DWORD	number of times DESQview told program runs only in foreground
 12h	DWORD	time of last /CLEAR or TAME-RES load
 16h	DWORD	time yielded
 1Ah	DWORD	time spent polling
 1Eh	DWORD	time spent waiting on key input with INT 16/AH=01h,11h
 22h	DWORD	original INT 10h
 26h	DWORD	original INT 14h
 2Ah	DWORD	original INT 15h
 2Eh	DWORD	original INT 16h
 32h	DWORD	original INT 17h
 36h	DWORD	original INT 21h
 3Ah	DWORD	original INT 28h
 3Eh	WORD	offset of TAME INT 10h handler
 40h	WORD	offset of TAME INT 14h handler
 42h	WORD	offset of TAME INT 15h handler
 44h	WORD	offset of TAME INT 16h handler
 46h	WORD	offset of TAME INT 17h handler
 48h	WORD	offset of TAME INT 21h handler
 4Ah	WORD	offset of TAME INT 28h handler
 4Ch	WORD	X in /max:X,Y or /freq:X,Y
 4Eh	WORD	Y in /max:X,Y or /freq:X,Y
 50h	WORD	number of polls remaining before next task switch
 52h	WORD	/KEYIDLE value
 54h	WORD	/FG: value
 56h	WORD	task switches left until next FGONLY DESQview API call
 58h	WORD	multitasker version
 5Ah	WORD	virtual screen segment
 5Ch	BYTE	flags for interrupts already grabbed by TAME
		bit 0: INT 10h
		    1: INT 14h
		    2: INT 15h
		    3: INT 16h
		    4: INT 17h
		    5: INT 21h
		    6: INT 28h
 5Dh	BYTE	flags for interrupts which may be acted on (same bits as above)
 5Eh	BYTE	window or task number for this task
 5Fh	BYTE	multitasker type
		01h DESQview
		02h DoubleDOS
		03h TopView
		04h OmniView
		05h VM/386
 60h	BYTE	type of task switching selected (bit flags)
		bit 0: DESQview
		    1: DoubleDOS
		    2: TopView
		    3: OmniView
		    4: KeySwitch
		    5: HLT instruction
 61h	BYTE	watch_DOS
 62h	BYTE	bit flags
		bit 0: TAME enabled
		    1: /FREQ instead of /MAX (counts in 3Ch and 3Eh per tick)
		    2: /TIMEPOLL
		    3: /KEYPOLL
		    4: inhibit timer
		    5: enable status monitoring
 63h	BYTE	old status
 64h	WORD	signature DA34h
---------------------------------------------
INT 21 - DOS - GET CURRENT TIME
	AH = 2Ch
Return: CH = hours
	CL = minutes
	DH = seconds
	DL = hundredths of seconds
Note:	time is updated approximately every 5/100 second
SeeAlso: AH=2Ah,AH=2Dh,AH=E7h,INT 1A/AH=00h,02h,FEh
---------------------------------------------
INT 21 - DOS - SET CURRENT TIME
	AH = 2Dh
	CH = hours
	CL = minutes
	DH = seconds
	DL = hundredths of seconds
Return: AL = 00h if no error
	   = FFh if bad value sent to routine
Note:	DOS 3.3+ also sets CMOS clock
SeeAlso: AH=2Bh"DOS",AH=2Ch,INT 1A/AH=01h,03h,FFh
---------------------------------------------
INT 21 - DOS - SET VERIFY FLAG
	AH = 2Eh
	DL = 00h
	AL = 01h VERIFY on
	     00h VERIFY off
Note:	when ON, all disk writes are verified
SeeAlso: AH=54h
---------------------------------------------
INT 21 - DOS 2+ - GET DISK TRANSFER AREA ADDRESS
	AH = 2Fh
Return: ES:BX -> DTA
SeeAlso: AH=1Ah
---------------------------------------------
INT 21 - DOS 2+ - GET DOS VERSION
	AH = 30h
Return: AL = major version number (00h for DOS 1.x)
	AH = minor version number
	BH = OEM number
	    00h IBM
	    16h DEC
	    FFh Phoenix
	BL:CX = 24-bit user number
Notes:	the OS/2 Compatibility Box returns 0Ah for the major version
	DOS 4.01 and 4.02 identify themselves as version 4.00
---------------------------------------------
INT 21 - Phar Lap 386/DOS-Extender - GET VERSION
	AH = 30h
	EBX = 50484152h ("PHAR")
Return: ???
---------------------------------------------
INT 21 - CTask 2.0 - INSTALLATION CHECK
	AX = 3000h
	BX = 1234h
	DS:DX -> version string??? (8 bytes)
Return: AL = DOS major version
	AH = DOS minor version
	CX:BX -> ???
Notes:	if first eight bytes of returned data block equal eight bytes passed
	  in, CTask is resident
	CTask is a multitasking kernel for C written by Thomas Wagner
---------------------------------------------
INT 21 - DOS 2+ - TERMINATE BUT STAY RESIDENT
	AH = 31h
	AL = exit code
	DX = program size, in paragraphs
Note:	most TSRs can save some memory by releasing their environment block
	  before terminating (see AH=26h,AH=49h)
SeeAlso: AH=00h,AH=4Ch,INT 20, INT 22, INT 27
---------------------------------------------
INT 21 - DOS 2+ internal - GET DRIVE PARAMETER BLOCK
	AH = 32h
	DL = drive number
	    0 = default, 1 = A, etc.
Return: AL = FFh if invalid drive number, else
	DS:BX -> drive parameter block (see below)
Note:	the OS/2 compatibility box supports the DOS 3.3 version of this call
	  except for the DWORD at offset 12h
SeeAlso: AH=1Fh

Format of DOS Drive Parameter Block:
Offset	Size	Description
 00h	BYTE	drive number (0 = A, etc.)
 01h	BYTE	unit number within device driver
 02h	WORD	number of bytes per sector
 04h	BYTE	largest sector number in cluster (one less than sect/clust)
 05h	BYTE	log base two of the cluster size
 06h	WORD	number of reserved (boot) sectors
 08h	BYTE	number of copies of the FAT
 09h	WORD	number of root directory entries
 0Bh	WORD	first data sector on medium
 0Dh	WORD	largest possible cluster number (one more than # data clust)
---DOS 2.x---
 0Fh	BYTE	number of sectors in one FAT copy
 10h	WORD	first sector of root directory
 12h	DWORD	address of device driver for this drive
 16h	BYTE	media descriptor byte for medium
 17h	BYTE	FFh indicates block must be rebuilt
 18h	DWORD	address of next device block, offset = FFFFh indicates last
 1Ch	WORD	starting cluster of current directory (0 = root directory)
 1Eh 64 BYTEs	ASCIZ current directory path string
---DOS 3.x---
 0Fh	BYTE	number of sectors in one FAT copy
 10h	WORD	first sector of root directory
 12h	DWORD	address of device driver for this drive
 16h	BYTE	media descriptor byte for medium
 17h	BYTE	FFh = block must be rebuilt, 00h indicates block accessed
 18h	DWORD	address of next device block, offset = FFFFh indicates last
 1Ch	WORD	cluster at which to start search for free space when writing
 1Eh	WORD	number of free clusters on drive, FFFFh = unknown
---DOS 4.0---
 0Fh	WORD	number of sectors in one FAT copy
 11h	WORD	first sector of root directory
 13h	DWORD	address of device driver for this drive
 17h	BYTE	media descriptor byte for medium
 18h	BYTE	FFh = block must be rebuilt, 00h indicates block accessed
 19h	DWORD	address of next device block, offset = FFFFh indicates last
 1Dh	WORD	cluster at which to start search for free space when writing
 1Fh	WORD	number of free clusters on drive, FFFFh = unknown
---------------------------------------------
INT 21 - DOS 2+ - EXTENDED CONTROL-BREAK CHECKING
	AH = 33h
	AL = subfunction
	    00h get state
		Return: DL = current BREAK setting
			    00h BREAK=OFF
			    01h BREAK=ON
	    01h set state
		DL = 00h for OFF or 01h for ON
Return:	AL = FFh if error
Note:	under DOS 3+, this function does not use any of the DOS-internal stacks
	  and is thus fully reentrant
SeeAlso: AX=3302h
---------------------------------------------
INT 21 - DOS 3.x internal - GET AND SET EXTENDED CONTROL-BREAK CHECKING STATE
	AX = 3302h
	DL = new state
	     00h for OFF or 01h for ON
Return: DL = old state of extended BREAK checking
Note:	this function does not use any of the DOS-internal stacks and is thus
	  fully reentrant
SeeAlso: AH=33h
---------------------------------------------
INT 21 - DOS 4.0 - GET BOOT DRIVE
	AX = 3305h
Return: DL = boot drive (1=A:,...)
---------------------------------------------
INT 21 - DOS 2+ internal - RETURN CritSectFlag (InDOS) POINTER
	AH = 34h
Return: ES:BX -> 1-byte DOS "Critical Section Flag", also known as InDOS flag
Notes:	when the critical section flag is nonzero, code within DOS is being
	  executed.  It is safe to enter DOS when both the critical section
	  flag and the critical error flag are zero.
	The critical error flag is the byte after the critical section flag in
	  DOS 2.x, and the byte BEFORE the critical section flag in DOS 3.x 
	  (except COMPAQ DOS 3.0, where the critical error flag is located 1AAh
	  bytes BEFORE the critical section flag)
	For DOS 3.1+, an undocumented call exists to get the address of the
	  critical error flag (see AX=5D06h)
SeeAlso: AX=5D06h, AX=5D0Bh
---------------------------------------------
INT 21 - DOS 2+ - GET INTERRUPT VECTOR
	AH = 35h
	AL = interrupt number
Return: ES:BX = value of interrupt vector
SeeAlso: AH=25h
---------------------------------------------
INT 21 - DOS 2+ - GET DISK SPACE
	AH = 36h
	DL = drive code (0 = default, 1 = A, 2 = B, etc.)
Return: AX = number of sectors per cluster
	     or FFFFh if invalid drive
	BX = number of available clusters
	CX = bytes per sector
	DX = total clusters
Notes:	multiply AX * CX * BX for free space on disk
	multiply AX * CX * DX for total disk space
	according to Dave Williams' MSDOS reference, the value in DX is
	  incorrect for non-default drives after ASSIGN is run
SeeAlso: AH=1Bh,AH=1Ch
---------------------------------------------
INT 21 - DOS 2+ internal - GET SWITCHAR
	AX = 3700h
Return: AL = FFh unsupported subfunction
	DL = current switch character
Notes:	documented in some OEM versions of some releases of DOS
	supported by OS/2 compatibility box
SeeAlso: AX=3701h
---------------------------------------------
INT 21 - DOS 2+ internal - SET SWITCHAR
	AX = 3701h
	DL = new switch character
Return: AL = FFh unsupported subfunction
Notes:	documented in some OEM versions of some releases of DOS
	supported by OS/2 compatibility box
SeeAlso: AX=3700h
---------------------------------------------
INT 21 - DOS 2.x and 4.0 only internal - AVAILDEV
	AH = 37h
	AL = subfunction
	   02h read device availability (as set by AL=03h)
		Return: DL = device availability (always FFh under DOS 4.0)
	   03h set device availability, where:
		DL = 00h means \DEV\ must preceed device names
		DL <> 00h means \DEV\ need not preceed device names
Return: AL = FFh if invalid subfunction
Notes:	all versions of DOS from 2.00 allow \DEV\ to be prepended to device
	  names without generating an error even if the directory \DEV does
	  not actually exist (other paths generate an error if they do not
	  exist).
	although DOS 4.0 accepts these calls, they have no effect
---------------------------------------------
INT 21 - DOS 2+ - GET COUNTRY-DEPENDENT INFORMATION
	AH = 38h
--DOS 2.x--
	AL = 00h get current-country info
	DS:DX -> buffer for returned info (see below)
Return: AX = country code (MSDOS 2.11 only)
	buffer at DS:DX filled
--DOS 3+--
	AL = 00h for current country
	AL = 01h thru 0FEh for specific country with code <255
	AL = 0FFh for specific country with code >= 255
	   BX = 16-bit country code
	DS:DX -> buffer for returned info (see below)
Return:	CF set on error
	    AX = error code (02h)
	CF clear if successful
	    BX = country code
	    DS:DX buffer filled
SeeAlso: AH=65h, INT 2F/AX=110Ch,1404h

Format of PCDOS 2.x country info:
Offset	Size	Description
 00h	WORD	date format  0 = USA	mm dd yy
			     1 = Europe dd mm yy
			     2 = Japan	yy mm dd
 02h	BYTE	currency symbol
 03h	BYTE	00h
 04h	BYTE	thousands separator char
 05h	BYTE	00h
 06h	BYTE	decimal separator char
 07h	BYTE	00h
 08h 24 BYTEs	reserved

Format of MSDOS 2.x, DOS 3+ country info:
Offset	Size	Description
 00h	WORD	date format (see above)
 02h  5 BYTEs	ASCIZ currency symbol string
 07h	BYTE	thousands separator char
 08h	BYTE	00h
 09h	BYTE	decimal separator char
 0Ah	BYTE	00h
 0Bh	BYTE	date separator char
 0Ch	BYTE	00h
 0Dh	BYTE	time separator char
 0Eh	BYTE	00h
 0Fh	BYTE	currency format
		bit 2 = set if currency symbol replaces decimal point
		bit 1 = number of spaces between value and currency symbol
		bit 0 = 0 if currency symbol precedes value
			1 if currency symbol follows value
 10h	BYTE	number of digits after decimal in currency
 11h	BYTE	time format
		bit 0 = 0 if 12-hour clock
			1 if 24-hour clock
 12h	DWORD	address of case map routine
		(FAR CALL, AL = char to map to upper case [>= 80h])
 16h	BYTE	data-list separator char
 17h	BYTE	00h
 18h 10 BYTEs	reserved
---------------------------------------------
INT 21 - DOS 3+ - SET COUNTRY CODE
	AH = 38h
	AL = 01h thru 0FEh for specific country with code <255
	AL = FFh for specific country with code >= 255
	   BX = 16-bit country code
	DX = FFFFh
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
SeeAlso: INT 2F/AX=1403h
---------------------------------------------
INT 21 - DOS 2+ - CREATE A SUBDIRECTORY (MKDIR)
	AH = 39h
	DS:DX -> ASCIZ pathname (may include drive)
Return: CF set on error
	    AX = error code (03h,05h) (see AH=59h)
	CF clear if successful
Note:	all directories in the given path except the last must exist
SeeAlso: AH=3Ah,AH=3Bh, INT 2F/AX=1103h
---------------------------------------------
INT 21 - DOS 2+ - REMOVE A DIRECTORY ENTRY (RMDIR)
	AH = 3Ah
	DS:DX -> ASCIZ pathname (may include drive)
Return: CF set on error
	    AX = error code (03h,05h,06h,10h) (see AH=59h)
	CF clear if successful
SeeAlso: AH=39h,AH=3Bh, INT 2F/AX=1101h
---------------------------------------------
INT 21 - DOS 2+ - CHANGE THE CURRENT DIRECTORY (CHDIR)
	AH = 3Bh
	DS:DX -> ASCIZ directory name (may include drive)
Return: CF set on error
	    AX = error code (03h) (see AH=59h)
	CF clear if successful
Note:	if new directory name includes a drive letter, the default drive is
	  not changed, only the current directory on that drive
SeeAlso: AH=47h, INT 2F/AX=1105h
---------------------------------------------
INT 21 - DOS 2+ - CREATE A FILE WITH HANDLE (CREAT)
	AH = 3Ch
	CX = attributes for file
	    bit 0: read-only
		1: hidden
		2: system
		3: volume label (ignored)
		4: reserved, must be zero (directory)
		5: archive bit
		7: if set, file is shareable under Novell NetWare
	DS:DX -> ASCIZ filename (may include drive and path)
Return: CF set on error
	    AX = error code (03h,04h,05h) (see AH=59h)
	CF clear if successful
	    AX = file handle
Note:	if a file with the given name exists, it is truncated to zero length
SeeAlso: AH=16h,AH=3Dh,AH=5Ah,AH=5Bh
---------------------------------------------
INT 21 - DOS 2+ - OPEN DISK FILE WITH HANDLE
	AH = 3Dh
	AL = access mode
	    00h read only
	    01h write only
	    02h read/write
	AL bits 7-3 = file-sharing modes (DOS 3+)
	    bit 7    = inheritance flag, set for no inheritance
	    bits 4-6 = sharing mode
		      000 compatibility mode
		      001 exclusive (deny all)
		      010 write access denied (deny write)
		      011 read access denied (deny read)
		      100 full access permitted (deny none)
		      111 used internally by SHARE
	    bit 3    = reserved, should be zero
	DS:DX -> ASCIZ filename
Return: CF set on error
	    AX = error code (01h,02h,03h,04h,05h,0Ch) (see AH=59h)
	CF clear if successful
	    AX = file handle
Notes:	file pointer is set to start of file
	file handles which are inherited from a parent also inherit sharing
	  and access restrictions
SeeAlso: AH=0Fh,AH=3Ch,INT 2F/AX=1226h

File sharing behavior:
	  |	Second and subsequent Opens
 First	  |Compat  Deny	  Deny	 Deny	Deny
 Open	  |	   All	  Write	 Read	None
	  |R W RW R W RW R W RW R W RW R W RW
 - - - - -| - - - - - - - - - - - - - - - - -
 Compat	R |Y Y Y  N N N  1 N N	N N N  1 N N
	W |Y Y Y  N N N  N N N	N N N  N N N
	RW|Y Y Y  N N N  N N N	N N N  N N N
 - - - - -|
 Deny	R |C C C  N N N  N N N	N N N  N N N
 All	W |C C C  N N N  N N N	N N N  N N N
	RW|C C C  N N N  N N N	N N N  N N N
 - - - - -|
 Deny	R |2 C C  N N N  Y N N	N N N  Y N N 
 Write	W |C C C  N N N  N N N	Y N N  Y N N 
	RW|C C C  N N N  N N N	N N N  Y N N
 - - - - -|
 Deny	R |C C C  N N N  N Y N	N N N  N Y N
 Read	W |C C C  N N N  N N N	N Y N  N Y N
	RW|C C C  N N N  N N N	N N N  N Y N
 - - - - -|
 Deny	R |2 C C  N N N  Y Y Y	N N N  Y Y Y
 None	W |C C C  N N N  N N N	Y Y Y  Y Y Y
	RW|C C C  N N N  N N N	N N N  Y Y Y
Legend: Y = open succeeds, N = open fails with error code 05h
	C = open fails, INT 24 generated
	1 = open succeeds if file read-only, else fails with error code
	2 = open succeeds if file read-only, else fails with INT 24
---------------------------------------------
INT 21 - DOS 2+ - CLOSE A FILE WITH HANDLE
	AH = 3Eh
	BX = file handle
Return: CF set on error
	    AX = error code (06h) (see AH=59h)
	CF clear if successful
Note:	if the file was written to, the time and date stamps are set to the
	  current time
SeeAlso: AH=10h,AH=3Ch,AH=3Dh,INT 2F/AX=1106h,1227h
---------------------------------------------
INT 21 - DOS 2+ - READ FROM FILE WITH HANDLE
	AH = 3Fh
	BX = file handle
	CX = number of bytes to read
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (05h,06h) (see AH=59h)
	CF clear if successful
	    AX = number of bytes read (0 if at EOF before call)
Notes:	the returned AX may be smaller than the request in CX if a partial
	  read occurred
	if reading from CON, read stops at first CR
SeeAlso: AH=27h,AH=40h,INT 2F/AX=1108h,1229h
---------------------------------------------
INT 21 - DOS 2+ - WRITE TO FILE WITH HANDLE
	AH = 40h
	BX = file handle
	CX = number of bytes to write
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (05h,06h) (see AH=59h)
	CF clear if successful
	    AX = number of bytes actually written
Notes:	if CX is zero, no data is written, and the file is truncated or
	  extended to the current position
	the usual cause for AX < CX on return is a full disk
SeeAlso: AH=28h,AH=3Fh,INT 2F/AX=1109h
---------------------------------------------
INT 21 - DOS 2+ - DELETE A FILE (UNLINK)
	AH = 41h
	DS:DX -> ASCIZ pathname of file to delete (no wildcards allowed)
Return: CF set on error
	    AX = error code (02h,05h) (see AH=59h)
	CF clear if successful
	    AX destroyed (DOS 3.3) AL seems to be drive of deleted file
Notes:	(DOS 3.1+) wildcards are allowed if invoked via AX=5D00h, in which case
	  the filespec must be canonical (as returned by AH=60h)
	deleting a file which is currently open may lead to filesystem
	  corruption.  Unless SHARE is loaded, DOS does not close the handles
	  referencing the deleted file, thus allowing writes to a nonexistent
	  file.
SeeAlso: AH=13h,AX=5D00h,AH=60h,INT 2F/AX=1113h
---------------------------------------------
INT 21 - DOS 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
	AH = 42h
	AL = method
	    00h offset from beginning of file
	    01h offset from present location
	    02h offset from end of file
	BX = file handle
	CX:DX = offset in bytes
Return: CF set on error
	    AX = error code (01h,06h) (see AH=59h)
	CF clear if successful
	    DX:AX = new absolute offset from beginning of file
SeeAlso: AH=24h,INT 2F/AX=1228h
---------------------------------------------
INT 21 - DOS 2+ - GET FILE ATTRIBUTES
	AX = 4300h
	DS:DX -> ASCIZ file name or directory name without trailing slash
Return: CF set on error
	    AX = error code (01h,02h,03h,05h) (see AH=59h)
	CF clear if successful
	    CX = file attributes (see AX=4301h)
SeeAlso: AX=4301h,AH=B6h,INT 2F/AX=110Fh
---------------------------------------------
INT 21 - DOS 2+ - PUT FILE ATTRIBUTES (CHMOD)
	AX = 4301h
	CX = file attribute bits
	    bit 0 = read only
		1 = hidden file
		2 = system file
		3 = volume label
		4 = subdirectory
		5 = written since backup ("archive" bit)
		8 = shareable (Novell NetWare)
	DS:DX -> ASCIZ file name
Return: CF set on error
	    AX = error code (01h,02h,03h,05h) (see AH=59h)
	CF clear if successful
Note:	will not change volume label or directory attributes
SeeAlso: AX=4300h,INT 2F/AX=110Eh
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - GET DEVICE INFORMATION
	AX = 4400h
	BX = file or device handle
Return: CF set on error
	   AX = error code (see AH=59h)
	CF clear if successful
	   DX = device info
	   If bit 7 set: (character device)
	       bit 0: console input device
		   1: console output device
		   2: NUL device
		   3: CLOCK$ device
		   4: device is special (uses INT 29)
		   5: binary (raw) mode
		   6: Not EOF
		  11: media not removable???
		  12: network device (DOS 3+)
		  14: can process IOCTL control strings (see AL = 02h-05h)
	   If bit 7 clear: (file)
	       bits 0-5 are block device number
		   6: file has not been written
		  11: media not removable
		  12: network device (DOS 3+)
		  14: don't set file date/time on closing (DOS 3+)
		  15: file is remote (DOS 3+)
SeeAlso: AX=4401h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - SET DEVICE INFORMATION
	AX = 4401h
	BX = device handle
	DH = 0
	DL = device information to set (bits 0-7 from function 0)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
SeeAlso: AX=4400h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - READ CHARACTER DEVICE CONTROL STRING
	AX = 4402h
	BX = device handle
	CX = number of bytes to read
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX = number of bytes read
SeeAlso: AX=4403h,AX=4404h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - Network Driver Interface Spec 2.0.1 - PROTOCOL MANAGER
	AX = 4402h
	BX = file handle for device "PROTMAN$"
	DS:DX -> request block (see below)
	CX = 000Eh (size of request block)

Format of request block for GetProtocolManagerInfo:
Offset	Size	Description
 00h	WORD	01h
 02h	WORD	returned status (see below)
 04h	DWORD	returned pointer to structure representing parsed user config
 08h	DWORD	unused
 0Ch	WORD	returned BCD version of NDIS on which Protocol Manager is based

Format of request block for RegisterModule:
Offset	Size	Description
 00h	WORD	02h
 02h	WORD	returned status (see below)
 04h	DWORD	pointer to module's common characteristics table (see below)
 08h	DWORD	pointer to list of modules to which the module is to be bound
 0Ch	WORD	unused

Format of request block for BindAndStart:
Offset	Size	Description
 00h	WORD	03h
 02h	WORD	returned status (see below)
 04h	DWORD	caller's virtual address in FailingModules structure
 08h	DWORD	unused
 0Ch	WORD	unused

Format of request block for GetProtocolManagerLinkage:
Offset	Size	Description
 00h	WORD	04h
 02h	WORD	returned status (see below)
 04h	DWORD	returned dispatch point
 08h	DWORD	unused
 0Ch	WORD	returned protocol manager DS
Note:	the dispatch point may be called as follows instead of using this IOCTL
	STACK: WORD  protocol manager DS
	       DWORD pointer to request block
	Return: AX = returned status
		STACK popped

Format of request block for GetProtocolIniPath:
Offset	Size	Description
 00h	WORD	05h
 02h	WORD	returned status (see below)
 04h	DWORD	pointer to a buffer for the ASCIZ pathname of PROTOCOL.INI
 08h	DWORD	unused
 0Ch	WORD	buffer length

Format of request block for RegisterProtocolManagerInfo:
Offset	Size	Description
 00h	WORD	06h
 02h	WORD	returned status (see below)
 04h	DWORD	pointer to structure containing parsed user config file
 08h	DWORD	unused
 0Ch	WORD	length of structure

Format of request block for InitAndRegister:
Offset	Size	Description
 00h	WORD	07h
 02h	WORD	returned status (see below)
 04h	DWORD	unused
 08h	DWORD	poitner to ASCIZ name of the module to be prebind initialized
 0Ch	WORD	unused

Format of request block for UnbindAndStop:
Offset	Size	Description
 00h	WORD	08h
 02h	WORD	returned status (see below)
 04h	DWORD	failing modules as for BindAndStart
 08h	DWORD	if not 0000h:0000h, pointer to ASCIZ name of module to unbind
		if 0000h:0000h, terminate a set of previously dynamically
		  bound protocol modules
 0Ch	WORD	unused

Format of request block for BindStatus:
Offset	Size	Description
 00h	WORD	09h
 02h	WORD	returned status (see below)
 04h	DWORD	must be 0000h:0000h
		on return, points to root tree
 08h	DWORD	0000h:0000h
 0Ch	WORD	unused under DOS

Format of request block for RegisterStatus:
Offset	Size	Description
 00h	WORD	0Ah
 02h	WORD	returned status (0000h, 0008h, 002Ch) (see below)
 04h	DWORD	0000h:0000h
 08h	DWORD	pointer to 16-byte ASCIZ module name
 0Ch	WORD	0000h

Values of status code:
 0000h success
 0001h wait for release--protocol has retained control of the data buffer
 0002h request queued
 0003h frame not recognized
 0004h frame rejected
 0005h frame should be forwarded
 0006h out of resource
 0007h invalid parameter
 0008h invalid function
 0009h not supported
 000Ah hardware error
 000Bh transmit error
 000Ch unrecognized destination
 000Dh buffer too small
 0020h already started
 0021h binding incomplete
 0022h driver not initialized
 0023h hardware not found
 0024h hardware failure
 0025h configuration failure
 0026h interrupt conflict
 0027h MAC incompatible
 0028h initialization failed
 0029h no binding
 002Ah network may be disconnected
 002Bh incompatible OS version
 002Ch already registered
 002Dh path not found
 002Eh insufficient memory
 002Fh info not found
 00FFh general failure
 F000h-FFFFh reserved for vendor-specific codes, treated as general failure

Format of common characteristics table:
Offset	Size	Description
 00h	WORD	size of table in bytes
 02h	BYTE	NDIS major version
 03h	BYTE	NDIS minor version
 04h	WORD	reserved
 06h	BYTE	module major version
 07h	BYTE	module minor version
 08h	DWORD	module function flag bits
		bit 0: binding at upper boundary supported
		bit 1: binding at lower boundary supported
		bit 2: dynamically bound
		bits 3-31 reserved, must be 0
 0Ch 16 BYTEs	ASCIZ module name
 1Ch	BYTE	upper boundary protocol level
		01h Media Access Control
		02h Data link
		03h network
		04h transport
		05h session
		FFh not specified
 1Dh	BYTE	upper boundary interface type
		for MACs: 1 = MAC
		for data links and transports: to be defined
		for session: 1 = NCB
		any level: 0 = private (ISV-defined)
 1Eh	BYTE	lower boundary protocol level
		00h physical
		01h Media Access Control
		02h Data link
		03h network
		04h transport
		05h session
		FFh not specified
 1Fh	BYTE	lower boundary interface type
		same as offset 1Dh
 20h	WORD	module ID filled in by protocol manager
 22h	WORD	module DS
 24h	DWORD	system request entry point
 28h	DWORD	pointer to service-specific characteristics
		0000h:0000h if none
 2Ch	DWORD	pointer to service-specific status
		0000h:0000h if none
 30h	DWORD	pointer to upper dispatch table (see below)
		0000h:0000h if none
 34h	DWORD	pointer to lower dispatch table (see below)
		0000h:0000h if none
 38h	DWORD	reserved, must be 0
 3Ch	DWORD	reserved, must be 0
Note:	for compatibility with NDIS 1.x.x, a major version of 00h is
	  interpreted as 01h

Format of MAC Service-Specific Characteristics Table:
Offset	Size	Description
 00h	WORD	length of table in bytes
 02h 16 BYTEs	ASCIZ MAC type name, "802.3", "802.4", "802.5", "802.6", "DIX",
		"DIX+802.3", "APPLETALK", "ARCNET", "FDDI", "SDLC", "BSC",
		"HDLC", or "ISDN"
 12h	WORD	length of station addresses in bytes
 14h 16 BYTEs	permanent station address
 24h 16 BYTEs	current station address
 34h	DWORD	current functional adapter address (00000000h if none)
 38h	DWORD	pointer to multicast address list
 3Ch	DWORD	link speed in bits/sec
 40h	DWORD	service flags
		bit 0: supports broadcast
		    1: supports multicast
		    2: supports functional/group addressing
		    3: supports promiscuous mode
		    4: station address software settable
		    5: statistics always current
		    6: supports InitiateDiagnostics
		    7: supports loopback
		    8: MAC does primarily ReceiveChain indications instead of
		       ReceiveLookahead indications
		    9: supports IBM source routing
		   10: supports MAC reset
		   11: supports Open/Close adapter
		   12: supports interrupt request
		   13: supports source routing bridge
		   14: supports GDT virtual addresses (OS/2 version)
		   15: multiple TransferDatas allowed durign a single
		       indication
		   16: MAC normally sets FrameSize = 0 in ReceiveLookahead
		   17-31: reserved, must be 0
 44h	WORD	maximum frame size which may be both sent and received
 46h	DWORD	total transmit buffer capacity in bytes
 4Ah	WORD	transmit buffer allocation block size in bytes
 4Ch	DWORD	total receive buffer capacity in bytes
 50h	WORD	receive buffer allocation block size in bytes
 52h  3 BYTEs	IEEE vendor code
 55h	BYTE	vendor adapter code
 56h	DWORD	pointer to ASCIZ vendor adapter description
 5Ah	WORD	IRQ used by adapter
 5Ch	WORD	transmit queue depth
 5Eh	WORD	maximum supported number of data blocks in buffer descriptors
 60h  N BYTEs	vendor-specific info

Format of NetBIOS Service-Specific Characteristics Table
Offset	Size	Description
 00h	WORD	length of table in bytes
 02h 16 BYTEs	ASCIZ type name of NetBIOS module
 12h	WORD	NetBIOS module code
 14h  N BYTEs	vendor-specific info

Format of MAC Service-Specific Status Table:
Offset	Size	Description
 00h	WORD	length of table in bytes
 02h	DWORD	seconds since 0:00 1/1/70 when diagnostics last run
		(FFFFFFFFh = never)
 06h	DWORD	MAC status bits
		bits 0-2: 000 hardware not installed
			  001 hardware failed startup diagnostics
			  010 hardware configuration problem
			  011 hardware fault
			  100 operating marginally due to soft faults
			  101 reserved
			  110 reserved
			  111 hardware fully operational
		bit 3:	  MAC bound
		    4:	  MAC open
		    5:	  diagnostics in progress
		    6-31: reserved
 0Ah	WORD	current packet filter flags
		bit 0: directed/multicast or group/functional
		    1: broadcast
		    2: promiscuous
		    3: all source routing
		    4-15: reserved, must be zero
 0Ch	DWORD	pointer to media-specific status table or 0000h:0000h
 10h	DWORD	seconds past 0:00 1/1/70 of last ClearStatistics
 14h	DWORD	total frames received (FFFFFFFFh = not counted)
 18h	DWORD	frames with CRC error (FFFFFFFFh = not counted)
 1Ch	DWORD	total bytes received (FFFFFFFFh = not counted)
 20h	DWORD	frames discarded--no buffer space (FFFFFFFFh = not counted)
 24h	DWORD	multicast frames received (FFFFFFFFh = not counted)
 28h	DWORD	broadcast frames received (FFFFFFFFh = not counted)
 2Ch	DWORD	frames with errors (FFFFFFFFh = not counted)
 30h	DWORD	overly large frames (FFFFFFFFh = not counted)
 34h	DWORD	frames less than minimum size (FFFFFFFFh = not counted)
 38h	DWORD	multicast bytes received (FFFFFFFFh = not counted)
 3Ch	DWORD	broadcast bytes received (FFFFFFFFh = not counted)
 40h	DWORD	frames discarded--hardware error (FFFFFFFFh = not counted)
 44h	DWORD	total frames transmitted (FFFFFFFFh = not counted)
 48h	DWORD	total bytes transmitted (FFFFFFFFh = not counted)
 4Ch	DWORD	multicast frames transmitted (FFFFFFFFh = not counted)
 50h	DWORD	broadcast frames transmitted (FFFFFFFFh = not counted)
 54h	DWORD	broadcast bytes transmitted (FFFFFFFFh = not counted)
 58h	DWORD	multicast bytes transmitted (FFFFFFFFh = not counted)
 5Ch	DWORD	frames not transmitted--timeout (FFFFFFFFh = not counted)
 60h	DWORD	frames not transmitted--hardware error (FFFFFFFFh = not countd)
 64h  N BYTEs	vendor-specific info
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - WRITE CHARACTER DEVICE CONTROL STRING
	AX = 4403h
	BX = device handle
	CX = number of bytes to write
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX = number of bytes written
SeeAlso: AX=4402h,AX=4405h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - READ BLOCK DEVICE CONTROL STRING
	AX = 4404h
	BL = drive number (0=default)
	CX = number of bytes to read
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX = number of bytes read
SeeAlso: AX=4402h,AX=4405h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - WRITE BLOCK DEVICE CONTROL STRING
	AX = 4405h
	BL = drive number (0=default)
	CX = number of bytes to write
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX = number of bytes written
SeeAlso: AX=4403h,AX=4404h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - GET INPUT STATUS
	AX = 4406h
	BX = file or device handle
Return: AL = FFh device ready
	     00h device not ready (or file at EOF)
SeeAlso: AX=4407h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - GET OUTPUT STATUS
	AX = 4407h
	BX = file or device handle
Return: AL = FFh device ready
	     00h device not ready
Note:	for DOS 2.x, files are always ready for output
SeeAlso: AX=4406h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 3+ - IOCTL - BLOCK DEVICE CHANGEABLE
	AX = 4408h
	BL = drive number (0=default)
Return:	CF set on error
	    AX = error code (0Fh invalid drive) (see AH=59h)
	CF clear if successful
	    AX = 00h removable
		 01h fixed
SeeAlso: AX=4400h,AX=4409h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 3+ - IOCTL - BLOCK DEVICE LOCAL
	AX = 4409h
	BL = drive number (0=default)
Return: DX = attribute word, bit 12 set if device is remote
SeeAlso: AX=4400h,AX=4408h,AX=440Ah,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 3+ - IOCTL - HANDLE LOCAL
	AX = 440Ah
	BX = file handle
Return: DX = attribute word, bit 15 set if file is remote
Note:	if file is remote, Novell Advanced NetWare 2.0 returns the number of
	  the file server on which the handle is located in CX
SeeAlso: AX=4400h,AX=4409h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 3+ - IOCTL - SET SHARING RETRY COUNT
	AX = 440Bh
	CX = delay (default 1)
	DX = retry count (default 3)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Note:	delay is dependent on processor speed (value in CX specifies number of
	  64K-iteration empty loops to execute)
SeeAlso: AH=52h,INT 2F/AX=1224h,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 3.2+ - IOCTL - GENERIC CHARACTER DEVICE REQUEST
	AX = 440Ch
	BX = device handle
	CH = category code
	    00h unknown (DOS 3.3+)
	    01h COMn: (DOS 3.3+)
	    03h CON (DOS 3.3+)
	    05h LPTn:
	CL = function
	    45h set iteration count
	    4Ah select code page
	    4Ch start code-page preparation
	    4Dh end code-page preparation
	    5Fh set display information (DOS 4.0)
	    65h get iteration count
	    6Ah query selected code page
	    6Bh query prepare list
	    7Fh get display information (DOS 4.0)
	DS:DX -> (DOS) parameter block (see below)
	SI:DI -> (OS/2 comp box) parameter block (see below)
Return: CF set on error
	    AX = error code (see AH=59h)
	DS:DX -> (OS/2 comp box) data block
SeeAlso: AX=440Dh,INT 2F/AX=122Bh,INT 2F/AX=1A01h

Format of parameter block for function 45h:
Offset	Size	Description
 00h	WORD	number of times output is attempted before driver assumes
		device is busy

Format of parameter block for functions 4Ah and 6Ah:
Offset	Size	Description
 00h	WORD	length of data
 02h	WORD	code page ID
 04h 2N BYTEs	DCBS (double byte character set) lead byte range
		  start/end for each of N ranges (DOS 4.0)
	WORD	0000h  end of data (DOS 4.0)

Format of parameter block for function 4Dh:
Offset	Size	Description
 00h	WORD	length of data
 02h	WORD	code page ID

Format of parameter block for function 4Ch:
Offset	Size	Description
 00h	WORD	flags
		DISPLAY.SYS = 0000h
		PRINTER.SYS bit 0 clear to prepare downloaded font, set to
			prepare cartridge selection
 02h	WORD	length of remainder of parameter block
 04h	WORD	number of code pages following
 06h  N WORDs	code page 1,...,N

Format of parameter block for functions 5Fh and 7Fh:
Offset	Size	Description
 00h	BYTE	level (0 for DOS 4.0)
 01h	BYTE	reserved (0)
 02h	WORD	length of following data (14)
 04h	WORD	control flags
		  bit 0 set for blink, clear for intensity
		  bits 1 to 15 reserved
 06h	BYTE	mode type (1=text, 2=graphics)
 07h	BYTE	reserved (0)
 08h	WORD	colors
		   0 = monochrome
		   else N bits per pixel
 0Ah	WORD	pixel columns
 0Ch	WORD	pixel rows
 0Eh	WORD	character columns
 10h	WORD	character rows

Format of parameter block for function 6Bh:
Offset	Size	Description
 00h	WORD	length of following data
 02h	WORD	number of hardware code pages
 04h  N WORDs	hardware code pages 1,...,N
	WORD	number of prepared code pages
      N WORDs	prepared code pages 1,...,N
---------------------------------------------
INT 21 - DOS 3.2+ - IOCTL - GENERIC BLOCK DEVICE REQUEST
	AX = 440Dh
	BL = drive number (0=default)
	CH = category code
	    08h disk drive
	CL = function
 	    40h set device parameters
	    41h write logical device track
	    42h format and verify logical device track
	    46h (DOS 4.0) set ???
	    47h (DOS 4.0) set access flag
	    60h get device parameters
	    61h read logical device track
	    62h verify logical device track
	    67h (DOS 4.0) get access flag
	DS:DX -> (DOS) parameter block (see below)
	SI:DI -> (OS/2 comp box) parameter block (see below)
Return: CF set on error
	   AX = error code (see AH=59h)
	DS:DX -> (OS/2 comp box) data block
Note:	DOS 4.01 seems to ignore the high byte of the number of directory
	  entries in the BPB for diskettes.
SeeAlso: AX=440Ch,INT 2F/AX=122Bh

Format of parameter block for functions 40h, 60h:
Offset	Size	Description
 00h	BYTE	special functions
		bit 0 set if function to use current BPB, clear if Device BIOS
			Parameter Block field contains new default BPB
		bit 1 set if function to use track layout fields only
			must be clear if CL=60h
		bit 2 set if all sectors in track same size (should be set)
		bits 3-7 reserved
 01h	BYTE	device type
		00h  320K/360K disk
		01h  1.2M disk
		02h  720K disk
		03h  single-density 8-inch disk
		04h  double-density 8-inch disk
		05h  fixed disk
		06h  tape drive
		07h  1.44M disk
		08h  other type of block device
 02h	WORD	device attributes
		bit 0 set if nonremovable medium
		bit 1 set if door lock supported
		bits 2-15 reserved
 04h	WORD	number of cylinders
 06h	BYTE	media type
		00h 1.2M disk (default)
		01h 320K/360K disk
 07h 31 BYTEs	device BPB (see AH=53h)
 26h	WORD	number of sectors per track (start of track layout field)
 28h  N word pairs: number,size of each sector in track

Format of parameter block for functions 41h, 61h:
Offset	Size	Description
 00h	BYTE	reserved, must be zero
 01h	WORD	number of disk head
 03h	WORD	number of disk cylinder
 05h	WORD	number of first sector to read/write
 07h	WORD	number of sectors
 09h	DWORD	transfer address

Format of parameter block for functions 42h, 62h:
Offset	Size	Description
 00h	BYTE	reserved, must be zero (DOS <3.2)
		  bit 0=0: format/verify track
			1: format status call (DOS 3.2+)
		  bits 1-7 reserved, must be zero
		on return (DOS 4.0):
		  bit 0: set if specified tracks, sectors/track supported
		  bit 1: set if function not supported by BIOS
		  bit 2: set if specified tracks, sectors/track not supported
		  bit 3: set if no disk in drive
 01h	WORD	number of disk head
 03h	WORD	number of disk cylinder

Format of parameter block for functions 47h, 67h:
Offset	Size	Description
 00h	BYTE	special-function field (must be zero)
 01h	BYTE	disk-access flag, nonzero if access allowed by driver
---------------------------------------------
INT 21 - DOS 3.2+ - IOCTL - GET LOGICAL DRIVE MAP
	AX = 440Eh
	BL = drive number (0=default)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AL = 00h block device has only one logical drive assigned
		 1..26 the last letter used to reference the drive (1=A:,etc)
SeeAlso: AX=440Fh,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - DOS 3.2+ - IOCTL - SET LOGICAL DRIVE MAP
	AX = 440Fh
	BL = physical drive number (0=default)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Note:	maps logical drives to physical drives, similar to DOS's treatment of
	  a single physical floppy drive as both A: and B:
SeeAlso: AX=440Eh,INT 2F/AX=122Bh
---------------------------------------------
INT 21 - Concurrent DOS v3.2+ - INSTALLATION CHECK
	AX = 4451h
Return: CF set if not Concurrent DOS
	    AX = error code (see AH=59h)
	CF clear if successful
	    AH = 14h
	    AL = version (high nybble = major version, low nybble = minor ver)
SeeAlso: AX=4452h
---------------------------------------------
INT 21 - DR DOS 3.41-5.0 - IOCTL - DETERMINE DOS TYPE
	AX = 4452h
	CF set
Return: CF set if not DR DOS
	    AX = error code (see AH=59h)
	CF clear if DR DOS
Notes:	the DR DOS version is stored in the environment variable VER
	Digital Research indicates that this call may change in future
	  versions, making the installation check unreliable.  DR DOS 3.41+ is
	  supposedly sufficiently compatible with MSDOS that programs need not
	  decide which of the two they are running under.
SeeAlso: AX=4451h
---------------------------------------------
INT 21 - DOS 2+ - CREATE DUPLICATE HANDLE (DUP)
	AH = 45h
	BX = file handle to duplicate
Return: CF set on error
	    AX = error code (04h,06h) (see AH=59h)
	CF clear if successful
	    AX = new file handle
Note:	moving file pointer for either handle will also move it for the other
SeeAlso: AH=3Dh,AH=46h
---------------------------------------------
INT 21 - DOS 2+ - FORCE DUPLICATE HANDLE (FORCDUP,DUP2)
	AH = 46h
	BX = existing file handle
	CX = new file handle
Return: CF set on error
	    AX = error code (04h,06h) (see AH=59h)
	CF clear if successful
Notes:	closes file with handle BX if it is still open
	moving file pointer for either handle will also move it for the other
SeeAlso: AH=45h
---------------------------------------------
INT 21 - DOS 2+ - GET CURRENT DIRECTORY
	AH = 47h
	DL = drive (0=default, 1=A, etc.)
	DS:SI points to 64-byte buffer area
Return: CF set on error
	    AX = error code (0Fh) (see AH=59h)
	CF clear if successful
Note:	the returned path does not include a drive or the initial backslash
SeeAlso: AH=3Bh
---------------------------------------------
INT 21 - DOS 2+ - ALLOCATE MEMORY
	AH = 48h
	BX = number of 16-byte paragraphs desired
Return: CF set on error
	    AX = error code (07h,08h) (see AH=59h)
	    BX = size of largest available block
	CF clear if successful
	    AX = segment of allocated memory block
Note:	DOS 3.30 coalesces free blocks while scanning for a block to allocate
SeeAlso: AH=49h,AH=4Ah,AH=58h
---------------------------------------------
INT 21 - DOS 2+ - FREE MEMORY
	AH = 49h
	ES = segment address of area to be freed
Return: CF set on error
	    AX = error code (07h,09h) (see AH=59h)
	CF clear if successful
Notes:	apparently never returns an error 07h, despite official docs; DOS 3.30
	  code contains only an error 09h exit
	DOS 3.30 does not coalesce adjacent free blocks when a block is freed,
	  only when a block is allocated or resized
SeeAlso: AH=48h,AH=4Ah
---------------------------------------------
INT 21 - DOS 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
	AH = 4Ah
	ES = segment address of block to change
	BX = new size in paragraphs
Return: CF set on error
	    AX = error code (07h,08h,09h) (see AH=59h)
	    BX = maximum size possible for the block (if AX=08h)
	CF clear if successful
Notes:	under PCDOS 2.1 and 3.1 and MSDOS 3.2 and 3.3, if there is insufficient
	  memory to expand the block as much as requested, the block will be
	  made as large as possible
	DOS 3.30 coalesces any free blocks immediately following the block to
	  be resized
SeeAlso: AH=48h,AH=49h
---------------------------------------------
INT 21 - DOS 2+ - LOAD OR EXECUTE (EXEC)
	AH = 4Bh
	AL = subfunction
	    00h load and execute program
	    01h load but do not execute (internal)
	    03h load overlay; do not create PSP
	    04h called by MSC spawn(P_NOWAIT,...) when running DOS 4.x.
		returns unsuccessfully under DOS 4.0 (but may be successful
		  in the original European OEM MSDOS 4.0, which has limited
		  multitasking built in)
	DS:DX -> ASCIZ filename
	ES:BX -> parameter block (see below)
Return: CF set on error
	    AX = error code (01h,02h,05h,08h,0Ah,0Bh) (see AH=59h)
	CF clear if successful
	    if subfunction 01h, process ID set to new program's PSP; get with
		INT 21/AH=62h
Notes:	DOS 2.x destroys all registers, including SS:SP
	for functions 00h and 01h, the calling process must ensure that there
	  is enough unallocated memory available; if necessary, by releasing
	  memory with AH=49h or AH=4Ah
BUG:	DOS 2.00 assumes that DS points at the current program's PSP
SeeAlso: AH=4Ch,AH=4Dh,INT 2E

Format of EXEC parameter block for AL=00h,01h:
Offset	Size	Description
 00h	WORD	segment of environment (0 = use current) (see AH=26h)
 02h	DWORD	pointer to command line
 06h	DWORD	pointer to first FCB (see AH=0Fh)
 0Ah	DWORD	pointer to second FCB (see AH=0Fh)
 0Eh	DWORD	(AL=01h) will hold subprogram's initial SS:SP on return
 12h	DWORD	(AL=01h) will hold entry point (CS:IP) on return

Format of EXEC parameter block for AL=03h:
Offset	Size	Description
 00h	WORD	segment load address
 02h	WORD	segment relocation factor

Format of .EXE file header:
Offset	Size  Description
 00h	WORD  4Dh, 5Ah signature (sometimes 5Ah, 4Dh)
 02h	WORD  image size remainder (program size mod 512, not including header)
 04h	WORD  number of 512-byte pages needed to hold .EXE file (incl header)
 06h	WORD  number of relocation items
 08h	WORD  header size in paragraphs
 0Ah	WORD  minimum extra paragraphs needed
 0Ch	WORD  maximum extra paragraphs needed
 0Eh	WORD  stack segment
 10h	WORD  stack offset
 12h	WORD  word checksum of entire file
 14h	DWORD initial CS:IP
 18h	WORD  offset of relocation table 
 1Ah	WORD  overlay number
Note:	if word at offset 02h is 4, it should be treated as 00h, since pre-1.10
	  versions of the MS linker set it that way
---------------------------------------------
INT 21 - DOS 2+ - QUIT WITH EXIT CODE (EXIT)
	AH = 4Ch
	AL = exit code
Return: never returns
Note:	unless the process is its own parent (see AH=26h, offset 16h in PSP),
	  all open files are closed
SeeAlso: AH=26h,AH=4Bh,AH=4Dh, INT 22
---------------------------------------------
INT 21 - DOS 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
	AH = 4Dh
Return: AL = exit code of subprogram (from AH=31h or AH=4Ch)
	AH = circumstance which caused termination
	    00h Terminate/abort
	    01h Control-C/Control-Break
	    02h Hard error
	    03h Terminate and stay resident
SeeAlso: AH=4Bh,AH=4Ch
---------------------------------------------
INT 21 - WILDUNIX.COM internal - INSTALLATION CHECK
	AH = 4Eh
	DS:DX = 0000h:0000h
Return:	AH = 99h if installed
Note:	WILDUNIX.COM is a resident Unix-style wildcard expander by Steve
	  Hosgood and Terry Barnaby
---------------------------------------------
INT 21 - DOS 2+ - FIND FIRST ASCIZ (FINDFIRST)
	AH = 4Eh
	CX = search attributes (see AX=4301h)
	DS:DX -> ASCIZ filespec (drive, path, and wildcards allowed)
Return: CF set on error
	    AX = error code (02h,12h) (see AH=59h)
	CF clear if successful
	    [DTA] = data block (see below)
Notes:	for search attributes other than 08h, all files with at MOST the
	  specified attribute bits, the archive (20h) bit, and the read-only
	  (01h) bits set will be returned.  Under DOS 2.x, searching for
	  attribute 08h (volume label) will also return normal files, while
	  under DOS 3+ only the volume label (if any) will be returned.
	this call also returns successfully if given the name of a character
	  device without wildcards.  DOS 2.x returns attribute 00h, size 0,
	  and the current date and time.  DOS 3+ returns attribute 40h and the
	  current date and time.
	under LANtastic, this call may be used to obtain a list of a server's
	  shared resources by searching for "\\SERVER\*.*"; a list of printer
	  resources may be obtained by searching for "\\SERVER\@*.*"
BUG:	under DOS 3.x and 4.x, the second and subsequent calls to this function
	  with a character device name (no wildcards) and search attributes
	  which include the volume-label bit (08h) will fail unless there is
	  an intervening DOS call which implicitly or explicity performs a
	  directory search without the volume-label bit.  Such implicit
	  searches are performed by CREATE (AH=3Ch), OPEN (AH=3Dh), UNLINK
	  (AH=41h), and RENAME (AH=56h)
SeeAlso: AH=11h,AH=4Fh,AX=4301h,INT 2F/AX=111Bh

Format of FindFirst data block:
Offset	Size	Description
---PCDOS 3.10, PCDOS 4.01, MSDOS 3.2/3.3---
 00h	BYTE	drive letter
 01h 11 BYTEs	search template
 0Ch	BYTE	search attributes
---DOS 2.x (and some DOS 3.x???)---
 00h	BYTE	search attributes
 01h	BYTE	drive letter
 02h 11 BYTEs	search template
---WILDUNIX.COM---
 00h 12 BYTEs	15-character wildcard search pattern and drive letter (packed)
 0Ch	BYTE	search attributes
---DOS 2.x and most 3.x---
 0Dh	WORD	entry count within directory
 0Fh	DWORD	pointer to DTA???
 13h	WORD	cluster number of start of parent directory
---PCDOS 4.01, MSDOS 3.2/3.3---
 0Dh	WORD	entry count within directory
 0Fh	WORD	cluster number of start of parent directory
 11h  4 BYTEs	reserved
---all versions, documented fields---
 15h	BYTE	attribute of file found
 16h	WORD	file time
		    bits 11-15: hour
		    bits 5-10:	minute
		    bits 0-4:	seconds/2
 18h	WORD	file date
		    bits 9-15:	year-1980
		    bits 5-8:	month
		    bits 0-4:	day
 1Ah	DWORD	file size
 1Eh 13 BYTEs	ASCIZ filename+extension
---------------------------------------------
INT 21 - DOS 2+ - FIND NEXT ASCIZ (FINDNEXT)
	AH = 4Fh
	[DTA] = data block from last AH = 4Eh/4Fh call
Return: CF set on error
	    AX = error code (12h) (see AH=59h)
	CF clear if successful
	    [DTA] = data block (see AH=4Eh)
SeeAlso: AH=12h,AH=4Eh
---------------------------------------------
INT 21 - DOS 2+ internal - SET PSP SEGMENT
	AH = 50h
	BX = segment address of new PSP (see AH=26h for format)
Notes:	under DOS 2.x, this function cannot be invoked inside an INT 28h
	  handler without setting the Critical Error flag
	under DOS 3+, this function does not use any of the DOS-internal stacks
	  and is thus fully reentrant
	supported by OS/2 compatibility box
SeeAlso: AH=26h,AH=51h,AH=62h
---------------------------------------------
INT 21 - DOS 2+ internal - GET PSP SEGMENT
	AH = 51h
Return: BX = current PSP segment (see AH=26h for format)
Notes:	under DOS 2.x, this function cannot be invoked inside an INT 28h
	  handler without setting the Critical Error flag
	under DOS 3+, this function does not use any of the DOS-internal stacks
	  and is thus fully reentrant
	supported by OS/2 compability box
	identical to the documented AH=62h
SeeAlso: AH=26h,AH=50h,AH=62h
---------------------------------------------
INT 21 - DOS 2+ internal - GET LIST OF LISTS
	AH = 52h
Return: ES:BX -> DOS list of lists
Note:	partially supported by OS/2 v1.1 compatibility box (however, most
	  pointers are FFFFh:FFFFh, LASTDRIVE is FFh, and the NUL header "next"
	  pointer is FFFFh:FFFFh).

Format of List of Lists:
Offset	Size	Description
 -12	WORD	(DOS 3.1-3.3) sharing retry count (see AX=440Bh)
 -10	WORD	(DOS 3.1-3.3) sharing retry delay (see AX=440Bh)
 -8	DWORD	(DOS 3.x) pointer to current disk buffer
 -4	WORD	(DOS 3.x) pointer in DOS code segment of unread CON input
		when CON is read via a handle, DOS reads an entire line,
		  and returns the requested portion, buffering the rest
		  for the next read.  0000h indicates no unread input
 -2	WORD	segment of first memory control block
 00h	DWORD	pointer to first DOS Drive Parameter Block (see AH=32h)
 04h	DWORD	pointer to list of DOS file tables (see below)
 08h	DWORD	pointer to CLOCK$ device driver, resident or installable
 0Ch	DWORD	pointer to actual CON device driver, resident or installable
---DOS 2.x---
 10h	BYTE	number of logical drives in system
 11h	WORD	maximum bytes/block of any block device
 13h	DWORD	pointer to first disk buffer (see below)
 17h 18 BYTEs	actual NUL device driver header (not a pointer!)
		This is the first device on DOS's linked list of device 
		drivers. (see below for format)
---DOS 3.0---
 10h	BYTE	number of block devices
 11h	WORD	maximum bytes/block of any block device
 13h	DWORD	pointer to first disk buffer (see below)
 17h	DWORD	pointer to array of current directory structures (see below)
 1Bh	BYTE	value of LASTDRIVE command in CONFIG.SYS (default 5)
 1Ch	DWORD	pointer to STRING= workspace area
 20h	WORD	size of STRING area (the x in STRING=x from CONFIG.SYS)
 22h	DWORD	pointer to FCB table
 26h	WORD	the y in FCBS=x,y from CONFIG.SYS
 28h 18 BYTEs	actual NUL device driver header (not a pointer!)
		This is the first device on DOS's linked list of device 
		drivers. (see below for format)
---DOS 3.1-3.3---
 10h	WORD	maximum bytes/block of any block device
 12h	DWORD	pointer to first disk buffer (see below)
 16h	DWORD	pointer to array of current directory structures (see below)
 1Ah	DWORD	pointer to FCB table (if CONFIG.SYS contains FCBS=)
 1Eh	WORD	number of protected FCBs (the y in FCBS=x,y)
 20h	BYTE	number of block devices
 21h	BYTE	value of LASTDRIVE command in CONFIG.SYS (default 5)
 22h 18 BYTEs	actual NUL device driver header (not a pointer!)
		This is the first device on DOS's linked list of device 
		drivers. (see below for format) (see also INT 2F/AX=122Ch)
 34h	BYTE	number of JOIN'ed drives
---DOS 4.x---
 10h	WORD	maximum bytes/block of any block device
 12h	DWORD	pointer to disk buffer info (see below)
 16h	DWORD	pointer to array of current directory structures (see below)
 1Ah	DWORD	pointer to FCB table (if CONFIG.SYS contains FCBS=)
 1Eh	WORD	number of protected FCBs (the y in FCBS=x,y)
 20h	BYTE	number of block devices
 21h	BYTE	value of LASTDRIVE command in CONFIG.SYS (default 5)
 22h 18 BYTEs	actual NUL device driver header (not a pointer!)
		This is the first device on DOS's linked list of device 
		drivers. (see below for format) (see also INT 2F/AX=122Ch)
 34h	BYTE	number of JOIN'ed drives???
 35h	WORD	pointer within IBMDOS code segment to list of special program
		names (see below)
 37h	DWORD	pointer to FAR routine for resident IFS utility functions
		(see below)
		may be called by any IFS driver which does not wish to
		service functions 20h or 24h-28h itself
 3Bh	DWORD	pointer to chain of IFS (installable file system) drivers
 3Fh	WORD	the x in BUFFERS x,y (rounded up to multiple of 30 if in EMS)
 41h	WORD	the y in BUFFERS x,y
 43h	BYTE	boot drive (1=A:)
 44h	BYTE	01h if 80386+, 00h otherwise???
 45h	WORD	extended memory size in K

Format of memory control block:
Offset	Size	Description
 00h	BYTE	block type: 5Ah if last block in chain, otherwise 4Dh
 01h	WORD	PSP segment of owner, 0000h if free, 0008h if belongs to DOS
 03h	WORD	size of memory block in paragraphs
 05h  3 BYTEs	unused
---DOS 2.x,3.x---
 08h  8 BYTEs	unused
---DOS 4.x---
 08h  8 BYTEs	ASCII program name if PSP memory block, else garbage
		null-terminated if less than 8 characters
Notes:	under DOS 3.1+, the first memory block is the DOS data segment,
	  containing installable drivers, buffers, etc.
	under DOS 4.x it is divided into subsegments, each with its own memory
	  control block (see below), the first of which is at offset 0000h

Format of DOS 4.x data segment subsegment control blocks:
Offset	Size	Description
 00h	BYTE	subsegment type (blocks typically appear in this order)
		"D"  device driver
		"E"  device driver appendage
		"I"  IFS (Installable File System) driver
		"F"  FILES=  control block storage area (for FILES>5)
		"X"  FCBS=   control block storage area, if present
		"C"  BUFFERS EMS workspace area (if BUFFERS /X option used)
		"B"  BUFFERS=  storage area
		"L"  LASTDRIVE=  current directory structure array storage area
		"S"  STACKS=  code and data area, if present (see below)
 01h	WORD	paragraph of subsegment start (usually the next paragraph)
 03h	WORD	size of subsegment in paragraphs
 05h  3 BYTEs	unused
 08h  8 BYTEs	for types "D" and "I", base name of file from which the driver
		  was loaded (unused for other types)

Format of data at start of STACKS code segment (if present):
Offset	Size	Description
 00h	WORD	???
 02h	WORD	number of stacks (the x in STACKS=x,y)
 04h	WORD	size of stack control block array (should be 8*x)
 06h	WORD	size of each stack (the y in STACKS=x,y)
 08h	DWORD	ptr to STACKS data segment
 0Ch	WORD	offset in STACKS data segment of stack control block array
 0Eh	WORD	offset in STACKS data segment of last element of that array
 10h	WORD	offset in STACKS data segment of the entry in that array for
		the next stack to be allocated (initially same as value in 0Eh
		and works its way down in steps of 8 to the value in 0Ch as
		hardware interrupts pre-empt each other)
Note:	the STACKS code segment data may, if present, be located as follows:
    DOS 3.2:	The code segment data is at a paragraph boundary fairly early
		in the IBMBIO segment (seen at 0070:0190h)
    DOS 3.3:	The code segment is at a paragraph boundary in the DOS data
		segment, which may be determined by inspecting the segment
		pointers of the vectors for those of interrupts 02h, 08h-0Eh,
		70h, 72-77h which have not been redirected by device drivers or
		TSRs.
    DOS 4.x:	Identified by sub-segment control block type "S" within the DOS
		data segment.

Format of array elements in STACKS data segment:
Offset	Size	Description
 00h	BYTE	status: 00h=free, 01h=in use, 03h=corrupted by overflow of
		higher stack.
 01h	BYTE	not used
 02h	WORD	previous SP
 04h	WORD	previous SS
 06h	WORD	ptr to word at top of stack (new value for SP). The word at the
		top of the stack is preset to point back to this control block.

SHARE.EXE hooks (DOS 3.1-4.01):
(offsets from first system file table--pointed at by ListOfLists+04h)
Offset	Size	Description
-3Ch	DWORD	pointer to FAR routine for ???
		Note: not called by MSDOS 3.3, set to 0000h:0000h by SHARE 3.3
-38h	DWORD	pointer to FAR routine called on opening file
		on call, internal DOS location points at filename(see AX=5D06h)
		Return: CF clear if successful
			CF set on error
			    AX = DOS error code (24h) (see AH=59h)
		Note: SHARE assumes DS=SS=DOS CS, direct-accesses DOS internals
			to get name of file just opened
-34h	DWORD	pointer to FAR routine called on closing file
		ES:DI -> system file table
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
			does something to every lock record for file
-30h	DWORD	pointer to FAR routine to close all files for given computer
		(called by AX=5D03h)
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
-2Ch	DWORD	pointer to FAR routine to close all files for given process
		(called by AX=5D04h)
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
-28h	DWORD	pointer to FAR routine to close file by name
		(called by AX=5D02h)
		DS:SI -> DOS parameter list (see AX=5D00h)
		   DPL's DS:DX -> name of file to close
		Return: CF clear if successful
			CF set on error
			    AX = DOS error code (03h) (see AH=59h)
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
-24h	DWORD	pointer to FAR routine to lock region of file
		call with BX = file handle
			  CX:DX = starting offset
			  SI:AX = size
		Return: CF set on error
			    AL = DOS error code (21h) (see AH=59h)
		Note: only called if file is marked as remote
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
-20h	DWORD	pointer to FAR routine to unlock region of file
		call with BX = file handle
			  CX:DX = starting offset
			  SI:AX = size
		Return: CF set on error
			    AL = DOS error code (21h) (see AH=59h)
		Note: only called if file is marked as remote
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
-1Ch	DWORD	pointer to FAR routine to check if file region is locked
		call with ES:DI -> system file table entry for file
			CX = length of region from current position in file
		Return: CF set if any portion of region locked
			    AX = 0021h
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
-18h	DWORD	pointer to FAR routine to get open file list entry
		(called by AX=5D05h)
		call with DS:SI -> DOS parameter list (see AX=5D00h)
			DPL's BX = index of sharing record
			DPL's CX = index of SFT in SFT chain of sharing rec
		Return: CF set on error or not loaded
			    AX = DOS error code (12h) (see AH=59h)
			CF clear if successful
			    ES:DI -> filename
			    CX = number of locks owned by specified SFT
			    BX = network machine number
			    DX destroyed
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
-14h	DWORD	pointer to FAR routine for updating FCB from SFT???
		call with DS:SI -> unopened FCB
			  ES:DI -> system file table entry
		Return: BL = C0h???
		Note: copies following fields from SFT to FCB:
		   starting cluster of file	  0Bh	 1Ah
		   sharing record offset	  33h	 1Ch
		   file attribute		  04h	 1Eh
-10h	DWORD	pointer to FAR routine to get first cluster of FCB file ???
		call with ES:DI -> system file table entry
			  DS:SI -> FCB
		Return: CF set if SFT closed or sharing record offsets
				mismatched
			CF clear if successful
			    BX = starting cluster number from FCB
-0Ch	DWORD	pointer to FAR routine to close file if duplicate for process
		DS:SI -> system file table
		Return: AX = number of handle in JFT which already uses SFT
		Note: called during open/create of a file
		Note: SHARE assumes SS=DOS CS, directly accesses DOS internals
		Note: if SFT was opened with inheritance enabled and sharing
			mode 111, does something to all other SFTs owned by
			same process which have the same file open mode and
			sharing record
-08h	DWORD	pointer to FAR routine for ???
		Note: SHARE assumes SS=DS=DOS CS, direct-accesses DOS internals
		Note: closes various handles referring to file most-recently
			opened
-04h	DWORD	pointer to FAR routine to update directory info in related SFT
		  entries
		call with ES:DI -> system file table entry for file (see below)
			  AX = subfunction (apply to each related SFT)
				00h: update time stamp (offset 0Dh) and date
				     stamp (offset 0Fh)
				01h: update file size (offset 11h) and starting
				     cluster (offset 0Bh).  Sets last-accessed
				     cluster fields to start of file if file
				     never accessed
				02h: as function 01h, but last-accessed fields
				     always changed
				03h: do both functions 00h and 02h
		Note: follows ptr at offset 2Bh in system file table entries
		Note: NOP if opened with no-inherit or via FCB

Format of sharing record:
Offset	Size	Description
 00h	BYTE	flag
		00h free block
		01h allocated block
		FFh end marker
 01h	WORD	size of block
 03h	BYTE	checksum of pathname (including NUL)
		if sum of ASCII values is N, checksum is (N/256 + N%256)
 04h	WORD	offset in SHARE's DS of lock record (see below)
 06h	DWORD	pointer to start of system file table chain for file
 0Ah	WORD	unique sequence number
 0Ch	var	ASCIZ full pathname

Format of SHARE.EXE lock record:
Offset	Size	Description
 00h	WORD	offset in SHARE's DS of next lock table in list
 02h	DWORD	offset in file of start of locked region
 06h	DWORD	offset in file of end of locked region
 0Ah	DWORD	pointer to System File Table entry for this file
 0Eh	WORD	PSP segment of lock's owner

Format of DOS 2.x system file tables:
Offset	Size	Description
 00h	DWORD	pointer to next file table
 04h	WORD	number of files in this table
 06h  28h bytes per file
	Offset	Size	Description
	 00h	BYTE	number of file handles referring to this file
	 01h	BYTE	file open mode (see AH=3Dh)
	 02h	BYTE	file attribute
	 03h	BYTE	drive (0 = character device, 1 = A, 2 = B, etc)
	 04h 11 BYTEs	filename in FCB format (no path,no period,blank-padded)
	 0Fh	WORD	???
	 11h	WORD	???
	 13h	DWORD	file size???
	 17h	WORD	file date in packed format (see AX=5700h)
	 19h	WORD	file time in packed format (see AX=5700h)
	 1Bh	BYTE	device attribute (see AX=4400h)
	---character device---
	 1Ch	DWORD	pointer to device driver
	---block device---
	 1Ch	WORD	starting cluster of file
	 1Eh	WORD	relative cluster in file of last cluster accessed
	------
	 20h	WORD	absolute cluster number of current cluster
	 22h	WORD	???
	 24h	DWORD	current file position???

Format of DOS 3.x system file tables and FCB tables:
Offset	Size	Description
 00h	DWORD	pointer to next file table
 04h	WORD	number of files in this table
 06h  35h bytes per file
	Offset	Size	Description
	 00h	WORD	number of file handles referring to this file
	 02h	WORD	file open mode (see AH=3Dh)
			bit 15 set if this file opened via FCB
	 04h	BYTE	file attribute
	 05h	WORD	device info word (see AX=4400h)
			bit 15 set if remote file
			bit 14 set means do not set file date/time on closing
	 07h	DWORD	pointer to device driver header if character device
			else pointer to DOS Drive Parameter Block (see AH=32h)
	 0Bh	WORD	starting cluster of file
	 0Dh	WORD	file time in packed format (see AX=5700h)
	 0Fh	WORD	file date in packed format (see AX=5700h)
	 11h	DWORD	file size
	 15h	DWORD	current offset in file
	 19h	WORD	relative cluster within file of last cluster accessed
	 1Bh	WORD	absolute cluster number of last cluster accessed
			0000h if file never read or written???
	 1Dh	WORD	number of sector containing directory entry
	 1Fh	BYTE	number of dir entry within sector (byte offset/32)
	 20h 11 BYTEs	filename in FCB format (no path/period, blank-padded)
	 2Bh	DWORD	(SHARE.EXE) pointer to previous SFT sharing same file
	 2Fh	WORD	(SHARE.EXE) network machine number which opened file
	 31h	WORD	PSP segment of file's owner (see AH=26h)
	 33h	WORD	offset within SHARE.EXE code segment of 
			sharing record (see below)  0000h = none

Format of DOS 4+ system file tables and FCB tables:
Offset	Size	Description
 00h	DWORD	pointer to next file table
 04h	WORD	number of files in this table
 06h  3Bh bytes per file
	Offset	Size	Description
	 00h	WORD	number of file handles referring to this file
	 02h	WORD	file open mode (see AH=3Dh)
			bit 15 set if this file opened via FCB
	 04h	BYTE	file attribute
	 05h	WORD	device info word (see AX=4400h)
			bit 15 set if remote file
			bit 14 set means do not set file date/time on closing
	 07h	DWORD	pointer to device driver header if character device
			else pointer to DOS Drive Parameter Block (see AH=32h)
			or REDIR data
	 0Bh	WORD	starting cluster of file
	 0Dh	WORD	file time in packed format (see AX=5700h)
	 0Fh	WORD	file date in packed format (see AX=5700h)
	 11h	DWORD	file size
	 15h	DWORD	current offset in file
	---local file---
	 19h	WORD	relative cluster within file of last cluster accessed
	 1Bh	DWORD	number of sector containing directory entry
	 1Fh	BYTE	number of dir entry within sector (byte offset/32)
	---network redirector---
	 19h	DWORD	pointer to REDIRIFS record
	 1Dh  3 BYTEs	???
	------
	 20h 11 BYTEs	filename in FCB format (no path/period, blank-padded)
	 2Bh	DWORD	(SHARE.EXE) pointer to previous SFT sharing same file
	 2Fh	WORD	(SHARE.EXE) network machine number which opened file
	 31h	WORD	PSP segment of file's owner (see AH=26h)
	 33h	WORD	offset within SHARE.EXE code segment of 
			sharing record (see below)  0000h = none
	 35h	WORD	(local) absolute cluster number of last clustr accessed
			(redirector) ???
	 37h	DWORD	pointer to IFS driver for file, 0000000h if native DOS

Format of current directory structure (array, 51h bytes [58h for DOS 4.x] per
drive):
Offset	Size	Description
 00h 67 BYTEs	current path as ASCIZ, starting with 'x:\'
 43h	WORD	bit flags
		bit 15: network drive	\ installable file system if both set
		bit 14: physical drive	/ invalid drive if neither bit set
		bit 13: JOIN'ed, current path is actual path without JOIN
			drive letter in path may differ from logical drive name
		bit 12: SUBST'ed, current path is actual path without SUBST
			drive letter in path may differ from logical drive name
 45h	DWORD	pointer to DOS Disk Block for this drive
---local drives---
 49h	WORD	starting cluster of current directory
		0000h = root, FFFFh never accessed
 4Bh	WORD	??? seems always to be FFFFh
 4Dh	WORD	??? seems always to be FFFFh
---network drives---
 49h	DWORD	pointer to a redirector/REDIRIFS record, else FFFFFFFFh
 4Dh	WORD	stored parameter from INT 21/AX=5F03h???
------
 4Fh	WORD	Offset of '\' in current path field representing root directory 
		of logical drive (2 if not SUBST'ed or JOIN'ed, otherwise 
		number of bytes in SUBST/JOIN path)
---DOS 4.x---
 51h	BYTE	??? used by network
 52h	DWORD	pointer to IFS driver for this drive, 00000000h if native DOS
 56h	WORD	???

Format of device driver header:
Offset	Size	Description
 00h	DWORD	pointer to next driver, offset=FFFFh if last driver
 04h	WORD	device attributes
		Character device:
		   bit 15  set
		   bit 14  IOCTL supported (see AH=44h)
		   bit 13  (DOS 3+) output until busy supported
		   bit 12  reserved
		   bit 11  (DOS 3+) OPEN/CLOSE/RemMedia calls supported
		   bits 10-7 reserved
		   bit 6  (DOS 3.2+) Generic IOCTL call supported (command 13h)
				(see AX=440Ch,440Dh)
		   bit 5  reserved
		   bit 4  device is special (use INT 29 "fast console output")
		   bit 3  device is CLOCK$ (all reads/writes use transfer
				record described below)
		   bit 2  device is NUL
		   bit 1  device is standard output
		   bit 0  device is standard input
		Block device:
		   bit 15  clear
		   bit 14  IOCTL supported
		   bit 13  non-IBM format
		   bit 12  reserved
		   bit 11  (DOS 3+) OPEN/CLOSE/RemMedia calls supported
		   bit 10  reserved
		   bit 9   ??? set by DOS 3.3 DRIVER.SYS for "new" drives
		   bit 8   ??? set by DOS 3.3 DRIVER.SYS for "new" drives
		   bit 7   reserved
		   bit 6  (DOS 3.2+) Generic IOCTL call supported (command 13h)
				implies support for commands 17h and 18h
				(see AX=440Ch,440Dh,440Eh,440Fh)
		   bits 5-2 reserved
		   bit 1   driver supports 32-bit sector addressing
		   bit 0   reserved
 06h	WORD	device strategy entry point
		call with ES:BX -> request header (see INT 2F/AX=0802h)
 08h	WORD	device interrupt entry point
---character device---
 0Ah  8 BYTEs	blank-padded character device name
---block device---
 0Ah	BYTE	number of subunits (drives) supported by driver
 0Bh  7 BYTEs	unused
---
 12h	WORD	(CD-ROM driver) reserved, must be 0000h
 14h	BYTE	(CD-ROM driver) drive letter (must initially be 00h)
 15h	BYTE	(CD-ROM driver) number of units
 16h  6 BYTEs	(CD-ROM driver) signature 'MSCDnn' where 'nn' is version 
			(currently '00')

Format of CLOCK$ transfer record:
Offset	Size	Description
 00h	WORD	number of days since 1-Jan-1980
 02h	BYTE	minutes
 03h	BYTE	hours
 04h	BYTE	hundredths of second
 05h	BYTE	seconds

Format of DOS 2.x disk buffer:
Offset	Size	Description
 00h	DWORD	pointer to next disk buffer, offset = FFFFh if last
		least-recently used buffer is first in chain
 04h	BYTE	drive (0=A, 1=B, etc), FFh if not in use
 05h  3 BYTEs	unused??? (seems always to be 00h 00h 01h)
 08h	WORD	logical sector number
 0Ah	BYTE	number of copies to write (1 for non-FAT sectors)
 0Bh	BYTE	sector offset between copies if multiple copies to be written
 0Ch	DWORD	pointer to DOS Drive Parameter Block (see AH=32h)
 10h		buffered data

Format of DOS 3.x disk buffer:
Offset	Size	Description
 00h	DWORD	pointer to next disk buffer, offset = FFFFh if last
		least-recently used buffer is first in chain
 04h	BYTE	drive (0=A,1=B, etc), FFh if not in use
 05h	BYTE	flags
		bit 7: ???
		bit 6: buffer dirty
		bit 5: buffer has been referenced
		bit 4: ???
		bit 3: sector in data area
		bit 2: sector in a directory, either root or subdirectory
		bit 1: sector in FAT
		bit 0: boot sector??? (guess)
 06h	WORD	logical sector number
 08h	BYTE	number of copies to write (1 for non-FAT sectors)
 09h	BYTE	sector offset between copies if multiple copies to be written
 0Ah	DWORD	pointer to DOS Drive Parameter Block (see AH=32h)
 0Eh	WORD	unused??? (almost always 0)
 10h		buffered data

Format of DOS 4.00 (pre UR 25066) disk buffer info:
Offset	Size	Description
 00h	DWORD	pointer to array of disk buffer hash chain heads (see below)
 04h	WORD	number of disk buffer hash chains (referred to as NDBCH below)
 06h	DWORD	pointer to lookahead buffer, zero if not present
 0Ah	WORD	number of lookahead sectors, else zero (the y in BUFFERS=x,y)
 0Ch	BYTE	00h if buffers in EMS (/X), FFh if not
 0Dh	WORD	EMS handle for buffers, zero if not in EMS
 0Fh	WORD	EMS physical page number used for buffers (usually 255)
 11h	WORD	??? seems always to be 0001h
 13h	WORD	segment of EMS physical page frame
 15h	WORD	??? seems always to be zero
 17h  4 WORDs	EMS partial page mapping information???

Format of DOS 4.01 (from UR 25066 Corrctive Services Disk on) disk buffer info:
Offset	Size	Description
 00h	DWORD	pointer to array of disk buffer hash chain heads (see below)
 04h	WORD	number of disk buffer hash chains (referred to as NDBCH below)
 06h	DWORD	pointer to lookahead buffer, zero if not present
 0Ah	WORD	number of lookahead sectors, else zero (the y in BUFFERS=x,y)
 0Ch	BYTE	01h, possibly to distinguish from pre-UR 25066 format
 0Dh	WORD	??? EMS segment for BUFFERS (only with /XD)
 0Fh	WORD	??? EMS physical page number of EMS seg above (only with /XD)
 11h	WORD	??? EMS segment for ??? (only with /XD)
 13h	WORD	??? EMS physical page number of above (only with /XD)
 15h	BYTE	??? number of EMS page frames present (only with /XD)
 16h	WORD	segment of one-sector workspace buffer allocated in main memory
		  if BUFFERS/XS or /XD options in effect, possibly to avoid DMA
		  into EMS
 18h	WORD	EMS handle for buffers, zero if not in EMS
 1Ah	WORD	EMS physical page number used for buffers (usually 255)
 1Ch	WORD	??? appears always to be 0001h
 1Eh	WORD	segment of EMS physical page frame
 20h	WORD	??? appears always to be zero
 22h	BYTE	00h if /XS, 01h if /XD, FFh if BUFFERS not in EMS

Format of DOS 4.x disk buffer hash chain head (array, one entry per chain):
Offset	Size	Description
 00h	WORD	EMS logical page number in which chain is resident, -1 if not
		in EMS
 02h	DWORD	pointer to least recently used buffer header.  All buffers on
		this chain are in the same segment.
 06h	BYTE	number of dirty buffers on this chain
 07h	BYTE	reserved (00h)
Notes:	buffered disk sectors are assigned to chain N where N is the sector's
	  address modulo NDBCH,  0 <= N <= NDBCH-1
	each chain resides completely within one EMS page
	this structure is in main memory even if buffers are in EMS

Format of DOS 4.x disk buffer:
Offset	Size	Description
 00h	WORD	forward ptr, offset only, to next least recently used buffer
 02h	WORD	backward ptr, offset only
 04h	BYTE	drive (0=A,1=B, etc), FFh if not in use
 05h	BYTE	flags
		bit 7: remote buffer
		bit 6: buffer dirty
		bit 5: buffer has been referenced
		bit 4: search data buffer (only valid if remote buffer)
		bit 3: sector in data area
		bit 2: sector in a directory, either root or subdirectory
		bit 1: sector in FAT
		bit 0: reserved
 06h	DWORD	logical sector number
 0Ah	BYTE	number of copies to write
		for FAT sectors, same as number of FATs
		for data and directory sectors, usually 1
 0Bh	WORD	offset in sectors between copies to write for FAT sectors
 0Dh	DWORD	pointer to DOS Drive Parameter Block (see AH=32h)
 11h	WORD	buffer use count if remote buffer (see flags above)
 13h	BYTE	reserved
 14h		buffered data
Note:	all buffered sectors which have the same hash value (computed as the
	  sum of high and low words of the logical sector number divided by
	  NDBCH) are on the same doubly-linked circular chain
	the links consist of offset addresses only, the segment being the same
	  for all buffers in the chain.

Format of IFS driver list:
Offset	Size	Description
 00h	DWORD	pointer to next driver header
 04h  8 BYTEs	IFS driver name (blank padded), as used by FILESYS command
 0Ch  4 BYTEs	???
 10h	DWORD	pointer to IFS utility function entry point (see below)
		call with ES:BX -> IFS request (see below)
 14h	WORD	offset in header's segment of driver entry point
	???

Call IFS utility function entry point with:
	AH = 20h miscellaneous functions
	    AL = 00h get date
		Return: CX = year
			DH = month
			DL = day
	    AL = 01h get process ID and computer ID
		Return: BX = current PSP segment
			DX = active network machine number
	    AL = 05h get file system info
		ES:DI -> 16-byte info buffer
		Return: buffer filled
			Offset	Size	Description
			 00h  2 BYTEs	unused
			 02h	WORD	number of SFTs (actually counts only
					the first two file table arrays)
			 04h	WORD	number of FCB table entries
			 06h	WORD	number of proctected FCBs
			 08h  6 BYTEs	unused
			 0Eh	WORD	largest sector size supported
	    AL = 06h get machine name
		ES:DI -> 18-byte buffer for name
		Return: buffer filled with name starting at offset 02h
	    AL = 08h get sharing retry count
		Return: BX = sharing retry count
	    AL = other
		Return: CF set
	AH = 21h get redirection state
		BH = type (03h disk, 04h printer)
		Return: BH = state (00h off, 01h on)
	AH = 22h ??? some sort of time calculation
		AL = 00h ???
		    nonzero ???
	AH = 23h ??? some sort of time calculation
	AH = 24h compare filenames
	    DS:SI -> first ASCIZ filename
	    ES:DI -> second ASCIZ filename
	    Return: ZF set if files are same ignoring case and / vs \
	AH = 25h normalize filename
	    DS:SI -> ASCIZ filename
	    ES:DI -> buffer for result
	    Return: filename uppercased, forward slashes changed to backslashes
	AH = 26h get DOS stack
	    Return: DS:SI -> top of stack
		    CX = size of stack in bytes
	AH = 27h increment InDOS flag
	AH = 28h decrement InDOS flag
Note:	IFS drivers which do not wish to implement functions 20h or 24h-28h may
	  pass them on to the default handler pointed at by [LoL+37h]

Format of IFS request block:
Offset	Size	Description
 00h	WORD	total size in bytes of request
 02h	BYTE	class of request
		02h ???
		03h redirection
		04h ???
		05h file access
		06h convert error code to string
		07h ???
 03h	WORD	returned DOS error code
 05h	BYTE	IFS driver exit status
		00h success
		01h ???
		02h ???
		03h ???
		04h ???
		FFh internal failure
 06h 16 BYTEs	???
---request class 02h---
 16h	BYTE	function code
		04h ???
 17h	BYTE	unused???
 18h	DWORD	pointer to ???
 1Ch	DWORD	pointer to ???
 20h  2 BYTEs	???
---request class 03h---
 16h	BYTE	function code
 17h	BYTE	???
 18h	DWORD	pointer to ???
 1Ch	DWORD	pointer to ???
 22h	WORD	returned ???
 24h	WORD	returned ???
 26h	WORD	returned ???
 28h	BYTE	returned ???
 29h	BYTE	unused???
---request class 04h---
 16h	DWORD	pointer to ???
 1Ah	DWORD	pointer to ???
---request class 05h---
 16h	BYTE	function code
		01h flush disk buffers
		02h get disk space
		03h MKDIR
		04h RMDIR
		05h CHDIR
		06h delete file
		07h rename file
		08h search directory
		09h file open/create
		0Ah LSEEK
		0Bh read from file
		0Ch write to file
		0Dh lock region of file
		0Eh commit/close file
		0Fh get/set file attributes
		10h printer control
		11h ???
		12h process termination
		13h ???
	---class 05h function 01h---
	 17h  7	BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h  4 BYTEs	???
	 26h	BYTE	???
	 27h	BYTE	???
	---class 05h function 02h---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h  4 BYTEs	???
	 26h	WORD	returned total clusters
	 28h	WORD	returned sectors per cluster
	 2Ah	WORD	returned bytes per sector
	 2Ch	WORD	returned available clusters
	 2Eh	BYTE	returned ???
	 2Fh	BYTE	???
	---class 05h functions 03h,04h,05h---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h  4 BYTEs	???
	 26h	DWORD	pointer to directory name
	---class 05h function 06h---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h  4 BYTEs	???
	 26h	WORD	attribute mask
	 28h	DWORD	pointer to filename
	---class 05h function 07h---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h  4 BYTEs	???
	 26h	WORD	attribute mask
	 28h	DWORD	pointer to source filespec
	 2Ch	DWORD	pointer to destination filespec
	---class 05h function 08h---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h  4 BYTEs	???
	 26h	BYTE	00h FINDFIRST
			01h FINDNEXT
	 28h	DWORD	pointer to FindFirst search data + 01h if FINDNEXT
	 2Ch	WORD	search attribute if FINDFIRST
	 2Eh	DWORD	pointer to filespec if FINDFIRST
	---class 05h function 09h---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h	DWORD	pointer to IFS open file structure (see below)
	 26h	WORD	???  \ together, specify open vs. create, whether or
	 28h	WORD	???  / not to truncate
	 2Ah  4 BYTEs	???
	 2Eh	DWORD	pointer to filename
	 32h  4 BYTEs	???
	 36h	WORD	file attributes on call
			returned ???
	 38h	WORD	returned ???
	---class 05h function 0Ah---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h	DWORD	pointer to IFS open file structure (see below)
	 26h	BYTE	seek type (02h = from end)
	 28h	DWORD	offset on call
			returned new absolute position
	---class 05h functions 0Bh,0Ch---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h	DWORD	pointer to IFS open file structure (see below)
	 28h	WORD	number of bytes to transfer
			returned bytes actually transferred
	 2Ah	DWORD	transfer address
	---class 05h function 0Dh---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h	DWORD	pointer to IFS open file structure (see below)
	 26h	BYTE	file handle???
	 27h	BYTE	unused???
	 28h	WORD	???
	 2Ah	WORD	???
	 2Ch	WORD	???
	 2Eh	WORD	???
	---class 05h function 0Eh---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h	DWORD	pointer to IFS open file structure (see below)
	 26h	BYTE	00h commit file
			01h close file
	 27h	BYTE	unused???
	---class 05h function 0Fh---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h  4 BYTEs	???
	 26h	BYTE	02h GET attributes
			03h PUT attributes
	 27h	BYTE	unused???
	 28h 12 BYTEs	???
	 34h	WORD	search attributes???
	 36h	DWORD	pointer to filename
	 3Ah	WORD	(GET) returned ??? 
	 3Ch	WORD	(GET) returned ???
	 3Eh	WORD	(GET) returned ???
	 40h	WORD	(GET) returned ???
	 42h	WORD	(PUT) new attributes
			(GET) returned attributes
	---class 05h function 10h---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h	DWORD	pointer to IFS open file structure (see below)
	 26h	WORD	???
	 28h	DWORD	pointer to ???
	 2Ch	WORD	???
	 2Eh	BYTE	???
	 2Fh	BYTE	subfunction
			01h get printer setup
			03h ???
			04h ???
			05h ???
			06h ???
			07h ???
			21h set printer setup
	---class 05h function 11h---
	 17h  7 BYTEs	???
	 1Eh	DWORD	pointer to ???
	 22h	DWORD	pointer to IFS open file structure (see below)
	 26h	BYTE	subfunction
	 27h	BYTE	unused???
	 28h	WORD	???
	 2Ah	WORD	???
	 2Ch	WORD	???
	 2Eh	BYTE	???
	 2Fh	BYTE	???
	---class 05h function 12h---
	 17h 15 BYTEs	unused???
	 26h	WORD	PSP segment
	 28h	BYTE	type of process termination
	 29h	BYTE	unused???
	---class 05h function 13h---
	 17h 15 BYTEs	unused???
	 26h	WORD	PSP segment
---request class 06h---
 16h	DWORD	returned pointer to string corresponding to error code at 03h
 1Ah	BYTE	returned ???
 1Bh	BYTE	unused
---request class 07h---
 16h	DWORD	pointer to IFS open file structure (see below)
 1Ah	BYTE	???
 1Bh	BYTE	unused???

Format of IFS open file structure:
Offset	Size	Description
 00h	WORD	???
 02h	WORD	device info word
 04h	WORD	file open mode
 06h	WORD	???
 08h	WORD	file attributes
 0Ah	WORD	owner's network machine number
 0Ch	WORD	owner's PSP segment
 0Eh	DWORD	file size
 12h	DWORD	current offset in file
 16h	WORD	file time
 18h	WORD	file date
 1Ah 11 BYTEs	filename in FCB format
 25h	WORD	???
 27h	WORD	hash value of SFT address
		(low word of linear address + segment&F000h)
 29h  3 WORDs	network info from SFT
 2Fh	WORD	???

Format of one item in DOS 4 list of special program names:
Offset	Size	Description
 00h	BYTE	length of name (00h = end of list)
 01h  N BYTEs	name in format name.ext
 N    3 BYTEs	???
---------------------------------------------
INT 21 - DOS 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
	AH = 53h
	DS:SI -> BPB (BIOS Parameter Block)
	ES:BP -> buffer for DOS Drive Parameter Block (see below)
Note:	translates BPB into a DOS Drive Parameter Block (see AH=32h)

Format of BIOS Parameter Block:
Offset	Size	Description
 00h	WORD	bytes/sector
 02h	BYTE	sectors/cluster. Get from (DPB byte 4) + 1
 03h	WORD	number of reserved sectors
 05h	BYTE	number of FATs
 06h	WORD	number of root directory entries
 08h	WORD	total number of sectors. Get from:
		  ((DPB bytes 0Dh-0Eh) - 1) * (sectors/cluster (BPB byte 2))
		    + (DPB Bytes 0Bh-0Ch)
		for DOS 4.0, set to zero if partition >32M, then set DWORD at
		  15h to actual number of sectors
 0Ah	BYTE	media descriptor byte
 0Bh	WORD	number of sectors per FAT
---DOS 3+---
 0Dh	WORD	number of sectors per track
 0Fh	WORD	number of heads
 11h	DWORD	number of hidden sectors
 15h 11 BYTEs	reserved	
---DOS 4.0---
 15h	DWORD	total number of sectors if word at 08h contains zero
 19h  6 BYTEs	???
 1Fh	WORD	number of cylinders
 21h	BYTE	device type
 22h	WORD	device attributes (removable or not, etc)
---------------------------------------------
INT 21 - DOS 2+ - GET VERIFY FLAG
	AH = 54h
Return: AL = 00h if flag OFF
	AL = 01h if flag ON
SeeAlso: AH=2Eh
---------------------------------------------
INT 21 - DOS 2+ internal - CREATE PSP
	AH = 55h
	DX = segment number at which to set up PSP (see AH=26h)
	SI = (DOS 3+) value to place in memory size field at DX:[0002h]
Notes:	like AH=26h but creates "child" PSP rather than copying existing one,
	  incrementing the reference count for each inherited file
	(DOS 2+) sets current PSP to DX
	(DOS 3+) marks "no inherit" file handles as closed in child PSP
SeeAlso: AH=26h,AH=50h
---------------------------------------------
INT 21 - DOS 2+ - RENAME A FILE
	AH = 56h
	DS:DX -> ASCIZ old name (drive and path allowed, no wildcards)
	ES:DI -> ASCIZ new name
Return: CF set on error
	    AX = error code (02h,03h,05h,11h) (see AH=59h)
	CF clear if successful
Notes:	allows move between directories on same logical volume
	does not set the archive attribute (see AX=4300h), which results in
	  incremental backups not backing up the file under its new name
	(DOS 3+) allows renaming of directories
	(DOS 3.1+) wildcards are allowed if invoked via AX=5D00h, in which case
	  error 12h (no more files) is returned on success, and both source and
	  destination specs must be canonical (as returned by AH=60h).
	  Wildcards in the destination are replaced by the corresponding char
	  of each source file being renamed.
SeeAlso: AH=17h,AH=60h,AX=5D00h
---------------------------------------------
INT 21 - DOS 2+ - GET FILE'S DATE/TIME
	AX = 5700h
	BX = file handle
Return: CF set on error
	    AX = error code (01h,06h) (see AH=59h)
	CF clear if successful
	    CX = time of last write
		bits 11-15: hour
		     5-10:  minute
		     0-4:   seconds/2
	    DX = date of last write
		bits 9-15:   year-1980 (max 119 = 2099)
		     5-8:    month
		     0-4:    day
SeeAlso: AX=5701h
---------------------------------------------
INT 21 - DOS 2+ - SET FILE'S DATE/TIME
	AX = 5701h
	BX = file handle
	CX = time to be set (see AX=5700h)
	DX = date to be set (see AX=5700h)
Return: CF set on error
	    AX = error code (01h,06h) (see AH=59h)
	CF clear if successful
SeeAlso: AX=5700h
---------------------------------------------
INT 21 - DOS 4.0 - GET ???
	AX = 5702h
	BX = ??? (0000h through 0004h)
	DS:SI -> ???
	ES:DI -> result buffer
	CX = size of result buffer
Return: CX = size of returned data
SeeAlso: AX=5703h,AX=5704h
---------------------------------------------
INT 21 - DOS 4.0 - GET ???
	AX = 5703h
	BX = ??? (0000h through 0004h)
	DS:SI -> ???
	ES:DI -> result buffer
	CX = size of result buffer
Return: CX = size of returned data
SeeAlso: AX=5702h,AX=5704h
---------------------------------------------
INT 21 - DOS 4.0 - ???
	AX = 5704h
	BX = ??? (0000h through 0004h)
	DS:SI -> ???
	ES:DI -> result buffer
	CX = size of result buffer
Return: nothing???
SeeAlso: AX=5702h,AX=5703h
---------------------------------------------
INT 21 - DOS 3+ - GET/SET MEMORY ALLOCATION STRATEGY
	AH = 58h
	AL = function code
	    00h get allocation strategy
	    01h set allocation strategy
	       BL = strategy code
		   00h first fit (use first memory block large enough)
		   01h best fit (use smallest memory block large enough)
		   02h last fit (use high part of last usable memory block)
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
	CF clear if successful
	    AX = strategy code
Note: the Set subfunction accepts any value in BL; 2 or greater means last fit.
      the Get subfunction returns the last value set, so programs should check
      whether the value is >= 2, not just equal to 2.
SeeAlso: AH=48h,AH=49h,AH=4Ah
---------------------------------------------
INT 21 - DOS 3+ - GET EXTENDED ERROR CODE
	AH = 59h
	BX = version code (0000h for DOS 3.x)
Return: AX = extended error code (see below)
	BH = class of error (see below)
	BL = suggested action (see below)
	CH = locus (where error occurred) (see below)
	CL, DX, SI, DI, BP, DS, and ES destroyed
Notes:	functions available under DOS 2.x map the true DOS 3+ error code into
	  one supported under DOS 2.x
	you should call this function to retrieve the true error code when an
	  FCB or DOS 2.x call returns an error
SeeAlso: AX=5D0Ah,INT 2F/AX=122Dh

Values for extended error code:
	01h function number invalid
	02h file not found
	03h path not found
	04h too many open files (no handles available)
	05h access denied
	06h invalid handle
	07h memory control block destroyed
	08h insufficient memory
	09h memory block address invalid
	0Ah environment invalid (usually >32K in length)
	0Bh format invalid
	0Ch access code invalid
	0Dh data invalid
	0Fh invalid drive
	10h attempted to remove current directory
	11h not same device
	12h no more files
---DOS 3+---
	13h disk write-protected
	14h unknown unit
	15h drive not ready
	16h unknown command
	17h data error (CRC)
	18h bad request structure length
	19h seek error
	1Ah unknown media type (non-DOS disk)
	1Bh sector not found
	1Ch printer out of paper
	1Dh write fault
	1Eh read fault
	1Fh general failure
	20h sharing violation
	21h lock violation
	22h disk change invalid
	    ES:DI -> ASCIZ volume label of required disk
	23h FCB unavailable
	24h sharing buffer overflow
	25h reserved
	26h (LANtastic) cannot complete file operation
	27h-31h reserved
	32h network request not supported
	33h remote computer not listening
	34h duplicate name on network
	35h network name not found
	36h network busy
	37h network device no longer exists
	38h network BIOS command limit exceeded
	39h network adapter hardware error
	3Ah incorrect response from network
	3Bh unexpected network error
	3Ch incompatible remote adapter
	3Dh print queue full
	3Eh queue not full
	3Fh not enough space to print file
	40h network name was deleted
	41h network: Access denied
	42h network device type incorrect
	43h network name not found
	44h network name limit exceeded
	45h network BIOS session limit exceeded
	46h temporarily paused
	47h network request not accepted
	48h network print/disk redirection paused
	49h (LANtastic) invalid network version
	4Ah (LANtastic) account expired
	4Bh (LANtastic) password expired
	4Ch (LANtastic) login attempt invalid at this time
	4Dh (LANtastic v3+) disk limit exceeded on network node
	4Eh (LANtastic v3+) not logged in to network node
	4Fh reserved
	50h file exists
	51h reserved
	52h cannot make directory
	53h fail on INT 24h
	54h (DOS 3.3+) too many redirections
	55h (DOS 3.3+) duplicate redirection
	56h (DOS 3.3+) invalid password
	57h (DOS 3.3+) invalid parameter
	58h (DOS 3.3+) network write fault
	59h (LANtastic) function not supported on network
	5Ah (LANtastic) required system component not installed

Values for Error Class:
	01h out of resource (storage space or I/O channels)
	02h temporary situation (file or record lock)
	03h authorization (denied access)
	04h internal (system software bug)
	05h hardware failure
	06h system failure (configuration file missing or incorrect)
	07h application program error
	08h not found
	09h bad format
	0Ah locked
	0Bh media error
	0Ch already exists
	0Dh unknown

Values for Suggested Action:
	01h retry
	02h delayed retry
	03h prompt user to reenter input
	04h abort after cleanup
	05h immediate abort
	06h ignore
	07h retry after user intervention

Values for Error Locus:
	01h unknown or not appropriate
	02h block device (disk error)
	03h network related
	04h serial device (timeout)
	05h memory related
---------------------------------------------
INT 21 - DOS 3+ - CREATE UNIQUE FILE
	AH = 5Ah
	DS:DX -> ASCIZ directory path name ending with a '\' + 13 bytes to
		 receive generated filename
	CX = file attributes (only bits 0,1,2,5 may be set)
Return: CF set on error
	    AX = error code (03h,05h) (see AH=59h)
	CF clear if successful
	    AX = file handle
	DS:DX -> path name
Notes:	the file created is not truly temporary; it MUST be removed by the user
	COMPAQ DOS 3.31 reportedly hangs if the pathname is at XXXXh:0000h
SeeAlso: AH=3Ch,AH=5Bh
---------------------------------------------
INT 21 - DOS 3+ - CREATE NEW FILE
	AH = 5Bh
	DS:DX -> ASCIZ directory path name
	CX = file attribute (see AX=4301h)
Return: CF set on error
	    AX = error code (03h,04h,05h,50h) (see AH=59h)
	CF clear if successful
	    AX = file handle
Note:	unlike function 3Ch, function 5Bh will fail if the file already exists
SeeAlso: AH=3Ch,AH=5Ah
---------------------------------------------
INT 21 - DOS 3+ - LOCK/UNLOCK FILE ACCESS
	AH = 5Ch
	AL = 00h lock
	     01h unlock
	BX = file handle
	CX:DX = starting offset of region to lock
	SI:DI = size of region to lock
Return: CF set on error
	    AX = error code (01h,06h,21h) (see AH=59h)
	CF clear if successful
Note:	error returned unless SHARE or network installed
SeeAlso: AX=440Bh, INT 2F/AX=110Ah,110Bh
---------------------------------------------
INT 21 - DOS 3.1+ internal - SERVER FUNCTION CALL
	AX = 5D00h
	DS:DX -> DOS parameter list (see below)
	DPL contains all register values for a call to INT 21h
Return: as appropriate for function being called
Notes:	does not check AH.  Out of range values will crash the system
	executes using specified computer ID and process ID
	sharing delay loops skipped
	a special sharing mode is enabled
	functions which take filenames require canonical names (as returned by
	  AH=60h); this is apparently to prevent multi-hop file forwarding
SeeAlso: AH=60h

Format of DOS parameter list:
Offset	Size	Description
 00h	WORD	AX 
 02h	WORD	BX
 04h	WORD	CX
 06h	WORD	DX
 08h	WORD	SI
 0Ah	WORD	DI
 0Ch	WORD	DS
 0Eh	WORD	ES
 10h	WORD	reserved (0)
 12h	WORD	computer ID (0 = current system)
 14h	WORD	process ID (PSP segment on specified computer)
---------------------------------------------
INT 21 - DOS 3.1+ internal - COMMIT ALL FILES FOR SPECIFIED COMPUTER/PROCESS
	AX = 5D01h
	DS:DX -> DOS parameter list (see AX=5D00h), only computer ID and
		process ID fields used
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Notes:	flushes buffers and updates directory entries for each file which has
	  been written to; if remote file, calls INT 2F/AX=1107h
	the computer ID and process ID are stored but ignored under DOS 3.3
SeeAlso: AH=68h, INT 2F/AX=1107h
---------------------------------------------
INT 21 - DOS 3.1+ internal - SHARE.EXE - CLOSE FILE BY NAME
	AX = 5D02h
	DS:DX -> DOS parameter list (see AX=5D00h), only fields DX, DS,
		computer ID, and process ID used
	DPL's DS:DX -> ASCIZ name of file to close
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Notes:	error unless SHARE is loaded (calls [SysFileTable-28h]) (see AH=52h)
	name must be canonical fully-qualified, such as returned by AH=60h
SeeAlso: AX=5D03h,5D04h,AH=3Eh,60h
---------------------------------------------
INT 21 - DOS 3.1+ internal - SHARE.EXE - CLOSE ALL FILES FOR GIVEN COMPUTER
	AX = 5D03h
	DS:DX -> DOS parameter list (see AX=5D00h), only computer ID used
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Note:	error unless SHARE is loaded (calls [SysFileTable-30h]) (see AH=52h)
SeeAlso: AX=5D02h,5D04h
---------------------------------------------
INT 21 - DOS 3.1+ internal - SHARE.EXE - CLOSE ALL FILES FOR GIVEN PROCESS
	AX = 5D04h
	DS:DX -> DOS parameter list (see AX=5D00h), only computer ID and
		process ID fields used
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Note:	error unless SHARE is loaded (calls [SysFileTable-2Ch]) (see AH=52h)
SeeAlso: AX=5D02h,AX=5D03h
---------------------------------------------
INT 21 - DOS 3.1+ internal - SHARE.EXE - GET OPEN FILE LIST ENTRY
	AX = 5D05h
	DS:DX -> DOS parameter list (see AX=5D00h)
	DPL's BX = index of sharing record
	DPL's CX = index of SFT in sharing record's SFT list
Return: CF clear if successful
	    ES:DI -> ASCIZ filename
	    BX = network machine number of SFT's owner
	    CX = number of locks held by SFT's owner
	CF set if either index out of range
	    AX = 0012h (no more files)
Notes:	error unless SHARE is loaded (calls [SysFileTable-18h]) (see AH=52h)
	names are always canonical fully-qualified, such as returned by AH=60h
SeeAlso: AH=5Ch,AH=60h 
---------------------------------------------
INT 21 - DOS 3.0+ internal - GET ADDRESS OF DOS SWAPPABLE DATA AREA
	AX = 5D06h
Return: CF set on error
	   AX = error code (see AH=59h)
	CF clear if successful
	    DS:SI -> nonreentrant data area (includes all three DOS stacks)
		(critical error flag is first byte)
	    CX = size in bytes of area which must be swapped while in DOS
	    DX = size in bytes of area which must always be swapped
Notes:	the Critical Error flag is used in conjunction with the InDOS flag
	  (see AH=34h) to determine when it is safe to enter DOS from a TSR
	setting CritErr flag allows use of functions 50h/51h from INT 28h under
	  DOS 2.x by forcing use of correct stack
	swapping the data area allows reentering DOS unless DOS is in a
	  critical section delimited by INT 2A/AH=80h and INT 2A/AH=81h,82h
	under DOS 4.0, AX=5D0Bh should be used instead of this function
SeeAlso: AX=5D0Bh, INT 2A/AH=80h,81h,82h

Format of DOS 3.10-3.30 Swappable Data Area:
Offset	Size	Description
 00h	BYTE	critical error flag
 01h	BYTE	InDOS flag (count of active INT 21 calls)
 02h	BYTE	drive on which current critical error occurred, or FFh
 03h	BYTE	locus of last error
 04h	WORD	extended error code of last error
 06h	BYTE	suggested action for last error
 07h	BYTE	class of last error
 08h	DWORD	ES:DI pointer for last error
 0Ch	DWORD	current DTA
 10h	WORD	current PSP
 12h	WORD	stores SP across an INT 23
 14h	WORD	return code from last process termination (zerod after reading
		with AH=4Dh)
 16h	BYTE	current drive
 17h	BYTE	extended break flag
---remainder need only be swapped if in DOS---
 18h	WORD	value of AX on call to INT 21
 1Ah	WORD	PSP segment for sharing/network
 1Ch	WORD	network machine number for sharing/network (0000h = us)
 1Eh	WORD	first usable memory block found when allocating memory
 20h	WORD	best usable memory block found when allocating memory
 22h	WORD	last usable memory block found when allocating memory
 24h  2 BYTEs	??? (don't seem to be referenced)
 26h	WORD	???
 28h	BYTE	???
 29h	BYTE	???
 2Ah	BYTE	???
 2Bh	BYTE	??? flag of some kind
 2Ch	BYTE	??? flag of some kind
 2Dh	BYTE	??? (doesn't seem to be referenced)
 2Eh	BYTE	day of month
 2Fh	BYTE	month
 30h	WORD	year - 1980
 32h	WORD	number of days since 1-1-1980
 32h	BYTE	day of week (0 = Sunday)
 35h	BYTE	???
 36h	BYTE	??? flag
 37h	BYTE	??? flag
 38h 26 BYTEs	device driver request header
 52h	DWORD	pointer to device driver entry point (used in calling driver)
 56h 22 BYTEs	device driver request header
 6Ch 22 BYTEs	device driver request header
 82h	BYTE	type of PSP copy (00h=simple for INT 21/AH=26h, FFh=make child)
 83h	BYTE	??? apparently not reference by kernel
 84h	WORD	???
 86h	WORD	???
 88h  2 BYTEs	???
 8Ah  6 BYTEs	CLOCK$ transfer record (see AH=52h)
 90h  2 BYTEs	???
 92h 128 BYTEs	buffer for filename
112h 128 BYTEs	buffer for filename
192h 21 BYTEs	findfirst/findnext search data block (see AH=4Eh)
1A7h 32 BYTEs	directory entry for found file
1C7h 81 BYTEs	copy of current directory structure for drive being accessed
218h 11 BYTEs	??? FCB-format filename
223h	BYTE	???
224h 11 BYTEs	wildcard destination specification for rename (FCB format)
22Fh  2 BYTEs	???
231h	WORD	???
233h  5 BYTEs	???
238h	BYTE	directory search attributes
239h	BYTE	type of FCB (00h regular, FFh extended)
23Ah	BYTE	extended FCB file attribute
23Bh	BYTE	file open mode???
23Ch	BYTE	??? flag bits
23Dh	BYTE	??? flag or counter
23Eh	BYTE	??? flag
23Fh	BYTE	flag indicating how DOS function was invoked
		(00h = direct INT 20/INT 21, FFh = server call AX=5D00h)
240h	WORD	???
242h	BYTE	???
243h	BYTE	???
244h	BYTE	???
245h	BYTE	??? flag or counter
246h	BYTE	??? flag
247h	BYTE	??? flag
248h	BYTE	??? flag
249h	BYTE	type of process termination (00h-03h)
24Ah	BYTE	??? flag
24Bh	BYTE	value with which to replace first byte of deleted file's name
		(normally E5h, but 00h as described under INT 21/AH=13h)
24Ch	DWORD	pointer to Drive Parameter Block for critical error invocation
250h	DWORD	pointer to stack frame containing user registers on INT 21
254h	WORD	stores SP???
256h	DWORD	pointer to DOS Drive Parameter Block for ???
25Ah	WORD	???
25Ch	WORD	???
25Eh	WORD	??? flag
260h	WORD	???
262h	BYTE	Media ID byte returned by AH=1Bh,1Ch
263h	BYTE	??? (doesn't seem to be referenced)
264h	DWORD	pointer to ???
268h	DWORD	pointer to current SFT
26Ch	DWORD	pointer to current directory structure for drive being accessed
270h	DWORD	pointer to caller's FCB
274h	WORD	???
276h	WORD	temporary storage for file handle
278h	DWORD	pointer to a JFT entry in process handle table (see AH=26h)
27Ch	WORD	offset in DOS CS of first filename argument
27Eh	WORD	offset in DOS CS of second filename argument
280h	WORD	???
282h	WORD	???
284h	WORD	???
286h	WORD	???
288h	WORD	???
28Ah	WORD	???
28Ch	WORD	???
28Eh  2 BYTEs	???
290h	WORD	???
292h	DWORD	current offset in file
296h	WORD	???
298h	WORD	???
29Ah	WORD	???
29Ch	WORD	???
29Eh	WORD	???
2A0h	WORD	???
2A2h	DWORD	number of bytes appended to file
2A6h	DWORD	pointer to ??? disk buffer
2AAh	DWORD	pointer to ??? SFT
2AEh	WORD	used by INT 21 dispatcher to store caller's BX
2B0h	WORD	used by INT 21 dispatcher to store caller's DS
2B2h	WORD	temporary storage while saving/restoring caller's registers
2B4h	DWORD	pointer to prev call frame (offset 250h) if INT 21 reentered
		also switched to for duration of INT 24
2B8h 21 BYTEs	FindFirst search data for source file(s) of a rename operation
		(see AH=4Eh)
2CDh 32 BYTEs	directory entry for file being renamed
2EDh 331 BYTEs	critical error stack
438h 384 BYTEs	disk stack (functions greater than 0Ch, INT 25, INT 26)
5B8h 384 BYTEs	character I/O stack (functions 01h through 0Ch)
---DOS 3.3 only---
738h	BYTE	flag affecting AH=08h (see AH=64h)
739h	BYTE	??? looks like a drive number
73Ah	BYTE	??? flag of some kind
73Ah	BYTE	???
---------------------------------------------
INT 21 - DOS 3.1+ network - GET REDIRECTED PRINTER MODE
	AX = 5D07h
Return: DL = mode
	    00h redirected output is combined
	    01h redirected output in separate print jobs
SeeAlso: AX=5D08h,AX=5D09h, INT 2F/AX=1125h
---------------------------------------------
INT 21 - DOS 3.1+ network - SET REDIRECTED PRINTER MODE
	AX = 5D08h
	DL = mode
	    00h redirected output is combined
	    01h redirected output placed in separate jobs, start new print job
		now
SeeAlso: AX=5D07h,AX=5D09h, INT 2F/AX=1125h
---------------------------------------------
INT 21 - DOS 3.1+ network - FLUSH REDIRECTED PRINTER OUTPUT
	AH = 5D09h
Note:	forces redirected printer output to be printed, and starts a new print
	  job
SeeAlso: AX=5D07h,AX=5D08h, INT 2F/AX=1125h
---------------------------------------------
INT 21 - DOS 3.1+ internal - SET EXTENDED ERROR INFORMATION
	AX = 5D0Ah
	DS:DX -> 11-word DOS parameter list (see AX=5D00h)
Return: nothing.  next call to AH=59h will return values from fields AX,BX,CX,
	  DX,DI, and ES in corresponding registers
SeeAlso: AH=59h
---------------------------------------------
INT 21 - DOS 4.x internal - GET DOS SWAPPABLE DATA AREAS
	AX = 5D0Bh
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    DS:SI -> swappable data area list (see below)
Note:	copying and restoring the swappable data areas allows DOS to be
	  reentered unless it is in a critical section delimited by calls to
	  INT 2A/AH=80h and INT 2A/AH=81h,82h
SeeAlso: AX=5D06h, INT 2A/AH=80h,81h,82h

Format of swappable data area list:
Offset	Size	Description
 00h	WORD	count of data areas
 02h  N BYTEs	"count" copies of data area record
		Offset	Size	Description
		 00h	DWORD	address
		 04h	WORD	length and type
				bit 15 set if swap always, clear if swap in DOS
				bits 14-0: length in bytes

Format of PCDOS 4.01 swappable data area:
Offset	Size	Description
 00h	BYTE	critical error flag
 01h	BYTE	InDOS flag (count of active INT 21 calls)
 02h	BYTE	??? drive number or FFh
 03h	BYTE	locus of last error
 04h	WORD	extended error code of last error
 06h	BYTE	suggested action for last error
 07h	BYTE	class of last error
 08h	DWORD	ES:DI pointer for last error
 0Ch	DWORD	current DTA
 10h	WORD	current PSP
 12h	WORD	stores SP across an INT 23
 14h	WORD	return code from last process termination (zerod after reading
		with AH=4Dh)
 16h	BYTE	current drive
 17h	BYTE	extended break flag
 18h  2 BYTEs	???
---remainder need only be swapped if in DOS---
 1Ah	WORD	value of AX on call to INT 21
 1Ch	WORD	PSP segment for sharing/network
 1Eh	WORD	network machine number for sharing/network (0000h = us)
 20h	WORD	first usable memory block found when allocating memory
 22h	WORD	best usable memory block found when allocating memory
 24h	WORD	last usable memory block found when allocating memory
 26h  2 BYTEs	??? (don't seem to be referenced)
 28h	WORD	???
 2Ah	BYTE	???
 2Bh	BYTE	???
 2Ch	BYTE	???
 2Dh	BYTE	???
 2Eh	BYTE	???
 2Fh	BYTE	??? (doesn't seem to be referenced)
 30h	BYTE	day of month
 31h	BYTE	month
 32h	WORD	year - 1980
 34h	WORD	number of days since 1-1-1980
 36h	BYTE	day of week (0 = Sunday)
 37h	BYTE	???
 38h	BYTE	???
 39h	BYTE	???
 38h 30 BYTEs	device driver request header
 58h	DWORD	pointer to device driver entry point (used in calling driver)
 5Ch 22 BYTEs	device driver request header
 72h 30 BYTEs	device driver request header
 90h  6	BYTEs	???
 96h  6 BYTEs	CLOCK$ transfer record (see AH=52h)
 9Ch  2 BYTEs	???
 9Eh 128 BYTEs	buffer for filename
11Eh 128 BYTEs	buffer for filename
19Eh 21 BYTEs	findfirst/findnext search data block (see AH=4Eh)
1B3h 32 BYTEs	directory entry for found file
1D3h 88 BYTEs	copy of current directory structure for drive being accessed
22Bh 11 BYTEs	??? FCB-format filename
236h	BYTE	???
237h 11 BYTEs	wildcard destination specification for rename (FCB format)
242h  2 BYTEs	???
244h	WORD	???
246h  5 BYTEs	???
24Bh	BYTE	???
24Ch	BYTE	???
24Dh	BYTE	attribute mask for directory search???
24Eh	BYTE	???
24Fh	BYTE	??? flag bits
250h	BYTE	???
251h	BYTE	???
252h	BYTE	flag indicating how DOS function was invoked
		(00h = direct INT 20/INT 21, FFh = server call AX=5D00h)
253h	BYTE	???
254h	BYTE	???
255h	BYTE	???
256h	BYTE	???
257h	BYTE	???
258h	BYTE	???
259h	BYTE	???
25Ah	BYTE	???
25Bh	BYTE	???
25Ch	BYTE	type of process termination (00h-03h)
25Dh	BYTE	???
25Eh	BYTE	???
25Fh	BYTE	???
260h	DWORD	pointer to Drive Parameter Block for critical error invocation
264h	DWORD	pointer to stack frame containing user registers on INT 21
268h	WORD	stores SP???
26Ah	DWORD	pointer to DOS Drive Parameter Block for ???
26Eh	WORD	segment of disk buffer
270h	WORD	???
272h	WORD	???
274h	WORD	???
276h	WORD	???
278h	BYTE	Media ID byte returned by AH=1Bh,1Ch
279h	BYTE	??? (doesn't seem to be referenced)
27Ah	DWORD	pointer to ???
27Eh	DWORD	pointer to current SFT
282h	DWORD	pointer to current directory structure for drive being accessed
286h	DWORD	pointer to caller's FCB
28Ah	WORD	???
28Ch	WORD	???
28Eh	DWORD	pointer to a JFT entry in process handle table (see AH=26h)
292h	WORD	offset in DOS CS of first filename argument
294h	WORD	offset in DOS CS of second filename argument
296h	WORD	???
298h	WORD	???
29Ah	WORD	???
29Ch	WORD	???
29Eh	WORD	???
2A0h	WORD	???
2A2h	WORD	??? directory cluster number???
2A4h	DWORD	???
2A8h	DWORD	???
2ACh	WORD	???
2AEh	DWORD	offset in file???
2B2h	WORD	???
2B4h	WORD	bytes in partial sector
2B6h	WORD	number of sectors
2B8h	WORD	???
2BAh	WORD	???
2BCh	WORD	???
2BEh	DWORD	number of bytes appended to file
2C2h	DWORD	pointer to ??? disk buffer
2C6h	DWORD	pointer to ??? SFT
2CAh	WORD	used by INT 21 dispatcher to store caller's BX
2CCh	WORD	used by INT 21 dispatcher to store caller's DS
2CEh	WORD	temporary storage while saving/restoring caller's registers
2D0h	DWORD	pointer to prev call frame (offset 264h) if INT 21 reentered
		also switched to for duration of INT 24
2D4h	WORD	???
2D6h	BYTE	???
2D7h	WORD	???
2D9h	DWORD	pointer to ???
2DDh	WORD	???
2DFh	WORD	???
2E1h	WORD	???
2E3h	DWORD	???
2E7h	WORD	???
2E9h	WORD	???
2EBh	BYTE	???
2ECh	WORD	stores DS during call to [List-of-Lists + 37h]
2EEh	WORD	???
2F0h	BYTE	???
2F1h	WORD	??? bit flags
2F3h	DWORD	pointer to user-supplied filename
2F7h	DWORD	pointer to ???
2FBh	WORD	stores SS during call to [List-of-Lists + 37h]
2FDh	WORD	stores SP during call to [List-of-Lists + 37h]
2FFh	BYTE	flag, nonzero if stack switched in calling [List-of-Lists+37h]
300h 21 BYTEs	FindFirst search data for source file(s) of a rename operation
		(see AH=4Eh)
315h 32 BYTEs	directory entry for file being renamed
335h 331 BYTEs	critical error stack
480h 384 BYTEs	disk stack (functions greater than 0Ch, INT 25, INT 26)
600h 384 BYTEs	character I/O stack (functions 01h through 0Ch)
780h	BYTE	flag affecting AH=08h (see AH=64h)
781h	BYTE	??? looks like a drive number
782h	BYTE	??? flag of some kind
783h	BYTE	???
784h	WORD	???
786h	WORD	???
788h	WORD	???
78Ah	WORD	???
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET MACHINE NAME
	AX = 5E00h
	DS:DX -> buffer for blank-padded ASCIZ name (16 bytes)
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
	CH = 00h if name not defined
	  <> 00h defined
		CL = NETBIOS name number
		DS:DX buffer filled with ASCIZ machine name
SeeAlso: AX=5E01h
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - SET MACHINE NAME
	AX = 5E01h
	CH = 00h undefine name
	   <> 0  define name
	CL = name number
	DS:DX -> 15-character blank-padded ASCIZ name
SeeAlso: AX=5E00h
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - SET PRINTER SETUP
	AX = 5E02h
	BX = redirection list index
	CX = length of setup string (<= 64)
	DS:SI -> string buffer
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
	CF clear if successful
SeeAlso: AX=5E03h, INT 2F/AX=111Fh
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET PRINTER SETUP
	AX = 5E03h
	BX = redirection list index
	ES:DI -> string buffer
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
	CX = length of setup string (<= 64)
SeeAlso: AX=5E02h, INT 2F/AX=111Fh
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - SET PRINTER MODE
	AX = 5E04h
	BX = redirection list index
	DX = mode
	    bit 0: set if binary, clear if text (tabs expanded to blanks)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Note:	calls INT 2F/AX=111Fh with 5E04h on stack
SeeAlso: AX=5E05h, INT 2F/AX=111Fh
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET PRINTER MODE
	AX = 5E05h
	BX = redirection list index
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    DX = printer mode (see AX=5E04h)
Note:	calls INT 2F/AX=111Fh with 5E05h on stack
SeeAlso: AX=5E04h, INT 2F/AX=111Fh
---------------------------------------------
INT 21 - DOS 3.1 + network - GET REDIRECTION MODE
	AX = 5F00h
	BL = redirection type
	    03h printer
	    04h disk drive
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    BH = redirection state
		00h off
		01h on
SeeAlso: AX=5F01h
---------------------------------------------
INT 21 - DOS 3.1 + network - SET REDIRECTION MODE
	AX = 5F01h
	BL = redirection type
	    03h printer
	    04h disk drive
	BH = redirection state
	    00h off
	    01h on
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Note:	when redirection is off, the local device (if any) rather than the
	  remote device is used
SeeAlso: AX=5F00h, INT 2F/AX=111Eh
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks, VINES - GET REDIRECTION LIST ENTRY
	AX = 5F02h
	BX = redirection list index
	DS:SI -> 16 char local device name buffer
	ES:DI -> 128 char network name buffer
Return: CF set on error
	    AX = error code (01h,12h) (see AH=59h)
	CF clear if successful
	    BH = device status flag (bit 0 = 0 if valid)
	    BL = device type (03h if printer, 04h if drive)
	    CX = stored parameter value (user data)
	    DS:SI and ES:DI buffers filled
Notes:	DX and BP are destroyed by this call!
	error code 12h is returned if BX is greater than the size of the list
SeeAlso: AX=5F03h, INT 2F/AX=111Eh
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks, Banyan VINES - REDIRECT DEVICE
	AX = 5F03h
	BL = device type
		03h = printer device
		04h = file device
	CX = stored parameter value
	DS:SI -> ASCIZ source device name
	ES:DI -> destination ASCIZ network path + ASCIZ password
Return: CF set on error
	    AX = error code (01h,03h,05h,08h,54h,55h,57h) (see AH=59h)
	CF clear if successful
SeeAlso: AX=5F02h,AX=5F04h, INT 2F/AX=111Eh
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks, Banyan VINES - CANCEL REDIRECTION
	AX = 5F04h
	DS:SI -> ASCIZ device name or network path
Return: CF set on error
	    AX = error code (01h,0Fh,57h) (see AH=59h)
	CF clear if successful
SeeAlso: AX=5F03h, INT 2F/AX=111Eh
---------------------------------------------
INT 21 - DOS 4.x + Microsoft Networks - GET REDIRECTION LIST EXTENDED ENTRY
	AX = 5F05h
	BX = redirection list index
	DS:SI -> buffer for ASCIZ source device name
	ES:DI -> buffer for destination ASCIZ network path
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    BH = device status flag (bit 0 clear if valid)
	    BL = device type (03h if printer, 04h if drive)
	    CX = stored parameter value (user data)
	    BP = NETBIOS local session number
	    DS:SI buffer filled
	    ES:DI buffer filled
Notes:	the local session number allows sharing the redirector's session number
	if an error is caused on the NETBIOS LSN, the redirector may be unable
	  to correctly recover from errors
SeeAlso: INT 2F/AX=111Eh
---------------------------------------------
INT 21 - Network - GET REDIRECTION LIST???
	AX = 5F06h
	???
Return: ???
Note:	appears to be similar to AX=5F02h and AX=5F05h
SeeAlso: AX=5F05h, INT 2F/AX=111Eh
---------------------------------------------
INT 21 - LANtastic - GET LOGIN ENTRY
	AX = 5F80h
	BX = login entry index (0-based)
	ES:DI -> 16-byte buffer for machine name
Return: CF clear if successful
	    buffer filled with machine name ("\\" prefix removed)
	    DL = adapter number (v3+)
	CF set on error
	    AX = error code
	BX = next login entry index (BX-1 is current index)
---------------------------------------------
INT 21 - LANtastic - LOGIN TO SERVER
	AX = 5F81h
	ES:DI -> ASCIZ login path followed immediately by ASCIZ password
	BL = adapter number
	    FFh try all valid adapters
	    00h-03h try only specified adapter
Return: CF clear if successful
	CF set on error
	    AX = error code
Note:	login path is of form "\\machine\username"
SeeAlso: AX=5F82h,AX=5F84h
---------------------------------------------
INT 21 - LANtastic - LOGOUT FROM SERVER
	AX = 5F82h
	ES:DI -> ASCIZ server name (in form "\\machine")
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5F81h
---------------------------------------------
INT 21 - LANtastic - GET USERNAME ENTRY
	AX = 5F83h
	BX = login entry index (0-based)
	ES:DI -> 16-byte buffer for username currently logged into
Return: CF clear if successful
	    DL = adapter number (v3+)
	CF set on error
	    AX = error code
	BX = next login entry index (BX-1 is current index)
---------------------------------------------
INT 21 - LANtastic - GET INACTIVE SERVER ENTRY
	AX = 5F84h
	BX = server index not currently logged into
	ES:DI -> 16-byte buffer for server name which is available for logging
		in to ("\\" prefix omitted)
Return: CF clear if successful
	    DL = adapter number to non-logged in server is on
	CF set on error
	    AX = error code
SeeAlso: AX=5F81h
---------------------------------------------
INT 21 - LANtastic - CHANGE PASSWORD
	AX = 5F85h
	ES:DI -> buffer containing "\\machine\oldpassword" 00h "newpassword"00h
Return: CF clear if successful
	CF set on error
	    AX = error code
Note:	must be logged into the named machine
---------------------------------------------
INT 21 - LANtastic - DISABLE ACCOUNT
	AX = 5F86h
	ES:DI -> ASCIZ machine name and password in form "\\machine\password"
Return: CF clear if successful
	CF set on error
	    AX = error code
Note:	must be logged into the named machine and concurrent logins set to 1
	  by NET_MGR.  Requires system manager to re-enable account.
---------------------------------------------
INT 21 - LANtastic v3+ - GET ACCOUNT
	AX = 5F87h
	DS:SI -> 128-byte buffer for account information (see below)
	ES:DI -> ASCIZ machine name in form "\\machine"
Return:	CF clear if successful
	CF set on error
	    AX = error code
	BX destroyed
Note:	must be logged into the specified machine

Format of user account structure:
Offset	Size	Description
 00h 16 BYTEs	blank-padded username
 10h 16 BYTEs	reserved (00h)
 20h 32 BYTEs	user description
 40h	BYTE	privilege bits
		bit 7: bypass access control lists
		    6: bypass queue protection
		    5: treat as local process
		    4: bypass mail protection
		    3: allow audit entry creation
		    2: system manager
 41h	BYTE	maximum concurrent users
 42h 42 BYTEs	bit map for disallowed half hours, beginning on Sunday
		(bit set if half-hour not an allowed time)
 6Ch	WORD	internal (0002h)
 6Eh  2 WORDs	last login time
 72h  2 WORDs	account expiration date (MSDOS-format year/month:day)
 76h  2 WORDs	password expiration date (0 = none)
 7Ah	BYTE	number of days to extend password after change (1-31)
 7Bh  5 BYTEs	reserved
---------------------------------------------
INT 21 - LANtastic - COPY FILE
	AX = 5F97h
	CX:DX = number of bytes to copy (FFFFFFFFh = entire file)
	SI = source file handle
	DI = destination file handle
Return: CF clear if successful
	    AX:DX = number of bytes copied
	CF set on error
	    AX = error code
Note:	copy is performed by server
---------------------------------------------
INT 21 - LANtastic - SEND UNSOLICITED MESSAGE
	AX = 5F98h
	DS:SI -> message buffer (see below)
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5F99h

Format of message buffer:
Offset	Size	Description
 00h	BYTE	reserved
 01h	BYTE	message type
		00h general 
		01h server warning
		02h-7Fh reserved
		80h-FFh user-defined
 02h 16 BYTEs	ASCIZ destination machine name
 12h 16 BYTEs	ASCIZ server name which user must be logged into
 22h 16 BYTEs	ASCIZ user name
 32h 16 BYTEs	ASCIZ originating machine name (filled in when received)
 42h 80 BYTEs	message text
---------------------------------------------
INT 21 - LANtastic - GET LAST RECEIVED UNSOLICITED MESSAGE
	AX = 5F99h
	ES:DI -> messsage buffer (see AX=5F98h for format)
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5F98h
---------------------------------------------
INT 21 - LANtastic - GET MESSAGE PROCESSING FLAG
	AX = 5F9Ah
Return: CF clear if successful
	    DL = bits describing processing for received unsolicited messages
		bit 0: beep before message is delivered
		    1: deliver message to message service
		    2: pop up message automatically (v3+)
	CF set on error
	    AX = error code
SeeAlso: AX=5F9Bh,AX=5F9Ch
---------------------------------------------
INT 21 - LANtastic - SET MESSAGE PROCESSING FLAG
	AX = 5F9Bh
	DL = bits describing processing for received unsolicited messages
	     (see AX=5F9Ah)
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5F9Ah
---------------------------------------------
INT 21 - LANtastic v3+ - POP UP LAST RECEIVED MESSAGE
	AX = 5F9Ch
	CX = time to leave on screen in clock ticks
	DH = 0-based screen line on which to place message
Return:	CF clear if successful
	CF set on error
	    AX = error code (0Bh)
Note:	the original screen contents are restored when the message is removed
SeeAlso: AX=5F9Ah
---------------------------------------------
INT 21 - LANtastic - GET QUEUE ENTRY
	AX = 5FA0h
	BX = queue entry index (0000h is first entry)
	DS:SI -> buffer for queue entry (see below)
	ES:DI -> ASCIZ server name in form "\\name"
Return: CF clear if successful
	CF set on error
	    AX = error code
	BX = entry index for next queue entry (BX-1 is current index)
SeeAlso: AX=5FA1h,5FA2h

Format of queue entry:
Offset	Size	Description
 00h	BYTE	status of entry
		00h empty
		01h being updated
		02h being held
		03h waiting for despool
		04h being despooled
		05h canceled
		06h spooled file could not be accessed
		07h destination could not be accessed
		08h rush job
 01h	DWORD	size of spooled file
 05h	BYTE	type of entry
		00h printer queue file
		01h message
		02h local file
		03h remote file
		04h to remote modem
		05h batch processor file
 06h	BYTE	output control
		bit 6: don't delete (for mail)
		bit 5: mail file contains voice mail (v3+)
 07h	WORD	number of copies
 09h	DWORD	sequence number of queue entry
 0Dh 48 BYTEs	pathname of spooled file
 3Dh 16 BYTEs	user who spooled file
 4Dh 16 BYTEs	name of machine from which file was spooled
 5Dh	WORD	date file was spooled (see AX=5700h)
 5Fh	WORD	time file was spooled (see AX=5700h)
 61h 17 BYTEs	ASCIZ destination device or user name
 72h 48 BYTEs	comment field
---------------------------------------------
INT 21 - LANtastic - SET QUEUE ENTRY
	AX = 5FA1h
	BX = handle of opened queue entry
	DS:SI -> queue entry (see AX=5FA0h)
Return: CF clear if successful
	CF set on error
	    AX = error code
Note:	the only queue entry fields which may be changed are output control,
	  number of copies, destination device, and comment
SeeAlso: AX=5FA0h,5FA2h
---------------------------------------------
INT 21 - LANtastic - CONTROL QUEUE
	AX = 5FA2h
	BL = control command
	    00h start despooling (privileged)
	    01h halt despooling (privileged)
	    02h halt despooling at end of job (privileged)
	    03h pause despooler at end of job (privileged)
	    04h print single job (privileged)
	    05h restart current job (privileged)
	    06h cancel the current job
	    07h hold queue entry
	    08h release a held queue entry
	    09h make queue entry a rushed job (privileged)
	CX:DX = sequence number to control (commands 06h-09h)
	DX = physical printer number (commands 00h-05h)
	    00h-02h LPT1-LPT3
	    03h,04h COM1,COM2
	    other	all printers
	ES:DI -> ASCIZ computer name
Return: CF clear if successful
	CF set on error
	    AX = error code
---------------------------------------------
INT 21 - LANtastic v3+ - GET PRINTER STATUS
	AX = 5FA3h
	BX = physical printer number (00h-02h = LPT1-LPT3, 03h-04h = COM1-COM2)
	DS:SI -> buffer for printer status (see below)
	ES:DI -> ASCIZ server name in form "\\machine"
Return: CF clear if successful
	CF set on error
	    AX = error code
	BX = next physical printer number

Format of printer status:
Offset	Size	Description
 00h	BYTE	printer state
		bit 7: printer paused
		bits 0-6: 0 printer disabled
			  1 will stop at end of job
			  2 print multiple jobs
 01h	WORD	queue index of print job being despooled
		FFFFh if not despooling--ignore all following fields
 03h	WORD	actual characters per second being output
 05h	DWORD	number of characters actually output so far
 09h	DWORD	number of bytes read from spooled file so far
 0Dh	WORD	copies remaining to print
---------------------------------------------
INT 21 - LANtastic v3+ - GET STREAM INFO
	AX = 5FA4h
	BX = 0-based stream index number
	DS:SI -> buffer for stream information (see below)
	ES:DI -> ASCIZ machine name in form "\\machine"
Return: CF clear if successful
	CF set on error
	    AX = error code
	BX = next stream number
SeeAlso: AX=5FA5h

Format of stream information:
Offset	Size	Description
 00h	BYTE	queueing of jobs for logical printer (0=disabled,other=enabled)
 01h 11 BYTEs	logical printer resourse template (may contain ? wildcards)
---------------------------------------------
INT 21 - LANtastic v3+ - SET STREAM INFO
	AX = 5FA5h
	BX = 0-based stream index number
	DS:SI -> buffer containing stream information (see AX=5FA4h)
	ES:DI -> ASCIZ machine name in form "\\machine"
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5FA4h
---------------------------------------------
INT 21 - LANtastic - CREATE USER AUDIT ENTRY
	AX = 5FA7h
	DS:DX -> ASCIZ reason code (max 8 bytes)
	DS:SI -> ASCIZ variable reason code (max 128 bytes)
	ES:DI -> ASCIZ machine name in form "\\machine"
Return: CF clear if successful
	CF set on error
	    AX = error code
---------------------------------------------
INT 21 - LANtastic - GET ACTIVE USER INFORMATION
	AX = 5FB0h
	BX = server login entry index
	DS:SI -> buffer for active user entry (see below)
	ES:DI -> ASCIZ machine name in form "\\server"
Return: CF clear if successful
	CF set on error
	    AX = error code
	BX = next login index

Format of active user entry:
Offset	Size	Description
 00h	WORD	virtual circuit number
 02h	BYTE	login state
		bit 0: fully logged in
		    1: remote program load login
		    3: user can create audit entries
		    4: bypass mail protection
		    5: treat as local process
		    6: bypass queue protection
		    7: bypass access control lists
 03h	BYTE	last command issued (see below)
 04h  5 BYTEs	number of I/O bytes (40-bit unsigned number)
 09h  3 BYTEs	number of server requests (24-bit unsigned)
 0Ch 16 BYTEs	name of user who is logged in
 1Ch 16 BYTEs	name of remote logged in machine

Values for last command:
 00h	login
 01h	process termination
 02h	open file
 03h	close file
 04h	create file
 05h	create new file
 06h	create unique file
 07h	commit data to disk
 08h	read file
 09h	write file
 0Ah	delete file
 0Bh	set file attributes
 0Ch	lock byte range
 0Dh	unlock byte range
 0Eh	create subdirectory
 0Fh	remove subdirectory
 10h	rename file
 11h	find first matching file
 12h	find next matching file
 13h	get disk free space
 14h	get a queue entry
 15h	set a queue entry
 16h	control the queue
 17h	return login information
 18h	return link description
 19h	seek on file
 1Ah	get server's time
 1Bh	create audit entry
 1Ch	open file in multitude of modes
 1Dh	change password
 1Eh	disable account
 1Fh	local server file copy
---v3+---
 20h	get username from account file
 21h	translate server's logical path
 22h	make indirect file
 23h	get indirect file contents
 24h	get physical printer status
 25h	get logical print stream info
 26h	set logical print stream info
 27h	get user's account record
---------------------------------------------
INT 21 - LANtastic - GET SHARED DIRECTORY INFORMATION
	AX = 5FB1h
	DS:SI -> 64-byte buffer for link description
	ES:DI -> ASCIZ machine and shared directory name in form
		 "\\machine\shared-resource"
Return: CF clear if successful
	    CX = access control list privilege bits for requesting user
		bit 5: allow attribute changing
		    6: allow physical access to device
		    7: allow program execution
		    8: allow file renaming
		    9: allow directory deletion
		   10: allow file deletion
		   11: allow file/directory lookups
		   12: allow directory creation
		   13: allow file creation
		   14: allow open for write and writing
		   15: allow open for read and reading
	CF set on error
	    AX = error code
---------------------------------------------
INT 21 - LANtastic v3+ - GET USERNAME FROM ACCOUNT FILE
	AX = 5FB2h
	BX = username entry index (0 for first)
	DS:SI -> 16-byte buffer for username
	ES:DI -> ASCIZ server name in form "\\machine"
Return: CF clear if successful
	CF set on error
	    AX = error code
	BX = next queue entry index
---------------------------------------------
INT 21 - LANtastic v3+ - TRANSLATE PATH
	AX = 5FB3h
	DS:SI -> 128-byte buffer for ASCIZ result
	ES:DI -> full ASCIZ path, including server name
	DX = types of translation to be performed
	    bit 0: expand last component as indirect file
		1: return actual path relative to server's physical disk
Return: CF clear if successful
	CF set on error
	    AX = error code
Note:	always expands any indirect files along the path
SeeALso: AX=5FB4h
---------------------------------------------
INT 21 - LANtastic v3+ - CREATE INDIRECT FILE
	AX = 5FB4h
	DS:SI -> 128-byte buffer containing ASCIZ contents of indirect file
	ES:DI -> full ASCIZ path of indirect file to create, incl machine name
Return: CF clear if successful
	CF set on error
	    AX = error code
Note:	the contents of the indirect file may be any valid server-relative path
---------------------------------------------
INT 21 - LANtastic v3+ - GET INDIRECT FILE CONTENTS
	AX = 5FB5h
	DS:SI -> 128-byte buffer for ASCIZ indirect file contents
	ES:DI -> full ASCIZ path of indirect file
Return: CF clear if successful
	CF set on error
	    AX = error code
---------------------------------------------
INT 21 - LANtastic - GET TIME FROM SERVER
	AX = 5FC0h
	DS:SI -> time block (see below)
	ES:DI -> ASCIZ server name to get time from
Return: CF clear if successful
	CF set on error
	    AX = error code

Format of time block:
Offset	Size	Description
 00h	WORD	year
 02h	BYTE	day
 03h	BYTE	month
 04h	BYTE	minutes
 05h	BYTE	hour
 06h	BYTE	hundredths of second
 07h	BYTE	second
---------------------------------------------
INT 21 - LANtastic - GET REDIRECTED PRINTER TIMEOUT
	AX = 5FD0h
Return: CF clear if successful
	    CX = redirected printer timeout in clock ticks of 55ms
		0000h if timeout disabled
	CF set on error
	    AX = error code
SeeAlso: AX=5FD1h
---------------------------------------------
INT 21 - LANtastic - SET REDIRECTED PRINTER TIMEOUT
	AX = 5FD1h
	CX = printer timeout in clock ticks of 55ms, 0000h to disable timeouts
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5FD0h
---------------------------------------------
INT 21 - LANtastic - GET DOS SERVICE VECTOR
	AX = 5FE0h
Return: CF clear if successful
	    ES:BX -> current FAR service routine
	CF set on error
	    AX = error code
SeeAlso: AX=5FE1h
---------------------------------------------
INT 21 - LANtastic - SET DOS SERVICE VECTOR
	AX = 5FE1h
	ES:BX -> FAR routine to call for DOS service
Return: CF clear if successful
	CF set on error
	    AX = error code
Note:	new handler must chain to previous handler as its first action
SeeAlso: AX=5FE0h
---------------------------------------------
INT 21 - LANtastic - GET MESSAGE SERVICE VECTOR
	AX = 5FE2h
Return: CF clear if successful
	    ES:BX -> current FAR message service routine
	CF set on error
	    AX = error code
SeeAlso: AX=5FE3h
---------------------------------------------
INT 21 - LANtastic - SET MESSAGE SERVICE VECTOR
	AX = 5FE3h
	ES:BX -> FAR routine for processing network messages
Return: CF clear if successful
	CF set on error
	    AX = error code
Notes:	handler must chain to previous handler as its first action
	on invocation, ES:BX -> Network Control Block
SeeAlso: AX=5FE2h
---------------------------------------------
INT 21 - DOS 3+ internal - RESOLVE PATH STRING TO CANONICAL PATH STRING
	AH = 60h
	DS:SI -> ASCIZ relative path string or directory name
	ES:DI -> 128-byte buffer for ASCIZ canonical fully qualified name
Return: CF set on error
	    AX = error code 
		02h invalid source name
		03h invalid drive or malformed path
		others???
	CF clear if successful
	    AH = 00h
	    AL = destroyed (00h or 5Ch or last char of current dir on drive)
	    buffer filled with qualified name of form D:\PATH\FILE.EXT or
	      \\MACHINE\PATH\FILE.EXT
Notes:	the input path need not actually exist
	letters are uppercased, forward slashes converted to backslashes,
	  asterisks converted to appropriate number of question marks, and
	  file and directory names are truncated to 8.3 if necessary.
	'.' and '..' in the path are resolved
	filespecs on local drives always start with "d:", those on network
	  drives always start with "\\"
	if path string is on a JOINed drive, the returned name is the one that
	  would be needed if the drive were not JOINed; similarly for a
	  SUBSTed, ASSIGNed, or network drive letter.	Because of this, it is
	  possible to get a qualified name that is not legal under the current
	  combination of SUBSTs, ASSIGNs, JOINs, and network redirections
	functions which take pathnames require canonical paths if invoked via
	  INT 21/AX=5D00h
	supported by OS/2 v1.1 compatibility box
SeeAlso: INT 2F/AX=1123h,1221h
---------------------------------------------
INT 21 - DOS 3+ internal - UNUSED
	AH = 61h
Return: AL = 00h
---------------------------------------------
INT 21 - DOS 3+ - GET PSP ADDRESS
	AH = 62h
Return: BX = current PSP segment address (see AH=26h for format)
Notes:	under DOS 3+, this function does not use any of the DOS-internal stacks
	  and is thus fully reentrant
	identical to the undocumented AH=51h
SeeAlso: AH=50h, AH=51h
---------------------------------------------
INT 21 - DOS 2.25 only - GET LEAD BYTE TABLE (2-BYTE CHARACTER SUPPORT)
	AH = 63h
	AL = subfunction
	     00h get system lead byte table
		Return:	DS:SI -> lead byte table
	     01h set/clear interim console flag (determine whether interim
			bytes are returned on some console functions)
		DL = 01h/00h to set/clear interim console flag
	     02h get interim console flag
		Return:	DL = interim console flag
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
	CF clear if successful
Note:	does not preserve any registers other than SS:SP
---------------------------------------------
INT 21 - Asian DOS 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
	AX = 6300h
Return: AL = error code
	    00h successful
		DS:SI -> DBCS table (see below)
		BX, CX, DX, BP, DI, and ES destroyed
	    FFh not supported
Notes:	probably identical to AX=6300h for DOS 2.25
	The US version of DOS 4.0 accepts this function, but returns an empty
	  list

Format of DBCS table:
Offset	Size	Description
 00h  2 BYTEs	low/high ends of a range of leading byte of double-byte chars
 02h  2 BYTEs	low/high ends of a range of leading byte of double-byte chars
	...
  N   2 BYTEs	00h,00h end flag
---------------------------------------------
INT 21 - Asian DOS 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
	AX = 6301h
	DL = new mode
	    00h return only full characters on DOS keyboard input functions
	    01h	return partially-formed characters also
Return: AL = status
	    00h successful
	    FFh invalid mode
SeeAlso: AX=6302h
---------------------------------------------
INT 21 - Asian DOS 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
	AX = 6302h
Return: AL = status
	    00h successful
		DL = current input mode
		    00h return only full characters
		    01h return partial characters
	    FFh not supported
SeeAlso: AX=6301h
---------------------------------------------
INT 21 - DOS 3.2 internal - GET/SET ???
	AH = 64h
	AL = subfunction
	    00h get ???
		Return: DL = ???
	    01h set ???
		DL = ???
	    02h get and set ???
		DL = new ???
		Return: DL = old ???
---------------------------------------------
INT 21 - DOS 3.3+ internal - SET ???
	AH = 64h
	AL = flag
		00h  ??? 
	    nonzero  ??? 
Return: nothing
Notes:	affects operation of AH=08h
	called by DOS 3.3+ PRINT.COM
---------------------------------------------
INT 21 - DOS 3.3+ - GET EXTENDED COUNTRY INFORMATION
	AH = 65h
	AL = info ID
	    01h get general internationalization info
	    02h get pointer to uppercase table
	    04h get pointer to filename uppercase table
	    05h (DOS 3.3+ internal) get pointer to filename terminator table
	    06h get pointer to collating sequence table
	    07h (DOS 4.x) get pointer to Double-Byte Character Set table
	BX = code page (-1=global code page)
	DX = country ID (-1=current country)
	ES:DI -> country information buffer (see below)
	CX = size of buffer (>= 5)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if succesful
	    CX = size of country information returned
	    ES:DI -> country information
Notes:	AL=05h appears to return same info for all countries and codepages
	NLSFUNC must be installed to get info for countries other than the
	  default
SeeAlso: AH=38h,INT 2F/AX=1401h,1402h

Format of country information:
Offset	Size	Description
 00h	BYTE	info ID
---if info ID = 01h---
 01h	WORD	size
 03h	WORD	country ID
 05h	WORD	code page
 07h 34 BYTEs	country-dependent info (see AH=38h)
---if info ID = 02h---
 01h	DWORD	pointer to uppercase table (see below)
---if info ID = 04h---
 01h	DWORD	pointer to filename uppercase table (see below)
---if info ID = 05h---
 01h	DWORD	pointer to filename character table (see below)
---if info ID = 06h---
 01h	DWORD	pointer to collating table (see below)
---if info ID = 07h (DOS 4.x)---
 01h	DWORD	pointer to DBCS lead byte table (see below)

Format of uppercase table:
Offset	Size	Description
 00h	WORD	table size
 02h 128 BYTEs	uppercase equivalents (if any) of chars 80h to FFh

Format of collating table:
Offset	Size	Description
 00h	WORD	table size
 02h 256 BYTEs	values used to sort characters 00h to FFh

Format of filename terminator table:
Offset	Size	Description
 00h	WORD	table size
 02h  7 BYTEs	???  (01h 00h FFh 00h 00h 20h 02h in MSDOS 3.30)
 09h	BYTE	length of following data
 0Ah  N BYTES	characters which terminate a filename:	."/\[]:|<>+=;,

Format of filename uppercase table:
Offset	Size	Description
 00h	WORD	table size
 02h 128 BYTEs	uppercase equivalents (if any) of chars 80h to FFh

Format of DBCS lead byte table:
Offset	Size	Description
 00h	WORD	length
 02h 2N BYTEs	start/end for N lead byte ranges
	WORD	0000h	(end of table)
---------------------------------------------
INT 21 - DOS 4.x internal - COUNTRY-DEPENDENT CHARACTER CAPITALIZATION
	AH = 65h
	AL = function
	    20h capitalize character
		DL = character to capitalize
		Return: DL = capitalized character
	    21h capitalize string
		DS:DX -> string to capitalize
		CX = length of string
	    22h capitalize ASCIZ string
		DS:DX -> ASCIZ string to capitalize
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
---------------------------------------------
INT 21 - DOS 4.x internal - DETERMINE IF CHARACTER REPRESENTS YES/NO RESPONSE
	AX = 6523h
	DL = character
	DH = second character of double-byte character (if applicable)
Return: CF set on error
	CF clear if successful
	    AX = type
		00h no
		01h yes
		02h neither yes nor no
---------------------------------------------
INT 21 - DOS 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
	AH = 65h
	AL = function
	    A0h capitalize filename character
		DL = character to capitalize
		Return: DL = capitalized character
	    A1h capitalize counted filename string
		DS:DX -> filename string to capitalize
		CX = length of string
	    A2h capitalize ASCIZ filename
		DS:DX -> ASCIZ filename to capitalize
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Note:	nonfunctional in DOS 4.00 and 4.01 due to a bug
---------------------------------------------
INT 21 - DOS 3.3+ - GET GLOBAL CODE PAGE TABLE
	AX = 6601h
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    BX = active code page
	    DX = system code page
SeeAlso: AX=6602h
---------------------------------------------
INT 21 - DOS 3.3+ - SET GLOBAL CODE PAGE TABLE
	AX = 6602h
	BX = active code page
	    437  US
	    850  Multilingual
	    860  Portugal
	    863  Canada (French)
	    865  Norway/Denmark
	DX = system code page (active page at boot time)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
SeeAlso: AX=6601h
---------------------------------------------
INT 21 - DOS 3.3+ - SET HANDLE COUNT
	AH = 67h
	BX = desired number of handles (max 255)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
Notes:	if BX <= 20, no action is taken
	only the first 20 handles are copied to child processes in DOS 3.3
BUG:	the original release of DOS 3.30 allocates a full 64K for the handle
	  table on requests for an even number of handles
SeeAlso: AH=26h
---------------------------------------------
INT 21 - DOS 3.3+ - COMMIT FILE, WRITE ALL BUFFERED DATA TO DISK
	AH = 68h
	BX = file handle
Return: CF set on error 
	    AX = error code (see AH=59h)
	CF clear if successful
SeeAlso: AX=5D01h, INT 2F/AX=1107h
---------------------------------------------
INT 21 - DOS 4.0 internal - GET/SET DISK SERIAL NUMBER
	AH = 69h
	AL = subfunction
	    00h	get serial number
	    01h set serial number
	BL = drive (0=default, 1=A, 2=B, etc)
	DS:DX -> disk info (see below)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX destroyed
	    (AL = 00h) buffer filled with appropriate values from extended BPB
	    (AL = 01h) extended BPB on disk set to values from buffer
Notes:	does not generate a critical error; all errors are returned in AX
	error 0005h given if no extended BPB on disk
	does not work on network drives (error 0001h)
	buffer after first two bytes is exact copy of bytes 27h thru 3Dh of
	   extended BPB on disk

Format of disk info:
Offset	Size	Description
 00h	WORD	info level (zero)
 02h	DWORD	disk serial number (binary)
 06h 11 BYTEs	volume label or "NO NAME    " if none present
 11h  8 BYTEs	(AL=00h only) filesystem type--string "FAT12   " or "FAT16   "
---------------------------------------------
INT 21 - DOS 4.0 internal - ???
	AH = 6Ah
	???
Return: ???
Note:	may be equivalent to INT 21/AH=48h
---------------------------------------------
INT 21 - DOS 4.0 internal - ???
	AH = 6Bh
	AL = subfunction
	    00h ???
		DS:SI -> Current Directory Structure???
		CL = drive (1=A:)
	    01h ???
		DS:SI -> ???
		CL = file handle???
	    02h ???
		DS:SI -> Current Directory Structure???
		DI = ???
		CX = drive (1=A:)
	???
Return: CF set on error
	    AX = error code (see INT 21/AH=59h)
	CF clear if successful
Return: ???
Note:	passed through to INT 2F/AX=112Fh with AX on top of stack
SeeAlso: INT 2F/AX=112Fh
---------------------------------------------
INT 21 - DOS 4.0 - EXTENDED OPEN/CREATE
	AX = 6C00h
	BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
	    bit 7: inheritance
	    bits 4-6: sharing mode
	    bit 3 reserved
	    bits 0-2: access mode
	BH = flags
	    bit 6 = auto commit on write
	    bit 5 = return error rather than doing INT 24h
	CX = create attribute
	    bits 6-15 reserved
	    bit 5: archive
	    bit 4: reserved
	    bit 3: volume label
	    bit 2: system
	    bit 1: hidden
	    bit 0: readonly
	DL = action if file exists/does not exists
	    bits 7-4 action if file does not exist
		    0000 fail
		    0001 create
	    bits 3-0 action if file exists
		    0000 fail
		    0001 open
		    0010 replace/open
	DH = 00h (reserved)
	DS:SI -> ASCIZ file name
Return: CF set on error
	   AX = error code (see AH=59h)
	CF clear if successful
	   AX = file handle
	   CX = 1 file opened
		2 file created
		3 file replaced
Note:	the PC LAN Program only supports DL=01h, DL=10h/sharing=compatibility,
	  and DL=12h
SeeAlso: AH=3Ch,3Dh
---------------------------------------------
INT 21 - ???
	AH = 89h
	???
Note:	reportedly called by Microsoft C 4.0 startup code
---------------------------------------------
INT 21 - Attachmate Extra - GET 3270 DISPLAY STATE
	AH = A0h
Return: AL = display status
	    bit  7  : 0=windowed, 1=enlarged
	    bits 6-3: current screen profile number 0-9
	    bits 2-0: active window number
			0=PC, 1-4=host B-E, 5-6=notepad F-G
	BX = host window status
	    bit 15:  reserved
	    bit 14:  0=host E window installed, 1=not
	    bit 13:  0=host E terminal on, 1=off
	    bit 12:  0=host E window displayed, 1=not
	    bit 11:  reserved
	    bit 10:  0=host D window installed, 1=not
	    bit  9:  0=host D terminal on, 1=off
	    bit  8:  0=host D window displayed, 1=not
	    bit  7:  reserved
	    bit  6:  0=host C window installed, 1=not
	    bit  5:  0=host C terminal on, 1=off
	    bit  4:  0=host C window displayed, 1=not
	    bit  3:  reserved
	    bit  2:  0=host B window installed, 1=not
	    bit  1:  0=host B terminal on, 1=off
	    bit  0:  0=host B window displayed, 1=not
Note:	Attachmate Extra is a 3270 emulator by Attachmate Corporation
SeeAlso: AH=A1h
---------------------------------------------
INT 21 - Attachmate Extra - SET 3270 DISPLAY STATE
	AH = A1h
	AL = set status byte
	    bit  7  : 0=windowed, 1=enlarged
	    bits 6-3: current screen profile number 0-9
	    bits 2-0: active window number
			0=PC, 1-4=host B-E, 5-6=notepad F-G
SeeAlso: AH=A0h,AH=A2h
---------------------------------------------
INT 21 - Attachmate Extra - SET HOST WINDOW STATE
	AH = A2h
	AL = set status byte
	    bit  7  : 0=power off, 1=power on
	    bit  6  : 0=not installed, 1=installed
	    bits 5-3: reserved
	    bits 2-0: window number 1-4=host B-E
SeeAlso: AH=A1h
---------------------------------------------
INT 21 - Attachmate Extra - SEND KEYSTROKES TO HOST WINDOW
	AH = A3h
	AL = window number (1-4=host B-E)
	CX = 0001h
	DS:BX -> keystroke buffer
	DL = zero if keystroke buffer contains host function code,
	     non-zero if keystroke buffer contains ASCII character
Return: CX = zero if character sent, non-zero if not
	BX incremented if CX=0

Values for host function code:
	00h=reserved	10h=PF16	20h=Clear	30h=SysRq
	01h=PF1		11h=PF17	21h=Print	31h=ErInp
	02h=PF2		12h=PF18	22h=Left	32h=ErEof
	03h=PF3		13h=PF19	23h=Right	33h=Ident
	04h=PF4		14h=PF20	24h=Up		34h=Test
	05h=PF5		15h=PF21	25h=Down	35h=Reset
	06h=PF6		16h=PF22	26h=Home	36h=DevCncl
	07h=PF7		17h=PF23	27h=Fast Left	37h=Dup
	08h=PF8		18h=PF24	28h=Fast Right	38h=FldMark
	09h=PF9		19h=Alt on	29h=Bksp	39h=Enter
	0Ah=PF10	1Ah=Alt off	2Ah=Insert	3Ah=CrSel
	0Bh=PF11	1Bh=Shift on	2Bh=Delete
	0Ch=PF12	1Ch=Shift off	2Ch=Backtab
	0Dh=PF13	1Dh=PA1		2Dh=Tab
	0Eh=PF14	1Eh=PA2		2Eh=Newline
	0Fh=PF15	1Fh=PA3		2Fh=Attn
---------------------------------------------
INT 21 - Attachmate Extra - GET HOST WINDOW BUFFER ADDRESS
	AH = A4h
	AL = window number (1-4=host B-E)
Return: DS:BX -> 3270 display buffer
SeeAlso: AH=A5h,AH=B8h
---------------------------------------------
INT 21 - Attachmate Extra - GET HOST WINDOW CURSOR POSITION
	AH = A5h
	AL = window number (1-4=host B-E)
Return: BX = cursor position (80 * row + column, where 0:0 is upper left)
Note:	if the host window is configured with the Extended Attribute (EAB)
	  feature, multiply the cursor position by 2 to obtain the byte offset
	  into the display buffer
SeeAlso: AH=A4h
---------------------------------------------
INT 21 - Attachmate Extra - GET TRANSLATE TABLE ADDRESS
	AH = AFh
Return: DS:BX -> translate tables

Format of translate tables:
Offset	Size	Description
 00h 256 BYTEs	ASCII to 3270 buffer code translate table
100h 256 BYTEs	3270 buffer code to ASCII translate table
200h 256 BYTEs	3270 buffer code to EBCDIC translate table
300h 256 BYTEs	EBCDIC to 3270 buffer code translate table
---------------------------------------------
INT 21 - Novell NetWare shell 3.01 - TASK MODE CONTROL
	AH = B5h
	AL = subfunction
	    03h get task mode
		Return: AH = 00h
			AL = current task mode byte
	    04h get task mode pointer
		Return: ES:BX -> task mode byte
Notes:	the task mode byte specifies how task cleanup should be performed, but
	  is declared to be version-dependent
	allows a program to disable the automatic cleanup for programs managing
	  task swapping, etc.

Values for task mode byte in version 3.01:
 00h-03h reserved
 04h	 no task cleanup
---------------------------------------------
INT 21 - Novell NetWare SFT Level II - EXTENDED FILE ATTRIBUTES
	AH = B6h
	AL = subfunction
	    00h get extended file attributes
	    01h set extended file attributes
	CL = attributes
	    bit 4: transaction tracking file
		5: indexing file (to be implemented)
		6: read audit (to be implemented)
		7: write audit (to be implemented)
	DS:DX -> ASCIZ pathname
Return: CF set on error
	    AL = error code
		FFh file not found
		8Ch caller lacks privileges
	CL = current extended file attributes
SeeAlso: AX=4300h
---------------------------------------------
INT 21 - Novell Advanced NetWare 2.0+ - PRINT JOBS
	AH = B8h
	AL = subfunction
	    00h get default print job flags
	    01h set default capture flags
	    02h get specific capture flags
	    03h set specific print job flags
	    04h get default local printer
	    05h set default local printer
	    06h set capture print queue
	    07h set capture print job
	    08h get banner user name
	    09h set banner user name
	CX = buffer size
	ES:BX -> buffer
Return: none
---------------------------------------------
INT 21 - Attachmate Extra - DISABLE HOST BUFFER UPDATES
	AH = B8h
	AL = window number (1-4=host B-E)
	DL = 01h
Notes:	only valid in CUT mode
	next AID keystroke (eg Enter) enables host buffer updates
SeeAlso: AH=A4h
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SET END OF JOB STATUS
	AH = BBh
	AL = new EOJ flag
	    00h disable EOJs
	    otherwise enable EOJs
Return: AL = old EOJ flag
SeeAlso: AH=D6h
---------------------------------------------
INT 21 - Novell NetWare 4.6 - LOG/LOCK PHYSICAL RECORD
	AH = BCh
	AL = flags
	    bit 0: lock as well as log record
		1: non-exclusive lock
	BX = file handle
	CX:DX = offset
	BP = timeout in timer ticks (1/18 sec)
	SI:DI = length
Return: AL = error code
SeeAlso: AH=BFh
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RELEASE PHYSICAL RECORD
	AH = BDh
	BX = file handle
	CX:DX = offset
Return: AL = error code
SeeAlso: AH=C0h
---------------------------------------------
INT 21 - Novell NetWare 4.6 - CLEAR PHYSICAL RECORD
	AH = BEh
	BX = file handle
	CX:DX = offset
Return: AL = error code
SeeAlso: AH=C1h
---------------------------------------------
INT 21 - Novell NetWare 4.6 - LOG/LOCK RECORD (FCB)
	AH = BFh
	AL = flags
	    bit 0: lock as well as log record
		1: non-exclusive lock
	DS:DX -> FCB
	BX:CX = offset
	BP = timeout in timer ticks (1/18 sec)
	SI:DI = length
Return: AL = error code
SeeAlso: AH=BCh,C2h
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RELEASE RECORD (FCB)
	AH = C0h
	DS:DX -> FCB
	BX:CX = offset
Return: AL = error code
SeeAlso: AH=BDh,C3h
---------------------------------------------
INT 21 - Novell NetWare 4.6 - CLEAR RECORD (FCB)
	AH = C1h
	DS:DX -> FCB
	BX:CX = offset
Return: AL = error code
SeeAlso: AH=BEh,C4h
---------------------------------------------
INT 21 - Novell NetWare 4.6 - LOCK PHYSICAL RECORD SET
	AH = C2h
	AL = flags
	    bit 1: non-exclusive lock
	BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
SeeAlso: AH=BFh
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RELEASE PHYSICAL RECORD SET
	AH = C3h
Return: AL = error code
SeeAlso: AH=C0h
---------------------------------------------
INT 21 - Novell NetWare 4.6 - CLEAR PHYSICAL RECORD SET
	AH = C4h
Return: AL = error code
SeeAlso: AH=C1h
---------------------------------------------
INT 21 - Novell NetWare 4.6 - SEMAPHORES
	AH = C5h
	AL = subfunction
	    00h open semaphore
		DS:DX -> semaphore name
		CL = initial value
	    01h examine semaphore
		Return: CX = semaphore value (sign extended)
			DL = open count
	    02h wait on semaphore
		BP = timeout in timer ticks (1/18 sec)
	    03h signal semaphore
	    04h close semaphore
	CX:DX = semaphore handle (except function 00h)
Return: AL = error code
	if function 00h
	   CX:DX = semaphore handle
	   BL = open count
---------------------------------------------
INT 21 - Novell NetWare 4.6 - GET OR SET LOCK MODE
	AH = C6h
	AL = subfunction
	    00h set old "compatibility" mode
	    01h set new extended locks mode 
	    02h get lock mode
Return: AL = current lock mode
---------------------------------------------
INT 21 - Novell NetWare 4.0 - TTS
	AH = C7h
	AL = subfunction
	    00h begin transaction (NetWare SFT level II)
		Return: AL = error code
	    01h end transaction (NetWare SFT level II)
		Return: AL = error code
			CX:DX = transaction reference number
	    02h TTS available (NetWare SFT level II)
		Return: AL = completion code
			    00h TTS not available
			    01h TTS available
			    FDh TTS available but disabled
	    03h abort transaction (NetWare SFT level II)
		Return: AL = error code
	    04h transaction status
	    05h get application thresholds
	    06h set application thresholds
	    07h get workstation thresholds
	    08h set workstation thresholds
Return: ???
---------------------------------------------
INT 21 - Novell NetWare 4.0 - BEGIN LOGICAL FILE LOCKING
	AH = C8h
	if function C6h lock mode 00h:
	    DL = mode
		00h no wait
		01h wait
	if function C6h lock mode 01h:
	    BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
SeeAlso: AH=C9h
---------------------------------------------
INT 21 - Novell NetWare 4.0 - END LOGICAL FILE LOCKING
	AH = C9h
Return: AL = error code
SeeAlso: AH=C8h
---------------------------------------------
INT 21 - Novell NetWare 4.0 - LOG/LOCK PERSONAL FILE (FCB)
	AH = CAh
	DS:DX -> FCB
	if function C6h lock mode 01h:
	    AL = log and lock flag
		00h log file only
		01h lock as well as log file
	    BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
SeeAlso: AH=CBh
---------------------------------------------
INT 21 - Novell NetWare 4.0 - LOCK FILE SET
	AH = CBh
	if function C6h lock mode 00h:
	    DL = mode
		00h no wait
		01h wait
	if function C6h lock mode 01h:
	    BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
SeeAlso: AH=CAh
---------------------------------------------
INT 21 - Novell NetWare 4.0 - RELEASE FILE (FCB)
	AH = CCh
	DS:DX -> FCB
Return: none
SeeAlso: AH=CDh
---------------------------------------------
INT 21 - Novell NetWare 4.0 - RELEASE FILE SET
	AH = CDh
Return: none
SeeAlso: AH=CCh
---------------------------------------------
INT 21 - Novell NetWare 4.0 - CLEAR FILE (FCB)
	AH = CEh
	DS:DX -> FCB
Return: AL = error code
SeeAlso: AH=CFh
---------------------------------------------
INT 21 - Novell NetWare 4.0 - CLEAR FILE SET
	AH = CFh
Return: AL = 00h
SeeAlso: AH=CEh
---------------------------------------------
INT 21 - Novell NetWare 4.6, Banyan VINES - LOCK LOGICAL RECORD
	AH = D0h
	DS:DX -> record string
	if function C6h lock mode 01h: (Novell only)
	    AL = flags
		bit 0: lock as well as log the record
		bit 1: non-exclusive lock
	    BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
	    00h successful
	    FFh unsuccessful
SeeAlso: AH=D1h,D2h
---------------------------------------------
INT 21 - Novell NetWare 4.6, Banyan VINES - LOCK LOGICAL RECORD SET
	AH = D1h
	if function C6h lock mode 00h:
	    DL = mode
		00h no wait
		01h wait
	if function C6h lock mode 01h: (Novell only)
	   BP = timeout in timer ticks (1/18 sec)
Return: AL = error code (see AH=D0h)
SeeAlso: AH=D0h,D3h
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - UNLOCK LOGICAL RECORD
	AH = D2h
	DS:DX -> semaphore identifier (counted string up to 100 chars long)
Return: AL = error code (see AH=D0h)
SeeAlso: AH=D0h,D3h
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - UNLOCK LOGICAL RECORD SET
	AH = D3h
Return: AL = error code (see AH=D0h)
Note:	unlocks all semaphores logged in the semaphore set of the requesting PC
SeeAlso: AH=D1h,D2h
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - CLEAR LOGICAL RECORD
	AH = D4h
	DS:DX -> semaphore identifier (counted string up to 100 chars long)
Return: AL = error code
	    00h successful
	    FFh not successful
SeeAlso: AH=D5h
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - CLEAR LOGICAL RECORD SET
	AH = D5h
Return: AL = error code (see AH=D4h)
Note:	unlocks and clears all semaphores associated with the semaphore set
	  of the requesting PC
SeeAlso: AH=D4h
---------------------------------------------
INT 21 - Novell NetWare 4.0 - END OF JOB
	AH = D6h
Return: AL = error code
SeeAlso: AH=BBh
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SYSTEM LOGOUT
	AH = D7h
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare, Banyan VINES - ALLOCATE RESOURCE
	AH = D8h
	DL = resource number
Return: AL = status
	    00h successful
	    FFh unsucessful
SeeAlso: AH=D9h
---------------------------------------------
INT 21 - Novell NetWare, Banyan VINES - DEALLOCATE RESOURCE
	AH = D9h
	DL = resource number
Return:	AL = status (see AH=D8h)
SeeAlso: AH=D8h
---------------------------------------------
INT 21 - Novell NetWare 4.0 - GET VOLUME STATISTICS
	AH = DAh
	DL = volume number
	ES:DI -> reply buffer (see below)
Return: AL = 00h
SeeAlso: AH=36h

Format of reply buffer:
Offset	Size	Description
 00h	WORD	sectors/block
 02h	WORD	total blocks
 04h	WORD	unused blocks
 06h	WORD	total directory entries
 08h	WORD	unused directory entries
 0Ah 16 BYTEs	volume name, null padded
 1Ah	WORD	removable flag, 0000h = not removable
---------------------------------------------
INT 21 - Novell NetWare 4.0 - GET NUMBER OF LOCAL DRIVES
	AH = DBh
Return: AL = number of local disks
SeeAlso: AH=0Eh
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - GET STATION NUMBER
	AH = DCh
Return: AL = station number
	    00h if NetWare not loaded or this machine is a non-dedicated server
	CX = station number in ASCII
Note:	station number only unique for those PCs connected to same semaphore
	  service
---------------------------------------------
INT 21 - PCMag PCMANAGE/DCOMPRES - TURN ON/OFF
	AH = DCh
	DX = state
	    0000h turn on
	    0001h turn off
SeeAlso: AX=FEDCh
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SET ERROR MODE
	AH = DDh
	DL = error mode
	    00h display critical I/O errors
	    01h extended errors for all I/O in AL
	    02h extended errors for critical I/O in AL
Return: AL = previous error mode
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SET BROADCAST MODE
	AH = DEh
	AL = broadcast mode
	    00h receive console and workstation broadcasts
	    01h receive console broadcasts only
	    02h receive no broadcasts
	    03h store all broadcasts for retrieval
	    04h get broadcast mode
	    05h disable shell timer interrupt checks
	    06h enable shell timer interrupt checks
Return: AL = old broadcast mode
---------------------------------------------
INT 21 - Novell NetWare 4.0 - CAPTURE
	AH = DFh
	AL = subfunction
	    00h start LPT capture
	    01h end LPT capture
	    02h cancel LPT capture
	    03h flush LPT capture
	    04h start specific capture
	    05h end specific capture
	    06h cancel specific capture
	    07h flush specific capture
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - PRINT SPOOLING
	AH = E0h
	DS:SI -> request buffer
	ES:DI -> reply buffer
	subfunction in third byte of request buffer
	    00h spool data to a capture file
	    01h close and queue capture file
	    02h set spool flags
	    03h spool existing file
	    04h get spool queue entry
	    05h remove entry from spool queue
	    06h get printer status
	    09h create a disk capture file
Return: AL = error code
---------------------------------------------
INT 21 - OS/286, OS/386 - INITIALIZE REAL PROCEDURE
	AH = E0h
	???
Return: ???
---------------------------------------------
INT 21 - Novell NetWare 4.0 - BROADCAST MESSAGES
	AH = E1h
	DS:SI -> request buffer
	ES:DI -> reply buffer
	subfunction in third byte of request buffer
	    00h send broadcast message
	    01h get broadcase message
	    02h disable station broadcasts
	    03h enable station broadcasts
	    04h send personal message
	    05h get personal message
	    06h open message pipe
	    07h close message pipe
	    08h check pipe status
	    09h broadcast to console
Return: AL = error code
---------------------------------------------
INT 21 - OS/286, OS/386 - ISSUE REAL PROCEDURE CALL
	AH = E1h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - Novell NetWare 4.0 - DIRECTORY FUNCTIONS
	AH = E2h
	DS:SI -> request buffer
	ES:DI -> reply buffer
	subfunction in third byte of request buffer
	    00h set directory handle
	    01h get directory path
	    02h scan directory information
	    03h get effective directory rights
	    04h modify maximum rights mask
	    05h get volume number
	    06h get volume name
	    0Ah create directory
	    0Bh delete directory
	    0Ch scan directory for trustees
	    0Dh add trustee to directory
	    0Eh delete trustee from directory
	    0Fh rename directory
	    10h purge erased files
	    11h restore erased file
	    12h allocate permanent directory handle
	    13h allocate temporary directory handle
	    14h deallocate directory handle
	    15h get volume info with handle
	    16h allocate special temporary directory handle
	    17h retrieve a short base handle (Advanced NetWare 2.0)
	    18h restore a short base handle (Advanced NetWare 2.0)
	    19h set directory information
Return: AL = error code
---------------------------------------------
INT 21 - OS/286, OS/386 - SET REAL PROCEDURE SIGNAL HANDLER
	AH = E2h
	???
Return: ???
---------------------------------------------
INT 21 - Novell NetWare 4.0 - CONNECTION CONTROL
	AH = E3h
	DS:SI -> request buffer
	ES:DI -> reply buffer
	subfunction in third byte of request buffer
	    00h login
	    01h change password
	    02h map user to station set
	    03h map object to number
	    04h map number to object
	    05h get station's logged information
	    06h get station's root mask (obsolete)
	    07h map group name to number
	    08h map number to group name
	    09h get memberset M of group G
	    0Ah enter login area
	    0Bh ???
	    0Ch ???
	    0Dh log network message
	    0Eh get disk utilization (Advanced NetWare 1.0)
	    0Fh scan file information (Advanced NetWare 1.0)
	    10h set file information (Advanced NetWare 1.0)
	    11h get file server information (Advanced NetWare 1.0)
	    12h ???
	    13h get internet address (Advanced NetWare 1.02)
	    14h login to file server (Advanced NetWare 2.0)
	    15h get object connection numbers (Advanced NetWare 2.0)
	    16h get connection information (Advanced NetWare 1.0)
	    32h create object (Advanced NetWare 1.0)
	    33h delete object (Advanced NetWare 1.0)
	    34h rename object (Advanced NetWare 1.0)
	    35h get object ID (Advanced NetWare 1.0)
	    36h get object name (Advanced NetWare 1.0)
	    37h scan object (Advanced NetWare 1.0)
	    38h change object security (Advanced NetWare 1.0)
	    39h create propery (Advanced NetWare 1.0)
	    3Ah delete property (Advanced NetWare 1.0)
	    3Bh change property security (Advanced NetWare 1.0)
	    3Ch scan property (Advanced NetWare 1.0)
	    3Dh read property value (Advanced NetWare 1.0)
		request buffer contains the property name in all caps
		property "IDENTIFICATION" returns the user's name
	    3Eh write property value (Advanced NetWare 1.0)
	    3Fh verify object password (Advanced NetWare 1.0)
	    40h change object password (Advanced NetWare 1.0)
	    41h add object to set (Advanced NetWare 1.0)
	    42h delete object from set (Advanced NetWare 1.0)
	    43h is object in set? (Advanced NetWare 1.0)
	    44h close bindery (Advanced NetWare 1.0)
	    45h open bindery (Advanced NetWare 1.0)
	    46h get bindery access level (Advanced NetWare 1.0)
	    47h scan object trustee paths (Advanced NetWare 1.0)
	    C8h check console priviledges
	    C9h get file server description strings
	    CAh set file server date and time
	    CBh disable file server login
	    CCh enable file server login
	    CDh get file server login status
	    CEh purge all erased files
	    CFh disable transaction tracking
	    D0h enable transaction tracking
	    D1h send console broadcast
	    D2h clear connection number
	    D3h down file server
	    D4h get file system statistics
	    D5h get transaction tracking statistics
	    D6h read disk cache statistics
	    D7h get drive mapping table
	    D8h read physical disk statistics
	    D9h get disk channel statistics
	    DAh get connection's task information
	    DBh get list of connection's open files
	    DCh get list of connections using a file
	    DDh get physical record locks by connection and file
	    DEh get physical record locks by file
	    DFh get logical records by connection
	    E0h get logical record information
	    E1h get connection's semaphores
	    E2h get semaphore information
	    E3h get LAN driver's configuration information
	    E5h get connection's usage statistics
	    E6h get object's remaining disk space
	    E7h get server LAN I/O statistics
	    E8h get server miscellaneous information
	    E9h get volume information
Return: AL = error code
---------------------------------------------
INT 21 - OS/286, OS/386 - ISSUE REAL INTERRUPT
	AH = E3h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SET FILE ATTRIBUTES (FCB)
	AH = E4h
	CL = file attributes
	    bit 0: read only
		1: hidden
		2: system
		7: shareable
	DX:DX -> FCB
Return: AL = error code
SeeAlso: AX=4301h
---------------------------------------------
INT 21 - DoubleDos - INSTALLATION CHECK
	AX = E400h
Return: AL <> 00h if DoubleDos is active
	AL = 02h if caller is running in the invisible partition
---------------------------------------------
INT 21 - OS/286, OS/386 - CHAIN TO REAL-MODE HANDLER
	AX = E400h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - OS/286, OS/386 - SET PROTECTED-MODE TASK GATE
	AX = E402h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - OS/286, OS/386 - REMOVE PROTECTED-MODE TASK GATE
	AX = E403h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - Novell NetWare 4.0 - UPDATE FILE SIZE (FCB)
	AH = E5h
	DS:DX -> FCB
Return: AL = error code
---------------------------------------------
INT 21 - OS/286, OS/386 - HEAP MANAGEMENT STRATEGY
	AX = E500h
	???
Return: ???
---------------------------------------------
INT 21 - OS/286, OS/386 - FORCE HEAP COMPACTION
	AX = E501h
	???
Return: ???
---------------------------------------------
INT 21 - Novell NetWare 4.0 - COPY FILE TO FILE (FCB)
	AH = E6h
	CX:DX = number of bytes to copy
	DS:SI -> source FCB
	ES:DI -> destination FCB
Return: AL = error code
---------------------------------------------
INT 21 - OS/286, OS/386 - ISSUE REAL PROCEDURE SIGNAL FROM PROTECTED MODE
	AH = E6h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - GET FILE SERVER DATE AND TIME
	AH = E7h
	DS:DX -> reply buffer
		BYTE  year - 1900
		BYTE  month
		BYTE  day
		BYTE  hours
		BYTE  minutes
		BYTE  seconds
		BYTE  day of week (0 = Sunday) (Novell only)
Return: AL = error code
	    00h successful
	    FFh unsuccessful
SeeAlso: AH=2Ah,2Ch
---------------------------------------------
INT 21 - OS/286, OS/386 - CREATE CODE SEGMENT
	AH = E7h
	???
Return: ???
---------------------------------------------
INT 21 - Novell NetWare 4.6 - SET FCB RE-OPEN MODE
	AH = E8h
	DL = mode
	    00h no automatic re-open
	    01h auto re-open
Return: AL = error code
---------------------------------------------
INT 21 - OS/286, OS/386 - SEGMENT CREATION
	AH = E8h
	AL = type
	    00h data segment
	    01h data window/alias
	    02h real segment
	    03h real window/alias
	    06h shareable segment
	???
Return: ???
---------------------------------------------
INT 21 - Novell NetWare 4.6 - SHELL'S "GET BASE STATUS"
	AX = E900h
	DX = drive number to check (0 = A:)
Return: AL = network pathbase
	AH = base flags
	    00h drive not currently mapped to a base
	    01h drive is mapped to a permanent base
	    02h drive is mapped to a temporary base
	    03h drive exists locally
---------------------------------------------
INT 21 - Novell NetWare shell 3.01 - MAP A FAKE ROOT DIRECTORY
	AX = E905h
	BL = drive number (0=default, 1=A:, ...)
	DS:DX -> ASCIZ path for fake root (may include server name or be empty)
Return: CF set on error
	    AL = error code (03h,0Fh,11h) (see AH=59h)
	CF clear if successful
Note:	if drive is not currently mapped, a drive mapping will be created
SeeAlso: AX=E906h
---------------------------------------------
INT 21 - Novell NetWare shell 3.01 - DELETE FAKE ROOT DIRECTORY
	AX = E906h
	BL = drive number (0=default, 1=A:, ...)
Note:	drive remains mapped
SeeAlso: AX=E905h
---------------------------------------------
INT 21 - Novell NetWare shell 3.01 - GET RELATIVE DRIVE DEPTH
	AX = E907h
	BL = drive number (0=default, 1=A:, ...)
Return: AL = number of directories below the fake root
	    FFh if no fake root assigned
SeeAlso: AX=E905h
---------------------------------------------
INT 21 - Novell NetWare shell 3.01 - SET SHOW DOTS
	AX = E908h
	BL = 00h	don't return '.' or '..' during directory scans
	   = nonzero	directory scans will return '.' or '..' entries
Return: BL = previous show-dots setting
---------------------------------------------
INT 21 - OS/286, OS/386 - CHANGE SEGMENTS
	AH = E9h
	AL = function
	    01h change code segment parameters
	    02h	change data segment parameters
	    05h adjust segment limit
	    06h change segment base address
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RETURN SHELL VERSION
	AH = EAh
	AL = return version environment string
	    00h		don't return string
	    nonzero	return string in 40-byte buffer pointed to by ES:DI
		Return: buffer filled with three null-terminated entries:
			major operating system
			version
			hardware type
Return: AH = operating system (00h = MSDOS)
	AL = hardware type
	    00h IBM PC
	    01h Victor 9000
	BH = major shell version
	BL = minor shell version
	CH = (v3.01+) shell type
	    00h conventional memory
	    01h expanded memory
	    02h extended memory
	CL = shell revision number
---------------------------------------------
INT 21 - DoubleDOS - TURN OFF TASK SWITCHING
	AH = EAh
Return: task switching turned off
SeeAlso: AH=EBh"DoubleDOS"
---------------------------------------------
INT 21 - OS/286, OS/386 - ALLOCATE HUGE SEGMENT
	AH = EAh
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - Novell NetWare 4.6 - LOG FILE
	AH = EBh
	DS:DX -> ASCIZ filename
	if function C6h lock mode 01h:
	    AL = flags
		00h log file only
		01h lock as well as log file
	    BP = timeout in timer ticks (1/18 second)
Return: AL = error code
---------------------------------------------
INT 21 - DoubleDOS - TURN ON TASK SWITCHING
	AH = EBh
Return: task switching turned on
SeeAlso: AH=EAh"DoubleDOS"
---------------------------------------------
INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY LINEAR ADDRESS
	AX = EB00h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY 16-BIT SEGMENT:OFFSET
	AX = EB02h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - OS/386 VMM - FREE MAPPED PAGES
	AX = EB03h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY 32-BIT SEGMENT:OFFSET
	AX = EB04h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - OS/386 VMM - MAP PAGES
	AX = EB05h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - OS/386 VMM - LOCK PAGES IN MEMORY
	AX = EB06h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - OS/386 VMM - UNLOCK MEMORY PAGES
	AX = EB07h
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RELEASE FILE
	AH = ECh
	DS:DX -> ASCIZ filename
Return: none
---------------------------------------------
INT 21 - DoubleDOS - GET VIRTUAL SCREEN ADDRESS
	AH = ECh
Return: ES = segment of virtual screen
Note:	screen address can change if task-switching is on!!
---------------------------------------------
INT 21 - OS/286, OS/386 - BLOCK TRANSFER
	AH = ECh
	???
Return: ???
---------------------------------------------
INT 21 - Novell NetWare - CLEAR FILE
	AH = EDh
	DS:DX -> ASCIZ filename
Return: AL = error code
---------------------------------------------
INT 21 - OS/286, OS/386 - GET SEGMENT OR WINDOW DESCRIPTOR
	AH = EDh
	???
Return: ???
Note:	protected mode only???
---------------------------------------------
INT 21 - Novell NetWare 4.6 - GET PHYSICAL STATION NUMBER
	AH = EEh
Return: CX:BX:AX = six-byte address
---------------------------------------------
INT 21 - DoubleDOS - GIVE AWAY TIME TO OTHER TASKS
	AH = EEh
	AL = number of 55ms time slices to give away
Return: returns after giving away time slices
---------------------------------------------
INT 21 - Novell Advanced NetWare 1.0+ - GET DRIVE INFO
	AH = EFh
	AL = subfunction
	    00h get drive handle table
	    01h get drive flag table
	    02h get drive connection ID table
	    03h get connection ID table
	    04h get file server name table
Return: ES:DI -> shell status table
---------------------------------------------
INT 21 - Novell Advanced NetWare 1.0+ - CONNECTION ID
	AH = F0h
	AL = subfunction
	    00h set preferred connection ID
	    01h get preferred connection ID
	    02h get default connection ID
	    03h LPT capture active
	    04h set primary connection ID
	    05h get primary connection ID
	DL = preferred file server
Return: AL = selected file server
---------------------------------------------
INT 21 - Novell Advanced NetWare 1.0+ - FILE SERVER CONNECTION
	AH = F1h
	AL = subfunction
	    00h attach to file server
		DL = preferred file server
	    01h detach from file server
	    02h logout from file server
Return: AL = completion code
---------------------------------------------
INT 21 - Novell NetWare - ???
	AH = F2h
	???
Return: ???
---------------------------------------------
INT 21 - Novell Advanced NetWare 2.0+ - FILE SERVER FILE COPY
	AH = F3h
	ES:DI -> request string (see below)
Return: AL = status/error code
	CX:DX = number of bytes copied

Format of request string:
Offset	Size	Description
 00h	WORD	source file handle
 02h	WORD	destination file handle
 04h	DWORD	starting offset in source
 08h	DWORD	starting offset in destination
 0Ch	DWORD	number of bytes to copy
---------------------------------------------
INT 21 - DOS v??? - SET OEM INT 21 HANDLER
	AH = F8h
	DS:DX -> OEM INT 21 handler for functions F9h to FFh
		 FFFFh:FFFFh resets to original handlers

Notes:	calls to AH=F9h through AH=FFH will return CF set and AX=1 (invalid
	  function) if no handler set
	handler is called with all registers exactly as set by caller, and
	  should exit with IRET
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = F9h
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FAh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FBh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FCh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FDh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FEh
---------------------------------------------
INT 21 - PCMag PCMANAGE/DCOMPRES - INSTALLATION CHECK
	AX = FEDCh
Return: AX = CDEFh if installed
SeeAlso: AH=DCh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FFh
---------------------------------------------
INT 21 - CED - INSTALLABLE COMMANDS
	AH = FFh
	AL = 00h add installable command
	       BL = mode - bit 0 = 1 callable from DOS prompt
			   bit 1 = 1 callable from application
	       DS:SI -> CR-terminated command name
	       ES:DI -> FAR routine entry point
	AL = 01h remove installable command
	       DS:SI -> CR-terminated command name
	AL = 02h reserved, may be used to test for CED installation
Return: CF set on error
	    AX = 01h invalid function
		 02h command not found (subfunction 01h only)
		 08h insufficient memory (subfunction 00h only)
		 0Eh bad data (subfunction 00h only)
	AH = 0FFh if CED not installed
---------------------------------------------
INT 21 - Topware Network Operating System - ???
	AH = FFh
	???
Return: ???
---------------------------------------------
INT 22 - DOS - TERMINATE ADDRESS
   FAR (DWORD) address to jump to when program "returns to DOS".  Normally
   points at the instruction immediately following INT 21/AH=4Bh call which
   loaded the current program.	Should NEVER be called directly.
SeeAlso: INT 20, INT 21/AH=00h,31h,4Ch
---------------------------------------------
INT 23 - DOS - CONTROL "C" EXIT ADDRESS
   Automatically called by DOS when CTRL-C or CTRL-BREAK is detected. Normally
   aborts program and returns to DOS, but may be changed.
SeeAlso: INT 1B
---------------------------------------------
INT 24 - DOS - FATAL ERROR HANDLER ADDRESS
   Automatically called upon detection of unrecoverable I/O error.
   Normally points to routine in resident part of COMMAND.COM that prints
   "Abort, Retry, Ignore?" message and takes the reply, but may be overridden
   if desired.

Provides the following values in registers on entry to interrupt handler:
	AH: bit 7 = 0 disk I/O error
		  = 1 other error -- if block device, bad FAT
				  -- if char device, code in DI
	    bit 6  unused
	    bit 5 = 1 if Ignore allowed, 0 if not (DOS 3+)
	    bit 4 = 1 if Retry allowed, 0 if not (DOS 3+)
	    bit 3 = 1 if Fail allowed, 0 if not (DOS 3+)
	    bit 2 \ disk area of error	00 = DOS area  01 = FAT
	    bit 1 /			10 = root dir  11 = data area
	    bit 0 = 1 if write, 0 if read
	AL = drive number if AH bit 7 = 1, otherwise undefined
	BP:SI -> header of device driver for which error occurred
	    block device if high bit of BP:[SI+4] set
	low byte of DI:
	   00h write-protect error
	   01h unknown unit
	   02h drive not ready
	   03h unknown command
	   04h data error (bad CRC)
	   05h bad request structure length
	   06h seek error
	   07h unknown media type
	   08h sector not found
	   09h printer out of paper
	   0Ah write fault
	   0Bh read fault
	   0Ch general failure
	   0Dh (DOS 3+) sharing violation
	   0Eh (DOS 3+) lock violation
	   0Fh (DOS 3+) invalid disk change
	   10h (DOS 3+) FCB unavailable
	   11h (DOS 3+) sharing buffer overflow
Handler must return
	AL = 00h ignore error
	   = 01h retry operation
	   = 02h terminate program through INT 22h
	   = 03h fail system call in progress (DOS 3+)
Notes:	for DOS 3.1+, IGNORE (AL=00h) is turned into FAIL (AL=03h) on network
	  critical errors
	if IGNORE specified but not allowed, it is turned into FAIL
	if RETRY specified but not allowed, it is turned into FAIL
	if FAIL specified but not allowed, it is turned into ABORT
---------------------------------------------
INT 25 - DOS - ABSOLUTE DISK READ (except DOS 4.0/COMPAQ DOS 3.31 >32M partitn)
	AL = drive number (0=A, 1=B, etc)
	DS:BX = Disk Transfer Address (buffer)
	CX = number of sectors to read
	DX = first relative sector to read
Return: CF set on error
	    AL = error code issued to INT 24h in low half of DI
	    AH = 80h if attachment failed to respond
		 40h if seek operation failed
		 20h if controller failed
		 10h if data error (bad CRC)
		 08h if DMA failure
		 04h if requested sector not found
		 03h if write-protected disk (INT 26 only)
		 02h if bad address mark
		 01h if bad command
	CF clear if successful
	    AL = 00h
Notes:	ORIGINAL FLAGS ON STACK!  Must be popped or discarded by adjusting SP
	May destroy all registers except segment regs
BUG:	DOS 3.1 through 3.3 set the word at ES:[BP+1Eh] to FFFFh if AL is an
	invalid drive number
SeeAlso: INT 26, INT 13/AH=02h
---------------------------------------------
INT 25 - DOS 4.0/COMPAQ DOS 3.31 - ABSOLUTE DISK READ (>32M hard-disk partitn)
	AL = drive number (0=A, 1=B, etc)
	CX = FFFFh
	DS:BX -> disk read packet (see below)
Return: same as above
Notes:	partition is potentially >32M (and requires this form of the call) if
	  bit 1 of device attribute word in device driver is set
	ORIGINAL FLAGS LEFT ON STACK! Must be popped or discarded by adj SP
SeeAlso: INT 26, INT 13/AH=02h

Format of disk read packet:
Offset	Size	Description
 00h	DWORD	sector number
 04h	WORD	number of sectors to read
 06h	DWORD	transfer address
---------------------------------------------
INT 26 - DOS - ABSOLUTE DISK WRITE (except DOS 4.0/COMPAQ DOS 3.31 >32M partn)
	AL = drive number (0=A, 1=B, etc)
	DS:BX = Disk Transfer Address (buffer)
	CX = number of sectors to write
	DX = first relative sector to write
Return: CF set on error
	    AL = error code issued to INT 24h in low half of DI
	    AH = same error codes as for INT 25h
	CF clear if successful
	    AL = 00h
Note:	ORIGINAL FLAGS ON STACK!  Must be popped or discarded by adjusting SP
BUG:	DOS 3.1 through 3.3 set the word at ES:[BP+1Eh] to FFFFh if AL is an
	invalid drive number
SeeAlso: INT 25, INT 13/AH=03h
---------------------------------------------
INT 26 - DOS 4.0/COMPAQ DOS 3.31 - ABSOLUTE DISK WRITE (>32M hard-disk partitn)
	AL = drive number (0=A, 1=B, etc)
	CX = FFFFh
	DS:BX -> disk write packet (see below)
Return: same as above
Notes:	partition is potentially >32M (and requires this form of the call) if
	  bit 1 of device attribute word in device driver is set
	ORIGINAL FLAGS LEFT ON STACK!  Must be popped or discarded by adj SP
SeeAlso: INT 25, INT 13/AH=03h

Format of disk write packet:
Offset	Size	Description
 00h	DWORD	sector number
 04h	WORD	number of sectors to read
 06h	DWORD	transfer address
---------------------------------------------
INT 27 - DOS - TERMINATE BUT STAY RESIDENT
	CS = current program segment
	DX = last program byte + 1
Return: never
Note:	this is an obsolete call
SeeAlso: INT 21/AH=31h
---------------------------------------------
Interrupt List, part 3 of 4
This compilation is Copyright (c) 1989,1990 Ralf Brown
---------------------------------------------
INT 28 - DOS 2+ internal - KEYBOARD BUSY LOOP
   This interrupt is called from inside the "get input from keyboard" routine
   in DOS, if and only if it is safe to use INT 21 to access the disk at that
   time.  It is used primarily by the PRINT.COM routines and TSR programs, but
   any number of other routines could be chained to it by saving the original
   vector, and calling it with a FAR call (or just JMPing to it) at the end of
   the new routine.

   The INT 28h handler may invoke any INT 21h function except functions 00h
   through 0Ch (and 50h/51h under DOS 2.xx unless DOS CriticalErr flag is set).
   Calls to functions 3Fh and 40h may not use a handle which refers to CON.

   Until some program installs its own routine, this interrupt vector simply
   points to an IRET opcode.

Note:	supported in OS/2 compatibility box
SeeAlso: INT 2A/AH=84h
---------------------------------------------
INT 29 - DOS 2+ internal - FAST PUTCHAR
	AL = character to display
Return: nothing
Notes:	this interrupt is called from the DOS output routines if output is
	  going to a device rather than a file, and the device driver's
	  attribute word has bit 4 (10h) set.
	COMMAND.COM v3.2 and v3.3 compare the INT 29 vector against the INT 20
	  vector and assume that ANSI.SYS is installed if the segment is larger
	the default handler under DOS 2.x and 3.x simply calls INT 10/AH=0Eh
	the default handler under DESQview 2.2 understands the <Esc>[2J
	  screen-clearing sequence, calls INT 10/AH=0Eh for all others
SeeAlso: INT 79
---------------------------------------------
INT 2A - Microsoft/LANtastic NETWORK - INSTALLATION CHECK
	AH = 00h
Return: AH <> 00h if installed
SeeAlso: INT 5C
---------------------------------------------
INT 2A - AT&T Starlan Extended NetBIOS (var length names) - INSTALLATION CHECK
	AX = 0000h
Return: AH = DDh
SeeAlso: INT 5B
---------------------------------------------
INT 2A - Microsoft/LANtastic NETWORK - EXECUTE NETBIOS REQUEST, NO ERROR RETRY
	AH = 01h
	ES:BX -> NCB (see INT 5C)
Return: AL = NetBIOS error code
	AH = 00h if no error
	   = 01h on error
SeeAlso: AH=04h, INT 5C
---------------------------------------------
INT 2A - Microsoft Networks - SET NET PRINTER MODE
	AH = 02h
	???
Return: ???
---------------------------------------------
INT 2A - Microsoft Networks - CHECK DIRECT I/O
	AX = 0300h
	DS:SI -> ASCIZ disk device name (may be full path or only drive
		specifier--must include the colon)
Return: CF clear if absolute disk access allowed
Notes:	do not use direct disk accesses if this function returns CF set or the
	  device is redirected (INT 21/AX=5F02h)
	may take some time to execute
SeeAlso: INT 13, INT 25, INT 26, INT 21/AX=5F02h
---------------------------------------------
INT 2A - Microsoft/LANtastic NETWORK - EXECUTE NETBIOS REQUEST
	AH = 04h
	AL = 00h for error retry, 01h for no retry
	ES:BX -> NCB (see INT 5C)
Return: AX = 0000h for no error
	AH = 01h, AL = error code
Note:	request automatically retried (if AL=00h) on errors 09h, 12h, and 21h
SeeAlso: AH=01h, INT 5C
---------------------------------------------
INT 2A - Microsoft/LANtastic NETWORK - GET NETWORK RESOURCE INFORMATION
	AX = 0500h
Return: AX = reserved
	BX = number of network names available
	CX = number of commands (NCBs) available
	DX = number of sessions available
---------------------------------------------
INT 2A - NETBIOS - NETWORK PRINT-STREAM CONTROL
	AH = 06h
	AL = 01h set concatenation mode (all printer output put in one job)
	     02h set truncation mode (default)
		 printer open/close starts new print job
	     03h flush printer output and start new print job
Return: CF set on error
	    AX = error code
	CF clear if successful
Note:	subfunction 03h is equivalent to Ctrl/Alt/keypad-*
SeeAlso: INT 21/AX=5D08h,5D09h, INT 2F/AX=1125h
---------------------------------------------
INT 2A - MS Networks or NETBIOS - ???
	AX = 2001h
	???
Return: ???
Note:	intercepted by DESQview 2.x
---------------------------------------------
INT 2A - Network - ???
	AX = 2002h
	???
Return: ???
Note:	called by MSDOS 3.30 APPEND
---------------------------------------------
INT 2A - Network - ???
	AX = 2003h
	???
Return: ???
Note:	called by MSDOS 3.30 APPEND
---------------------------------------------
INT 2A - Microsoft Networks - BEGIN DOS CRITICAL SECTION
	AH = 80h
	AL = critical section number (00h-0Fh)
	    01h DOS kernel, SHARE.EXE
		apparently for maintaining the integrity of DOS/SHARE/NET
		  data structures
	    02h DOS kernel
		ensures that no multitasking occurs while DOS is calling an
		  installable device driver
	    05h DOS 4+ IFSFUNC
	    06h DOS 4+ IFSFUNC
	    08h ASSIGN.COM
Notes:	normally hooked to avoid interrupting a critical section, rather than
	  called
	the handler should ensure that none of the critical sections are
	  reentered, usually by suspending a task which attempts to reenter
	  an active critical section
SeeAlso: AH=81h, AH=82h, AH=87h, INT 21/AX=5D06h,5D0Bh
---------------------------------------------
INT 2A - Microsoft Networks - END DOS CRITICAL SECTION
	AH = 81h
	AL = critical section number (00h-0Fh) (see AH=80h)
Notes:	normally hooked rather than called
	the handler should reawaken any tasks which were suspended due to an
	  attempt to enter the specified critical section
SeeAlso: AH=80h, AH=82h, AH=87h
---------------------------------------------
INT 2A - Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
	AH = 82h
Notes:	called by the INT 21h function dispatcher for function 0 and functions
	  greater than 0Ch except 59h, and on process termination
	the handler should reawaken any tasks which were suspended due to an
	  attempt to enter one of the critical sections 0 through 7
SeeAlso: AH=81h
---------------------------------------------
INT 2A - Microsoft Networks - KEYBOARD BUSY LOOP
	AH = 84h
Note:	similar to DOS's INT 28h
SeeAlso: INT 28
---------------------------------------------
INT 2A - ??? - CRITICAL SECTION
	AH = 87h
	AL = start/end
	    00h start
	    01h end
Note:	called by PRINT.COM
SeeAlso: AH=80h,81h
---------------------------------------------
INT 2A - Network - ???
	AH = 89h
	AL = ???  (ASSIGN uses 08h)
	???
Return: ???
---------------------------------------------
INT 2A - Network - ???
	AH = C2h
	AL = subfunction
	    07h ???
	    08h ???
	BX = 0001h
	???
Return: ???
Note:	called by DOS 3.30 APPEND
---------------------------------------------
INT 2B - Internal routine for MSDOS (IRET)
---------------------------------------------
INT 2C - Internal routine for MSDOS (IRET)
---------------------------------------------
INT 2D - Internal routine for MSDOS (IRET)
---------------------------------------------
INT 2E - DOS 2+ internal - EXECUTE COMMAND
	DS:SI -> counted CR-terminated command string
Notes:	the top-level command.com executes the command
	all registers including SS and SP are destroyed as in INT 21/AH=4Bh
	Since COMMAND.COM processes the string as if typed from the keyboard,
	  the transient portion needs to be present, and the calling program
	  must ensure that sufficient memory to load the transient portion can
	  be allocated by DOS if necessary.
	hooked but ignored by 4DOS v3.0 COMMAND.COM replacement
---------------------------------------------
INT 2F - Multiplex - notes
	AH = identifier of program which is to handle the interrupt
	   00h-7Fh reserved for DOS
	   C0h-FFh reserved for applications
	AL is the function code
This is a general mechanism for verifying the presence of a TSR and 
communicating with it.
---------------------------------------------
INT 2F - Multiplex - BMB Compuscience Canada Utilities Interface
	AH = xx (dynamically assigned based upon a search for a multiplex
		 number which doesn't answer installed)
	AL = 00h install check
	ES:DI = EBEB:BEBE
Return: AL = 00h not installed
	     01h not installed, not OK to install
	     FFh installed and if ES:DI != EBEB:BEBE then ES:DI will point
		 to a string 'BMB xxxx' where xxxx is a product name and
		 version
---------------------------------------------
INT 2F - Multiplex - DOS 2.x PRINT.COM - ???
	AH = 00h
	???
Return: ???
Notes:	DOS 2.x PRINT.COM does not chain to previous INT 2F handler
	values in AH other than 00h or 01h cause PRINT to return the number of
	  files in the queue in AH
SeeAlso: AH=01h
---------------------------------------------
INT 2F - Multiplex - DOS 3.1+ PRINT.COM - GIVE PRINT A TIME SLICE
	AX = 0080h
Return: after PRINT executes
---------------------------------------------
INT 2F - Multiplex - DOS 2.x PRINT.COM - ???
	AH = 01h
	???
Return: ???
Notes:	DOS 2.x PRINT.COM does not chain to previous INT 2F handler
	values in AH other than 00h or 01h cause PRINT to return the number of
	  files in the queue in AH
SeeAlso: AH=00h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ PRINT.COM - INSTALLATION CHECK
	AX = 0100h
Return: AL =
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
---------------------------------------------
INT 2F - Multiplex - DOS 3+ PRINT.COM - SUBMIT FILE
	AX = 0101h
	DS:DX -> packet (see below)
Return: CF set on error
	    AX = error code
	CF clear if successful
	    AL = 01h added to queue
		 9Eh now printing
SeeAlso: AX=0102h

Format of submit packet:
Offset	Size	Description
 00h	BYTE	level (must be 0)
 01h	DWORD	pointer to ASCIZ filename (no wildcards)
---------------------------------------------
INT 2F - Multiplex - DOS 3+ PRINT.COM - REMOVE FILE
	AX = 0102h
	DS:DX -> ASCIZ file name (wildcards allowed)
Return: CF set on error
	    AX = error code
	CF clear if successful
SeeAlso: AX=0103h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ PRINT.COM - REMOVE ALL FILES
	AX = 0103h
Return: CF set on error
	    AX = error code
	CF clear if successful
SeeAlso: AX=0102h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ PRINT.COM - HOLD QUEUE/GET STATUS
	AX = 0104h
Return: CF set on error
	    AX = error code
		01h function invalid
		02h file not found
		03h path not found
		04h too many open files
		05h access denied
		08h queue full
		09h spooler busy
		0Ch name too long
		0Fh drive invalid
	DX = error count
	DS:SI -> print queue (null-string terminated list of 64-byte ASCIZ 
		 file names)
SeeAlso: AX=0105h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ PRINT.COM - RESTART QUEUE
	AX = 0105h
Return: CF set on error
	   AX = error code
	CF clear if successful
SeeAlso: AX=0104h
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ PRINT.COM - CHECK IF ERROR ON OUTPUT DEVICE
	AX = 0106h
Return: CF set on error
	    AX = error code
	    DS:SI -> device driver header
	CF clear if successful
	    AX = 0000h
Note:	eventually calls device driver for spooled device with request 0Ah,
	  looping until not busy or timeout
SeeAlso: AX=0104h
---------------------------------------------
INT 2F - Multiplex - PC LAN PROGRAM REDIR/REDIRIFS internal - INSTALL CHECK
	AX = 0200h
Return: AL = FFh if installed
---------------------------------------------
INT 2F - Multiplex - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 0201h
Return: nothing???
Notes:	called by DOS 3.3+ PRINT.COM
	AX=0202h appears to be the opposite function
SeeAlso: AX=0202h
---------------------------------------------
INT 2F - Multiplex - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 0202h
	???
Return: nothing???
Note:	called by DOS 3.3+ PRINT.COM
SeeAlso: AX=0201h
---------------------------------------------
INT 2F - Multiplex - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 0203h
Return: nothing???
Notes:	called by DOS 3.3+ PRINT.COM
	AX=0204h appears to be the opposite function
SeeAlso: AX=0204h
---------------------------------------------
INT 2F - Multiplex - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 0204h
	???
Return: nothing???
Note:	called by DOS 3.3 PRINT.COM
---------------------------------------------
INT 2F - Multiplex - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 02xxh
	???
Return: ???
---------------------------------------------
INT 2F - Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
	AX = 0500h
Return: AL = 00h not installed, OK to install
	     01h not installed, can't install
	     FFh installed
Note:	this set of functions allows a user program to partially or completely
	  override the default critical error handler in COMMAND.COM
SeeAlso: INT 24
---------------------------------------------
INT 2F - Multiplex - DOS 3+ CRITICAL ERROR HANDLER - EXPAND ERROR INTO STRING
	AH = 05h
---DOS 3.x---
	AL = extended error code (not zero)
---DOS 4.x---
	AL = error type
	    01h DOS extended error code
	    02h parameter error
	BX = error code
Return: CF clear if successful
	    ES:DI -> ASCIZ error message (read-only)
	    AL = ???
	CF set if error code can't be converted to string
Notes:	called at start of COMMAND.COM's default critical error handler if 
	  installed by a user program, allowing partial or complete overriding
	  of the default error message
	subfunction 02h called by many DOS 4 external programs
SeeAlso: AX=122Eh, INT 24
---------------------------------------------
INT 2F - Multiplex - ASSIGN - INSTALLATION CHECK
	AX = 0600h
Return: AL <> 00h if installed
---------------------------------------------
INT 2F - Multiplex - ASSIGN - GET MEMORY SEGMENT
	AX = 0601h
Return: ES = segment of ASSIGN work area and assignment table
Note:	under DOS 3+, the 26 bytes starting at ES:0103h specify which drive
	  each of A: to Z: is mapped to.  Initially set to 01h 02h 03h....
---------------------------------------------
INT 2F - Multiplex - DRIVER.SYS support - INSTALLATION CHECK
	AX = 0800h
Return:	AL = 00h not installed, OK to install
	     01h not installed, not OK to install
	     FFh installed
---------------------------------------------
INT 2F - Multiplex - DRIVER.SYS support - ADD NEW BLOCK DEVICE
	AX = 0801h
	DS:DI -> drive data table (see AX=0803h)
Notes:	moves down internal list of drive data tables, copying and modifying
	  the drive description flags word for tables referencing same physical
	  drive
	data table appended to chain of tables
SeeAlso: AX=0803h
---------------------------------------------
INT 2F - Multiplex - DRIVER.SYS support - EXECUTE DEVICE DRIVER REQUEST
	AX = 0802h
	ES:BX -> device driver request header (see below)
Return: request header updated as per requested operation

Format of device driver request header:
Offset	Size	Description
 00h	BYTE	length of request header
 01h	BYTE	subunit within device driver
 02h	BYTE	command code (see below)
 03h	WORD	status (filled in by device driver)
		bit 15: error
		bits 14-10: reserved
		bit 9: busy
		bit 8: done
		bits 7-0: error code if bit 15 set (see below)
 05h  8 BYTEs	reserved (unused in DOS 2.x and 3.x)
---command code 00h---
 0Dh	BYTE	number of units (set by driver)
 0Eh	DWORD	address of first free byte following driver (set by driver)
 12h	DWORD	pointer to BPB array (set by block drivers only)
 16h	BYTE	(DOS 3+) drive number for first unit of block driver (0=A)
---command code 01h---
 0Dh	BYTE	media descriptor
 0Eh	BYTE	returned status
		00h don't know
		01h media has not changed
		FFh media has been changed
 0Fh	DWORD	(DOS 3+) pointer to previous volume ID if OPEN/CLOSE/RM bit in
		  device header set and disk changed (set by driver)
---command code 02h---
 0Dh	BYTE	media descriptor
 0Eh	DWORD	transfer address
		-> scratch sector if NON-IBM FORMAT bit in device header set
		-> first FAT sector otherwise
 12h	DWORD	pointer to BPB (set by driver)
---command codes 03h,0Ch---
 0Dh	BYTE	media descriptor (block devices only)
 0Eh	DWORD	transfer address
 12h	WORD	byte count (character devices) or sector count (block devices)
 14h	WORD	starting sector number (block devices only)
---command codes 04h,08h,09h---
 0Dh	BYTE	media descriptor (block devices only)
 0Eh	DWORD	transfer address
 12h	WORD	byte count (character devices) or sector count (block devices)
 14h	WORD	starting sector number (block devices only)
 16h	DWORD	(DOS 3+) pointer to volume ID if error 0Fh returned
---command code 05h---
 0Dh	BYTE	byte read from device if BUSY bit clear on return
---command codes 06h,07h,0Ah,0Bh---
 no further fields
---command code 10h---
 0Dh	BYTE	unused
 0Eh	DWORD	transfer address
 12h	WORD	byte count
---command code 13h---
 0Dh	BYTE	category code
		00h unknown
		01h COMn:
		03h CON
		05h LPTn:
		08h disk
 0Eh	BYTE	function code
 0Fh	DWORD	??? (apparently unused in DOS 3.3)
 13h	DWORD	pointer to parameter block from INT 21/AX=440Dh

Values for command code:
	00h INIT
	01h MEDIA CHECK (block devices)
	02h BUILD BPB (block devices)
	03h IOCTL INPUT
	04h INPUT
	05h NONDESTRUCTIVE INPUT, NO WAIT (character devices)
	06h INPUT STATUS (character devices)
	07h INPUT FLUSH (character devices)
	08h OUTPUT
	09h OUTPUT WITH VERIFY
	0Ah OUTPUT STATUS (character devices)
	0Bh OUTPUT FLUSH (character devices)
	0Ch IOCTL OUTPUT
	0Dh (DOS 3+) DEVICE OPEN
	0Eh (DOS 3+) DEVICE CLOSE
	0Fh (DOS 3+) REMOVABLE MEDIA (block devices)
	10h (DOS 3+) OUTPUT UNTIL BUSY (character devices)
	11h unused
	12h unused
	13h (DOS 3.2+) GENERIC IOCTL
	14h unused
	15h unused
	16h unused
	17h (DOS 3.2+) GET LOGICAL DEVICE
	18h (DOS 3.2+) SET LOGICAL DEVICE
	80h (CD-ROM) READ LONG
	81h (CD-ROM) reserved
	82h (CD-ROM) READ LONG PREFETCH
	83h (CD-ROM) SEEK
	84h (CD-ROM) PLAY AUDIO
	85h (CD-ROM) STOP AUDIO
	86h (CD-ROM) WRITE LONG
	87h (CD-ROM) WRITE LONG VERIFY
	88h (CD-ROM) RESUME AUDIO

Values for error code:
	00h write-protect violation
	01h unknown unit
	02h drive not ready
	03h unknown command
	04h CRC error
	05h bad drive request structure length
	06h seek error
	07h unknown media
	08h sector not found
	09h printer out of paper
	0Ah write fault
	0Bh read fault
	0Ch general failure
	0Dh reserved
	0Eh reserved
	0Fh invalid disk change
---------------------------------------------
INT 2F - Multiplex - DOS 4.x DRIVER.SYS support - GET DRIVE DATA TABLE LIST
	AX = 0803h
Return: DS:DI -> first drive data table in list
SeeAlso: AX=0801h

Format of DOS 3.3 drive data table:
Offset	Size	Description
 00h	DWORD	pointer to next table
 04h	BYTE	physical unit number (for INT 13)
 05h	BYTE	logical drive number
 06h 19 BYTEs	BIOS Parameter Block (see also INT 21/AH=53h)
		Offset	Size	Description
		 00h	WORD	bytes per sector
		 02h	BYTE	sectors per cluster, FFh if unknown
		 03h	WORD	number of reserved sectors
		 05h	BYTE	number of FATs
		 06h	WORD	number of root dir entries
		 08h	WORD	total sectors
		 0Ah	BYTE	media descriptor, 00h if unknown
		 0Bh	WORD	sectors per FAT
		 0Dh	WORD	sectors per track
		 0Fh	WORD	number of heads
		 11h	WORD	number of hidden sectors
 19h  	BYTE	???
 1Ah	WORD	number of DEVICE OPEN calls without corresponding DEVICE CLOSE
 1Ch 11 BYTEs	volume label or "NO NAME    " if none
 27h	BYTE	terminating null for volume label???
 28h	BYTE	device type (see INT 21/AX=440Dh)
 29h	WORD	bit flags describing drive
		bit 0: fixed media
		bit 1: door lock supported
		bit 2: ??? (used in determining BPB to set for INT 21/AX=440Dh)
		bit 3: all sectors in a track are the same size
		bit 4: physical drive has multiple logical units
		bit 5: current logical drive for physical drive
		bit 6: ???
		bit 7: ???
		bit 8: ??? (related to disk change detection)
 2Bh	WORD	number of cylinders
 2Dh 19 BYTEs	BIOS Parameter Block for highest capacity supported
 40h  3 BYTEs	???
 43h  9 BYTEs	filesystem type???, default = "NO NAME	"
 4Ch	BYTE	terminating null for filesystem type???
 4Dh	DWORD	time of last access in clock ticks (FFFFFFFFh if never)
		removable media only???

Format of DOS 4.01 drive data table:
Offset	Size	Description
 00h	DWORD	pointer to next table
 04h	BYTE	physical unit number (for INT 13)
 05h	BYTE	logical drive number
 06h 19 BYTEs	BIOS Parameter Block (see also INT 21/AH=53h)
		Offset	Size	Description
		 00h	WORD	bytes per sector
		 02h	BYTE	sectors per cluster, FFh if unknown
		 03h	WORD	number of reserved sectors
		 05h	BYTE	number of FATs
		 06h	WORD	number of root dir entries
		 08h	WORD	total sectors
		 0Ah	BYTE	media descriptor, 00h if unknown
		 0Bh	WORD	sectors per FAT
		 0Dh	WORD	sectors per track
		 0Fh	WORD	number of heads
		 11h	WORD	number of hidden sectors
 19h  9	BYTEs	???
 22h	BYTE	device type (see INT 21/AX=440Dh)
 23h	WORD	bit flags describing drive
		bit 0: fixed media
		bit 1: door lock supported
		bit 2: ???
		bit 3: all sectors in a track are the same size
		bit 4: physical drive has multiple logical units
		bit 5: current logical drive for physical drive
		bit 6: ???
		bit 7: ???
		bit 8: ???
 25h	WORD	number of cylinders
 27h 19 BYTEs	BIOS Parameter Block for highest capacity supported
 3Ah 13 BYTEs	???
 47h	DWORD	time of last access in clock ticks (FFFFFFFFh if never)
 4Bh 11 BYTEs	volume label or "NO NAME    " if none
 56h	BYTE	terminating null for volume label???
 57h	DWORD	serial number
 5Bh  8 BYTEs	filesystem type ("FAT12   " or "FAT16	")
 63h	BYTE	terminating null for filesystem type???
---------------------------------------------
INT 2F - Multiplex - SHARE - INSTALLATION CHECK
	AX = 1000h
Return: AL = 00h  not installed, OK to install
	     01h  not installed, not OK to install
	     FFh  installed
BUG:	values of AL other than 00h put DOS 3.x SHARE into an infinite loop
	  (08E9: OR  AL,AL
	   08EB: JNZ 08EB) <- the buggy instruction (DOS 3.3)
	values of AL other than described here put PCDOS 4.00 into the same
	  loop (the buggy instructions are the same)
SeeAlso: INT 21/AH=52h
---------------------------------------------
INT 2F - Multiplex - DOS 4.0 SHARE internal - ???
	AX = 1040h
	???
Return: ???
---------------------------------------------
INT 2F - Multiplex - DOS 4.0 SHARE internal - CLEAR ??? FLAG
	AX = 1080h
Return: AL = F0h function supported
---------------------------------------------
INT 2F - Multiplex - DOS 4.0 SHARE internal - SET ??? FLAG
	AX = 1081h
Return: AL = F0h function supported
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
	AX = 1100h
Return: AL = 00h  not installed, OK to install
	     01h  not installed, not OK to install
	     FFh  installed
Notes:	called by DOS 3.1+ kernel
	In DOS 4+, the 11xx calls are all in IFSFUNC.EXE, not in the PC LAN
	  Program redirector. 
---------------------------------------------
INT 2F - Multiplex - MSCDEX (MS CD-ROM Extensions) - INSTALLATION CHECK
	AX = 1100h
	STACK: WORD DADAh
Return: AL = 00h not installed, OK to install
		STACK unchanged
	   = 01h not installed, not OK to install
		STACK unchanged
	   = FFh installed
		STACK: WORD ADADh
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
	AX = 1101h
	SS = DOS CS
	SDA first filename pointer -> fully-qualified directory name
	SDA CDS pointer -> current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1103h, AX=1105h, INT 21/AH=3Ah, INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - REMOVE REMOTE DIRECTORY
	AX = 1102h
	SS = DOS CS
	SDA first filename pointer -> fully-qualified directory name
	SDA CDS pointer -> current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	appears to be identical to AX=1101h
SeeAlso: AX=1101h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
	AX = 1103h
	SS = DOS CS
	SDA first filename pointer -> fully-qualified directory name
	SDA CDS pointer -> current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1101h, AX=1105h, INT 21/AH=39h, INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - MAKE REMOTE DIRECTORY
	AX = 1104h
	SS = DOS CS
	SDA first filename pointer -> fully-qualified directory name
	SDA CDS pointer -> current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	appears to be identical to AX=1103h
SeeAlso: AX=1103h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - CHDIR
	AX = 1105h
	SS = DOS CS
	SDA first filename pointer -> fully-qualified directory name
	SDA CDS pointer -> current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1101h, AX=1103h, INT 21/AH=3Bh, INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
	AX = 1106h
	ES:DI -> SFT
	    SFT DPB field -> DPB of drive containing file
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1201h,1227h, INT 21/AH=3Eh
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
	AX = 1107h
	ES:DI -> SFT
	    SFT DPB field -> DPB of drive containing file
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 3.1+ kernel
SeeAlso: INT 21/AH=68h, INT 21/AX=5D01h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
	AX = 1108h
	ES:DI -> SFT
	    SFT DPB field -> DPB of drive containing file
	CX = number of bytes
	SS = DOS CS
	SDA DTA field -> user buffer
Return: CF set on error
	CF clear if successful
	    CX = number of bytes read
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1109h,1229h, INT 21/AH=3Fh, INT 21/AX=5D06h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
	AX = 1109h
	ES:DI -> SFT
	    SFT DPB field -> DPB of drive containing file
	CX = number of bytes
	SS = DOS CS
	SDA DTA field -> user buffer
Return: CF set on error
	CF clear if successful
	    CX = number of bytes written
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1107h, AX=1108h, INT 21/AH=40h, INT 21/AX=5D06h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
	AX = 110Ah
	BX = file handle
	CX:DX = starting offset
	SI = high word of size
	STACK: WORD low word of size
	ES:DI -> SFT
	    SFT DPB field -> DPB of drive containing file
	SS = DOS CS
Return: CF set on error
	   AL = DOS error code (see INT 21/AH=59h)
	STACK unchanged
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=110Bh, INT 21/AH=5Ch
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
	AX = 110Bh
	BX = file handle
	CX:DX = starting offset
	SI = high word of size
	STACK: WORD low word of size
	ES:DI -> SFT for file
	    SFT DPB field -> DPB of drive containing file
Return: CF set on error
	   AL = DOS error code (see INT 21/AH=59h)
	STACK unchanged
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=110Ah, INT 21/AH=5Ch
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
	AX = 110Ch
	ES:DI -> current directory structure for desired drive
Return: AL = sectors per cluster
	AH = ???
	BX = total clusters
	CX = bytes per sector
	DX = number of available clusters
Note:	called by DOS 3.1+ kernel
SeeAlso: INT 21/AH=36h
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 110Dh
	SDA first filename pointer -> name of file
	???
Return: ???
Note:	appears to be similar to AX=110Fh
SeeAlso: AX=110Fh
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
	AX = 110Eh
	SS = DOS CS
	SDA first filename pointer -> fully-qualified name of file
	SDA CDS pointer -> current directory structure for drive with file
	STACK: WORD new file attributes
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
	STACK unchanged
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=110Fh,INT 21/AX=4301h,INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
	AX = 110Fh
	SS = DOS CS
	SDA first filename pointer -> fully-qualified name of file
	SDA CDS pointer -> current directory structure for drive with file
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
	    AX = file attributes
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=110Eh,INT 21/AX=4300h,INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 1110h
	SDA first filename pointer -> name of file
	???
Return: ???
Note:	appears to be similar to AX=110Eh
SeeAlso: AX=110Eh
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
	AX = 1111h
	SS = DS = DOS CS
	SDA first filename pointer = offset of fully-qualified old name
	SDA second filename pointer = offset of fully-qualified new name
	SDA CDS pointer -> current directory structure for drive with file
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 3.1+ kernel
SeeAlso: INT 21/AH=56h,INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 1112h
	SS = DS = DOS CS
	SDA first filename pointer -> name of file
	???
Return: ???
SeeAlso: AX=1111h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
	AX = 1113h
	SS = DS = DOS CS
	SDA first filename pointer -> fully-qualified filename in DOS CS
	SDA CDS pointer -> current directory structure for drive with file
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 3.1+ kernel
SeeAlso: INT 21/AH=41h,INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 1114h
	SDA first filename pointer -> name of file
	???
Return: ???
SeeAlso: AX=1113h
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 1115h
	SS = DOS CS
	ES:DI -> SFT ???
	???
Return: ???
SeeAlso: AX=112Eh
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
	AX = 1116h
	ES:DI -> uninitialized SFT
	SS = DOS CS
	SDA first filename pointer -> fully-qualified name of file to open
	STACK: WORD file open mode (see INT 21/AH=3Dh)
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
	    SFT filled
	STACK unchanged
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1106h,AX=1117h,AX=1118h, INT 21/AH=3Dh, INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
	AX = 1117h
	ES:DI -> uninitialized SFT
	SS = DOS CS
	SDA first filename pointer -> fully-qualified name of file to open
	SDA CDS pointer -> current directory structure for drive with file
	STACK: WORD file creation mode???
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
	    SFT filled
	STACK unchanged
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1106h,AX=1116h,AX=1118h,INT 21/AH=3Ch,INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
	AX = 1118h
	ES:DI -> uninitialized SFT
	SS = DOS CS
	SDA first filename pointer -> fully-qualified name of file
	STACK: WORD file creation mode???
Return: ???
	STACK unchanged
Note:	called by DOS 3.1+ kernel when creating a file on a drive for which the
	  SDA CDS pointer has offset FFFFh
SeeAlso: AX=1106h,AX=1116h,AX=1117h, INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - ???
	AX = 1119h
	???
Return: ???
Notes:	called by DOS 3.1+ kernel
	DOS 4.0 IFSFUNC returns CF set, AX=0003h	
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 111Ah
	???
Return: CF set
	    AX = error code (03h for DOS 4.01 IFSFUNC)
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - FINDFIRST
	AX = 111Bh
	SS = DS = DOS CS
	[DTA] = uninitialized 21-byte findfirst search data (see INT 21/AH=4Eh)
	SDA first filename pointer -> fully-qualified search template
	SDA CDS pointer -> current directory structure for drive with file
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
	    [DTA] = updated findfirst search data
		    (bit 7 of first byte must be set)
	    [DTA+15h] = standard directory entry for file
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=111Ch, INT 21/AH=4Eh, INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - FINDNEXT
	AX = 111Ch
	SS = DS = DOS CS
	[DTA] = 21-byte findfirst search data (see INT 21/AH=4Eh)
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
	    [DTA] = updated findfirst search data
		    (bit 7 of first byte must be set)
	    [DTA+15h] = standard directory entry for file
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=111Bh, INT 21/AH=4Fh
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS
	AX = 111Dh
	DS???
	SS = DOS CS
Return: ???
Notes:	called by DOS 3.1+ kernel
	closes all FCBs opened by process
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
	AX = 111Eh
	SS = DOS CS
	STACK: WORD function to execute
		5F00h  get redirection mode
			BL = type (03h printer, 04h disk)
			Return: BH = state (00h off, 01h on)
		5F01h  set redirection mode
			BL = type (03h printer, 04h disk)
			BH = state (00h off, 01h on)
		5F02h  get redirection list entry
			BX = redirection list index
			DS:SI -> 16-byte local device name buffer
			ES:DI -> 128-byte network name buffer
		5F03h  redirect device
			BL = device type (see INT 21/AX=5F03h)
			CX = stored parameter value
			DS:SI -> ASCIZ source device name
			ES:DI -> destination ASCIZ network path + ASCIZ passwd
		5F04h  cancel redirection
			DS:SI -> ASCIZ device name or network path
		5F05h  get redirection list extended entry
			BX = redirection list index
			DS:SI -> buffer for ASCIZ source device name
			ES:DI -> buffer for destination ASCIZ network path
			Return: BH = status flag
				BL = type (03h printer, 04h disk)
				CX = stored parameter value
				BP = NETBIOS local session number
		5F06h  similar to 5F05h???
Return: CF set on error
	    AX = error code (see INT 21/AH=59h)
	STACK unchanged
Note:	called by DOS 3.1+ kernel
SeeAlso: INT 21/AX=5F00h,5F01h,5F02h,5F03h,5F04h,5F05h,5F06h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
	AX = 111Fh
	STACK: WORD function
		5E02h  set printer setup
		5E03h  get printer setup
		5E04h  set printer mode
		5E05h  get printer mode
Return: CF set on error
	    AX = error code (see INT 21/AH=59h)
	STACK unchanged
Note:	called by DOS 3.1+ kernel
SeeAlso: INT 21/AX=5E02h,5E03h,5E04h,5E05h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
	AX = 1120h
	DS = DOS CS
	???
Return: CF clear (successful)
Notes:	called by DOS 3.1+ kernel
	uses CDS array pointer and LASTDRIVE= entries in DOS list of lists
SeeAlso: INT 21/AH=0Dh, INT 21/AX=5D01h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
	AX = 1121h
	CX:DX = offset (in bytes) from end
	ES:DI -> SFT
	    SFT DPB field -> DPB of drive with file
	SS = DOS CS
Return: CF set on error
	    AL = DOS error code (see INT 21/AH=59h)
	CF clear if successful
	    DX:AX = new file position
Note:	called by DOS 3.1+ kernel
SeeAlso: AX=1228h, INT 21/AH=42h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
	AX = 1122h
	SS = DOS CS
	???
Return: ???
Note:	called by DOS 3.1+ kernel
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
	AX = 1123h
	DS:SI -> ASCIZ filename to canonicalize
	ES:DI -> 128-byte buffer for qualified name
Return: CF set if not resolved
Notes:	called by DOS 3.1+ kernel
	called first when DOS attempts to resolve a filename (unless inside an
	  AX=5D00h server call); if this fails, DOS resolves the name locally
SeeAlso: AX=1221h, INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - ???
	AX = 1124h
	ES:DI -> SFT
	SS = DOS CS
	???
Return: CX = ???
Note:	called by DOS 3.1+ kernel
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
	AX = 1125h
	STACK: WORD subfunction
		5D07h get print stream state
			Return: DL = current state
		5D08h set print stream state
			DL = new state
		5D09h finish print job
Return: CF set on error
	    AX = error code (see INT 21/AH=59h)
	STACK unchanged
Note:	called by DOS 3.1+ kernel
SeeAlso: INT 21/AX=5D07h,5D08h,5D09h
---------------------------------------------
INT 2F - Multiplex - NETWORK REDIRECTOR - ???
	AX = 1126h
	???
Return: CF set on error???
Note:	called by DOS 3.1+ kernel
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - UNUSED
	AX = 1127h
Return: CF set
	    AX = 0001h (invalid function) (see INT 21/AH=59h)
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - UNUSED
	AX = 1128h
Return: CF set
	    AX = 0001h (invalid function) (see INT 21/AH=59h)
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - UNUSED
	AX = 1129h
Return: CF set
	    AX = 0001h (invalid function) (see INT 21/AH=59h)
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 112Ah
	DS = DOS CS
	???
Return: ???
Note:	does something to each IFS driver
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 112Bh
	SS = DOS CS
	CX = ???
	DX = ???
	STACK: WORD low byte contains function???
		0Dh ???
	???
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 4.0 kernel
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 112Ch
	SS = DOS CS
	SDA current SFT pointer -> SFT for file
	???
Return: CF set on error
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 112Dh
	BL = subfunction
	    04h ???
		Return: CF clear
	    else ???
		Return: CX = ??? (00h or 02h for DOS 4.01)
	SS = DOS CS
Return: DS = DOS CS
Note:	called by DOS 4.0 kernel
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 112Eh
	SS = DS = DOS CS
	STACK: WORD ???   low byte = ???
Return: CF set on error
	CF clear if successful
	    CX = ???
Note:	called by DOS 4.0 kernel
SeeAlso: AX=1115h
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - ???
	AX = 112Fh
	SS = DOS CS
	STACK: WORD function in low byte
		00h ???
		    DS:SI -> Current Directory Structure???
		    CL = drive (1=A:)
		01h ???
		    DS:SI -> ???
		    CL = file handle???
		02h ???
		    DS:SI -> Current Directory Structure???
		    DI = ???
		    CX = drive (1=A:)
	???
Return: CF set on error
	    AX = DOS error code (see INT 21/AH=59h)
	CF clear if successful
Note:	called by DOS 4.0 kernel
SeeAlso: INT 21/AH=6Bh
---------------------------------------------
INT 2F - Multiplex - DOS 4 IFSFUNC.EXE - GET IFSFUNC SEGMENT
	AX = 1130h
Return: ES = CS of resident IFSFUNC
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - INSTALLATION CHECK
	AX = 1200h
Return: AL = FFh (for compatibility with other INT 2F functions)
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - CLOSE CURRENT FILE
	AX = 1201h
	SS = DOS CS
	SDA current SFT pointer -> SFT of file to close
Return: BX???
	CX???
	ES:DI -> SFT for file
SeeAlso: AX=1106h,1227h, INT 21/AH=3Eh
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET INTERRUPT ADDRESS
	AX = 1202h
	STACK: WORD vector number
Return: ES:BX -> interrupt vector
	STACK unchanged
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET DOS DATA SEGMENT
	AX = 1203h
Return: DS = segment of IBMDOS
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - NORMALIZE PATH SEPARATOR
	AX = 1204h
	STACK: WORD character to normalize
Return: AL = normalized character (forward slash turned to backslash, all
		others unchanged)
	ZF set if path separator
	STACK unchanged
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - OUTPUT CHARACTER TO STANDARD OUTPUT
	AX = 1205h
	STACK: WORD character to output
Return: STACK unchanged
Note:	can be called only from within DOS
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - INVOKE CRITICAL ERROR
	AX = 1206h
	DI = error code
	BP:SI -> device driver header
	SS = DOS CS
	STACK: WORD value to be passed to INT 24 in AX
Return: AL = 0-3 for Abort, Retry, Ignore, Fail
	STACK unchanged
SeeAlso: INT 24
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - MAKE DISK BUFFER MOST-RECENTLY USED
	AX = 1207h
	DS:DI -> disk buffer
Return: buffer moved to end of buffer list (least-recently used is first)
Note:	can be called only from within DOS
SeeAlso: AX=120Fh
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - DECREMENT SFT REFERENCE COUNT
	AX = 1208h
	ES:DI -> SFT
Return: AX = new value of reference count
Note:	if the reference count was 1, it is set to FFFFh (since 0 indicates
	  that the SFT is not in use)
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - FLUSH AND FREE DISK BUFFER
	AX = 1209h
	DS:DI -> disk buffer
Return: disk buffer marked unused, contents written to disk if buffer dirty
Note:	can be called only from within DOS
SeeAlso: AX=120Eh,1215h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - PERFORM CRITICAL ERROR INTERRUPT
	AX = 120Ah
	DS = SS = DOS CS
	STACK: WORD extended error code
Return: AL = user response (0=ignore, 1=retry, 2=abort, 3=fail)
	CF clear if retry, set otherwise
	STACK unchanged
Note:	can only be called during a DOS function call, as it uses various
	  fields in the SDA to set up the registers for the INT 24
SeeAlso: INT 24
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - SIGNAL SHARING VIOLATION TO USER
	AX = 120Bh
	ES:DI -> system file table entry for previous open of file
	STACK: WORD extended error code (should be 20h--sharing violation)
Return: CF clear if operation should be retried
	CF set if operation should not be retried
	    AX = error code (20h) (see AH=59h)
	STACK unchanged
Notes:	can only be called during a DOS function call
	should only be called if an attempt was made to open an already-open
	  file contrary to the sharing rules
	invokes INT 24 if SFT file opened via FCB or in compatibility mode with
	  inheritance allowed
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - SET FCB FILE'S OWNER???
	AX = 120Ch
	SDA current SFT pointer -> SFT for file
	DS = SS = DOS CS
Return: ES, DI, AX destroyed
Note:	seems to change owner of last-accessed file to calling process
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET DATE AND TIME
	AX = 120Dh
	SS = DOS CS
Return: AX = current date in packed format (see INT 21/AX=5700h)
	DX = current time in packed format (see INT 21/AX=5700h)
SeeAlso: INT 21/AH=2Ah,2Ch
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - MARK ALL DISK BUFFERS UNREFERENCED
	AX = 120Eh
	SS = DOS CS
Return: DS:DI -> first disk buffer
Note:	clears "referenced" flag on all disk buffers
SeeAlso: AX=1209h,1210h, INT 21/AH=0Dh
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - MAKE BUFFER MOST RECENTLY USED
	AX = 120Fh
	DS:DI -> disk buffer
	SS = DOS CS
Return: DS:DI -> next buffer in buffer list
Note:	indicated buffer moved to end of chain
SeeAlso: AX=1207h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - FIND UNREFERENCED DISK BUFFER
	AX = 1210h
	DS:DI -> first disk buffer to check
Return: ZF clear if found
	    DS:DI -> first unreferenced disk buffer
	ZF set if not found
SeeAlso: AX=120Eh
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - NORMALIZE ASCIZ FILENAME
	AX = 1211h
	DS:SI -> ASCIZ filename to normalize
	ES:DI -> buffer for normalized filename
Return: destination buffer filled with uppercase filename, with slashes turned
	to backslashes
SeeAlso: AX=121Eh,1221h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET LENGTH OF ASCIZ STRING
	AX = 1212h
	ES:DI -> ASCIZ string
Return: CX = length of string
SeeAlso: AX=1225h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - UPPERCASE CHARACTER
	AX = 1213h
	STACK: WORD character to convert to uppercase
Return: AL = uppercase character
	STACK unchanged
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - COMPARE FAR POINTERS
	AX = 1214h
	DS:SI = first pointer
	ES:DI = second pointer
Return: ZF set if pointers are equal, ZF clear if not equal
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - FLUSH BUFFER
	AX = 1215h
	DS:DI -> disk buffer
	SS = DOS CS
	STACK: WORD drives for which to skip buffer
		ignore buffer if drive same as high byte, or bytes differ and
		the buffer is for a drive OTHER than that given in low byte
Return: STACK unchanged
Note:	can be called only from within DOS
SeeAlso: AX=1209h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET ADDRESS OF SYSTEM FILE TABLE
	AX = 1216h
	BX = system file table entry number
Return: CF clear if successful
	    ES:DI -> system file table entry
	CF set if BX greater than FILES=
SeeAlso: AX=1220h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - SET WORKING DRIVE
	AX = 1217h
	SS = DOS CS
	STACK: WORD drive (0 = A:, 1 = B:, etc)
Return: CF set on error
	    (drive > LASTDRIVE)
	CF clear if successful
	    DS:SI -> current directory structure for specified drive
	STACK unchanged
SeeAlso: AX=1219h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET CALLER'S REGISTERS
	AX = 1218h
Return: DS:SI -> saved caller's AX,BX,CX,DX,SI,DI,BP,DS,ES (on stack)
Note:	only valid while within DOS
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - SET DRIVE???
	AX = 1219h
	SS = DOS CS
	STACK: WORD drive (0 = default, 1 = A:, etc)
Return: ???
	STACK unchanged
Notes:	calls AX=1217h
	builds a current directory structure if inside server call
	  (INT 21/AX=5D00h)
SeeAlso: AX=1217h,121Fh
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET FILE'S DRIVE
	AX = 121Ah
	DS:SI -> filename
Return: AL = drive (0 = default, 1 = A:, etc, FFh = invalid)
SeeAlso: INT 21/AH=19h,60h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - SET YEAR/LENGTH OF FEBRUARY
	AX = 121Bh
	CL = year - 1980
Return: AL = number of days in February
Note:	requires DS to be set to the DOS code segment
SeeAlso: INT 21/AH=2Bh
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - CHECKSUM MEMORY
	AX = 121Ch
	DS:SI -> start of memory to checksum
	CX = number of bytes
	DX = initial checksum
	SS = DOS CS
Return: AX, CX destroyed
	DX = checksum
	DS:SI -> first byte after checksummed range
SeeAlso: AX=121Dh
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - SUM MEMORY
	AX = 121Dh
	DS:SI -> memory to add up
	CX = 0000h
	DX = limit
Return: AL = byte which exceeded limit
	CX = number of bytes before limit exceeded
	DX = remainder after adding first CX bytes
	DS:SI -> byte beyond the one which exceeded the limit
SeeAlso: AX=121Ch
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - COMPARE FILENAMES
	AX = 121Eh
	DS:SI -> first ASCIZ filename
	ES:DI -> second ASCIZ filename
Return: ZF set if filenames equivalent, ZF clear if not
SeeAlso: AX=1211h,1221h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - BUILD CURRENT DIRECTORY STRUCTURE
	AX = 121Fh
	SS = DOS CS
	STACK: WORD drive letter
Return: ES:DI -> current directory structure (will be overwritten by next call)
	STACK unchanged
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET JOB FILE TABLE ENTRY
	AX = 1220h
	BX = file handle
Return: CF set on error
	    AL = 6 (invalid file handle)
	CF clear if successful
	    ES:DI -> JFT entry for file handle in current process
Note:	the byte pointed at by ES:DI contains the number of the SFT for the
	  file handle, or FFh if the handle is not open
SeeAlso: AX=1216h,1229h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - CANONICALIZE FILE NAME
	AX = 1221h
	DS:SI -> file name to be fully qualified
	ES:DI -> 128-byte buffer for resulting canonical file name
	SS = DOS CS
Return: (see INT 21/AH=60h)
Note:	identical to INT 21/AH=60h
SeeAlso: AX=1123h, INT 21/AH=60h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - SET EXTENDED ERROR INFO
	AX = 1222h
	SS = DOS data segment
	SS:SI -> 4-byte records
		BYTE	error code, FFh = last record
		BYTE	error class, FFh = don't change
		BYTE	suggested action, FFh = don't change
		BYTE	error locus, FFh = don't change
	SDA error code set
Return: SI destroyed
	SDA error class, error locus, and suggested action fields set
Note:	can be called only from within DOS
SeeAlso: AX=122Dh,INT 21/AH=59h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - CHECK IF CHARACTER DEVICE
	AX = 1223h
	SDA+218h (DOS 3.10-3.30) = eight-character blank-padded name
	SDA+22Bh (DOS 4.0x) = eight-character blank-padded name
Return: CF set if no character device by that name found
	CF clear if found
	    BH = low byte of device attribute word
Note:	can only be called from within DOS (assumes DS=SS=DOS CS)
SeeAlso: INT 21/AX=5D06h,5D0Bh
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - DELAY
	AX = 1224h
	SS = DOS CS
Return: after delay set by INT 21/AX=440Bh, unless in server call
	  (INT 21/AX=5D00h)
Note:	delay is dependent on the processor speed, and is skipped entirely if
	  inside a server call
SeeAlso: INT 21/AX=440Bh, INT 21/AH=52h
---------------------------------------------
INT 2F - Multiplex - DOS 3+ internal - GET LENGTH OF ASCIZ STRING
	AX = 1225h
	DS:SI -> ASCIZ string
Return: CX = length of string
SeeAlso: AX=1212h
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - OPEN FILE
	AX = 1226h
	CL = access mode
	DS:DX -> ASCIZ filename
Return: CF set on error
	    AL = error code (see INT 21/AH=59h)
	CF clear if successful
	    AX = file handle
Notes:	can only be called from within DOS (assumes SS=DOS CS)
	equivalent to INT 21/AH=3Dh	
SeeAlso: AX=1227h,INT 21/AH=3Dh
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - CLOSE FILE
	AX = 1227h
	BX = file handle
Return: CF set on error
	    AL = 06h invalid file handle
	CF clear if successful
Notes:	can only be called from within DOS (assumes SS=DOS CS)
	equivalent to INT 21/AH=3Eh
SeeAlso: AX=1106h,1201h,1226h, INT 21/AH=3Eh
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - MOVE FILE POINTER
	AX = 1228h
	BP = 4200h, 4201h, 4202h (see INT 21/AH=42h)
	BX = file handle
	CX:DX = offset in bytes
	SS = DOS CS
Return: as for INT 21/AH=42h
Notes:	equivalent to INT 21/AH=42h, but may only be called from inside a DOS
	  function call
	sets user stack frame pointer to dummy buffer, moves BP to AX, performs
	  LSEEK, and restores frame pointer
SeeAlso: INT 21/AH=42h
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - READ FROM FILE
	AX = 1229h
	BX = file handle
	CX = number of bytes to read
	DS:DX -> buffer
	SS = DOS CS
Return: as for INT 21/AH=3Fh
Note:	equivalent to INT 21/AH=3Fh, but may only be called when already inside
	  a DOS function call
SeeAlso: AX=1226h,INT 21/AH=3Fh
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - SET FASTOPEN ENTRY POINT
	AX = 122Ah
	BX = entry point to set (0001h or 0002h)
	DS:SI -> FASTOPEN entry point
		(entry point not set if SI = FFFFh for DOS 4+)
Return: CF set if specified entry point already set
Notes:	entry point in BX is ignored under DOS 3.30
	both entry points set to same handler by DOS 4.01

DOS 3.30 FASTOPEN is called with:
	AL = 01h  ???
	    CX = ??? seems to be offset
	    DI = ??? seems to be offset
	    SI = offset in DOS CS of filename
	AL = 02h  ???
	AL = 03h  open file???
	    SI = offset in DOS CS of filename
	AL = 04h  ???
	    AH = subfunction (00h,01h,02h)
	    ES:DI -> ???
	    CX = ??? (subfunctions 01h and 02h only)
Returns: CF set on error or not installed
Note: function 03h calls function 01h first

PCDOS 4.01 FASTOPEN is additionally called with:
	AL = 04h ???
	    AH = 03h
	    ???
	AL = 05h ???
	AL = 0Bh ???
	AL = 0Ch ???
	AL = 0Dh ???
	AL = 0Eh ???
	AL = 0Fh ???
	AL = 10h ???
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - IOCTL
	AX = 122Bh
	BP = 44xxh
	SS = DOS CS
	additional registers as appropriate for INT 21/AX=44xxh
Return: as for INT 21/AH=44h
Notes:	equivalent to INT 21/AH=44h, but may only be called when already inside
	  a DOS function call
	sets user stack frame pointer to dummy buffer, moves BP to AX, performs
	  IOCTL, and restores frame pointer
SeeAlso: INT 21/AH=44h
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - GET DEVICE CHAIN
	AX = 122Ch
Return: BX:AX -> header of second device driver (NUL is first) in driver chain
SeeAlso: INT 21/AH=52h
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - GET EXTENDED ERROR CODE
	AX = 122Dh
Return: AX = current extended error code
SeeAlso: AX=1222h,INT 21/AH=59h
---------------------------------------------
INT 2F - Multiplex - DOS 4.00 internal - GET OR SET ERROR TABLE ADDRESSES
	AX = 122Eh
	DL = subfunction
	    00h get standard DOS error table (errors 00h-12h,50h-5Bh)
		Return: ES:DI -> error table
	    01h set standard DOS error table
		ES:DI -> error table
	    02h get parameter error table (errors 00h-0Ah)
		Return: ES:DI -> error table
	    03h set parameter error table
		ES:DI -> error table
	    04h get critical/SHARE error table (errors 13h-2Bh)
		Return: ES:DI -> error table
	    05h set critical/SHARE error table
		ES:DI -> error table
	    06h get ??? error table
		Return: ES:DI -> error table
	    07h set ??? error table
		ES:DI -> error table
	    08h get ??? error table
		Return: ES:DI -> error table
	    09h set ??? error table
		ES:DI -> error table
SeeAlso: INT 21/AH=59h

Format of error table:
Offset	Size	Description
 00h	BYTE	FFh
 01h  2 BYTEs	04h,00h (DOS version???)
 03h	BYTE	number of error headers following
 04h 2N WORDs	table of all error headers for table
		Offset	Size	Description
		 00h	WORD	error message number
		 02h	WORD	offset of error message from start of header
				error messages are count byte followed by msg
---------------------------------------------
INT 2F - Multiplex - DOS 4.0 internal - SET ???
	AX = 122Fh
	DX = ???
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ - SET DISK INTERRUPT HANDLER
	AH = 13h
	DS:DX -> interrupt handler disk driver calls on read/write
	ES:BX = address to restore INT 13 to on system halt (exit from root
		 shell)
Return: DS:DX from previous invocation of this function
	ES:BX from previous invocation of this function
Notes:	most DOS 3.3+ disk access is via the vector in DS:DX, although a few
	  functions are still invoked via an INT 13 instruction
	this is a dangerous security loophole for any virus-monitoring software
	  which does not trap this call (at least two viruses are known to use
	  it to get the original ROM entry point)
---------------------------------------------
INT 2F - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
	AX = 1400h
Return: AL = 00h not installed, OK to install
	     01h not installed, not OK
	     FFh installed
Note:	called by DOS v3.3+ kernel
---------------------------------------------
INT 2F - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
	AX = 1401h
	DS:SI -> internal code page structure (see below)
	BX = new code page
	DX = country code???
Return: AL = status
	     00h successful
	     else DOS error code
Note:	called by DOS v3.3+ kernel
SeeAlso: INT 21/AH=66h

Format of DOS 3.30 internal code page structure:
Offset	Size	Description
 00h  8 BYTEs	???
 08h 64 BYTEs	name of country information file
 48h	WORD	system code page
 4Ah	WORD	number of supported subfunctions
 4Ch  5 BYTEs	data to return for INT 21/AX=6502h
 51h  5 BYTEs	data to return for INT 21/AX=6504h
 56h  5 BYTEs	data to return for INT 21/AX=6505h
 5Bh  5 BYTEs	data to return for INT 21/AX=6506h
 60h 41 BYTEs	data to return for INT 21/AX=6501h
---------------------------------------------
INT 2F - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
	AX = 1402h
	BP = subfunction (same as AL for INT 21/AH=65h)
	BX = code page
	DX = country code
	DS:SI -> internal code page structure (see AX=1401h)
	ES:DI -> user buffer
	CX = size of user buffer
Return: AL = status
	    00h successful
	    else DOS error code
Notes:	called by DOS v3.3+ kernel on INT 21/AH=65h
	code page structure apparently only needed for COUNTRY.SYS pathname
SeeAlso: AX=1403h,1404h, INT 21/AH=65h
---------------------------------------------
INT 2F - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
	AX = 1403h
	DS:SI -> internal code page structure (see AX=1401h)
	BX = code page
	DX = country code
Return: AL = status 
	     ???
Note:	called by DOS v3.3+ kernel on INT 21/AH=38h
SeeAlso: AX=1402h,1404h, INT 21/AH=38h"SET"
---------------------------------------------
INT 2F - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
	AX = 1404h
	BX = code page
	DX = country code
	DS:SI -> internal code page structure (see AX=1401h)
	ES:DI -> user buffer
Return: AL = status
	     ???
Notes:	called by DOS v3.3+ kernel on INT 21/AH=38h
	code page structure apparently only needed for COUNTRY.SYS pathname
SeeAlso: AX=1402h,1403h, INT 21/AH=38h"GET"
---------------------------------------------
INT 2F - Multiplex - CDROM - INSTALLATION CHECK
	AX = 1500h
	BX = 0000h
Return: BX = number of CDROM drive letters used
	CX = starting drive letter (0=A:)
Note:	this installation check DOES NOT follow the format used by other
	  software
---------------------------------------------
INT 2F - Multiplex - DOS 4+ GRAPHICS.COM - INSTALLATION CHECK
	AX = 1500h
Return: AX = FFFFh
	ES:DI -> ??? (graphics data?)
---------------------------------------------
INT 2F - Multiplex - CDROM - GET DRIVE DEVICE LIST
	AX = 1501h
	ES:BX -> buffer to hold drive letter list (5 bytes per drive letter)
Return: buffer filled, for each drive letter
	  BYTE	subunit number in driver
	  DWORD address of device driver header
---------------------------------------------
INT 2F - Multiplex - CDROM - GET COPYRIGHT FILE NAME
	AX = 1502h
	ES:BX -> 38-byte buffer for name of copyright file
	CX = drive number (0=A:)
Return: CF set if drive is not a CDROM drive
	    AX = 15 (invalid drive)
	CF clear if successful
SeeAlso: AX=1503h
---------------------------------------------
INT 2F - Multiplex - CDROM - GET ABSTRACT FILE NAME
	AX = 1503h
	ES:BX -> 38-byte buffer for name of abstract file
	CX = drive number (0=A:)
Return: CF set if drive is not a CDROM drive
	    AX = 15 (invalid drive)
	CF clear if successful
SeeAlso: AX=1502h
---------------------------------------------
INT 2F - Multiplex - CDROM - GET BIBLIOGRAPHIC DOC FILE NAME
	AX = 1504h
	ES:BX -> 38-byte buffer for name of bibliographic documentation file
	CX = drive number (0=A:)
Return: CF set if drive is not a CDROM drive
	    AX = 15 (invalid drive)
	CF clear if successful
---------------------------------------------
INT 2F - Multiplex - CDROM - READ VTOC
	AX = 1505h
	ES:BX -> 2048-byte buffer
	CX = drive number (0=A:)
	DX = sector index (0=first volume descriptor,1=second,...)
Return: CF set on error
	    AX = error code (15=invalid drive,21=not ready)
	CF clear if successful
	    AX = volume descriptor type (1=standard,FFh=terminator,0=other)
---------------------------------------------
INT 2F - Multiplex - CDROM - TURN DEBUGGING ON
	AX = 1506h
	BX = debugging function to enable
Note:	reserved for development
SeeAlso: AX=1507h
---------------------------------------------
INT 2F - Multiplex - CDROM - TURN DEBUGGING OFF
	AX = 1507h
	BX = debugging function to disable
Note:	reserved for development
SeeAlso: AX=1506h
---------------------------------------------
INT 2F - Multiplex - CDROM - ABSOLUTE DISK READ
	AX = 1508h
	ES:BX -> buffer
	CX = drive number (0=A:)
	SI:DI = starting sector number
	DX = number of sectors to read
Return: CF set on error
	    AL = error code (15=invalid drive,21=not ready)
	CF clear if successful
SeeAlso: AX=1509h
---------------------------------------------
INT 2F - Multiplex - CDROM - ABSOLUTE DISK WRITE
	AX = 1509h
	ES:BX -> buffer
	CX = drive number (0=A:)
	SI:DI = starting sector number
	DX = number of sectors to write
Note:	corresponds to INT 26h and is currently reserved and nonfunctional
SeeAlso: AX=1508h
---------------------------------------------
INT 2F - Multiplex - CDROM - RESERVED
	AX = 150Ah
---------------------------------------------
INT 2F - Multiplex - CDROM 2.00 - DRIVE CHECK
	AX = 150Bh
	CX = drive number (0=A:)
Return: BX = ADADh if MSCDEX.EXE installed
	    AX = 0000h if drive not supported
		nonzero if supported
SeeAlso: AX=150Dh
---------------------------------------------
INT 2F - Multiplex - CDROM 2.00 - GET MSCDEX.EXE VERSION
	AX = 150Ch
Return: BH = major version
	BL = minor version
Note:	MSCDEX.EXE versions prior to 1.02 return BX=0
---------------------------------------------
INT 2F - Multiplex - CDROM 2.00 - GET CDROM DRIVE LETTERS
	AX = 150Dh
	ES:BX -> buffer for drive letter list (1 byte per drive)
Return: buffer filled with drive numbers (0=A:).  Each byte corresponds
	to the drive in the same position for function 1501h
SeeAlso: AX=150Bh
---------------------------------------------
INT 2F - Multiplex - CDROM 2.00 - GET/SET VOLUME DESCRIPTOR PREFERENCE
	AX = 150Eh
	BX = subfunction
	    00h get preference
		DX = 0000h
		Return: DX = preference settings
	    01h set preference
		DH = volume descriptor preference
		    01h = primary volume descriptor
		    02h = supplementary volume descriptor
		DL = supplementary volume descriptor preference
		    01h = shift-Kanji
	CX = drive number (0=A:)
Return: CF set on error
	    AX = error code (15=invalid drive,1=invalid function)
	CF clear if successful
---------------------------------------------
INT 2F - Multiplex - CDROM 2.00 - GET DIRECTORY ENTRY
	AX = 150Fh
	CX = drive number (0=A:)
	ES:BX -> ASCIZ path name
	SI:DI -> 255-byte buffer for directory entry
Return: CF set on error
	    AX = error code
	CF clear if succesful
	    AX = disk format (0=High Sierra,1=ISO 9660)

Format of directory entry:
Offset	Size	Description
 00h	BYTE  length of directory entry
 01h	BYTE  length of XAR in LBN's (don't ask me what that means...)
 02h	DWORD LBN of data, Intel (little-endian) format
 06h	DWORD LBN of data, Motorola (big-endian) format
 0Ah	DWORD length of file, Intal format
 0Eh	DWORD length of file, Motorola format
---High Sierra---
 12h  6 BYTEs date and time
 18h	BYTE  bit flags
 19h	BYTE  reserved
---ISO 9660---
 12h  7 BYTEs date and time
 19h	BYTE  bit flags
---both formats---
 1Ah	BYTE  interleave size
 1Bh	BYTE  interleave skip factor
 1Ch	WORD  volume set sequence number, Intel format
 1Eh	WORD  volume set sequence number, Motorola format
 20h	BYTE  length of file name
 21h  N BYTEs file name
	BYTE (optional) padding if filename is odd length
      N BYTEs system data
---------------------------------------------
INT 2F - Multiplex - CDROM 2.10 - SEND DEVICE DRIVER REQUEST
	AX = 1510h
	CX = CD-ROM drive letter (0 = A, 1 = B, etc)
	ES:BX -> CD-ROM device driver request header (see AX=0802h)
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS - ENHANCED WINDOWS INSTALLATION CHECK
	AX = 1600h
Return: AL = 00h if Enhanced Windows 3.x or Windows/386 2.x not running
	AL = 80h if Enhanced Windows 3.x or Windows/386 2.x not running
	AL = 01h if Windows/386 2.x running
	AL = FFh if Windows/386 2.x running
	AL = anything else
	    AL = Windows major version number >= 3
	    AH = Windows minor version number
Note:	INT 2F/AH=16h comprises an API for non-Windows programs (DOS device
	  drivers, TSRs, and applications) to cooperate with multitasking
	  Windows/386 2.x and Windows 3.x and higher enhanced mode.
	certain calls are also supported in the Microsoft 80286 DOS extender in
	  Windows standard mode
SeeAlso: AX=4680h
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS/386 2.x - GET API ENTRY POINT
	AX = 1602h
Return: ES:DI -> Windows/386 2.x API procedure entry point
Notes:	this interface is supported in Windows 3.x only for compatibility
	to get the current virtual machine (VM) ID in Windows/386 2.x:
	    AX = 0000h
	    ES:DI -> return address
	    JUMP to address returned from INT 2F/AX=1602h
	After JUMP, at return address:
	    VX??? = current VM ID.
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS - ENHANCED WINDOWS & 286 DOSX INIT BROADCAST
	AX = 1605h
	ES:BX = 0000h:0000h
	DS:SI = 0000h:0000h
	CX = 0000h
	DX = flags
	    bit 0 = 0 if enhanced Windows initialization
	    bit 0 = 1 if Microsoft 286 DOS extender initialization
	    bits 1-15 reserved (undefined)
Return: CX = 0000h if okay for Windows to load
	CX <> 0 if Windows should not load
Note:	the enhanced Windows loader and Microsoft 286 DOS extender will
	  broadcast an INT 2F/AX=1605h call when initializing.	Any DOS device
	  driver or TSR can watch for this broadcast and return the appropriate
	  values.  If the driver or TSR returns CX <> 0, it is also its
	  responsibility to display an error message.
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS - ENHANCED WINDOWS & 286 DOSX EXIT BROADCAST
	AX = 1606h
	DX = flags
	    bit 0 = 0 if enhanced Windows exit
	    bit 0 = 1 if Microsoft 286 DOS extender exit
	    bits 1-15 reserved (undefined)
Return: CX = 0000h if okay for Windows to load
	CX <> 0 if Windows should not load
Note:	if the init broadcast fails (AX=1605h returned CX <> 0), then this
	  broadcast will be issued immediately.
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS - VIRTUAL DEVICE CALL OUT API
	AX = 1607h
	BX = virtual device ID (see INT 2Fh AX=1684h)
Note:	more of a convention than an API, this call specifies a standard
	  mechanism for enhanced Windows virtual devices (VxD's) to talk to DOS
	  device drivers and TSRs
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS - ENHANCED WINDOWS INIT COMPLETE BROADCAST
	AX = 1608h
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS - ENHANCED WINDOWS BEGIN EXIT BROADCAST
	AX = 1609h
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS - RELEASE CURRENT VIRTUAL MACHINE TIME-SLICE
	AX = 1680h
Return: AL = 00h if the call is supported
	AL = 80h (unchanged) if the call is not supported
Notes:	programs can use this function, even when not running under Windows in
	  386 enhanced mode, because OS/2 can use the call to detect idleness
	  even though it does not support the complete enhanced Windows API. 
	this call will be supported in OS/2 2.0 for multitasking DOS
	  applications
	does not block the program; it just gives up the remainder of the time
	  slice
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS 3+ - BEGIN CRITICAL SECTION
	AX = 1681h
Notes:	used to prevent a task switch from occurring
	should be followed by an INT 2F/AX=1682h call as soon as possible
	not supported in Windows/386 2.x. Get INDOS flag with INT 21/AH=34h and
	  and increment by hand.
SeeAlso: AX=1682h, INT 21/AH=34h
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS 3+ - END CRITICAL SECTION
	AX = 1682h
Note:	not supported in Windows/386 2.x.  Get INDOS flag with INT 21/AH=34h
	  and decrement by hand.
SeeAlso: AX=1681h, INT 21/AH=34h
---------------------------------------------
INT 2Fh - Multiplex - MS WINDOWS 3+ - GET CURRENT VIRTUAL MACHINE ID
	AX = 1683h
Return: BX = current virtual machine (VM) ID
Notes:	Windows itself currently runs in VM 1, but this can't be relied upon
	VM IDs are reused when VMs are destroyed
	an ID of 0 will never be returned
SeeAlso: AX=1684h, AX=1685h
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS - GET DEVICE API ENTRY POINT
	AX = 1684h
	BX = virtual device (VxD) ID (see below)
	ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point, or 0:0 if the VxD does not support an API
Note:	some enhanced Windows virtual devices provide services that
	  applications can access.  For example, the Virtual Display Device
	  (VDD) provides an API used in turn by WINOLDAP.
SeeAlso: AX=1683h

Values for VxD ID:
 01h	VMM		Virtual Machine Manager
 02h	Debug
 03h	VPICD		Virtual Prog. Interrupt Controller (PIC) Device
 04h	VDMAD		Virtual Direct Memory Access (DMA) Device
 05h	VTD		Virtual Timer Device
 06h	V86MMGR		Virtual 8086 Mode Device
 07h	PAGESWAP	Paging Device
 08h	Parity
 09h	Reboot
 0Ah	VDD		Virtual Display Device (GRABBER)
 0Bh	VSD		Virtual Sound Device
 0Ch	VMD		Virtual Mouse Device
 0Dh	VKD		Virtual Keyboard Device
 0Eh	VCD		Virtual COMM Device
 0Fh	VPD		Virtual Printer Device
 10h	VHD		Virtual Hard Disk Device
 11h	VMCPD
 12h	EBIOS		Reserve EBIOS page (e.g., on PS/2)
 13h	BIOSXLAT	Map ROM BIOS API between prot & V86 mode
 14h	VNETBIOS	Virtual NetBIOS Device
 15h	DOSMGR
 16h	WINLOAD
 17h	SHELL
 18h	VMPoll
 19h	VPROD
 1Ah	DOSNET		assures network integrity across VMs
 1Bh	VFD		Virtual Floppy Device
 1Ch	VDD2		Secondary display adapter
 1Dh	WINDEBUG
 1Eh	TSRLoad		TSR instance utility
Note:	The high bit of the VxD ID is reserved for future use. The
	next 10 bits are the OEM # which is assigned by Microsoft. The
	low 5 bits are the device number. 
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS - SWITCH VMs AND CALLBACK
	AX = 1685h
	BX = VM ID of virtual machine to switch to
	CX = flags
		bit 0 wait until interrupts enabled
		bit 1 wait until critical section unowned
		bits 2-15 reserved (zero)
	DX:SI = priority boost (see VMM.INC)
	ES:DI -> FAR procedure to callback
Return: CF set on error
	    AX = error code
		01h invalid VM ID
		02h invalid priority boost
		03h invalid flags
	CF clear if successful
	    event will be or has been called
Note:	some DOS devices, such as networks, need to call functions in a
	  specific VM. This call forces the appropriate VM to be installed.
SeeAlso: AX=1683h, INT 15/AX=1117h
---------------------------------------------
INT 2F - Multiplex - DOS Protected-Mode Interface - DETECT MODE
	AX = 1686h
Return: AX = 0000h if operating in protected mode under DPMI
	AX nonzero if in real/V86 mode or no DPMI (INT 31 not available)
SeeAlso: AX=1687h
---------------------------------------------
INT 2F - Multiplex - DOS Protected-Mode Interface - INSTALLATION CHECK
	AX = 1687h
Return: AX = 0000h if installed
	    BX = flags
		bit 0: 32-bit programs supported
	    CL = processor type (02h=80286, 03h=80386, 04h=80486)
	    DH = DPMI major version
	    DL = DPMI minor version
	    SI = number of paragraphs of DOS extender private data
	    ES:DI -> DPMI mode-switch entry point
SeeAlso: AX=1686h

Call mode switch entry point with:
	AX = flags
	    bit 0: set if 32-bit program
	ES = real mode segment of buffer for DPMI private data (ignored if
		SI was zero)
Return: CF set on error
	    program still in real mode
	CF clear if successful
	    CS = 16-bit selector corresponding to real-mode CS
	    SS = selector corresponding to real-mode SS (64K limit)
	    DS = selector corresponding to real-mode DS (64K limit)
	    ES = selector to program's PSP (100h byte limit)
	    FS = GS = 0
	    high word of ESP = 0 if 32-bit program
	    program now in protected mode
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - IDENTIFY WinOldAp VERSION
	AX = 1700h
Return: AX = 1700h if this version of WINOLDAP doesn't support clipboard
	AX <> 1700h
		AL = WINOLDAP major version
		AH = WINOLDAP minor version
Notes:	WinOldAp (WINOLDAP.MOD) is a Microsoft Windows extension supporting
	  "old" (character-mode) application access to Dynamic Data Exchange,
	  menus, and the Windows clipboard.
	this installation check DOES NOT follow the format used by other
	  software
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - OPEN CLIPBOARD
	AX = 1701h
Return:	AX <> 0  success
	AX = 0	 clipboard is already open
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - EMPTY CLIPBOARD
	AX = 1702h
Return: AX <> 0  clipboard has been emptied
	AX = 0	 failure
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - SET CLIPBOARD DATA
	AX = 1703h
	DX = clipboard format supported by WinOldAp:
		01h text
		02h bitmap
		03h metafile picture
		04h SYLK
		05h DIF
		06h TIFF
		07h OEM text
	ES:BX -> data (see below for formats)
	SI:CX = size of data
Return: AX <> 0 data copied into the Clipboard
	AX = 0 failure

Format of bitmap:
Offset	Size	Description
 00h	WORD	type (0000h)
 02h	WORD	width of bitmap in pixels
 04h	WORD	height of bitmap in pixels
 06h	WORD	bytes per line
 08h	BYTE	number of color planes
 09h	BYTE	number of adjacent color bits in pixel
 0Ah	DWORD	pointer to start of data
 0Eh	WORD	width in 0.1mm units
 10h	WORD	height in 0.1mm units
 12h  N BYTEs	bitmap data

Format of metafile picture:
Offset	Size	Description
 00h	WORD	mapping mode
 02h	WORD	X extent
 04h	WORD	Y extent
 06h	WORD	picture data
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - GET CLIPBOARD DATA SIZE
	AX = 1704h
	DX = clipboard format supported by WinOldAp (see AX=1703h)
Return:  DX:AX = size of data in bytes, including any headers
Failure: DX:AX = 0  no data in this format in the Clipboard
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - GET CLIPBOARD DATA
	AX = 1705h
	DX = clipboard format supported by WinOldAp (see AX=1703h)
	ES:BX -> buffer
Return: AX <> 0  success
	AX = 0	 error, or no data in this format in Clipboard
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - CloseClipboard
	AX = 1708h
Return: AX <> 0 success
	AX = 0 failure
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - COMPACT CLIPBOARD
	AX = 1709h
	SI:CX = desired size in bytes
Return: DX:AX = number of bytes in largest block of free memory
Note:	WinOldAp is responsible for including the size of any headers
---------------------------------------------
INT 2F - Multiplex - MS WINDOWS "WINOLDAP" - GET DEVICE CAPABILITIES
	AX = 170Ah
	DX = GDI information index
	    00h device driver version
	    02h device classification
	    04h width in mm
	    06h height in mm
	    08h width in pixels
	    0Ah height in pixels
	    0Ch bits per pixel
	    0Eh number of bit planes
	    10h number of brushes supported by device
	    12h number of pens supported by device
	    14h number of markers supported by device
	    16h number of fonts supported by device
	    18h number of colors
	    1Ah size required for device descriptor
	    1Ch curve capabilities
	    1Eh line capabilities
	    20h polygon capabilities
	    22h text capabilities
	    24h clipping capabilities
	    26h bitblt capabilities
	    28h X aspect
	    2Ah Y aspect
	    2Ch length of hypotenuse of aspect
	    58h logical pixels per inch of width
	    5Ah logical pixels per inch of height
Return:  AX = integer value of the desired item
		device classification
		    00h vector plotter
		    01h raster display
		    02h raster printer
		    03h raster camera
		    04h character-stream, PLP
		    05h Metafile, VDM
		    06h display-file
		curve capabilities
		    bit 0  circles
		    bit 1  pie wedges
		    bit 2  chord arcs
		    bit 3  ellipses
		    bit 4  wide lines
		    bit 5  styled lines
		    bit 6  wide styled lines
		    bit 7  interiors
		line capabilities
		    bit 1  polylines
		    bit 2  markers
		    bit 3  polymarkers
		    bit 4  wide lines
		    bit 5  styled lines
		    bit 6  wide styled lines
		    bit 7  interiors
		polygon capabilities
		    bit 0  polygons
		    bit 1  rectangles
		    bit 2  trapezoids
		    bit 3  scanlines
		    bit 4  wide borders
		    bit 5  styled borders
		    bit 6  wide styled borders
		    bit 7  interiors
		text capabilities
		    bit 0  output precision character
		    bit 1  output precision stroke
		    bit 2  clippping precision stroke
		    bit 3  90-degree character rotation
		    bit 4  arbitrary character rotation
		    bit 5  independent X and Y scaling
		    bit 6  double-size
		    bit 7  integer scaling
		    bit 8  continuous scaling
		    bit 9  bold
		    bit 10 italic
		    bit 11 underline
		    bit 12 strikeout
		    bit 13 raster fonts
		    bit 14 vector fonts
		    bit 15 reserved
		clipping capabilities
		    00h none
		    01h clipping to rectangles
		raster capabilities
		    bit 0  simple bitBLT
		    bit 1  device requires banding support
		    bit 2  device requires scaling support
		    bit 3  supports >64K bitmap
Note:  This function returns the device-capability bits for the given display
---------------------------------------------
INT 2F - Multiplex - DOS 4.x only SHELLB.COM - INSTALLATION CHECK
	AX = 1900h
Return: AL = 00h  not installed
	     FFh  installed
---------------------------------------------
INT 2F - Multiplex - DOS 4.x only SHELLB.COM - SHELLC.EXE INTERFACE
	AX = 1901h
	BL = 00h if SHELLC transient
	     01h if SHELLC resident
	DS:DX -> far call entry point for resident SHELLC.EXE
Return: ES:DI -> SHELLC.EXE workspace within SHELLB.COM
Note:	SHELLB.COM and SHELLC.EXE are parts of the DOS 4.x shell
---------------------------------------------
INT 2F - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
	AX = 1902h
	ES:DI -> ASCIZ full filename of current batch file, with at least the
		 final filename element uppercased
	DS:DX -> buffer for results
Return: AL = 00h  failed, either
		  (a) final filename element quoted at ES:DI does not match
		      identity of shell batch file quoted as parameter of most
		      recent call of SHELLB command, or
		  (b) no more Program Start Commands available.
	AL= FFh  success, then:
		memory at DS:[DX+1] onwards filled as:
		DX+1:	BYTE	count of bytes of PSC
		DX+2: N BYTEs	Program Start Command text
			BYTE	0Dh terminator 
Explanation: COMMAND.COM executes the result of this call in preference to 
	reading a command from a batch file. Thus the batch file does not
	advance in execution for so long as SHELLB provides PSCs from its
	workspace. The PSCs are planted in SHELLB workspace by SHELLC, the user
	menu interface. The final PSC of a sequence is finished with a 
	GOTO COMMON, which causes a loop back in the batch file which called
	SHELLC so as to execute SHELLC again. The check on batch file name
	permits PSCs to CALL nested batch files while PSCs are still stacked
	up for subsequent execution.
---------------------------------------------
INT 2F - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM interface
	AX = 1903h
	ES:DI -> ASCIZ batch file name as for AX=1902h
Return: AL = FFh if quoted batch file name matches last SHELLB parameter
	AL = 00h if it does not
---------------------------------------------
INT 2F - Multiplex - DOS 4.x only SHELLB.COM - SHELLB transient to TSR intrface
	AX = 1904h
Return: ES:DI -> name of current shell batch file:
		WORD	number of bytes of name following
		BYTEs	(8 max) uppercase name of shell batch file
---------------------------------------------
INT 2F - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
	AX = 1A00h
Return: AL = FFh if installed
Note:	AVATAR.SYS also responds to this call
---------------------------------------------
INT 2F - Multiplex - AVATAR.SYS - INSTALLATION CHECK
	AX = 1A00h
	BX = 4156h ('AV')
	CX = 4154h ('AT')
	DX = 4152h ('AR')
Return: AL = FFh if installed
	    CF clear
	    BX = AVATAR protocol level supported
	    CX = driver type
		0000h AVATAR.SYS
		4456h DVAVATAR.COM inside DESQview window
	    DX = 0016h
Notes:	AVATAR also identifies itself as ANSI.SYS if BX, CX, or DX differ from
	  the magic values
	AVATAR.SYS is a CON replacement by George Adam Stanislav which
	  interprets AVATAR command codes in the same way that ANSI interprets
	  ANSI command codes
---------------------------------------------
INT 2F - Multiplex - DOS 4+ ANSI.SYS internal - GET/SET DISPLAY INFORMATION
	AX = 1A01h
	CL = 7Fh for GET
	   = 5Fh for SET
	DS:DX -> parm block as for INT 21,AX=440Ch,CX=037Fh/035Fh respectively
Return: CF set on error
	    AX = error code (many non-standard)
	CF clear if successful
	    AX destroyed
Note:	presumably this is the DOS IOCTL interface to ANSI.SYS
SeeAlso: AX=1A02h, INT 21/AX=440Ch
---------------------------------------------
INT 2F - Multiplex - DOS 4+ ANSI.SYS internal - MISC REQUESTS
	AX = 1A02h
	DS:DX -> parameter block (see below)
SeeAlso: AX=1A01h

Format of parameter block:
Offset	Size	Description
 00h	BYTE	subfunction
		00h set/reset interlock
		01h get /L flag
 01h	BYTE	interlock state
		00h=reset, 01h=set
		  This interlock prevents some of the ANSI.SYS post-processing
		  in its hook onto INT 10, AH=00h mode set
 02h	BYTE	(returned)
		00h if /L not in effect
		01h if /L in effect
---------------------------------------------
INT 2F - Multiplex - AVATAR.SYS - SET DRIVER STATE
	AX = 1A21h (AL='!')
	DS:SI -> command string with one or more state characters
	CX = length of command string
Return: CF set on error (invalid subfunction)
	CF clear if successful
Note:	the characters in the state string are interpreted left to right, and
	  need not be in any particular order
SeeAlso: AX=1A3Fh

Values of state characters:
 'a'	activate driver
 'd'	disable driver
 'f'	use fast screen output
 'g'	always convert gray keys (+ and -) to function keys
 'G'	never convert gray keys
 'l'	convert gray keys only when ScrollLock active
 's'	use slow screen output
 't'	Tandy 1000 keyboard (not yet implemented)
---------------------------------------------
INT 2F - Multiplex - AVATAR.SYS - QUERY DRIVER STATE
	AX = 1A3Fh (AL='?')
	ES:DI -> buffer
	CX = length of buffer in bytes
Return: CF clear
	CX = actual size of returned info
Note:	the returned information consists of multiple letters whose meanings
	  are described under AX=1A21h
SeeAlso: AX=1A21h
---------------------------------------------
INT 2F - Multiplex - DOS 4+ XMA2EMS.SYS extension internal - INSTALLATION CHECK
	AX = 1B00h
Return: AL = FFh if installed
Note:	XMA2EMS.SYS extension is only installed if DOS has page frames to hide.
	This extension hooks onto INT 67/AH=58h and returns from that call data
	  which excludes the physical pages being used by DOS.
SeeAlso: AX=1B01h
---------------------------------------------
INT 2F - Multiplex - DOS 4+ XMA2EMS.SYS extens internal - GET HIDDEN FRAME INFO
	AX = 1B01h
	DI = hidden physical page number
Return: AX = FFFFh if failed (no such hidden page)
	AX = 0000h if OK, then
	     ES = segment of page frame
	     DI = physical page number
Note:	this corresponds to the data edited out of the INT 67/AH=58h call
SeeAlso: AX=1BFFh
---------------------------------------------
INT 2F - Multiplex - DOS 4+ XMA2EMS.SYS internal??? - ???
	AX = 1BFFh
	DI = ???
Return: AH = ???
	ES:DI -> ???
Note:	called by FASTOPEN
SeeAlso: AX=1B01h
---------------------------------------------
INT 2F - Multiplex - OS/2 compatibility box - SWITCH DOS TO BACKGROUND
	AX = 4001h
SeeAlso: AX=4002h
---------------------------------------------
INT 2F - Multiplex - OS/2 compatibility box - SWITCH DOS TO FOREGROUND
	AX = 4002h
SeeAlso: AX=4001h
---------------------------------------------
INT 2F - Multiplex - XMS - INSTALLATION CHECK
	AX = 4300h
Return: AL = 80h XMS driver installed
	AL <> 80h no driver
Notes:	XMS gives access to extended memory and noncontiguous/nonEMS memory
	  above 640K
	this installation check DOES NOT follow the format used by other
	  software
SeeAlso: AX=4310h
---------------------------------------------
INT 2F - Multiplex - XMS - GET DRIVER ADDRESS
	AX = 4310h
Return: ES:BX -> driver entry point
SeeAlso: AX=4300h

Perform a FAR call to the driver entry point with AH set to the function code
	AH	function
	00h  Get XMS version number
	     Return: AX = XMS version (in BCD)
		     BX = internal revision number
		     DX = 0001h if HMA (1M to 1M + 64K) exists
			  0000h if HMA does not exist
	01h  Request High Memory Area (1M to 1M + 64K)
	     DX = memory in bytes (for TSR or device drivers)
		  FFFFh if application program
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	02h  Release High Memory Area
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	03h  Global enable A20, for using the HMA
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	04h  Global disable A20
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	05h  Local enable A20, for direct access to extended memory
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	06h  Local disable A20
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	07h  Query A20 state
	     Return: AX = 0001h enabled
			= 0000h disabled
		     BL = error code (0 = successful)
	08h  Query free extended memory, not counting HMA
	     Return: AX = size of largest extended memory block in K
		     DX = total extended memory in K
		     BL = error code (see below)
	09h  Allocate extended memory block
	     DX = Kbytes needed
	     Return: AX = 0001h success
			   DX = handle for memory block
			= 0000h failure
			   BL = error code (see below)
	0Ah  Free extended memory block
	     DX = handle of block to free
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	0Bh  Move extended memory block
	     DS:SI -> EMM structure (see below)
	     Note: if either handle is 0000h, the corresponding offset is
		   considered to be an absolute segment:offset address in
		   directly addressable memory
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	0Ch  Lock extended memory block
	     DX = handle of block to lock
	     Return: AX = 0001h success
			   DX:BX = 32-bit linear address of locked block
			= 0000h failure
			   BL = error code (see below)
	0Dh  Unlock extended memory block
	     DX = handle of block to unlock
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	0Eh  Get handle information
	     DX = handle for which to get info
	     Return: AX = 0001h success
			   BH = block's lock count
			   BL = number of free handles left
			   DX = block size in K
			= 0000h failure
			   BL = error code (see below)
	0Fh  Reallocate extended memory block
	     DX = handle of block
	     BX = new size of block in K
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
	10h  Request upper memory block (nonEMS memory above 640K)
	     DX = size of block in paragraphs
	     Return: AX = 0001h success
			   BX = segment address of UMB
			   DX = actual size of block
			= 0000h failure
			   BL = error code (see below)
			   DX = largest available block
	11h  Release upper memory block
	     DX = segment address of UMB to release
	     Return: AX = 0001h success
			= 0000h failure
			   BL = error code (see below)
Note:	HIMEM.SYS requires at least 256 bytes free stack space

Format of EMM structure:
Offset	Size	Description
 00h	DWORD	number of bytes to move (must be even)
 04h	WORD	source handle
 06h	DWORD	offset into source block
 0Ah	WORD	destination handle
 0Ch	DWORD	offset into destination block

Error codes returned in BL:
	80h Function not implemented
	81h Vdisk was detected
	82h An A20 error occurred
	8Eh a general driver error
	8Fh unrecoverable driver error
	90h HMA does not exist
	91h HMA is already in use
	92h DX is less than the /HMAMIN= parameter
	93h HMA is not allocated
	94h A20 line still enabled
	A0h all extended memory is allocated
	A1h all available extended memory handles are allocated
	A2h Invalid handle
	A3h Source handle is invalid
	A4h Source offset is invalid
	A5h Destination handle is invalid
	A6h Destination offset is invalid
	A7h Length is invalid
	A8h Move has an invalid overlap
	A9h Parity error occurred
	AAh Block is not locked
	ABh Block is locked
	ACh Block lock count overflowed
	ADh Lock failed
	B0h Only a smaller UMB is available
	B1h No UMB's are available
	B2h UMB segment number is invalid
---------------------------------------------
INT 2F - Multiplex - F-LOCK.EXE 
	AX = 4653h
	CX = 0002h
	BX = subfunction
	    0000h  installation check
		Return: AX = FFFFh
	    0001h  uninstall
	    0002h  disable (v1.08 and below only)
	    0003h  enable (v1.08 and below only)
Note:	F-LOCK is part of the F-PROT virus/trojan protection package by Fridrik
	  Skulason
---------------------------------------------
INT 2F - Multiplex - F-XCHK.EXE
	AX = 4653h
	CX = 0003h
	BX = subfunction
	    0000h  installation check
		Return: AX = FFFFh
	    0001h  uninstall
Note:	F-XCHK is part of the F-PROT virus/trojan protection package by Fridrik
	  Skulason
---------------------------------------------
INT 2F - Multiplex - F-POPUP.EXE
	AX = 4653h
	CX = 0004h
	BX = subfunction
	    0000h  installation check
		Return: AX = FFFFh
	    0001h  uninstall
	    0002h  disable (v1.08 and below only)
	    0003h  enable (v1.08 and below only)
Note:	F-POPUP is part of the F-PROT virus/trojan protection package by
	  Fridrik Skulason
---------------------------------------------
INT 2F - Multiplex - F-DLOCK.EXE
	AX = 4653h
	CX = 0005h
	BX = subfunction
	    0000h installation check
		Return: AX = FFFFh
	    0001h uninstall
Note:	F-DLOCK is part of the F-PROT virus/trojan protection package by
	  Fridrik Skulason
---------------------------------------------
INT 2F - Multiplex - MS Windows 3 - INSTALLATION CHECK
	AX = 4680h
Return: AX = 0000h MS Windows 3.0 running in real (/R) or standard (/S) mode
	   nonzero  no Windows, Windows prior to 3.0, or Windows3 in enhanced
		    mode
Note:	not officially documented, but Microsoft has indicated that they
	  intend to provide an installation check which works in all modes
SeeAlso: AX=1600h
---------------------------------------------
INT 2F - Multiplex - TesSeRact RAM-RESIDENT PROGRAM INTERFACE
	AX = 5453h
	BX = subfunction
	    00h installation check
		DS:SI -> 8-char blank-padded name
		Return: AX = FFFFh installed
				CX = ID number of already-installed copy
			   = anything else, not installed
				CX = ID number for TSR when installed
	    01h get user parameters
		CX = TSR ID number
		Return: AX = 0000h successful
			   ES:BX -> user parameter block (see below)
			   = nonzero failed
	    02h check if hotkey in use
		CL = scan code of hot key
		Return: AX = FFFFh hot key conflicts with another TSR
			     otherwise safe to use the hotkey
	    03h replace default critical error handler
		CX = TSR ID number
		DS:SI -> new routine for INT 24h
		Return: AX = nonzero, unable to install new handler
	    04h get internal data area
		CX = TSR ID number
		Return: AX = 0000h
			    ES:BX -> TSR's internal data area (see below)
			   = nonzero, TSR not found
	    05h set multiple hot keys
		CX = TSR ID number
		DL = number of additional hot keys to allocate
		DS:SI -> table of hot keys
			BYTE  hotkey scan code
			BYTE  hotkey shift state
			BYTE  flag value to pass to TSR (nonzero)
		Return: AX = nonzero, unable to install hot keys
	    06h - 0Fh reserved
	    10h enable TSR
		CX = TSR ID number
		Return: AX = nonzero, unable to enable
	    11h disable TSR
		CX = TSR ID number
		Return: AX = nonzero, unable to disable
	    12h unload TSR
		CX = TSR ID number
		Return: AX = nonzero, invalid TSR number
		Note: if any interrupts used by TSR have been grabbed by
			another TSR, the TesSeRact routines will wait until
			it is safe to remove the indicated TSR from memory
	    13h restart TSR
		CX = TSR ID number of TSR which was unloaded but is still in
		     memory
		Return: AX = nonzero, unable to restart TSR
	    14h get status word
		CX = TSR ID number
		Return: AX = FFFFh invalid ID number
			   = other, successful
				BX = bit flags
	    15h set status word
		CX = TSR ID number
		DX = new bit flags
		Return: AX = nonzero, unable to set status word
	    16h get INDOS state at popup
		CX = TSR ID number
		Return: AX = 0000h successful
			    BX = value of INDOS flag
	    17h - 1Fh reserved
	    20h call user procedure
		CX = TSR ID number
		ES:DI -> user-defined data
		Return: AX = 0000h successful
	    21h stuff keystrokes into keyboard buffer
		CX = TSR ID number
		DL = speed
		    00h stuff keystrokes only when buffer is empty
		    01h stuff up to four keystrokes per clock tick
		    02h stuff up to 15 keystrokes per clock tick
		DH = scan code flag
		    if zeor, buffer contains alternating ASCII and scan codes
		    if nonzero, buffer contains only ASCII codes
		SI = number of keystrokes
		ES:DI -> buffer to stuff
		Return: AX = 0000h success
			     F0F0h user aborted with ^C or ^Break
			     other unable to stuff keystrokes
	    22h (v1.10) trigger popup
		CX = TSR ID number
		Return: AX = 0000h success, TSR will either pop up or beep to
				   indicate that it is unable to pop up
			     nonzero invalid ID number
	    23h (v1.10) invoke TSR's background function
		CX = TSR ID number
		Return: AX = 0000h success
			     FFFFh not safe to call background function
			     nonzero invalid ID number
	    24h - 2Fh reserved
Note:	Borland's THELP.COM popup help system for Turbo Pascal and Turbo C
	  fully supports the TesSeRact API, as do the SWAP?? programs by 
	  Innovative Data Concepts.

Format of User Parameter Block:
Offset	Size	Description
 00h  8 BYTEs	blank-padded TSR name
 08h	WORD	TSR ID number
 0Ah	DWORD	bitmap of supported functions
 0Eh	BYTE	scan code of primary hotkey
		    00h = pop up when shift states match
		    FFh = no popup (if shift state also FFh)
 0Fh	BYTE	shift state of primary hotkey
		    FFh = no popup (if scan code also FFh)
 10h	BYTE	number of secondary hotkeys
 11h	DWORD	pointer to extra hotkeys set by func 05h
 15h	WORD	current TSR status flags
 17h	WORD	PSP segment of TSR
 19h	DWORD	DTA for TSR
 1Dh	WORD	default DS for TSR
 1Fh	DWORD	stack at popup
 23h	DWORD	stack at background invocation

Format of TSR internal data area:
Offset	Size	Description
 00h	BYTE	revision level of TesSeRact library
 01h	BYTE	type of popup in effect
 02h	BYTE	INT 08 occurred since last invocation
 03h	BYTE	INT 13 occurred since last invocation
 04h	BYTE	active interrupts
 05h	BYTE	active soft interrupts
 06h	BYTE	DOS major version
 07h	BYTE	how long to wait before popping up
 08h	DWORD	pointer to INDOS flag
 0CH	DWORD	pointer to DOS critical error flag
 10h	WORD	PSP segment of interrupted program
 12h	WORD	PSP segment of prog interrupted by INT 28
 14h	DWORD	DTA of interrupted program
 18h	DWORD	DTA of program interrupted by INT 28
 1Ch	WORD	SS of interrupted program
 1Eh	WORD	SP of interrupted program
 20h	WORD	SS of program interrupted by INT 28
 22h	WORD	SP of program interrupted by INT 28
 24h	DWORD	INT 24 of interrupted program
 28h  3 WORDs	DOS 3+ extended error info
 2Eh	BYTE	old BREAK setting
 2Fh	BYTE	old VERIFY setting
 30h	BYTE	were running MS WORD 4.0 before popup
 31h	BYTE	MS WORD 4.0 special popup flag
 32h	BYTE	enhanced keyboard call in use
 33h	BYTE	delay for MS WORD 4.0
11 times:
	DWORD	old interrupt vector
	BYTE	interrupt number
	DWORD	new interrupt vector
---------------------------------------------
INT 2F - Multiplex - SCRNSAV2.COM - INSTALLATION CHECK
	AX = 6400h
Return: AL = 00h not installed
	     FFh installed
Note:	SCRNSAV2.COM is a screen saver for PS/2's with VGA by Alan Ballard
---------------------------------------------
INT 2F - Multiplex - Novell NetWare - LOW-LEVEL API (IPX) INSTALLATION CHECK
	AX = 7A00h
Return: AL = 00h not installed
	   = FFh installed
		ES:DI -> FAR entry point for routines otherwise accessed
			 through INT 7Ah
---------------------------------------------
INT 2F - Multiplex - Novell NetWare shell 3.01 - BROADCAST INFORM
	AX = 7A85h
	CX = broadcast server number
Return: CX = 0000h if broadcast message handled by another program
	CX unchanged if broadcast not handled
---------------------------------------------
INT 2F - Multiplex - EASY-NET - INSTALLATION CHECK
	AX = 8000h
Return: AL = 00h not installed
	     FFh installed
Note:	EASY-NET is a shareware two-machine serial-port network
---------------------------------------------
INT 2F - Multiplex - WHOA!.COM - INSTALLATION CHECK
	AX = 8900h
Return: AL = 00h not installed
	   = FFh installed
Note:	WHOA!.COM is a system slow-down utility by Brad D Crandall
---------------------------------------------
INT 2F - Multiplex - WHOA!.COM - UNINSTALL
	AX = 8901h
Return: AL = FDh successful
	   = FEh error
Note:	WHOA!.COM is a system slow-down utility by Brad D Crandall
---------------------------------------------
INT 2F - Multiplex - WHOA!.COM - SET DELAY COUNT
	AX = 8902h
	BX = delay count (larger values slow system down more)
Return: AL = FDh successful
	   = FEh error
Note:	WHOA!.COM is a system slow-down utility by Brad D Crandall
---------------------------------------------
INT 2F - Multiplex - RAID - ???
	AH = 90h
	???
Return: ???
Note:	RAID is a TSR utility program that resides mostly in EMS
---------------------------------------------
INT 2F - Multiplex - VIDCLOCK.COM - INSTALLATION CHECK
	AX = AA00h
Return: AL = 00h not installed
	     FFh installed
Note:	VIDCLOCK.COM is a memory-resident clock by Thomas G. Hanlin III
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ DISPLAY.SYS internal - INSTALLATION CHECK
	AX = AD00h
Return: AL = FFh if installed
	    BX = ??? (0100h in MS-DOS 3.30, PCDOS 4.01)
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ DISPLAY.SYS internal - SET ???
	AX = AD01h
	BX = ???
Return: ???
	CF set on error
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ DISPLAY.SYS internal - GET ???
	AX = AD02h
Return: BX = ??? (value set with AX=AD01h)
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ DISPLAY.SYS internal - GET ???
	AX = AD03h
	ES:DI -> user buffer
	CX = size of buffer
Return: CF set if buffer too small
	CF clear if successful
---------------------------------------------
INT 2F - Multiplex - DOS 4+ DISPLAY.SYS internal - ???
	AX = AD04h
	???
Return: ???
---------------------------------------------
INT 2F - Multiplex - DOS 4+ DISPLAY.SYS internal - INSTALLATION CHECK???
	AX = AD10h
	???
Return: AX = FFFFh
	BX = ??? (0100h in PCDOS 4.01)
---------------------------------------------
INT 2F - Multiplex - DOS 4.0 - ???
	AX = AD40h
	DX = ???
	???
Return: ???
Note:	called by PCDOS 4.01 PRINT.COM
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ KEYB.COM internal - INSTALLATION CHECK
	AX = AD80h
Return: AL = FFh if installed
	    BX = ??? (0100h in MSDOS 3.30 and PCDOS 4.01)
	    ES:DI -> internal data (see below)

Format of KEYB internal data:
Offset	Size	Description
 00h	DWORD	original INT 09
 04h	DWORD	original INT 2F
 08h  6 BYTEs	???
 0Eh	WORD	flags
 10h	BYTE	???
 11h	BYTE	???
 12h  4 BYTEs	???
 16h  2 BYTEs	country ID letters
 18h	WORD	current code page
---DOS 3.3---
 1Ah	WORD	pointer to first item in list of code page tables???
 1Ch	WORD	pointer to ??? item in list of code page tables
 1Eh  2 BYTEs	???
 20h	WORD	pointer to key translation data
 22h	WORD	pointer to last item in code page table list (see below)
 24h  9 BYTEs	???
---DOS 4.01---
 1Ah  2 BYTEs	???
 1Ch	WORD	pointer to first item in list of code page tables???
 1Eh	WORD	pointer to ??? item in list of code page tables
 20h  2 BYTEs	???
 22h	WORD	pointer to key translation data
 24h	WORD	pointer to last item in code page table list (see below)
 26h  9 BYTEs	???

Format of code page table list entries:
Offset	Size	Description
 00h	WORD	pointer to next item, FFFFh = last
 02h	WORD	code page
 04h  2 BYTEs	???

Format of translation data:
Offset	Size	Description
 00h	WORD	size of data in bytes, including this word
 02h N-2 BYTEs	???
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ KEYB.COM internal - SET KEYBOARD CODE PAGE
	AX = AD81h
	BX = code page
Return: CF set on error
	    AX = 0001h (code page not available)
	CF clear if successful
Note:	called by DISPLAY.SYS
SeeAlso: AX=AD82h
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ KEYB.COM internal - SET KEYBOARD MAPPING
	AX = AD82h
	BL = 00h US keyboard (Control-Alt-F1)
	   = FFh foreign keyboard (Control-Alt-F2)
Return: CF set on error (BL not 00h or FFh)
	CF clear if successful
SeeAlso: AX=AD81h
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - INSTALLABLE COMMAND - INSTALL CHECK
	AX = AE00h
	DX = FFFFh
	DS:BX -> command line
Return: AL = FFh if this command is a TSR extension to COMMAND.COM
	AL = 00h if the command should be executed as usual
Notes:	This call provides a mechanism for TSRs to install permanent extensions
	  to the command repertoire of COMMAND.COM.  It appears that
	  COMMAND.COM makes this call before executing the current command
	  line,	and does not execute it itself if the return is FFh.
	APPEND hooks this call, to allow subsequent APPEND commands to execute
	  without re-running APPEND

Format of command line:
Offset	Size	Description
 00h	BYTE	max length of command line, as in INT 21/AH=0Ah
 01h	BYTE	count of bytes to follow
      N BYTEs	command line text, terminated by 0Dh
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ internal - INSTALLABLE COMMAND - EXECUTE
	AX = AE01h
	DX = FFFFh
	DS:SI -> buffer
Return: buffer at DS:SI filled with a length byte followed by the uppercase
	  internal command to execute (if length not 0)
Notes:	this call requests execution of the command which a previous call to
	  AX=AE00h indicated was resident
	APPEND hooks this call
	if the buffer is filled with a nonempty string, COMMAND.COM will
	  attempt to execute it as an internal command
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ GRAFTABL.COM - INSTALLATION CHECK
	AX = B000h
Return: AL = 00h not installed, OK to install
	   = 01h not installed, not OK to install
	   = FFh installed
Note:	called by DISPLAY.SYS
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ GRAFTABL.COM - GET ???
	AX = B001h
	DS:DX -> 4-byte buffer (see below)
Return: buffer filled
	AL = FFh

Format of buffer:
Offset	Size	Description
 00h	WORD	??? (PCDOS 3.30/4.01 fill in 0130h, MSDOS 3.30 fills in 0030h)
 02h	WORD	CS of resident code
---------------------------------------------
INT 2F - Multiplex - IBM PC3270 EMUL PROG v3 - INSTALLATION CHECK
	AX = B400h
Return: AL = FFh if installed
---------------------------------------------
INT 2F - Multiplex - IBM PC3270 EMUL PROG v3 - GET HOST BUFFER ADDRESS
	AX = B401h
Return: ES -> host screen buffer (PC ASCII format)
	ES unchanged if communications not started
---------------------------------------------
INT 2F - Multiplex - IBM PC3270 EMUL PROG v3 - ???
	AX = B402h
	BX = ???
Return: ???
---------------------------------------------
INT 2F - Multiplex - IBM PC3270 EMUL PROG v3 - ???
	AX = B403h
	???
Return: ???
---------------------------------------------
INT 2F - Multiplex - IBM PC3270 EMUL PROG v3 - ???
	AX = B404h
	???
Return: ???
---------------------------------------------
INT 2F - Multiplex - IBM PC3270 EMUL PROG v3 - ???
	AX = B405h
	???
Return: ???
---------------------------------------------
INT 2F - Multiplex - APPEND - INSTALLATION CHECK
	AX = B700h
Return: AL = 00h not installed
	     FFh if installed
Note:	MSDOS 3.30 APPEND refuses to install itself when run inside TopView or
	  a TopView-compatible environment
---------------------------------------------
INT 2F - Multiplex - APPEND - ???
	AX = B701h
	???
Note:	MSDOS 3.30 APPEND displays "Incorrect APPEND Version" and aborts caller
---------------------------------------------
INT 2F - Multiplex - APPEND - VERSION CHECK
	AX = B702h
Return: AX = FFFFh if not DOS 4.0 APPEND
	AL = major version number
	AH = minor version number, otherwise
SeeAlso: AX=B710h
---------------------------------------------
INT 2F - Multiplex - DOS 3.3 APPEND - HOOK INT 21
	AX = B703h
	ES:DI -> INT 21 handler APPEND should chain to
Return: ES:DI -> APPEND's INT 21 handler
Note:	each invocation of this function toggles a flag which APPEND uses to
	  determine whether to chain to the user handler or the original
	  INT 21
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ APPEND - GET APPEND PATH
	AX = B704h
Return: ES:DI -> active APPEND path (128 bytes max)
---------------------------------------------
INT 2F - Multiplex - DOS 4.0 APPEND - GET APPEND FUNCTION STATE
	AX = B706h
Return: BX = APPEND state
	    bit 0: set if APPEND enabled
	    bits 1-12 reserved
	    bit 13: set if /PATH flag active
	    bit 14: set if /E flag active (environment var APPEND exists)
	    bit 15: set if /X flag active
---------------------------------------------
INT 2F - Multiplex - DOS 4.0 APPEND - SET APPEND FUNCTION STATE
	AX = B707h
	BX = APPEND state bits (see AX=B706h)
---------------------------------------------
INT 2F - Multiplex - DOS 3.3+ APPEND - GET VERSION INFO
	AX = B710h
Return: AX = ???
	BX = ??? (0000h in MSDOS 3.30)
	CX = ??? (0000h in MSDOS 3.30)
	DL = major version
	DH = minor version
SeeAlso: AX=B702h
---------------------------------------------
INT 2F - Multiplex - DOS 4.0 APPEND - SET RETURN FOUND NAME STATE
	AX = B711h
Note:	if the next INT 21h call (and ONLY the next) is function 3Dh, 43h, or
	6Ch, the fully qualified filename is written over top of the filename
	passed to the INT 21h call.  The application must provide a 
	sufficiently large buffer.  This state is reset after next INT 21h
	call processed by APPEND.
---------------------------------------------
INT 2F - Multiplex - Network - INSTALLATION CHECK
	AX = B800h
Return: AL = 00h not installed
	    nonzero installed
	      BX = installed component flags (test in this order!)
		   bit 6   server
		   bit 2   messenger
		   bit 7   receiver
		   bit 3   redirector
---------------------------------------------
INT 2F - Multiplex - Network - GET CURRENT POST HANDLER ADDRESS
	AX = B803h
Return: ES:BX = post address
SeeAlso: AX=B804h,B903h
---------------------------------------------
INT 2F - Multiplex - Network - SET NEW POST HANDLER ADDRESS
	AX = B804h
	ES:BX -> new FAR post handler
Notes:	used in conjunction with AX=B803h to hook into the network event post
	  routine.
	The specified handler is called on any network event.  Two events are
	  defined: message received and critical network error.
SeeAlso: AX=B803h,B904h

Values post routine is called with:
	AX = 0000h single block message
	    DS:SI -> ASCIZ originator name
	    DS:DI -> ASCIZ destination name
	    ES:BX -> text header (see below)
	AX = 0001h start multiple message block
	    CX = block group ID
	    DS:SI -> ASCIZ originator name
	    DS:DI -> ASCIZ destination name
	AX = 0002h multiple block text
	    CX = block group ID
	    ES:BX -> text header (see below)
	AX = 0003h end multiple block message
	    CX = block group ID
	AX = 0004h message aborted due to error
	    CX = block group ID
	AX = 0101h server received badly formatted network request
	    Return: AX = FFFFh (PC LAN will process error)
	AX = 0102h unexpected network error
	    ES:BX -> NCB (see INT 5C)
	AX = 0103h server received INT 24 error
	    other registers as for INT 24, except AH is in BH
	    Return: as below, but only 0000h and FFFFh allowed
Return:	AX = response code
	    0000h user post routine processed message
	    0001h PC LAN will process message, but message window not displayed
	    FFFFh PC LAN will process message
	
Format of text header:
Offset	Size	Description
 00h	WORD	length of text (maximum 512 bytes)
 02h  N BYTEs	text of message
Note:	all CRLF sequences in message text are replaced by 14h
---------------------------------------------
INT 2F - Multiplex - Network - GET NetBIOS NAME NUMBER OF MACHINE NAME
	AX = B807h
Return: CH = NetBIOS name number of the machine name
SeeAlso: INT 21/AX=5E00h
---------------------------------------------
INT 2F - Multiplex - Network - ???
	AX = B808h
	???
Return: ???
---------------------------------------------
INT 2F - Multiplex - LANtastic Network - VERSION CHECK
	AX = B809h
Return: AH = major version
	AL = minor version
---------------------------------------------
INT 2F - PC Network RECEIVER.COM - INSTALLATION CHECK
	AX = B900h
Return: AL = 00h if not installed
	     FFh if installed
---------------------------------------------
INT 2F - PC Network RECEIVER.COM - GET RECEIVER.COM INT 2F HANDLER ADDRESS
	AX = B901h
Return: AL = ???
	ES:BX -> RECEIVER.COM INT 2F handler
Note:	allows more efficient execution by letting the caller bypass any other
	  INT 2F handlers which have been added since RECEIVER.COM was
	  installed
---------------------------------------------
INT 2F - PC Network RECEIVER.COM - GET RECEIVER.COM POST ADDRESS
	AX = B903h
Return: ES:BX -> POST handler
SeeAlso: AX=B803h,B904h
---------------------------------------------
INT 2F - PC Network RECEIVER.COM - SET RECEIVER.COM POST ADDRESS
	AX = B904h
	ES:BX -> new POST handler
SeeAlso: AX=B804h,B903h
---------------------------------------------
INT 2F - PC Network RECEIVER.COM - GET FILENAME
	AX = B905h
	DS:BX -> 128-byte buffer for filename 1
	DS:DX -> 128-byte buffer for filename 2
Return: buffers filled from RECEIVER.COM internal buffers
Note:	use of filenames is unknown, but one appears to be for storing messages
SeeAlso: AX=B906h
---------------------------------------------
INT 2F - PC Network RECEIVER.COM - SET FILENAME
	AX = B906h
	DS:BX -> 128-byte buffer for filename 1
	DS:DX -> 128-byte buffer for filename 2
Return: RECEIVER.COM internal buffers filled from user buffers
Note:	use of filenames is unknown, but one appears to be for storing messages
SeeAlso: AX=B905h
---------------------------------------------
INT 2F - PC Network RECEIVER.COM - UNLINK KEYBOARD HANDLER
	AX = B908h
	ES:BX -> INT 09 handler RECEIVER should call after it finishes INT 09
Note:	this call replaces the address to which RECEIVER.COM chains on an
	  INT 09 without preserving the original value.  This allows a prior
	  handler to unlink, but does not allow a new handler to be added
	  such that RECEIVER gets the INT 09 first.
---------------------------------------------
INT 2F - Multiplex - Windows 3.0 EGA.SYS - INSTALLATION CHECK
	AX = BC00h
Return: AL = 00h not installed, OK to install
	   = 01h not installed, not OK to install
	   = FFh installed
		BX = 5456h ("TV")
Note:	AH=BCh is the default value, which may be changed by a command line
	  parameter
---------------------------------------------
INT 2F - Multiplex - MS Windows 3.0 EGA.SYS - ???
	AX = BC06h
Return: CX = 020Ah
	DL = 12h
---------------------------------------------
INT 2F - Multiplex - PC LAN PROGRAM REDIRIFS.EXE internal - INSTALLATION CHECK
	AX = BF00h
Return: AL = FFh if installed
---------------------------------------------
INT 2F - Multiplex - PC LAN PROGRAM REDIRIFS.EXE internal - ???
	AX = BF01h
	???
Return: ???
---------------------------------------------
INT 2F - Multiplex - PC LAN PROG REDIR.SYS internal - SET REDIRIFS ENTRY POINT
	AX = BF80h
	ES:DI -> FAR entry point to IFS handler in REDIRIFS
Return: AL = FFh if installed
	    ES:DI -> internal workspace
Note:	all future IFS calls to REDIR.SYS are passed to the ES:DI entry point
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - INSTALLATION CHECK
	AX = CB00h
Return: AL = 00h not installed, OK to install
	     01h not installed, not OK to install
	     FFh installed
Note:	AH = CBh is the default identifier, but may be reconfigured
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - SUBMIT A TASK
	AX = CB01h
	DS:DX -> ASCIZ name of task control file
Return: AX >= 0: event handle
	   < 0: error code
Note:	files needed for an event must be kept until task is complete or error
SeeAlso: AX=CB0Bh

Error codes (AH = class, AL = subcode, value passed back is 2's complement):
  Class 00h	--- FAX warnings
	Subcode 00h	no error
		02h	bad scanline count
		03h	page sent with errors, could not retransmit
		04h	received data lost
		05h	invalid or missing logo file
		06h	filename does not match nonstandard format (NSF) header
		07h	file size does not match NSF header
  Class 01h	--- DOS warnings (data was sent)
	Subcode 01h	invalid function
		05h	access denied
		06h	invalid handle
		others	see INT 21/AH=59h
  Class 02h	--- fatal errors (data not sent)
	Subcode	00h	multiplex handler failed
		01h	unknown command
		02h	bad event handle
		03h	FIND NEXT attempted before FIND FIRST
		04h	no more events
		07h	invalid queue type
		08h	bad control file
		09h	communication board busy
		0Ah	invalid command parameter
		0Bh	can't uninstall resident code
		0Ch	file exists
		80h	unknown task type
		81h	bad phone number
		82h	bad .PCX file header
		83h	unexpected EOF
		84h	unexpected disconnect
		85h	too many dialing retries
		86h	no file specified for send
		87h	communication board timeout
		88h	received too many pages (>1023) of data
		89h	manual connect initiated too long ago
		8Ah	hardware command set error
		8Bh	bad NonStandard Format (NSF) header file
  Class 03h	--- fatal DOS errors
	Subcode 02h	file not found
		03h	path not found
		others	see INT 21/AH=59h
  Class 04h	--- FAX errors
	Subcode 03h	other FAX machine incompatible
		5Eh	other FAX machine jammed
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - ABORT CURRENT EVENT
	AX = CB02h
Return: AX >= 0: event handle of aborted event (>= 0)
	   < 0: error code (see AX=CB01h)
SeeAlso: AX=CB10h
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - FIND FIRST QUEUE ENTRY
	AX = CB05h
	CX = status of events to find
	    0000h successful completion
	    0001h waiting to be processed
	    0002h number has been dialed
	    0003h connection established, sending
	    0004h connection established, receiving
	    0005h even aborted
	    FFFFh find any event, regardless of status
	    other negative values, match error code
	DH = direction
	    00h chronological order, earliest to latest
	    01h reverse chronological order, latest to earliest
	DL = queue to search
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX = 0000h successful
	    BX = event handle for found event
	   < 0	   error code (see AX=CB01h)
SeeAlso: AX=CB06h
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - FIND NEXT QUEUE ENTRY
	AX = CB06h
	DL = queue to search
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX = 0000h successful
	    BX = event handle for found event
	   < 0	   error code (see AX=CB01h)
Note:	direction of search is same as preceding FIND FIRST call
SeeAlso: AX=CB05h
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - OPEN FILE
	AX = CB07h
	BX = event handle
	CX = receive file number (ignored for task queue and log queue)
	    0000h  open receive control file
	    N	   open Nth received data file
	DL = queue
	    00h task queue
	    01h receive queue control file or received file, as given by CX
	    02h log queue
Return: AX = 0000h successful
	    BX = DOS file handle for requested file
	   < 0	   error code (see AX=CB01h)
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - DELETE FILE
	AX = CB08h
	BX = event handle
	CX = receive file number
	    0000h delete ALL received files and receive control file
	    N	  delete Nth received file
	DL = queue
	    00h delete control file in task queue
	    01h delete file in receive queue, as given by CX
	    02h delete control file in log queue (individual deletions not
		recommended, to maintain integrity of log)
Return: AX = 0000h successful
	   < 0	   error code (see AX=CB01h)\
SeeAlso: AX=CB09h
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - DELETE ALL FILES IN Q
	AX = CB09h
	DL = queue
	    00h delete all control files in task queue
	    01h delete all files in receive queue
	    02h delete all control files in log queue
Return: AX = 0000h successful
	   < 0	   error code (see AX=CB01h)
SeeAlso: AX=CB08h
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - GET EVENT DATE
	AX = CB0Ah
	BX = event handle
	DL = queue
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX = 0000h successful
		CX = year
		DH = month
		DL = day
	   < 0	   error code (see AX=CB01h)
SeeAlso: AX=CB0Ch
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - SET TASK DATE
	AX = CB0Bh
	BX = event handle (task event only)
	CX = year
	DH = month
	DL = day
Return: AX = 0000h successful
	   < 0	   error code (see AX=CB01h)
Note:	setting a task's date and time to before the current date and time
	  causes it to execute immediately
SeeAlso: AX=CB01h,CB0Dh
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - GET EVENT TIME
	AX = CB0Ch
	BX = event handle
	DL = queue
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX = 0000h successful
		CH = hour
		CL = minute
		DH = second
		DL = 00h
	   < 0	   error code (see AX=CB01h)
SeeAlso: AX=CB0Ah,CB0Dh
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - SET TASK TIME
	AX = CB0Dh
	BX = event handle (task events only)
	CH = hour
	CL = minute
	DH = second
	DL unused
Return: AX = 0000h successful
	   < 0	   error code (see AX=CB01h)
Note:	setting a task's date and time to before the current date and time
	  causes it to execute immediately
SeeAlso: AX=CB0Bh,CB0Ch,CB10h
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - GET EXTERNAL DATA BLOCK
	AX = CB0Eh
	DS:DX -> 256-byte buffer
Return: AX = 0000h successful
		buffer filled
	   < 0	   error code (see AX=CB01h)

Format of external data block:
Offset	Size	Description
 00h	BYTE	CAS major version
 01h	BYTE	CAS minor version
 02h 68 BYTEs	ASCIZ path to directory containing CAS software, ends in slash
 46h 13 BYTEs	ASCIZ name of current phonebook (in CAS directory)
 53h 13 BYTEs	ASCIZ name of current logo file (in CAS directory)
 60h 32 BYTEs	ASCIZ default sender name
 80h 21 BYTEs	ASCIZ CCITT identification of fax device
 95h 107 BYTEs	reserved
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - GET/SET AUTORECEIVE
	AX = CB0Fh
	DL = subfunction
	    00h get current autoreceive state
	    01h set autoreceive state
		DH = number of rings before answer, 00h = never
Return: AX = 0000h autoreceive disabled
	   = N	   number of rings before answer
	   < 0	   error code (see AX=CB01h)
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - GET EVENT STATUS
	AX = CB10h
	DS:DX -> 511-byte buffer
Return: AX = 0000h successful
		BX = event handle of current event
		buffer filled
	   < 0	   error code (see AX=CB01h)
SeeAlso: AX=CB02h,CB0Dh

Format of status area:
Offset	Size	Description
 00h	BYTE	event type
		00h send
		01h receive
		02h polled send
		03h polled receive
		04h to 7Fh reserved
		FFh serious hardware error
 01h	BYTE	transfer type
		00h 200x200 dpi, FAX mode
		01h 100x200 dpi, FAX mode
		02h file transfer mode
		03h to 7Fh reserved
 02h	WORD	event status 
		0000h completed successfully
		0001h waiting
		0002h number dialed
		0003h connected, sending
		0004h connected, receiving
		0005h aborted
		0006h to 007Fh reserved
		0080h to 7FFFh application-specific events
		8000h to FFFFh error codes
 04h	WORD	event time (packed DOS time format, see INT 21/AX=5700h)
 06h	WORD	event date (packed DOS date format, see INT 21/AX=5700h)
 08h	WORD	number of files to transfer, max 7FFFh
 0Ah	WORD	offset of file transfer record
 0Ch 47 BYTEs	ASCIZ phone number to call
 3Bh 64 BYTEs	ASCIZ application-specific tag string
 7Bh	BYTE	reserved (00h)
 7Ch	BYTE	connect time, seconds
 7Dh	BYTE	connect time, minutes
 7Eh	BYTE	connect time, hours
 7Fh	DWORD	total number of pages in all files
 83h	DWORD	pages already transmitted 
 87h	WORD	number of files already transmitted
 89h	BYTE	cover page flag
		00h don't transmit cover page
		01h transmit cover page
		02h to 7Fh reserved
 8Ah	WORD	total number of transmission errors
 8Ch 78 BYTEs	reserved (zeros)
 DAh 21 BYTEs	ASCIZ remote FAX's CCITT identification
 EFH 32 BYTEs	ASCIZ destination name
10Fh 32 BYTEs	ASCIZ sender name
12Fh 80 BYTEs	filename of PCX logo file (max 1780x800 pixels)
17Fh 128 BYTEs	file transfer record for current event (see below)

Format of file transfer record:
Offset	Size	Description
 00h	BYTE	file type (ignored unless FAX)
		00h ASCII
		01h PCX
		02h DCX
		03h to 7Fh reserved
 01h	BYTE	text size for ASCII FAX file
		00h = 80 columns by 66 lines (11 inches)
		01h = 132 columns by 88 lines (11 inches)
		02h to 7Fh reserved
 02h	BYTE	status of file
		00h untouched
		01h opened
		02h moved
		03h deleted
		04h not yet received
		05h to 7Fh reserved
 03h	DWORD	bytes already transmitted
 07h	DWORD	file size in bytes
 0Bh	WORD	pages alread transmitted
 0Dh	WORD	number of pages in file
 0Fh 80 BYTEs	ASCIZ filename
 5Fh	BYTE	1/8 inch page length
		if page length below set to 01h through 7Fh, this value 
		specifies additional 1/8 inch increments to page length
 60h	BYTE	page length
		00h = 11 inches
		01h to 7Fh = page length is this number of inches plus value of
			1/8 inch field above
		80h to FEh reserved
		FFh = ASCII pages ending with formfeed
 61h 31 BYTEs	reserved (zeros)
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - GET QUEUE STATUS
	AX = CB11h
	DL = queue to get status of
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX >= 0  total number of changes made to queue, modulo 32768
		BX = number of control files currently in queue
		CX = number of received files (zero for task and log queues)
	   < 0	 error code (see AX=CB01h)
SeeAlso: AX=CB12h
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - GET HARDWARE STATUS
	AX = CB12h
	DS:DX -> 128-byte status buffer
Return: AX = 0000h successful
		buffer filled with hardware-dependent status information
	   < 0	   error code (see AX=CB01h)
SeeAlso: AX=CB11h

Format of status buffer for Intel Connection CoProcessor:
Offset	Size	Description
 00h	BYTE	bit flags
		bit 7: hardware busy sending or receiving
		bit 6: last page of data
		bit 5: no data on current page
		bit 4: retransmit request for current page being transmitted
		bit 3: NSF mode active
		bits 2-0: reserved
 01h	BYTE	number of kilobytes of free buffer space
 02h	BYTE	page buffer status
		bit 7: Connection CoProcessor has documents to send
		bits 6-0: number of pages in buffer
 03h	BYTE	number of retries left for dialing number
 04h	BYTE	page number to retransmit
 05h	BYTE	communications status
		bit 7: originating call
		bit 6: FAX message to be sent
		bit 5: on line
		bit 4: ring detected and receive enabled
		bit 3: buffer dumped on receive
		bits 2-0: hardware sequence state
			000 idle
			001 dial
			010 answer
			011 transmit
			100 receive
			101 pre-message
			110 post-message
			111 disconnect
 06h	BYTE	baud rate
		bit 7: reserved
		bits 6-4: baud rate
			000 = 300 baud (SDLC mode)
			100 = 2400 baud
			101 = 4800 baud
			110 = 7200 baud
			111 = 9600 baud
		bits 3-0: reserved, should be 0110
 07h  3 BYTEs	reserved
 0Ah	BYTE	hardware status
		bit 7: modem option installed
		bit 6: Connection CoProcessor has control of DAA (not latched)
		bit 5: on line (not latched)
		bit 4: ring detected (not latched)
		bit 3: data in command buffer (not latched)
		bit 2: set if using DMA channel 1, clear if using DMA channel 3
		bit 1: line length compensation bit 1 set (not latched)
		bit 0: line length compensation bit 0 set (not latched)
 0Bh	BYTE	switch states
		bit 7: reserved
		bit 6: unused
		bit 5: spare switch open
		bit 4: FAX ADR1 switch open
		bit 3: FAX ADR0 switch open
		bit 2: alternate interrupt switch open
		bit 1: COM SEL 1 switch open
		bit 0: COM SEL 0 switch open
 0Ch	BYTE	bit flags
		bit 7: reserved
		bit 6: auxiliary relay forced ON
		bit 5: modem select relay forced ON
		bit 4: offhook relay forced ON
		bit 3: 9600 bps enabled
		bit 2: 7200 bps enabled
		bit 1: 4800 bps enabled
		bit 0: 2400 bps enabled
 0Dh	BYTE	reserved
 0Eh	WORD	error count
 10h	DWORD	size of nonstandard format (NSF) file in bytes
 14h 10 BYTEs	reserved
 1Eh 21 BYTEs	ASCIZ CCITT identification
 33h 77 BYTEs	reserved
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - GET DIAGNOSTICS RESULTS
	AX = CB13h
	DL = 00h
Return: AX = 0040h in progress
	   > 0	   passed
	   < 0	   failure code
Note:	diagnostics return values are hardware dependent
SeeAlso: AX=CB13h/DL=01h

Intel Connection CoProcessor failure codes:
	bit 3: 9600 bps FAX modem module failed
	bit 2: SDLC chip failed
	bit 1: RAM failed
	bit 0: ROM checksum failed
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - START DIAGNOSTICS
	AX = CB13h
	DL = 01h
Return: AX = 0000h successfully started
	   < 0	   error code (see AX=CB01h)
SeeAlso: AX=CB13h/DL=00h
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - MOVE RECEIVED FILE
	AX = CB14h
	BX = event handle
	CX = receive file number
	     0001h first received file
	     N	   Nth received file
	DS:DX -> ASCIZ string specifying new name for file
Return: AX = 0000h successful
	   < 0	   error code (see AX=CB01h)
---------------------------------------------
INT 2F - Multiplex - Communicating Applications Spec - SUBMIT FILE TO SEND
	AX = CB15h
	DS:DX -> variable-length data area
Return: AX >= 0	event handle
	   < 0	error code (see AX=CB01h)

Format of data area:
Offset	Size	Description
 00h	BYTE	transfer type
		00h = 200x200 dpi, fax mode
		01h = 100x200 dpi, fax mode
		02h = file transfer mode
		03h to 7Fh reserved
 01h	BYTE	text size
		00h = 80 columns
		01h = 132 columns
		02h to 7Fh reserved
 02h	WORD	time to send (DOS packed time format, see INT 21/AX=5700h)
 04h	WORD	date to send (DOS packed date format, see INT 21/AX=5700h)
 06h 32 BYTEs	ASCIZ destination name
 26h 80 BYTEs	ASCIZ name of file to send
 76h 47 BYTEs	ASCIZ phone number to dial
 A5h 64 BYTEs	ASCIZ application-specific tag string
 E5h	BYTE	reserved (00h)
 E6h	BYTE	cover page
		00h don't send cover page
		01h send cover page
		02h to 7Fh reserved
 E7h 23 BYTEs	reserved (zeros)
 FEh variable	ASCIZ string containing text of cover page (if cover page flag
		set to 01h)
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - INSTALLATION CHECK
	AX = CD00h
Return: AL = 00h not installed, OK to install
	     01h not installed, not OK to install
	     FFh installed
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - INSTALLATION CHECK
	AX = CD00h
Return: AX = 00FFh installed
	    BH = major version
	    BL = minor version
Note:	SWELL.EXE is a TSR which swaps programs to disk when they EXEC a child
	  process with INT 21/AH=4Bh
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - SET DEVICE NAME
	AX = CD01h
	CX:BX -> ASCIZ character device name ("LPTn", "COMn", "PRN")
Return: AL = 00h successful
		CX:BX -> internal character device name
	   = 80h error
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - SUSPEND ONCE
	AX = CD01h
Return: AX = 0000h
SeeAlso: AX=CD02h"SWELL"
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - GET VERSION NUMBER
	AX = CD02h
Return: AL = 00h/01h successful
		BH = major version number (BCD)
		BL = minor version number (BCD)
	   = 80h error
Note:	if return AL = 01h, the IPI supports network redirection
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - SUSPEND
	AX = CD02h
Return: AX = 0000h
SeeAlso: AX=CD03h"SWELL"
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - SELECT SCAN LINE
	AX = CD03h
	BX = scan line
	CX = requested density in dots per inch (300, 600, or 1200)
Return: AL = 00h succesful
		CX = density at which scan line was mapped
		ES:DI -> start of scan line
	AL = 80h unsuccessful
	   = 81h scan line out of range
	   = 82h unsupported scan line density
	   = 83h out of memory
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - ACTIVATE
	AX = CD03h
Return: AX = 0000h
SeeAlso: AX=CD02h"SWELL"
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - MOVE BITMAP TO SCANLINE
	AX = CD04h
	CX:BX -> structure (see below)
Return: AL = 00h successful
	   = 80h unsuccessful
	   = 81h scan line out of range
	   = 82h unsupported scan line density
	   = 83h out of memory
	   = 84h unrecognized source
	   = 85h initialization error

Format of structure:
Offset	Size	Description
 00h	WORD	image source (0 = conventional memory, 1 = expanded memory)
 02h	DWORD	pointer to image data
 06h	WORD	scan line on which to place
 08h	WORD	bit offset from start of scan line at which to place
 0Ah	WORD	density of bitmap data (300, 600, or 1200 dpi)
 0Ch	WORD	width in bits of data
 0Eh	WORD	source logical page number
 10h	WORD	source handle (only if source in expanded memory)
 12h	WORD	source offset (only if source in expanded memory)
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - TURN OFF VERBOSE MODE
	AX = CD04h
Return: AX = 0000h
SeeAlso: AX=CD05h"SWELL"
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - PRINT PAGE
	AX = CD05h
Return: AL = 00h successful
	   = 80h unsuccessful
Note:	page image is retained, so multiple calls will print multiple copies of
	  the page
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - TURN ON VERBOSE MODE
	AX = CD05h
Return: AX = 0000h
SeeAlso: AX=CD04h"SWELL"
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - CLEAR PAGE
	AX = CD06h
Return: AL = 00h successful
	   = 80h unsuccessful
Note:	palette is reset to default
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - UNINSTALL
	AX = CD06h
Return: AX = 0000h uninstalled
	   = 8002h programs still swapped, not uninstalled
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - reserved
	AX = CD07h
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - GET INFO
	AX = CD07h
	ES:BX -> 32-byte buffer for info
Return: AX = 0000h successful
	    ES:BX buffer filled
	   = 8001h buffer wrong size

Format of info buffer:
Offset	Size	Description
 00h	WORD	20h  (total size of buffer)
 02h	BYTE	suspend-once mode active if nonzero
 03h	BYTE	00h active, 01h suspended
 04h	BYTE	00h quiet, 01h verbose
 05h	BYTE	"Borland support" (allowing INT 21/AX=4B01h) on if nonzero
 06h 26 BYTEs	unused???
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - SCREEN IMAGE
	AX = CD08h
	CX:BX -> structure (see below)
Return: AL = 00h successful
	   = 80h unsuccessful
	   = 81h scan line out of range
	   = 82h unsupported scan line density
	   = 83h out of memory
	   = 84h unrecognized source
	   = 85h initialization error

Format of structure:
Offset	Size	Description
 00h	WORD	image source (0 = conventional memory, 1 = expanded memory)
 02h	DWORD	pointer to image data
 06h	WORD	horizontal position on paper of left edge (in 1200 dpi units)
 08h	WORD	vertical position on paper of top edge (in 1200 dpi units)
 0Ah	WORD	left cropping (currently must be zero)
 0Ch	WORD	top cropping (currently must be zero)
 0Eh	WORD	width (currently must be 8000h)
 10h	WORD	height (currently must be 8000h)
 12h	WORD	horizontal size of image in 1200 dpi units
 14h	WORD	vertical size of image in 1200 dpi units
 16h	WORD	aspect ratio (currently reserved)
 18h	WORD	initialization flag (if 01h, initialization is performed)
 1Ah	WORD	pixels per line of source data
 1Ch	WORD	number of scan lines in source data
 1Eh	WORD	number of scan lines in packet
 20h	WORD	bits per pixel (1,2,4,6, or 8)
 22h	WORD	pixels per byte (1,2,4, or 8)
 24h	WORD	compression type (currently only 00h [uncompressed] supported)
 26h	WORD	source page number (if in expanded memory)
 28h	WORD	source handle (if in expanded memory)
 2Ah	WORD	source offset (if in expanded memory)
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - UNUSED
	AX = CD08h
Return: AX = FFFFh (error)
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - LOAD SCREEN
	AX = CD09h
	CX:BX -> structure (see below)
Return: AL = 00h successful
	   = 80h unsuccessful
SeeAlso: AX=CD0Ah"Image Processing"

Format of structure:
Offset	Size	Description
 00h	BYTE	style
		44h ('D') diamond style
		4Ch ('L') line style
 01h	BYTE	reserved (00h)
 02h	WORD	frequency in lines per inch [sic]
		currently, coerced to nearest of 50, 60, 68, 70, 75, 85, or 100
 04h	WORD	screen angle in degrees (-360 to 360)
		currently coerced to nearest of -45, 0, 45, or 90
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - TURN OFF "BORLAND SUPPORT"
	AX = CD09h
Return: AX = 0000h
SeeAlso: AX=CD0Ah"SWELL"
---------------------------------------------
INT 2F - Multiplex - Intel Image Processing Interface - LOAD PALETTE
	AX = CD0Ah
	CX:BX -> palette structure (see below)
Return: AL = 00h successful
	   = 80h unsuccessful
SeeAlso: AX=CD09h"Image Processing"

Format of palette structure:
Offset	Size	Description
 00h	BYTE	bits per pixel for which palette is to be used (1,2,4,6, or 8)
 01h	2**N	palette translation values, one per possible pixel value
---------------------------------------------
INT 2F - Multiplex - SWELL.EXE - TURN ON "BORLAND SUPPORT"
	AX = CD0Ah
Return: AX = 0000h
SeeAlso: AX=CD09h"SWELL"
---------------------------------------------
INT 2F - Multiplex - Quarterdeck QEMM/QRAM/MFT 5.0 - INSTALLATION CHECK
	AX = D200h
	BX = 5144h ("QD")
	CX = 4D45h ("ME")
	DX = 4D30h ("M0")
Return: AL = FFh installed	  
	if BX,CX,DX registers were as specified on entry:
	    BX = 4D45h ("ME")
	    CX = 4D44h ("MD")
	    DX = 5652h ("VR")
Notes:	QEMM/QRAM/VIDRAM/MANIFEST will search for a free AH value from D2h
	  through FFh, then C0h through D1h
	QEMM and QRAM both responded the same
	for AL <> 0, if the BX/CX/DX values don't match a the identifier of a
	  Quarterdeck product, it just chains to the previous INT 2F handler
---------------------------------------------
INT 2F - Multiplex - Quarterdeck QEMM/QRAM 5.0 - GET HIRAM MEMORY CHAIN
	AX = D201h
	BX = 4849h ("HI")
	CX = 5241h ("RA")
	DX = 4D30h ("M0")
Return: BX = 4F4Bh ("OK")
	CX = segment of start of HIRAM chain
	DX = QEMM/QRAM code segment
Notes:	QEMM/QRAM/VIDRAM/MANIFEST will search for a free AH value from D2h
	  through FFh, then C0h through D1h
	QEMM and QRAM both responded the same
	the HIRAM memory chain has the same format as the regular DOS 4.0
	  memory chain (see INT 21/AH=52h), except that XMS Upper Memory Blocks
	  have the block header program name field set to "UMB"
---------------------------------------------
INT 2F - Multiplex - Quarterdeck QEMM/QRAM 5.0 - INSTALLATION CHECK???
	AX = D201h
	BX = 5145h ("QE")
	CX = 4D4Dh ("MM")
	DX = 3432h ("42")
Return: BX = 4F4Bh ("OK")
	DI = ???
	ES = QEMM/QRAM code segment
Note:	QEMM/QRAM/VIDRAM/MANIFEST will search for a free AH value from D2h
	  through FFh, then C0h through D1h
	QEMM and QRAM both responded the same
---------------------------------------------
INT 2F - Multiplex - Quarterdeck VIDRAM 5.0 - INSTALLATION CHECK
	AX = D201h
	BX = 5649h ("VI")
	CX = 4452h ("DR")
	DX = 414dh ("AM")
Return: BX = 4F4Bh ("OK")
	DI = ???
	ES = VIDRAM code segment
Note:	QEMM/QRAM/VIDRAM/MANIFEST will search for a free AH value from D2h
	  through FFh, then C0h through D1h
---------------------------------------------
INT 2F - Multiplex - Quarterdeck MANIFEST 5.0 - INSTALLATION CHECK
	AX = D201h
	BX = 4D41h ("MA")
	CX = 4E49h ("NI")
	DX = 4645h ("FE")
Return: BX = 5354h ("ST")
Note:	QEMM/QRAM/VIDRAM/MANIFEST will search for a free AH value from D2h
	  through FFh, then C0h through D1h
---------------------------------------------
INT 2F - Multiplex - 4DOS.COM v2.1+
	AX = D44Dh
	BH = function
	    00h installation check
		Return: AX = 44DDh
			BL = minor version number
			BH = major version number
			CX = PSP segment address for current invocation
			DL = 4DOS shell number (0 for the first (root) shell,
			     updated each time a new copy is loaded)
	    01h (internal) terminate current copy of 4DOS
	    02h ???
		DX = ???
	    03h EXEC program
		CX:DX -> EXEC record
	    FEh deallocate shell number (passed through to root shell)
		???
	    FFh allocate shell number (passed through to root shell)
Note:	bug in v3.00 will crash system if unrecognized value in BH

Format of EXEC record:
Offset	Size	Description
 00h	WORD	offset of ASCIZ program name in same segment as EXEC record
 02h	WORD	offset of DOS commandline in same segment as EXEC record
 04h	WORD	segment of environment for child process (see INT 21/AH=26h)
---------------------------------------------
INT 2F - Multiplex - 4DOS.COM v3.0+ - AWAITING USER INPUT
	AX = D44Eh
---4DOS v3.01+---
	BX = 0000h 4DOS is ready to display prompt
	   = 0001h 4DOS has displayed the prompt, about to accept user input
Return: handler must preserve SI, DI, BP, SP, DS, ES, and SS
Note:	v3.00 only makes the call corresponding to BX=0001h, does not set BX
---------------------------------------------
INT 2F - Multiplex - BANYAN VINES v4+ - GET BANV INTERRUPT NUMBER
	AX = D701h
Return: AX = 0000h installed
	    BX = interrupt number (60h to 66h)
	   nonzero not present
Note:	if AX is nonzero, VINES 3.x or earlier may be installed, thus it is
	  necessary to examine the four bytes preceding the handlers for
	  INT 60 through INT 66 for the string "BANV"
---------------------------------------------
INT 2F - Multiplex - TRAP.COM - INSTALLATION CHECK
	AX = DA55h
	DL = interrupt number
	DH = ???
Return: if installed
	    AH = interrupt number
	    AL = ???
	    ES:BX -> ???
Notes:	TRAP is an interrupt call tracer by Patrick Phillipot/Udo Chrosziel
	a separate copy of TRAP is loaded for each interrupt to be traced; thus
	  the interrupt number is part of the installation check
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 External Dev Interface - INSTALLATION CHECK
	AX = DE00h
	BX = 4445h ("DE")
	CX = 5844h ("XD")
	DX = 4931h ("I1")
Return: AL = FFh if installed (even if other registers do not match)
	if BX,CX, and DX were as specified on entry,
	    BX = 4845h ("HE")
	    CX = 5245h ("RE")
	    DX = 4456h ("DV")
Notes:	AH=DEh is the default XDI multiplex number, but may range from C0h-FFh
	programs should check for XDI starting at DEh to FFh, then C0h to DDh
	the XDI handler should not issue any DOS or BIOS calls, nor should it
	  issue DESQview API calls other than those allowed from hardware ints
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 External Dev Itrface - DRIVER CUSTOM SUBFUNC
	AX = DE01h
	BX = driver ID
	other registers as needed by driver
Notes:	XDI drivers should pass this call through to previous handler if ID
	  does not match
	DESQview never calls this function
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XMS XDI - ???
	AX = DE01h
	BX = FFFEh
	CX = 4D47h
	DX = 0052h
Return: AL = FFh
	DX = 584Dh
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - DVTree DVTXDI.COM
	AX = DE01h
	BX = 7474h
	CL = function
	    00h installation check
		Return: AL = FFh
	    01h get process handle
		DX = keys on Open Window menu (DL = first, DH = second)
		Return: AX = process handle or 0000h if not running
Return: BX = 4F4Bh ("OK")
	DL = ???
Note:	DVTree is a shareware DOS shell/DESQview process manager by Mike Weaver
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 External Device Interface - DV INIT COMPLETE
	AX = DE02h
	BX = mapping context of DESQview
	DX = handle of DESQview system task
SeeAlso: AX=DE03h
Note:	driver should pass this call to previous handler after doing its work
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 External Device Interface - DV TERMINATION
	AX = DE03h
	BX = mapping context of DESQview
	DX = handle of DESQview system task
SeeAlso: AX=DE02h
Notes:	driver should pass this call to previous handler before doing its work
	DESQview makes this call when it is exiting, but before unhooking any
	  interrupt vectors
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 External Device Interface - ADD PROCESS
	AX = DE04h
	BX = mapping context of new process
	DX = handle of process
Return: nothing
Notes:	XMS XDI handler (installed by default) allocates a 22-byte record
	  (see below) from "common" memory to control access to XMS memory
	all DOS, BIOS, and DV API calls are valid in handler
	driver should pass this call to previous handler after processing it
SeeAlso: AX=DE05h

Format of XMS XDI structure:
Offset	Size	Description
 00h	DWORD	pointer to 10-byte record???
 04h	DWORD	pointer to next XMS XDI structure
 08h	WORD	mapping context
 0Ah	BYTE	???
 0Bh  5 BYTEs	XMS entry point to return for INT 2F/AX=4310h
		(FAR jump to next field)
 10h  6 BYTEs	FAR handler for XMS driver entry point
		(consists of a FAR CALL followed by RETF)
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 External Device Interface - REMOVE PROCESS
	AX = DE05h
	BX = mapping context of process
	DX = handle of last task in process
Return: nothing
Notes:	XMS XDI handler releases the structure allocated by AX=DE04h
	driver should pass this call to previous handler before processing it
	all DOS, BIOS, and DV API calls except those generating a task switch
	  are valid in handler
SeeAlso: AX=DE04h
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - CREATE TASK
	AX = DE06h
	BX = mapping context of process containing task
	DX = handle of new task
Notes:	driver should pass this call to previous handler after processing it
	all DOS, BIOS, and DV API calls are valid in handler
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - TERMINATE TASK
	AX = DE07h
	BX = mapping context of process containing task
	DX = handle of task
Notes:	driver should pass this call to previous handler before processing it
	all DOS, BIOS, and DV API calls except those generating a task switch
	  are valid in handler
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - SAVE STATE
	AX = DE08h
	BX = mapping context of task being switched from
	DX = handle of task being switched from
Notes:	invoked prior to task swap, interrupts, etc
	driver should pass this call to previous handler after processing it
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - RESTORE STATE
	AX = DE09h
	BX = mapping context of task being switched to
	DX = handle of task being switched to
Notes:	state is restored except for interrupts
	driver should pass this call to previous handler before processing it
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - CHANGE KEYBOARD FOCUS
	AX = DE0Ah
	BX = mapping context of task receiving focus
	DX = handle of running task
Notes:	driver should pass this call to previous handler before processing it
	this call often occurs inside a keyboard interrupt
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - DVP PROCESSING COMPLETE
	AX = DE0Bh
	BX = mapping context of DESQview system task
	CX = number of system memory paragraphs required for the use of all
		XDI drivers (DV will add this to system memory in DVP buffer)
	DX = handle of DESQview system task
	SI = mapping context of new process if it starts
	ES:DI -> DVP buffer
Return: CX incremented as needed
Notes:	once DV invokes this function, the DVP buffer contents may be changed
	driver should pass this call to previous handler before processing it
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - SWAP OUT PROCESS
	AX = DE0Ch
	BX = mapping context of task being swapped out
	DX = handle of DESQview system task
Note:	driver should pass this call to previous handler after processing it
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - SWAP IN PROCESS
	AX = DE0Dh
	BX = mapping context of process just swapped in
	DX = handle of DESQview system task
Note:	driver should pass this call to previous handler before processing it
---------------------------------------------
INT 2F - Multiplex - DESQview 2.26 XDI - DVP START FAILED
	AX = DE0Eh
	BX = mapping context of DESQview system task
	DX = handle of DESQview system task
	SI = mapping context of failed process (same as for call to AX=DE0Bh)
Note:	driver should pass this call to previous handler after processing it
---------------------------------------------
INT 2F - Multiplex - ANARKEY.COM - INSTALLATION CHECK
	AX = E300h
Return: AL = 00h not installed
	     FEh if installed but suspended (v3.0+)
	     FFh installed
Notes:	ANARKEY.COM is a commandline recall program by Steven Calwas
	E3h is the default function number, but can be set to any value from
	  C0h to FFh.
---------------------------------------------
INT 2F - Multiplex - ANARKEY.COM v2+ - GET ???
	AX = E301h
Return: DX:BX -> ???
Note:	ANARKEY.COM is a commandline recall program by Steven Calwas

Format of returned data structure for ANARKEY v2.0:
Offset	Size	Description
 -7   7 BYTEs	signature ('ANARKEY')
 00h	WORD	??? (I see 0001h in v2.0)
 02h	WORD	??? (I see 0001h in v2.0)
 04h	WORD	??? (I see 0 in v2.0)
 06h	WORD	PSP segment of next program loaded

Format of returned data structure for ANARKEY v3.0:
Offset	Size	Description
 -1	BYTE	multiplex number
 00h	WORD	??? (I see 0001h in v3.0)
 02h	WORD	??? (I see 0001h in v3.0)
 04h	BYTE	??? (I see 0 in v3.0)
 05h	WORD	PSP segment of next program loaded
---------------------------------------------
INT 2F - Multiplex - ANARKEY.COM v3.0 - ???
	AX = E302h
	BL = ???
Return: ???
Note:	ANARKEY.COM is a commandline recall program by Steven Calwas
---------------------------------------------
INT 2F - Multiplex - ANARKEY.COM v3.0 - ANARKMD API
	AX = E303h
	BL = function
	    01h  toggle insert mode
	    02h  display contents of history buffer
	    03h  write history buffer to file
		ES:DX -> file name
	    04h  clear history buffer
	    05h  undefine all aliases
	    06h  show aliases
	    07h	 list programs using Unix switchar
	    08h	 jump to bottom of history buffer	
Return: ???
Note:	ANARKEY.COM is a commandline recall program by Steven Calwas
---------------------------------------------
INT 2F - Multiplex - ANARKEY.COM v2.0 - ???
	AX = E304h
	BL = ???
Return: ???
Note:	ANARKEY.COM is a commandline recall program by Steven Calwas
---------------------------------------------
INT 2F - Multiplex - ANARKEY.COM v3.0 - SUSPEND ANARKEY
	AX = E305h
	BL = 01h suspend
	     00h enable
Note:	ANARKEY.COM is a commandline recall program by Steven Calwas
---------------------------------------------
INT 2F - Multiplex - AUTOPARK.COM - INSTALLATION CHECK
	AX = F700h
Return: AL = 00h not installed
	     FFh installed
Note:	AUTOPARK.COM is a resident hard disk parker by Alan D. Jones
---------------------------------------------
INT 2F - Multiplex - AUTOPARK.COM - SET PARKING DELAY
	AX = F701h
	BX:CX = 32 bit count of 55ms timer ticks
---------------------------------------------
INT 2F - Multiplex - RESERVED BY BORLAND INTERNATIONAL
	AH = FBh
---------------------------------------------
INT 2F - Multiplex - Borland DPMI LOADER
	AX = FB42h
	details not yet available
---------------------------------------------
INT 2F - Multiplex - Topware Network Operating System - INSTALLATION CHECK
	AX = FF00h
Return: AL = 00h not installed, OK to install
	   = 01h not installed, not OK to install
	   = FFh installed
---------------------------------------------
INT 2F - Multiplex - Topware Network Operating System - GET VERSION
	AX = FF01h
Return: AX = version
---------------------------------------------
INT 30 - (NOT A VECTOR!) FAR JMP instruction for CP/M-style calls
   the CALL 5 entry point does a FAR jump to here
Note:	under DOS 2+, the instruction at PSP:0005 points two bytes too low in
	  memory
SeeAlso: INT 21/AH=26h
---------------------------------------------
INT 31 - overwritten by CP/M jump instruction in INT 30
---------------------------------------------
INT 31 - DOS Prot-Mode Interface 0.9 API - protected mode - ALLOCATE LDT DESCRS
	AX = 0000h
	CX = number of descriptors to allocate
Return: CF set on error
	CF clear if successful
	    AX = base selector
Notes:	the base and limit of the returned descriptors will be 0
	add the value returned by INT 31/AX=0003h to move to subsequent
	  descriptors if multiple descriptors were allocated
SeeAlso: AX=0001h,AX=000Dh
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - FREE LDT DESCRIPTOR
	AX = 0001h
	BX = selector to free
Return: CF set on error
	CF clear if successful
Notes:	only one descriptor is freed per call
	the program's initial CS, DS, and SS descriptors may be freed
SeeAlso: AX=0000h,AX=000Ah,AX=000Dh
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SEGMENT TO DESCRIPTOR
	AX = 0002h
	BX = real mode segment
Return: CF set on error
	CF clear if successful
	    AX = selector corresponding to real mode segment (64K limit)
Notes:	multiple calls for the same real mode segment return the same selector
	the returned descriptor should never be modified or freed
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET NEXT SELECTOR INCREMENT VALUE
	AX = 0003h
Return: CF clear
	    AX = value to add to get next sequential selector
Note:	the increment will be a power of two
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - RESERVED
	AX = 0004h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - RESERVED
	AX = 0005h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET SEGMENT BASE ADDRESS
	AX = 0006h
	BX = selector
Return: CF set on error
	CF clear if successful
	    CX:DX = linear base address of segment
SeeAlso: AX=0007h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SET SEGMENT BASE ADDRESS
	AX = 0007h
	BX = selector
	CX:DX = linear base address
Return: CF set on error
	CF clear if successful
Notes:	only modify descriptors allocated with INT 31/AX=0000h
	only the low 24 bits of the address will be used by 16-bit DPMI
	  implementations even on a 386 or higher
SeeAlso: AX=0006h,AX=0008h,AX=0009h,AX=000Ch
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SET SEGMENT LIMIT
	AX = 0008h
	BX = selector
	CX:DX = segment limit
Return: CF set on error
	CF clear if successful
Notes:	CX must be zero for 16-bit DPMI implementations
	limits greater than 1MB must be page aligned (low 12 bits set)
	only modify descriptors allocated with INT 31/AX=0000h
SeeAlso: AX=0007h,AX=0009h,AX=000Ch
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SET DESCRIPTOR ACCESS RIGHTS
	AX = 0009h
	BX = selector
	CL = access rights/type byte
	CH = 80386 extended rights/type byte (32-bit DPMI implementations only)
Return: CF set on error
	CF clear if successful
SeeAlso: AX=0007h,AX=0008h,AX=000Ch
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - CREATE CODE SEGMENT ALIAS DESCRIPTOR
	AX = 000Ah
	BX = code segment selector
Return: CF set on error
	CF clear if successful
	    AX = new data selector
Notes:	fails if selector in BX is not a code segment or is invalid
	use INT 31/AX=0001h to free new selector
	future changes to the code segment will not be reflected in the data
	  segment
SeeAlso: AX=0001h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET DESCRIPTOR
	AX = 000Bh
	BX = selector
	ES:DI / ES:EDI -> 8-byte buffer for copy of descriptor
Return: CF set on error
	CF clear if successful
Note:	16-bit programs use ES:DI as pointer, 32-bit must use ES:EDI
SeeAlso: AX=000Ch
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SET DESCRIPTOR
	AX = 000Ch
	BX = selector
	ES:DI / ES:EDI -> 8-byte buffer containing descriptor
Return: CF set on error
	CF clear if successful
Notes:	16-bit programs use ES:DI as pointer, 32-bit must use ES:EDI
	only modify descriptors allocated with INT 31/AX=0000h
SeeAlso: AX=000Bh
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - ALLOCATE SPECIFIC LDT DESCRIPTOR
	AX = 000Dh
	BX = selector
Return: CF set on error
	CF clear if successful
	    descriptor allocated
Notes:	free descriptor with INT 31/AX=0001h
	16 descriptors are reserved for this function, but some may already be
	  in use by other applications
SeeAlso: AX=0000h,AX=0001h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - ALLOCATE DOS MEMORY BLOCK
	AX = 0100h
	BX = number of paragraphs to allocate
Return: CF set on error
	    AX = DOS error code (07h,08h) (see INT 21/AH=59h)
	    BX = size (in paragraphs) of largest available block
	CF clear if successful
	    AX = real mode segment of allocated block
	    DX = first selector for allocated block
Notes:	multiple contiguous selectors are allocated for blocks of more than 64K
	never modify or deallocate returned descriptors
SeeAlso: AX=0101h,AX=0501h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - FREE DOS MEMORY BLOCK
	AX = 0101h
	DX = selector of block
Return: CF set on error
	    AX = DOS error code (07h,09h) (see INT 21/AH=59h)
	CF set if successful
SeeAlso: AX=0100h,AX=0102h,AX=0502h
Note:	all descriptors allocated for the block are automatically freed
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - RESIZE DOS MEMORY BLOCK
	AX = 0102h
	BX = new block size in paragraphs
	DX = selector of block
Return: CF set on error
	    AX = DOS error code (07h,08h,09h) (see INT 21/AH=59h)
	    BX = maximum block size (in paragraphs) possible
	CF clear if successful
Notes:	increasing the size of a block past a 64K boundary will fail if the
	  next descriptor in the LDT is already in use
	shrinking a block past a 64K boundary will cause some selectors to be
	  freed
SeeAlso: AX=0100h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET REAL MODE INTERRUPT VECTOR
	AX = 0200h
	BL = interrupt number
Return: CF clear
	CX:DX = segment:offset of real mode interrupt handler
Note:	the DPMI implementation is required to support all 256 vectors
SeeAlso: AX=0201h,AX=0204h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SET REAL MODE INTERRUPT VECTOR
	AX = 0201h
	BL = interrupt number
	CX:DX = segment:offset of real mode handler
Return: CF set on error
	CF clear if successful
Note:	all memory that may be touched by a hardware interrupt handler must be
	  locked down with INT 31/AX=0600h	
SeeAlso: AX=0200h,AX=0205h,AX=0600h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET PROCESSOR EXCEPTION HANDLER VECTOR
	AX = 0202h
	BL = exception number (00h-1Fh)
Return: CF set on error
	CF clear if successful
	    CX:DX / CX:EDX = selector:offset of handler
Note:	16-bit programs receive the pointer in CX:DX, 32-bit programs in CX:EDX
SeeAlso: AX=0203h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SET PROCESSOR EXCEPTION HANDLER VECTOR
	AX = 0203h
	BL = exception number (00h-1Fh)
	CX:DX / CX:EDX = selector:offset of handler
Return: CF set on error
	CF clear if successful
Notes:	32-bit programs must supply an offset in EDX and use a 32-bit interrupt
	  stack frame on chaining to the next exception handler
	the handler should return using a FAR return
	all fault stack frames contain an error code, but it is only valid for
	  exceptions 08h and 0Ah-0Eh
	handlers will only be called if the exception occurs in protected mode
	the handler may change certain values on the stack frame (see below)
SeeAlso: AX=0202h

Format of stack frame for 16-bit programs: (offset from SS:SP)
Offset	Size	Description
 00h	DWORD	return CS:IP (do not change)
 04h	WORD	error code
 06h	DWORD	CS:IP of exception
 0Ah	WORD	flags
 0Ch	DWORD	SS:SP

Format of stack frame for 32-bit programs: (offset from SS:ESP)
Offset	Size	Description
 00h	DWORD	return EIP (do not change)
 04h	WORD	return CS selector (do not change)
 06h	WORD	reserved (do not change)
 08h	DWORD	error code
 0Ch	DWORD	EIP of exception
 10h	WORD	CS selector of exception
 12h	WORD	reserved (do not change)
 14h	DWORD	EFLAGS
 18h	DWORD	ESP
 1Ch	WORD	SS
 1Eh	WORD	reserved (do not change)
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET PROTECTED MODE INTERRUPT VECTOR
	AX = 0204h
	BL = interrupt number
Return: CF set on error
	CF clear if successful
	    CX:DX / CX:EDX = selector:offset of handler
Notes:	16-bit programs use CX:DX, 32-bit programs use CX:EDX
	DPMI implementations are required to support all 256 vectors
SeeAlso: AX=0200h,AX=0205h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SET PROTECTED MODE INTERRUPT VECTOR
	AX = 0205h
	BL = interrupt number
	CX:DX / CX:EDX = selector:offset of handler
Return: CF set on error
	CF clear if successful
Notes:	16-bit programs use CX:DX, 32-bit programs use CX:EDX
	32-bit programs must use a 32-bit interrupt stack frame when chaining
	  to the next handler
	DPMI implementations are required to support all 256 vectors
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SIMULATE REAL MODE INTERRUPT
	AX = 0300h
	BL = interrupt number
	BH = flags
	    bit 0: reset the interrupt controller and A20 line
	    others must be 0
	CX = number of words to copy from protected mode to real mode stack
	ES:DI / ES:EDI = selector:offset of real mode call structure
			(see below)
Return: CF set on error
	CF clear if successful
	    real mode call structure modified (all fields except SS:SP, CS:IP
	      filled with return values from real mode interrupt)
	protected mode stack unchanged
Notes:	16-bit programs use ES:DI as pointer, 32-bit programs use ES:EDI
	CS:IP in the real mode call structure is ignored for this call,
	  instead, the indicated interrupt vector is used for the address
	the flags in the call structure are pushed on the real mode stack to
	  form an interrupt stack frame, and the trace and interrupt flags are
	  clear on entry to the handler
	DPMI will provide a small (30 words) real mode stack if SS:SP is zero
	the real mode handler must return with the stack in the same state as
	  it was on being called
SeeAlso: AX=0302h

Format of real mode call structure:
Offset	Size	Description
 00h	DWORD	EDI
 04h	DWORD	ESI
 08h	DWORD	EBP
 0Ch	DWORD	reserved
 10h	DWORD	EBX
 14h	DWORD	EDX
 18h	DWORD	ECX
 1Ch	DWORD	EAX
 20h	WORD	flags
 22h	WORD	ES
 24h	WORD	DS
 26h	WORD	FS
 28h	WORD	GS
 2Ah	WORD	IP
 2Ch	WORD	CS
 2Eh	WORD	SP
 30h	WORD	SS
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - CALL REAL MODE PROC WITH FAR RET FRAME
	AX = 0301h
	BH = flags
	    bit 0: reset the interrupt controller and A20 line
	    others must be 0
	CX = number of words to copy from protected mode to real mode stack
	ES:DI / ES:EDI = selector:offset of real mode call structure
			(see INT 31/AX=0300h)
Return: CF set on error
	CF clear if successful
	    real mode call structure modified (all fields except SS:SP, CS:IP
	      filled with return values from real mode interrupt)
	protected mode stack unchanged
Notes:	16-bit programs use ES:DI as pointer, 32-bit programs use ES:EDI
	the real mode procedure must exit with a FAR return
	DPMI will provide a small (30 words) real mode stack if SS:SP is zero
	the real mode handler must return with the stack in the same state as
	  it was on being called
SeeAlso: AX=0302h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - CALL REAL MODE PROC WITH IRET FRAME
	AX = 0302h
	BH = flags
	    bit 0: reset the interrupt controller and A20 line
	    others must be 0
	CX = number of words to copy from protected mode to real mode stack
	ES:DI / ES:EDI = selector:offset of real mode call structure
			(see INT 31/AX=0300h)
Return: CF set on error
	CF clear if successful
	    real mode call structure modified (all fields except SS:SP, CS:IP
	      filled with return values from real mode interrupt)
	protected mode stack unchanged
Notes:	16-bit programs use ES:DI as pointer, 32-bit programs use ES:EDI
	the flags in the call structure are pushed on the real mode stack to
	  form an interrupt stack frame, and the trace and interrupt flags are
	  clear on entry to the handler
	the real mode procedure must exit with an IRET
	DPMI will provide a small (30 words) real mode stack if SS:SP is zero
	the real mode handler must return with the stack in the same state as
	  it was on being called
SeeAlso: AX=0300h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - ALLOCATE REAL MODE CALL-BACK ADDRESS
	AX = 0303h
	DS:SI / DS:ESI = selector:offset of procedure to call
	ES:DI / ES:EDI = selector:offset of real mode call structure
			(see AX=0300h)
Return: CF set on error
	CF clear if successful
	    CX:DX = segment:offset of real mode call address
Notes:	the real mode call structure is static, causing reentrancy problems
	the called procedure must modify the real mode CS:IP before returning
	values are returned to real mode by modifying the real mode call struc
	DPMI hosts should provide for at least 16 call-backs per task
SeeAlso: AX=0304h

Values call-back procedure is called with:
	DS:SI / DS:ESI = selector:offset of real mode SS:SP
	ES:DI / ES:EDI = selector:offset of real mode call structure
	SS:SP / SS:ESP = locked protected omde API stack
	interrupts disabled
Return: (with IRET)
	ES:DI / ES:EDI = selector:offset of real mode call structure to restore
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - FREE REAL MODE CALL-BACK ADDRESS
	AX = 0304h
	CX:DX = real mode call-back address
Return: CF set on error
	CF clear if successful
SeeAlso: AX=0303h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET STATE SAVE/RESTORE ADDRESSES
	AX = 0305h
Return: CF set on error
	CF clear if successfule
	    AX = size in bytes of state buffer
	    BX:CX = real mode address of procedure to save/restore state
	    SI:DI / SI:EDI = protected mode procedure to save/restore state
Notes:	the buffer size will be zero if it is not necessary to preserve state
	16-bit programs should call SI:DI, 32-bit programs should call SI:EDI
	this function is only needed if using the raw mode switch service
SeeAlso: AX=0306h

Values to call state-save procedures with:
	AL = direction
	    00h save state
	    01h restore state
	ES:DI / ES:EDI -> state buffer
Return: all registers preserved
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET RAW MODE SWITCH ADDRESSES
	AX = 0306h
Return: CF set on error
	CF clear if successful
	    BX:CX -> procedure to switch from real to protected mode
	    SI:DI / SI:EDI -> procedure to switch from protected to real mode
Notes:	16-bit programs should jump to SI:DI, 32-bit programs should use SI:EDI
	the caller must save and restore the state of the task with AX=0305h
SeeAlso: AX=0305h

Values to JUMP at mode-switch procedures with:
	AX = new DS
	CX = new ES
	DX = new SS
	BX / EBX = new SP / ESP
	SI = new CS
	DI / EDI = new IP / EIP
Note:	BP/EBP is preserved across the call, but AX/EAX, BX/EBX, CX/ECX,
	  DX/EDX, SI/ESI, and DI/EDI will be undefined
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET DPMI VERSION
	AX = 0400h
Return: CF clear
	AH = major version
	AL = minor version
	BX = flags
	    bit 0: running under an 80386 implementation
	    bit 1: processor returns to real mode for reflected interrupts
		   instead of V86 mode
	    bit 2: virtual memory supported
	    bit 3: reserved (undefined)
	    others reserved (zero)
	CL = processor type (02h=80286, 03h=80386, 04h=80486)
	DH = curr value of virtual master interrupt controller base interrupt
	DL = curr value of virtual slave interrupt controller base interrupt
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET FREE MEMORY INFORMATION
	AX = 0500h
	ES:DI / ES:EDI -> buffer for memory information (see below)
Return: CF clear
Notes:	16-bit programs use ES:DI, 32-bit programs use ES:EDI
	this function must be considered advisory because other applications
	  may affect the results at any time after the call
	fields not supported by the DPMI implementation are filled with
	  FFFFFFFFh
SeeAlso: AX=0501h, AX=0604h

Format of memory information:
Offset	Size	Description
 00h	DWORD	largest available block in bytes
 04h	DWORD	maximum unlocked page allocation
 08h	DWORD	maximum locked page allocation
 0Ch	DWORD	linear address space in pages
 10h	DWORD	total unlocked pages
 14h	DWORD	free pages
 18h	DWORD	total physical pages
 1Ch	DWORD	free linear address space in pages
 20h	DWORD	size of paging file/partition in pages
 24h 12 BYTEs	reserved
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - ALLOCATE MEMORY BLOCK
	AX = 0501h
	BX:CX = size in bytes
Return: CF set on error
	CF clear if successful
	    BX:CX = linear address of block
	    SI:DI = memory block handle
Notes:	no selectors are allocated
	the memory block is allocated unlocked
	allocations are often page granular
SeeAlso: AX=0000h, AX=0100h, AX=0500h, AX=0502h, AX=0503h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - FREE MEMORY BLOCK
	AX = 0502h
	SI:DI = handle of memory block
Return: CF set on error
	CF clear if successful
Note:	any selectors allocated for the memory block must also be freed
SeeAlso: AX=0001h, AX=0101h, AX=0501h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - RESIZE MEMORY BLOCK
	AX = 0503h
	BX:CX = new size in bytes
	SI:DI = handle of memory block
Return: CF set on error
	CF clear if successful
	    BX:CX = new linear address
	    SI:DI = new handle of memory block
Note:	any selectors pointing at the block must be updated
	an error is returned if the new size is 0
SeeAlso: AX=0102h, AX=0501h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - LOCK LINEAR REGION
	AX = 0600h
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF set on error
	    none of the memory is locked
	CF clear if successful
Note:	pages at beginning and end will be locked if the region overlaps them
SeeAlso: AX=0601h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - UNLOCK LINEAR REGION
	AX = 0601h
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF set on error
	    none of the memory is unlocked
	CF clear if successful
Notes:	pages at beginning and end will be unlocked if the region overlaps them
	memory whose lock count has not reached zero remains locked
SeeAlso: AX=0600h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - MARK REAL MODE REGION AS PAGEABLE
	AX = 0602h
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF set on error	
	    none of the memory is made pageable
	CF clear if successful
Notes:	relock all unlocked real mode memory before terminating process
	pages at beginning and end will be unlocked if the region overlaps them
	pageability of real mode pages is binary, not a count
SeeAlso: AX=0600h,AX=0603h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - RELOCK REAL MODE REGION
	AX = 0603h
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF set on error	
	    none of the memory is relocked
	CF clear if successful
Note:	pages at beginning and end will be relocked if the region overlaps them
SeeAlso: AX=0602h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET PAGE SIZE
	AX = 0604h
Return: CF set on error
	CF clear if successful
	    BX:CX = page size in bytes
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - RESERVED
	AX = 0700h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - RESERVED
	AX = 0701h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - MARK PAGE AS DEMAND PAGING CANDIDATE
	AX = 0702h
	BX:CX = starting linear address
	SI:DI = number of bytes to mark as paging candidates
Return: CF set on error
	CF clear if successful
Notes:	this function is advisory, and does not force immediate paging
	partial pages will not be discarded
SeeAlso: AX=0703h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - DISCARD PAGE CONTENTS
	AX = 0703h
	BX:CX = starting linear address
	SI:DI = number of bytes to mark as paging candidates
Return: CF set on error
	CF clear if successful
Notes:	this function is advisory, and may be ignored by DPMI implementations
	partial pages will not be discarded
SeeAlso: AX=0702h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - PHYSICAL ADDRESS MAPPING
	AX = 0800h
	BX:CX = physical address
	SI:DI = size in bytes
Return: CF set on error
	CF clear if successful
	    BX:CX = linear address which maps the requested physical memory
Notes:	implementations may refuse this call because it can circumvent protects
	the caller must build an appropriate selector for the memory
	do not use for memory mapped in the first megabyte
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET AND DISABLE VIRTUAL INTERRPT STATE
	AX = 0900h
Return: CF clear
	virtual interrupts disabled
	AL = 00h if previously disabled
	   = 01h if previously enabled
	AH preserved
Note:	the previous state may be restored simply by executing an INT 31
SeeAlso: AX=0901h,AX=0902h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET AND ENABLE VIRTUAL INTERRUPT STATE
	AX = 0901h
Return: CF clear
	virtual interrupts enabled
	AL = 00h if previously disabled
	   = 01h if previously enabled
	AH preserved
Note:	the previous state may be restored simply by executing an INT 31
SeeAlso: AX=0900h, AX=0902h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET VIRTUAL INTERRUPT STATE
	AX = 0902h
Return: CF clear
	AL = 00h if disabled
	   = 01h if enabled
SeeAlso: AX=0900h, AX=0901h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET VENDOR SPECIFIC API ENTRY POINT
	AX = 0A00h
	DS:SI / DS:ESI -> case-sensitive ASCIZ vendor name or identifier
Return: CF set on error
	CF clear if successful
	    ES:DI / ES:EDI -> FAR extended API entry point
	    DS, FS, GS, EAX, EBX, ECX, EDX, ESI, EBP destroyed
Note:	extended API parameters are vendor-specific
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - SET DEBUG WATCHPOINT
	AX = 0B00h
	BX:CX = linear address
	DL = size (1,2,4 bytes)
	DH = type (00h execute, 01h write, 02h read/write)
Return: CF set on error
	CF clear if successful
	    BX = watchpoint handle
SeeAlso: AX=0601h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - CLEAR DEBUG WATCHPOINT
	AX = 0B01h
	BX = watchpoint handle
Return: CF set on error
	CF clear if successful
Note:	the watchpoint handle is freed
SeeAlso: AX=0B00h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - GET STATE OF DEBUG WATCHPOINT
	AX = 0B02h
	BX = watchpoint handle
Return: CF set on error
	CF clear if successful
	    AX = status flags
		bit 0: watch point has been executed since AX=0B00h or AX=0B03h
SeeAlso: AX=0B00h, AX=0B03h
---------------------------------------------
INT 31 - DPMI 0.9 API - protected mode - RESET DEBUG WATCHPOINT
	AX = 0B03h
	BX = watchpoint handle
Return: CF set on error
	CF clear if successful
SeeAlso: AX=0B02h
---------------------------------------------
INT 32 - reserved
---------------------------------------------
INT 33 - MS MOUSE - RESET DRIVER AND READ STATUS
	AX = 0000h
Return: AX = status
	    0000h hardware/driver not installed
	    FFFFh hardware/driver installed
	BX = number of buttons
	    FFFFh two buttons
	    0000h other than two
	    0003h Mouse Systems/Logitech mouse
Notes:	to use mouse on a Hercules-compatible monographics card in graphics
	  mode, you must first set 0040h:0049h to 6 for page 0 or 5 for page 1,
	  and then call this function.
	the Logitech mouse driver contains the signature string "LOGITECH"
SeeAlso: INT 74
---------------------------------------------
INT 33 - MS MOUSE - SHOW MOUSE CURSOR
	AX = 0001h
SeeAlso: AX=0002h, INT 16/AX=FFFEh
---------------------------------------------
INT 33 - MS MOUSE - HIDE MOUSE CURSOR
	AX = 0002h
Note:	multiple calls to hide the cursor will require multiple calls to
	  function 01h to unhide it.
SeeAlso: AX=0001h, INT 16/AX=FFFFh
---------------------------------------------
INT 33 - MS MOUSE - RETURN POSITION AND BUTTON STATUS
	AX = 0003h
Return: BX = button status
	   bit 0  left button pressed if 1
	   bit 1  right button pressed if 1
	   bit 2  middle button pressed if 1 (Mouse Systems/Logitech mouse)
	CX = column
	DX = row
SeeAlso: AX=0004h
---------------------------------------------
INT 33 - MS MOUSE - POSITION MOUSE CURSOR
	AX = 0004h
	CX = column
	DX = row
Note:	the row and column are truncated to the next lower multiple of the cell
	  size; however, some versions of the Microsoft documentation
	  incorrectly state that the coordinates are rounded
SeeAlso: AX=0003h
---------------------------------------------
INT 33 - MS MOUSE - RETURN BUTTON PRESS DATA
	AX = 0005h
	BX = button
	    0000h left
	    0001h right
	    0002h middle (Mouse Systems/Logitech mouse)
Return: AX = button states
	    bit 0 left button pressed if 1
	    bit 1 right button pressed if 1
	    bit 2 middle button pressed if 1 (Mouse Systems/Logitech mouse)
	BX = number of times specified button has been pressed since last call
	CX = column at time specified button was last pressed
	DX = row at time specified button was last pressed
SeeAlso: AX=0006h
---------------------------------------------
INT 33 - MS MOUSE - RETURN BUTTON RELEASE DATA
	AX = 0006h
	BX = button
	    0000h left
	    0001h right
	    0002h middle (Mouse Systems/Logitech mouse)
Return: AX = button states
	    bit 0 left button pressed if 1
	    bit 1 right button pressed if 1
	    bit 2 middle button pressed if 1 (Mouse Systems/Logitech mouse)
	BX = number of times specified button has been released since last call
	CX = column at time specified button was last released
	DX = row at time specified button was last released
SeeAlso: AX=0005h
---------------------------------------------
INT 33 - MS MOUSE - DEFINE HORIZONTAL CURSOR RANGE
	AX = 0007h
	CX = minimum column
	DX = maximum column
SeeAlso: AX=0008h
---------------------------------------------
INT 33 - MS MOUSE - DEFINE VERTICAL CURSOR RANGE
	AX = 0008h
	CX = minimum row
	DX = maximum row
SeeAlso: AX=0007h
---------------------------------------------
INT 33 - MS MOUSE - DEFINE GRAPHICS CURSOR
	AX = 0009h
	BX = column of cursor hot spot in bitmap (-16 to 16)
	CX = row of cursor hot spot (-16 to 16)
	ES:DX -> bitmap
		16 words screen mask
		16 words cursor mask
		    each word defines the sixteen pixels of a row, low bit
		    rightmost
SeeAlso: AX=000Ah
---------------------------------------------
INT 33 - MS MOUSE - DEFINE TEXT CURSOR
	AX = 000Ah
	BX = hardware/software text cursor
	    0000h software
		CX = screen mask
		DX = cursor mask
	    0001h hardware
		CX = start scan line
		DX = end scan line
Note:	when the software cursor is selected, the char/attribute data at the
	  current screen position is ANDed with the screen mask and then XORed
	  with the cursor mask
SeeAlso: AX=0009h
---------------------------------------------
INT 33 - MS MOUSE - READ MOTION COUNTERS
	AX = 000Bh
Return: CX = number of mickeys mouse moved horizontally since last call
	DX = number of mickeys mouse moved vertically
Notes:	a mickey is the smallest increment the mouse can sense
	positive values indicate down/right
---------------------------------------------
INT 33 - MS MOUSE - DEFINE INTERRUPT SUBROUTINE PARAMETERS
	AX = 000Ch
	CX = call mask
	     bit 0 call if mouse moves
	     bit 1 call if left button pressed
	     bit 2 call if left button released
	     bit 3 call if right button pressed
	     bit 4 call if right button released
	     bit 5 call if middle button pressed (Mouse Systems/Logitech mouse)
	     bit 6 call if middle button released (Mouse Sys/Logitech mouse)
	ES:DX -> FAR routine
Notes:	when the subroutine is called, it is passed the following values:
	  AX = condition mask (same bit assignments as call mask)
	  BX = button state
	  CX = cursor column
	  DX = cursor row
	  SI = horizontal mickey count
	  DI = vertical mickey count
	some versions of the Microsoft documentation incorrectly state that CX
	  bit 0 means call if mouse cursor moves, and swap the meanings of SI
	  and DI
---------------------------------------------
INT 33 - MS MOUSE - LIGHT PEN EMULATION ON
	AX = 000Dh
SeeAlso: AX=000Eh
---------------------------------------------
INT 33 - MS MOUSE - LIGHT PEN EMULATION OFF
	AX = 000Eh
SeeAlso: AX=000Dh
---------------------------------------------
INT 33 - MS MOUSE - DEFINE MICKEY/PIXEL RATIO
	AX = 000Fh
	CX = number of mickeys per 8 pixels horizontally (default 8)
	DX = number of mickeys per 8 pixels vertically (default 16)
---------------------------------------------
INT 33 - MS MOUSE - DEFINE SCREEN REGION FOR UPDATING
	AX = 0010h
	CX,DX = X,Y coordinates of upper left corner
	SI,DI = X,Y coordinates of lower right corner
Note:	mouse cursor is hidden during updating, and needs to be explicitly
	  turned on again
---------------------------------------------
INT 33 - MS MOUSE - SET LARGE GRAPHICS CURSOR BLOCK
	AX = 0012h
	BH = cursor width in words
	CH = rows in cursor
	BL = horizontal hot spot (-16 to 16)
	CL = vertical hot spot (-16 to 16)
	ES:DX -> bit map of screen and cursor maps
Return: AX = FFFFh if successful
---------------------------------------------
INT 33 - MS MOUSE - DEFINE DOUBLE-SPEED THRESHOLD
	AX = 0013h
	DX = threshold speed in mickeys/second, 0000h = default of 64/second
Note:	if speed exceeds threshold, the cursor's on-screen motion is doubled
---------------------------------------------
INT 33 - MS MOUSE - EXCHANGE INTERRUPT SUBROUTINES
	AX = 0014h
	CX = call mask (see AX=000Ch)
	ES:DX -> FAR routine 
Return: CX = call mask of previous interrupt routine
	ES:DX = FAR address of previous interrupt routine
---------------------------------------------
INT 33 - MS MOUSE - RETURN DRIVER STORAGE REQUIREMENTS
	AX = 0015h
Return: BX = size of buffer needed to store driver state
---------------------------------------------
INT 33 - MS MOUSE - SAVE DRIVER STATE
	AX = 0016h
	ES:DX -> buffer for driver state
SeeAlso: AX=0017h
---------------------------------------------
INT 33 - MS MOUSE - RESTORE DRIVER STATE
	AX = 0017h
	ES:DX -> buffer containing saved state
SeeAlso: AX=0016h
---------------------------------------------
INT 33 - MS MOUSE - SET ALTERNATE MOUSE USER HANDLER
	AX = 0018h
	CX = call mask
	     bit 0 call if alt key pressed during event
	     bit 1 call if ctrl key pressed during event
	     bit 2 call if shift button pressed during event
	     bit 3 call if right button released
	     bit 4 call if right button pressed
	     bit 5 call if left button released
	     bit 6 call if left button pressed
	     bit 7 call if mouse moves
	ES:DX = address of FAR routine
Return: AX = 0018h if successful
	   = FFFFh on error
Notes:	when the subroutine is called, it is passed the following values:
	  AX = condition mask (same bit assignments as call mask)
	  BX = button state
	  CX = cursor column
	  DX = cursor row
	  DI = horizontal mickey count
	  SI = vertical mickey count
	up to three handlers can be defined by separate calls to this function
---------------------------------------------
INT 33 - MS MOUSE - RETURN USER ALTERNATE INTERRUPT VECTOR
	AX = 0019h
	CX = call mask
Return: BX:DX = user interrupt vector
	CX = call mask (0 if not found)
Note:	attempts to find a user event handler (defined by function 18h)
	  whose call mask matches CX
---------------------------------------------
INT 33 - MS MOUSE - SET MOUSE SENSITIVITY
	AX = 001Ah
	BX = horizontal speed \
	CX = vertical speed   / (see AX=000Fh)
	DX = double speed threshold (see AX=0013h)
SeeAlso: AX=001Bh
---------------------------------------------
INT 33 - MS MOUSE - RETURN MOUSE SENSITIVITY
	AX = 001Bh
Return: BX = horizontal speed
	CX = vertical speed
	DX = double speed threshold
SeeAlso: AX=001Ah
---------------------------------------------
INT 33 - MS MOUSE - SET INTERRUPT RATE
	AX = 001Ch
	BX = rate
	    00h no interrupts allowed
	    01h 30 per second
	    02h 50 per second
	    03h 100 per second
	    04h 200 per second
Notes:	only available on InPort mouse
	values greater than 4 may cause unpredictable driver behavior
---------------------------------------------
INT 33 - MS MOUSE - DEFINE DISPLAY PAGE NUMBER
	AX = 001Dh
	BX = display page number
Note:	the cursor will be displayed on the specified page
---------------------------------------------
INT 33 - MS MOUSE - RETURN DISPLAY PAGE NUMBER
	AX = 001Eh
Return: BX = display page number
---------------------------------------------
INT 33 - MS MOUSE - DISABLE MOUSE DRIVER
	AX = 001Fh
Return: AX = 001Fh successful
	     FFFFh unsuccessful
	ES:BX = vector for INT 33h before mouse driver was first installed
Note:	restores vectors for Int 10h and Int 71h (8086) or Int 74h (286/386)
	if you restore Int 33h to ES:BX, driver will be completely disabled
---------------------------------------------
INT 33 - MS MOUSE - ENABLE MOUSE DRIVER
	AX = 0020h
Note:	restores vectors for Int 10h and Int 71h (8086) or Int 74h (286/386)
	  which were removed by function 1Fh
---------------------------------------------
INT 33 - MS MOUSE - SOFTWARE RESET
	AX = 0021h
Return: AX = FFFFh if mouse driver installed
	     0021h if mouse driver not installed
	BX = 2 if mouse driver is installed
Note:	identical to funtion 00h, but does not reset the mouse
---------------------------------------------
INT 33 - MS MOUSE - SET LANGUAGE FOR MESSAGES
	AX = 0022h
	BX = language
	    00h English
	    01h French
	    02h Dutch
	    03h German
	    04h Swedish
	    05h Finnish
	    06h Spanish
	    07h Portugese
	    08h Italian
Note:	only available on international versions of the driver, US versions
	  ignore this call
SeeAlso: AX=0023h
---------------------------------------------
INT 33 - MS MOUSE - GET LANGUAGE FOR MESSAGES
	AX = 0023h
Return:	BX = language (see AX=0022h)
Note:	the US version of the driver always returns zero 
SeeAlso: AX=0022h
---------------------------------------------
INT 33 - MS MOUSE - GET SOFTWARE VERSION AND MOUSE TYPE
	AX = 0024h
Return: AX = FFFFh on error
	otherwise,
	    BH = major version
	    BL = minor version
	    CH = type (1=bus, 2=serial, 3=InPort, 4=PS/2, 5=HP)
	    CL = interrupt (0=PS/2, 2=IRQ2, 3=IRQ3,...,7=IRQ7)
---------------------------------------------
INT 33 - PCMOUSE - GET MSMOUSE STORAGE REQUIREMENTS
	AX = 0042h
Return: AX = FFFFh successful
		BX = buffer size in bytes for functions 50h and 52h
	   = 0000h MSMOUSE not installed
	   = 0042h functions 42h, 50h, and 52h not supported
SeeAlso: AX=0050h
---------------------------------------------
INT 33 - LOGITECH - RETURN POINTER TO MICROSOFT COPYRIGHT
	AX = 004Dh
Return: ES:DI -> "Copyright 1983 Microsoft ***"
---------------------------------------------
INT 33 - PCMOUSE - SAVE MSMOUSE STATE
	AX = 0050h
	BX = buffer size
	ES:DX -> buffer
Return: AX = FFFFh if successful
SeeAlso: AX=0042h,0052h
---------------------------------------------
INT 33 - PCMOUSE - RESTORE MSMOUSE STATE
	AX = 0052h
	BX = buffer size
	ES:DX -> buffer
Return: AX = FFFFh if successful
SeeAlso: AX=0050h
---------------------------------------------
INT 33 - LOGITECH - ???
	AX = 006Dh
Return: ES:DI -> 06 02 40 08
---------------------------------------------
INT 33 - LOGITECH - GET COMPASS PARAMETER
	AX = 1D6Ch
Return: BX = direction (0=north, 1=south, 2=east, 3=west)
SeeAlso: AX=1E6Ch
---------------------------------------------
INT 33 - LOGITECH - SET COMPASS PARAMETER
	AX = 1E6Ch
	BX = direction (0=north, 1=south, 2=east, 3=west)
SeeAlso: AX=1D6Ch
---------------------------------------------
INT 33 - LOGITECH - GET BALLISTICS INFORMATION
	AX = 1F6Ch
Return: BX = 0=off, 1=on
	CX = 1=low, 2=high
SeeAlso: AX=236Ch
---------------------------------------------
INT 33 - LOGITECH - SET LEFT OR RIGHT PARAMETER
	AX = 206Ch
	BX = parameter (00h = right, FFh = left)
SeeAlso: AX=216Ch
---------------------------------------------
INT 33 - LOGITECH - GET LEFT OR RIGHT PARAMETER
	AX = 216Ch
Return: BX = parameter (00h = right, FFh = left)
SeeAlso: AX=206Ch
---------------------------------------------
INT 33 - LOGITECH - REMOVE DRIVER FROM MEMORY
	AX = 226Ch
Note:	this only frees memory; does not restore hooked interrupts
---------------------------------------------
INT 33 - LOGITECH - SET BALLISTICS INFORMATION
	AX = 236Ch
	BX = 0=off, 1=on
	CX = 1=low, 2=high
SeeAlso: AX=1F6Ch
---------------------------------------------
INT 33 - LOGITECH - GET PARAMETERS AND RESET SERIAL MOUSE
	AX = 246Ch
	ES:DX -> parameter table buffer (see below)
Return: AX = FFFFh if driver installed for serial mouse
SeeAlso: AX=256Ch

Format of parameter table:
Offset	Size	Description
 00h	WORD	baud rate divided by 100  (serial mouse only)
 02h	WORD	emulation		  (serial mouse only)
 04h	WORD	report rate		  (serial mouse only)
 06h	WORD	firmware revision	  (serial mouse only)
 08h	WORD	0			  (serial mouse only)
 0Ah	WORD	port			  (serial mouse only)
 0Ch	WORD	physical buttons
 0Eh	WORD	logical buttons
---------------------------------------------
INT 33 - LOGITECH - SET PARAMETERS
	AX = 256Ch
	BX = 00h set baud rate (serial mouse only)
		CX = rate (0=1200, 1=2400, 2=4800, 3=9600)
	   = 01h set emulation (serial mouse only)
		CX = emulation
		    0 = 5 byte packed binary
		    1 = 3 byte packed binary
		    2 = hexadecimal
		    3 = relative bid pad
		    4 = not supported
		    5 = MM Series
		    6 = not supported
		    7 = Microsoft
	   = 02h set report rate (serial mouse only)
		CX = rate (0=10, 1=20, 2=35, 3=50, 4=70, 5=100, 6=150)
	   = 03h set port (serial mouse only)
		CX = port (1, 2)
	   = 04h set mouse logical buttons
		CX = buttons (2, 3)
Return: AX = FFFFh if driver installed for serial mouse
SeeAlso: AX=246Ch
---------------------------------------------
INT 33 - LOGITECH - GET VERSION???
	AX = 266Ch
Return: BX = 'SS'
	CH = '4'  major version number
	CL = '1'  minor version number
---------------------------------------------
INT 33 - LOGITECH - ??? Tries MMSeries, Baud 2400
	AX = 276Ch
---------------------------------------------
INT 34 - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates opcode D8h
---------------------------------------------
INT 35 - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates opcode D9h
---------------------------------------------
INT 36 - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates opcode DAh
---------------------------------------------
INT 37 - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates opcode DBh
---------------------------------------------
INT 38 - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates opcode DCh
---------------------------------------------
INT 39 - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates opcode DDh
---------------------------------------------
INT 3A - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates opcode DEh
---------------------------------------------
INT 3B - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates opcode DFh
---------------------------------------------
INT 3C - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates instructions with a segment override
Note:	the generated code is  CD 3C xy mm ....
	where xy is a modified ESC instruction and mm is the modR/M byte.  The
	xy byte appears to be encoded as
	    s s 0 1 1 x x x
	where "ss" specifies the segment override:
		00 -> DS:
		01 -> SS:
		10 -> CS:
		11 -> ES:
---------------------------------------------
INT 3D - Borland/Microsoft languages - Floating Point emulation
	This interrupt emulates a standalone FWAIT instruction
---------------------------------------------
INT 3E - Borland languages - Floating Point emulation "shortcut" call
	The two bytes following the INT 3E instruction are the subcode and
	a NOP (90h)

Subcode		Function
 DCh	load 8086 stack with 8087 registers
 DEh	load 8087 registers from 8086 stack
 E0h	round TOS and R1 to single precision, compare, pop twice
 E2h	round TOS and R1 to double precision, compare, pop twice
	Note: apparently buggy in TPas5.5, actually rounding to single prec.
 E4h	compare TOS/R1 with two POP's
 E6h	compare TOS/R1 with POP
 E8h	FTST (check TOS value)
 EAh	FXAM (check TOS value)
 ECh	sine
 EEh	cosine
 F0h	tangent
 F2h	arctangent
 F4h	Ln (FLDLN2 to TOS)
 F6h	Log2 (FLDLG2 to TOS)
 F8h	Log10 (FLDLG10 to TOS
 FAh	Exp (FLDL2E to TOS)
 FCh	TOS = 2**TOS
 FEh	TOS = 10**TOS
---------------------------------------------
INT 3F - Overlay manager interrupt (Microsoft LINK.EXE)
Note:	INT 3F is the default, and may be overridden while linking
---------------------------------------------
INT 3F - Microsoft Dynamic Link Library manager
---------------------------------------------
INT 40 - Hard disk - Relocated Floppy Handler (original INT 13h)
SeeAlso: INT 63
---------------------------------------------
INT 40 - Z100 - Master 8259 - Parity error or S100 error
---------------------------------------------
INT 41 - (NOT a vector!) FIXED DISK PARAMS (XT,AT,XT2,XT286,PS except ESDI)
SeeAlso: INT 1E,INT 46

Format of fixed disk parameters:
Offset	Size	Description
 00h	WORD	cylinders
 02h	BYTE	heads
 03h	WORD	starting reduced write current cylinder (XT only, 0 for others)
 05h	WORD	starting write pre-comp cylinder
 07h	BYTE	maximum ECC burst length
 08h	BYTE	control byte
		   bits 0-2: drive option (XT only, 0 for others)
		   bit 3:    set if more than 8 heads
		   bit 4:    always 0
		   bit 5:    set if manufacturer's defect map on max cylinder+1
		   bit 6:    disable ECC retries
		   bit 7:    disable access retries
 09h	BYTE	standard timeout (XT only, 0 for others)
 0Ah	BYTE	formatting timeout (XT only, 0 for others)
 0Bh	BYTE	timeout for checking drive (XT only, 0 for others)
 0Ch	WORD	landing zone (AT/PS2)
 0Eh	BYTE	sectors/track (AT/PS2)
 0Fh	BYTE	0
---------------------------------------------
INT 41 - Z100 - Master 8259 - Processor Swap
---------------------------------------------
INT 42 - EGA/VGA/PS - Relocated (by EGA) Video Handler (original INT 10h)
---------------------------------------------
INT 42 - Z100 - Master 8259 - Timer
---------------------------------------------
INT 43 - EGA/VGA/PS - User font table
SeeAlso: INT 1F,INT 44
---------------------------------------------
INT 43 - Z100 - Master 8259 - Slave 8259 input
Note:	slave runs in special fully nested mode
---------------------------------------------
INT 44 - EGA/VGA/CONV/PS - EGA/PCjr fonts, characters 00h to 7Fh
SeeAlso: INT 1F,INT 43
---------------------------------------------
INT 44 - Novell NetWare - HIGH-LEVEL LANGUAGE API
---------------------------------------------
INT 44 - IBM 3270-PC High Level Language API
	DS:SI -> parameter control block
---------------------------------------------
INT 44 - Z100 - Master 8259 - Serial A
---------------------------------------------
INT 45 - Z100 - Master 8259 - Serial B
---------------------------------------------
INT 46 - Secondary Fixed Disk Params (AT,XT286,PS except ESDI)
SeeAlso: INT 41
---------------------------------------------
INT 46 - Z100 - Master 8259 - Keyboard, Retrace, and Light Pen
---------------------------------------------
INT 47 - Z100 - Master 8259 - Printer
---------------------------------------------
INT 47 - SQL Base - DATABASE ENGINE API
	AX = 8000h
	DS:BX -> parameter block, first word is function number
Note:	SQL Base is a network-oriented database engine by Gupta Technologies

Values for function number:
 01h	"SQLFINI" initalialize application's use of the database
 02h	"SQLFDON" application is done using the database
 03h	"SQLFCON" connect to a cursor/database
 04h	"SQLFDIS" disconnect from a cursor/database
 05h	"SQLFCOM" compile a SQL command
 06h	"SQLFEXE" execute a SQL command
 07h	"SQLFCEX" compile and execute a SQL command
 08h	"SQLFCMT" commit a transaction to the database
 09h	"SQLFDES" describe the items of a SELECT statement
 0Ah	"SQLFGFI" get fetch information
 0Bh	"SQLFFBK" fetch previous result row from SELECT statement
 0Ch	"SQLFFET" fetch next result row from SELECT statement
 0Dh	"SQLFEFB" enable fetch backwards
 0Eh	"SQLFPRS" position in result set
 0Fh	"SQLFURS" undo result set
 10h	"SQLFNBV" get number of bind variables
 11h	"SQLFBND" bind data variables
 12h	"SQLFBNN" bind numerics
 13h	"SQLFBLN" bind long number
 14h	"SQLFBLD" bind long data variables
 15h	"SQLFSRS" start restriction set processing
 16h	"SQLFRRS" restart restriction set processing
 17h	"SQLFCRS" close restriction set
 18h	"SQLFDRS" drop restriction set
 19h	"SQLFARF" apply Roll Forward journal
 1Ah	"SQLFERF" end Roll Forward journal
 1Bh	"SQLFSRF" start Roll Forward journal
 1Ch	"SQLFSTO" store a compiled SQL command
 1Dh	"SQLFRET" retrieve a compiled SQL command
 1Eh	"SQLFDST" drop a stored command
 1Fh	"SQLFCTY" get command type
 20h	"SQLFEPO" get error position
 21h	"SQLFGNR" get number of rows
 22h	"SQLFNSI" get number of select items
 23h	"SQLFRBF" get Roll Back flag
 24h	"SQLFRCD" get return code
 25h	"SQLFROW" get number of ROWs
 26h	"SQLFSCN" set cursor name
 27h	"SQLFSIL" set isolation level
 28h	"SQLFSLP" set log parameters
 29h	"SQLFSSB" set select buffer
 2Ah	"SQLFSSS" set sort space
 2Bh	"SQLFRLO" read long
 2Ch	"SQLFWLO" write long
 2Dh	"SQLFLSK" long seek
 2Eh	"SQLFGLS" get long size
 2Fh	"SQLFELO" end long operation
 30h	"SQLFRBK" roll back a transaction from the database
 31h	"SQLFERR" error message
 32h	"SQLFCPY" copy
 33h	"SQLFR01" reserved
 34h	"SQLFSYS" system
 35h	"SQLFSTA" statistics
 36h	"SQLFR02" reserved
 37h	"SQLFXAD" extra add
 38h	"SQLFXCN" extra character to number
 39h	"SQLFXDA" extra date add
 3Ah	"SQLFXDP" extra date picture
 3Bh	"SQLFXDV" extra divide
 3Ch	"SQLFXML" extra multiply
 3Dh	"SQLFXNP" extra number picture
 3Eh	"SQLFXPD" extra picture date
 3Fh	"SQLFXSB" extra subtract
 40h	"SQLFINS" install database
 41h	"SQLFDIN" deinstall database
 42h	"SQLFDIR" directory of databases
 43h	"SQLFTIO" timeout
 44h	"SQLFFQN" get fully qualified column name
 45h	"SQLFEXP" explain execution plan
 46h	"SQLFFER" get full error
 47h	"SQLFBKP" begin online backup
 48h	"SQLFRDC" read backup data chunk
 49h	"SQLFEBK" end backup
 4Ah	"SQLFRES" begin restore from backup
 4Bh	"SQLFWDC" write backup data chunk for restore
 4Ch	"SQLFRRD" recover restored database to consistent state
 4Dh	"SQLFERS" end restore
 4Eh	"SQLFNRR" return number of result set rows
 4Fh	"SQLFSTR" start restriction mode
 50h	"SQLFSPR" stop restriction mode
 51h	"SQLFCNC" connect 2
 52h	"SQLFCNR" connect with no recovery
 53h	"SQLFOMS" set output message size
 54h	"SQLFIMS" set input message size
 55h	"SQLFSCP" set cache pages
 56h	"SQLFDSC" describe items of a SELECT statement (external)
 57h	"SQLFLAB" get label info for items in SELECT statement
 58h	"SQLFCBV" clear bind variables
 59h	"SQLFGET" get database information
 5Ah	"SQLFSET" set database information
 5Bh	"SQLFTEC" translate error code
---------------------------------------------
INT 47 - SQL Base - GET VERSION NUMBER
	AX = 8001h
Return: ???
Note:	SQL Base is a network-oriented database engine by Gupta Technologies
---------------------------------------------
INT 48 - PCjr - Cordless Keyboard Translation
---------------------------------------------
INT 48 - Z100 - Slave 8259 - S100 vectored line 0
---------------------------------------------
INT 49 - PCjr - Non-keyboard Scan Code Translation Table

Format of translation table:
Offset	Size	Description
 00h	BYTE	number of nonkeyboard scancodes in the table
 01h  N WORDs	high byte 00h (NUL) byte scancode with low order byte
		representing the scancode mapped values relative to their
		input values within the range of 56h through 7Eh
---------------------------------------------
INT 49 - Z100 - Slave 8259 - S100 vectored line 1
---------------------------------------------
INT 4A - AT/CONV/PS - User Alarm
	Invoked by BIOS when real-time clock alarm occurs
SeeAlso: INT 1A/AH=06h
---------------------------------------------
INT 4A - Z100 - Slave 8259 - S100 vectored line 2
---------------------------------------------
INT 4B - Virtual DMA Specification (VDS) - GET VERSION
	AX = 8102h
	DX = 0000h
Return: CF clear if successful
	    AH = major version number
	    AL = minor version number
	    BX = product number
	    CX = product revision number
	    SI:DI = maximum DMA buffer size
	    DX = flags
		bit 0: PC/XT bus (DMA in first megabyte only)
		    1: physical buffer/remap region in first megabyte
		    2: automatic remap enabled
		    3: all memory is physically contiguous
		 4-15: reserved (zero)
	CF set on error
	    AL = error code (see below)
Note:	bit 5 of 0040h:007Bh is supposed to be set if VDS is supported; this is
	  apparently not always the case
SeeAlso: INT 31

Values for error code:
 01h	region not in contiguous memory
 02h	region crossed a physical alignment boundary
 03h	unable to lock pages
 04h	no buffer available
 05h	region too large for buffer
 06h	buffer currently in use
 07h	invalid memory region
 08h	region was not locked
 09h	number of physical pages greater than table length
 0Ah	invalid buffer ID
 0Bh	copy out of buffer range
 0Ch	invalid DMA channel number
 0Dh	disable count overflow
 0Eh	disable count underflow
 0Fh	function not supported
 10h	reserved flag bits set in DX

Format of DMA descriptor structure (DDS):
Offset	Size	Description
 00h	DWORD	region size
 04h	DWORD	offset
 08h	WORD	segment/selector
 0Ah	WORD	buffer ID
 0Ch	DWORD	physical address

Format of Extended DMA descriptor structure (EDDS):
Offset	Size	Description
 00h	DWORD	region size
 04h	DWORD	offset
 08h	WORD	segment/selector
 0Ah	WORD	reserved
 0Ch	WORD	number available
 0Eh	WORD	number used
 10h	DWORD	region 0 physical address
 14h	DWORD	region 0 size in bytes
 18h	DWORD	region 1 physical address
 1Ch	DWORD	region 1 size in bytes
	...

Format of Extended DMA descriptor structure (EDDS) with page table entries:
Offset	Size	Description
 00h	DWORD	region size
 04h	DWORD	offset
 08h	WORD	segment/selector
 0Ah	WORD	reserved
 0Ch	WORD	number available
 0Eh	WORD	number used
 10h	DWORD	page table entry 0 (same as 80386 page table entry)
 14h	DWORD	page table entry 1
	...
Note:	bits 1-12 of the page table entries should be zero; bit 0 set if page
	  is present and locked
---------------------------------------------
INT 4B - Virtual DMA Specification - LOCK DMA REGION
	AX = 8103h
	DX = flags
	    bit 0: reserved (zero)
		1: data should be copied into buffer (ignored if bit 2 set)
		2: buffer should not be allocated if region noncontiguous or
		   crosses physical alignment boundary specified by bits 4-5
		3: don't attempt automatic remap
		4: region must not cross 64K physical alignment boundary
		5: region must not cross 128K physical alignment boundary
	     6-15: reserved (zero)
	DS:SI -> DMA descriptor structure (see AX=8102h)
Return:	CF clear if successful
	    DDS physical address field filled in
	    DDS buffer ID field filled (0000h if no buffer allocated)
	CF set on error
	    AL = error code (see AX=8102h)
	    DDS region size field filled wth maximum contiguous length in bytes
SeeAlso: AX=8104h,AX=8105h
---------------------------------------------
INT 4B - Virtual DMA Specification - UNLOCK DMA REGION
	AX = 8104h
	DX = flags
	    bit 0: reserved (zero)
		1: data should be copied out of buffer
	     2-15: reserved (zero)
	ES:DI -> DMA descriptor structure (see AX=8102h) with region size,
		physical address, and buffer ID fields set
Return: CF clear if successful
	    DDS physical address field set
	    DDS buffer ID field set (0000h if no buffer allocated)
	CF set on error
	    AL = error code (see AX=8102h)
	    DDS region size field filled wth maximum contiguous length in bytes
SeeAlso: AX=8103h,AX=8106h
---------------------------------------------
INT 4B - Virtual DMA Specification - SCATTER/GATHER LOCK REGION
	AX = 8105h
	DX = flags
	    bits 0-5: reserved (zero)
		   6: EDDS should be returned with page table entries
		   7: only present pages should be locked (not-present pages
			receive entry of 0000h)
		8-15: reserved (zero)
	ES:DI -> Extended DMA descriptor structure (see AX=8102h)
		region size, linear segment, linear offset, and number avail
		fields set
Return: CF clear if successful
	    EDDS number used field set
	    if DX bit 6 set, lower 12 bits of BX = offset in first page
	CF set on error
	    AL = error code (see AX=8102h)
	    EDDS region size field filled with max length in bytes that can be
		locked and described in the EDDS table
SeeAlso: AX=8103h,AX=8106h
---------------------------------------------
INT 4B - Virtual DMA Specification - SCATTER/GATHER UNLOCK REGION
	AX = 8106h
	DX = flags
	    bits 0-5: reserved (zero)
		   6: EDDS contains page table entries
		   7: EDDS may contain not-present pages (entry = 0000h)
		8-15: reserved (zero)
	ES:DI -> Extended DMA descriptor structure (see AX=8102h) returned
		by AX=8105h	
Return: CF clear if successful
	CF set on error
	    AL = error code (see AX=8102h)
SeeAlso: AX=8104h,AX=8105h
---------------------------------------------
INT 4B - Virtual DMA Specification - REQUEST DMA BUFFER
	AX = 8107h
	DX = flags
	    bit 0: reserved (zero)
		1: data should be copied into buffer
	     2-15: reserved (zero)
	ES:DI -> DMA descriptor structure (see AX=8102h) with region size set
		(also region offset and region segment if DX bit 1 set)
Return: CF clear if successful
	    DDS physical address and buffer ID set
	    DDS region size filled with length of buffer
	CF set on error
	    AL = error code (see AX=8102h)
SeeAlso: AX=8108h
---------------------------------------------
INT 4B - Virtual DMA Specification - RELEASE DMA BUFFFER
	AX = 8108h
	DX = flags
	    bit 0: reserved (zero)
		1: data should be copied out of buffer
	     2-15: reserved (zero)
	ES:DI -> DMA descriptor structure (see AX=8102h) with buffer ID set
		(also region size/region offset/segment if DX bit 1 set)
Return: CF clear if successful
	CF set on error
	    AL = error code (see AX=8102h)
SeeAlso: AX=8107h
---------------------------------------------
INT 4B - Virtual DMA Specification - COPY INTO DMA BUFFER
	AX = 8109h
	DX = 0000h
	ES:DI -> DMA descriptor structure (see AX=8102h) with buffer ID,
		region segment/offset, and region size fields set
	BX:CX = starting offset into DMA buffer
Return: CF clear if successful
	CF set on error
	    AL = error code (see AX=8102h)
SeeAlso: AX=810Ah
---------------------------------------------
INT 4B - Virtual DMA Specification - COPY OUT OF DMA BUFFER
	AX = 810Ah
	DX = 0000h
	ES:DI -> DMA descriptor structure (see AX=8102h) with buffer ID,
		region segment/offset, and region size fields set
	BX:CX = starting offset into DMA buffer
Return: CF clear if successful
	CF set on error
	    AL = error code (see AX=8102h)
SeeAlso: AX=8109h
---------------------------------------------
INT 4B - Virtual DMA Specification - DISABLE DMA TRANSLATION
	AX = 810Bh
	BX = DMA channel number
	DX = 0000h
Return: CF clear if successful
	CF set on error
	    AL = error code (see AX=8102h)
SeeAlso: AX=810Ch
---------------------------------------------
INT 4B - Virtual DMA Specification - ENABLE DMA TRANSLATION
	AX = 810Ch
	BX = DMA channel number
	DX = 0000h
Return: CF clear if successful
	    ZF set if disable count decremented to zero
	CF set on error
	    AL = error code (see AX=8102h)
SeeAlso: AX=810Bh
---------------------------------------------
INT 4B - Z100 - Slave 8259 - S100 vectored line 3
---------------------------------------------
INT 4C - Z100 - Slave 8259 - S100 vectored line 4
---------------------------------------------
INT 4D - Z100 - Slave 8259 - S100 vectored line 5
---------------------------------------------
INT 4E - TI Professional PC - DISK I/O
	used instead of INT 13 on the TI Professional PC
---------------------------------------------
INT 4E - Z100 - Slave 8259 - S100 vectored line 6
---------------------------------------------
INT 4F - Z100 - Slave 8259 - S100 vectored line 7
---------------------------------------------
INT 50 - TIL Xpert AIM (X.25)
	AH = function
---------------------------------------------
INT 50 - through 57 - IRQ0-IRQ7 relocated by DESQview
---------------------------------------------
INT 50 - through 57 - IRQ0-IRQ7 relocated by IBM 3278 emulation control program
---------------------------------------------
INT 58 - IRQ8 relocated by DESQview 2.26+
SeeAlso: INT 70
---------------------------------------------
INT 59 - IRQ9 relocated by DESQview 2.26+
SeeAlso: INT 71
---------------------------------------------
INT 59 - GSS Computer Graphics Interface (GSS*CGI)
	DS:DX -> block of 5 array pointers
Return:	CF set on error
	    AX = error code
	CF clear if successful
	    AX = return code
Note:	INT 59 is the means by which GSS*CGI language bindings communicate with
	  GSS*CGI device drivers and the GSS*CGI device driver controller.
	also used by the IBM Graphic Development Toolkit
---------------------------------------------
INT 5A - IRQ10 relocated by DESQview 2.26+
SeeAlso: INT 72
---------------------------------------------
INT 5A - Cluster adapter BIOS entry address
	???
---------------------------------------------
INT 5B - IRQ11 relocated by DESQview 2.26+
SeeAlso: INT 73
---------------------------------------------
INT 5B - Used by cluster adapter
---------------------------------------------
INT 5B - AT&T Starlan Extended NetBIOS (variable length names)
	ES:BX -> Network Control Block (see below)
Return: AL = status (see INT 5C)
SeeAlso: INT 5C

Format of Network Control Block
Offset	Size	Description
 00h	BYTE	ncb_command (see below)
 01h	BYTE	ncb_retcode
 02h	BYTE	ncb_lsn
 03h	BYTE	ncb_num
 04h	DWORD	-> ncb_buffer
 08h	WORD	ncb_length
 0Ah 16 BYTEs	ncb_callname
 1Ah 16 BYTEs	ncb_name
 2Ah	BYTE	ncb_rto
 2Bh	BYTE	ncb_sto
 2Ch	DWORD	-> ncb_post  	/* int (far *ncb_post)(); */
 30h	BYTE	ncb_lana_num
 31h	BYTE	ncb_cmd_cplt
 32h	DWORD	-> ncb_vname
 36h	BYTE	ncb_vnamelen
 37h  9 BYTEs	ncb_reserve
Note: fields 00h-31h are the same as for a standard NetBIOS NCB (see INT 5C)

Values for ncb_command field same as for INT 5C, except
	70h	send net Break
---------------------------------------------
INT 5B - Microsoft Network Transport Layer Interface
---------------------------------------------
INT 5C - IRQ12 relocated by DESQview 2.26+
SeeAlso: INT 74
---------------------------------------------
INT 5C - NETBIOS INTERFACE
	ES:BX -> Network Control Block (see below)
Return: AL = status
	    00h successful
	    01h bad buffer size
	    03h invalid NETBIOS command
	    05h timeout
	    06h receive buffer too small
	    08h bad session number
	    09h LAN card out of memory
	    0Ah session closed
	    0Bh command has been cancelled
	    0Dh name already exists
	    0Eh local name table full
	    0Fh name still in use, can't delete
	    11h local session table full
	    12h remote PC not listening
	    13h bad NCB_NUM field
	    14h no answer to CALL or no such remote
	    15h name not in local name table
	    16h duplicate name
	    17h bad delete
	    18h abnormal end
	    19h name error, multiple identical names in use
	    1Ah bad packet
	    21h network card busy
	    22h too many commands queued
	    23h bad LAN card number
	    24h command finished while cancelling
	    26h command can't be cancelled
	    FFh NETBIOS busy
Note:	Sytek PCnet card uses DMA 3.
SeeAlso: INT 5B

Format of Network Control Block:
Offset	Size	Description
 00h	BYTE	ncb_command (see below)
 01h	BYTE	ncb_retcode
 02h	BYTE	ncb_lsn
 03h	BYTE	ncb_num
 04h	DWORD	-> ncb_buffer
 08h	WORD	ncb_length
 0Ah 16 BYTEs	ncb_callname
 1Ah 16 BYTEs	ncb_name
 2Ah	BYTE	ncb_rto
 2Bh	BYTE	ncb_sto
 2Ch	DWORD	-> ncb_post  	/* int (far *ncb_post)(); */
 30h	BYTE	ncb_lana_num
		00h-03h IBM NetBIOS specs
		F0h-FFh Eicon NABios interface
 31h	BYTE	ncb_cmd_cplt
 32h 14 BYTEs	ncb_reserve

Values for "ncb_command" field in NCB (or with 80h for non-waiting call):
	10h start session with NCB_NAME name (call)
	11h listen for call
	12h end session with NCB_NAME name (hangup)
	14h send data via NCB_LSN
	15h receive data from a session
	16h receive data from any session
	17h send multiple data buffers
	20h send unACKed message (datagram)
	21h receive datagram
	22h send broadcast datagram
	23h receive broadcast datagram
	30h add name to name table
	31h delete name from name table
	32h reset adapter card and tables
	33h get adapter status (see structure "astatus" below)
	34h status of all sessions for name (see structure "sstatus" below)
	35h cancel
	36h add group name to name table
	70h unlink from IBM remote program (no F0h function)
	71h send data without ACK
	72h send multiple buffers without ACK
	78h find name
	79h token-ring protocol trace

Format of structure "name":
Offset	Size	Description
 00h 16 BYTEs nm_name
 10h	BYTE  nm_num
 11h	BYTE  nm_status

Format of structure "astatus":
Offset	Size	Description
 00h  6 BYTEs as_id
 06h	BYTE  as_jumpers
 07h	BYTE  as_post
 08h	BYTE  as_major
 09h	BYTE  as_minor
 0Ah	WORD  as_interval
 0Ch	WORD  as_crcerr
 0Eh	WORD  as_algerr
 10h	WORD  as_colerr
 12h	WORD  as_abterr
 14h	DWORD as_tcount
 18h	DWORD as_rcount
 1Ch	WORD  as_retran
 1Eh	WORD  as_xresrc
 20h  8 BYTEs as_res0
 28h	WORD  as_ncbfree
 2Ah	WORD  as_ncbmax
 2Ch	WORD  as_ncbx
 2Eh  4 BYTEs as_res1
 32h	WORD  as_sespend
 34h	WORD  as_msp
 36h	WORD  as_sesmax
 38h	WORD  as_bufsize
 3Ah	WORD  as_names
 3Ch 16 name structures  as_name

Format of structure "sstatus":
Offset	Size	Description
 00h	BYTE	number of sessions being reported
 01h	BYTE	number of sessions with this name
 02h	BYTE	number of outstanding receive datagrams
 03h	BYTE	number of outstanding ReceiveAnys
 04h	var	session structures (see below)

Format of structure "session":
Offset	Size	Description
 00h	BYTE	local session number
 01h	BYTE	state
		01h listen pending
		02h call pending
		03h session established
		04h hangup pending
		05h hangup done
		06h session aborted
 02h 16 BYTEs	local name
 12h 16 BYTEs	remote name
 22h	BYTE	number of outstanding receives
 23h	BYTE	number of outstanding sends/chainsends
---------------------------------------------
INT 5C - TOPS INTERFACE
	ES:BX -> Network Control Block
Note:	TOPS card uses DMA 1, 3 or none.
---------------------------------------------
INT 5C - $25 LAN - INSTALLATION CHECK
Notes:	current versions only check whether the vector is 0000h:0000h or not
	future versions are supposed to have the signature "NET" in the three
	  bytes preceding the INT 5C handler
---------------------------------------------
INT 5C - $25 LAN - CHECK IF CONNECTION ALIVE
	AH = 04h
	AL = COM port (0 = default)
	CX = wait count in character times (should be at least 100)
Return: ZF set if link alive
---------------------------------------------
INT 5D - IRQ13 relocated by DESQview 2.26+
SeeAlso: INT 75
---------------------------------------------
INT 5E - IRQ14 relocated by DESQview 2.26+
SeeAlso: INT 76
---------------------------------------------
INT 5F - IRQ15 relocated by DESQview 2.26+
SeeAlso: INT 77
---------------------------------------------
INT 60 - reserved for user interrupt
---------------------------------------------
INT 60 - Zero Bug Virus
   The "Zero Bug" virus hooks this vector.  Purpose unknown.
---------------------------------------------
INT 60 - Adaptec and OMTI controllers - DRIVE 0 DATA
---------------------------------------------
INT 60 - PC-IPC API
	STACK:	DWORD	pointer to parameter block (see below)
Return: STACK:	unchanged
Notes:	PC-IPC is a shareware TSR by Donnelly Software Engineering which allows
	  communication between independent programs
	INT 60 is the default, any interrupt vector may be used by specifying
	  the vector on the commandline

Format of parameter block:
Offset	Size	Description
 00h	WORD	caller's ID
 02h	WORD	to ID
 04h	WORD	command code (see below)
 06h	WORD	returned status
		bit 0: unused
		bit 1: IPC enabled
		bit 2: IPC installed
		bit 3: error
		bit 4: message(s) available
 08h	WORD	returned error code
 0Ah	WORD	size of data
 0Ch	DWORD	pointer to data buffer

Values of command code:
 01h "IPC_CMND_INQUIRE"  inquire current status
		set status field, writes WORD to data buffer containing free
		  message space in bytes, and sets the "size" field to the
		  number of messages waiting
 02h "IPC_CMND_ENABLE"	reenable PC-IPC
		ignored unless called with the same ID that disabled PC-IPC
 03h "IPC_CMND_DISABLE" disable PC-IPC
 04h "IPC_CMND_INSTALL" reset PC-IPC
 06h "IPC_CMND_RDATA"	read data
		returns first message in data buffer, sets "size" to message
		  length and "to ID" field to sender's ID
		if no messages available, bit 4 of status is cleared and "size"
		  is set to zero
 07h "IPC_CMND_SDATA"	send data
 08h "IPC_CMND_REQID"	require user ID
		create a new recognized ID and return in "caller's ID" field
 09h "IPC_CMND_DELID"	cancel user ID
		delete caller's ID from pool of recognized IDs
 0Ah "IPC_CMND_RDATAW"	read data, wait if no messages available
 0Bh "IPC_CMND_VERS"	get PC-IPC version 
		string representing version returned in data buffer, "size"
		  field set to length of string
---------------------------------------------
INT 60 - Tangram Arbiter - API
Notes:	Arbiter may use any interrupt from 60h to 66h (parameterized)
	identified by string "@ARB_API" immediately following a short jump at
	  the interrupt handler address
	Arbiter makes a PC disk look like a slow disk over an SNA link to an
	  IBM mainframe
---------------------------------------------
INT 60 - FTP Packet Driver - PC/TCP Packet Driver Specification
   The handler for the interrupt will start with a 3-byte jump instruction, 
   followed by the ASCIZ string "PKT DRVR".  To find the interrupt being used
   by the driver, an application should scan through interrupt vectors 60h to
   80h until it finds one with the "PKT DRVR" string.
---------------------------------------------
INT 60 - SYS_PROF.EXE - PROFILER STATUS
	AH = 00h
Return: AX = 0000h    profiling is off
	    otherwise profiling is on
Note:	SYS_PROF.EXE is the TSR portion of a profiler from Micro Cornucopia #47
SeeAlso: AH=01h"SYS_PROF",02h"SYS_PROF"
---------------------------------------------
INT 60 - FTP Packet Driver - BASIC FUNC - GET DRIVER INFO
	AX = 01FFh
	BX = handle returned by function 02h
Return: CF set on error
	    DH = error code (see below)
	CF clear if successful
	    BX = version
	    CH = network interface class (see below)
	    DX = interface type (see below)
	    CL = number
	    DS:SI -> name
	    AL = driver functions supported
		01h basic
		02h basic and extended
		05h basic and high-performance
		06h basic, high-performance, and extended
		FFh not installed
Note:	the handle in BX is optional for drivers written to v1.07 or later of
	  the packet driver specification

Values for error code:
	01h invalid handle number
	02h no interfaces of the specified class found
	03h no interfaces of the specified type found
	04h no interfaces of the specified number found
	05h bad packet type
	06h interface does not support multicast messages
	07h this packet driver cannot terminate
	08h invalid receiver mode
	09h insufficient space
	0Ah type accessed but never released
	0Bh bad command
	0Ch packet could not be sent
	0Dh hardware address could not be changed
	0Eh hardware address has a bad length or format
	0Fh could not reset interface

Values for Network Interface classes/types:
    Class 01h  Ethernet/IEEE 802.3	 
	01h 3COM 3C500/3C501
	02h 3COM 3C505
	03h MICOM-Interlan NI5010
	04h BICC Data Networks 4110
	05h BICC Data Networks 4117
	06h MICOM-Interlan NP600
	08h Ungermann-Bass PC-NIC
	09h Univation NC-516
	0Ah TRW PC-2000	
	0Bh MICOM-Interlan NI5210
	0Ch 3COM 3C503
	0Dh 3COM 3C523
	0Eh Western Digital WD8003
	0Fh Spider Systems S4
	10h Torus Frame Level
	11h 10Net Communications
	12h Gateway PC-bus
	13h Gateway AT-bus
	14h Gateway MCA-bus
	15h IMC PCnic
	16h IMC PCnic II
	17h IMC PCnic 8-bit
	18h Tigan Communications
	19h Micromatic Research
	1Ah Clarkson "Multiplexor"
	1Bh D-Link 8-bit
	1Ch D-Link 16-bit
	1Dh D-Link PS/2
	1Eh Research Machines 8
	1Fh Research Machines 16
	20h Research Machines MCA
	21h Radix Microsystems EXM1 16-bit
	22h Interlan Ni9210
	23h Interlan Ni6510
	24h Vestra LANMASTER 16-bit
	25h Vestra LANMASTER 8-bit
	26h Allied Telesis PC/XT/AT
	27h Allied Telesis NEC PC-98
	28h Allied Telesis Fujitsu FMR
	29h Ungermann-Bass NIC/PS2
	2Ah Tiara LANCard/E AT
	2Bh Tiara LANCard/E MC
	2Ch Tiara LANCard/E TP
	2Dh Spider Communications SpiderComm 8
	2Eh Spider Communications SpiderComm 16
	2Fh AT&T Starlan NAU
	30h AT&T Starlan-10 NAU
	31h AT&T Ethernet NAU
	32h Intel smart card
    Class 02h  ProNET-10
	01h Proteon p1300
	02h Proteon p1800
    Class 03h  IEEE 802.5/ProNet-4
	01h IBM Token-Ring Adapter
	02h Proteon p1340
	03h Proteon p1344
	04h Gateway PC-bus
	05h Gateway AT-bus
	06h Gateway MCA-bus
    Class 04h  Omninet
    Class 05h  Appletalk
    Class 06h  Serial Line
	01h Clarkson 8250-SLIP
	02h Clarkson "Multiplexor"
    Class 07h  StarLAN (subsumed by Ethernet class)
    Class 08h  ARCnet
	01h Datapoint RIM
    Class 09h  AX.25
    Class 0Ah  KISS
    Class 0Bh  IEEE 802.3 with 802.2 headers
	types same as for class 01h
    Class 0Ch  FDDI with 802.2 headers
    Class 0Dh  Internet X.25
	01h Western Digital
	02h Frontier Technology
    Class 0Eh  N.T. LANSTAR (encapsulating DIX Ethernet)
	01h NT LANSTAR/8
	02h NT LANSTAR/MC
Note: class and type numbers are cleared through FTP Software
---------------------------------------------
INT 60 - SYS_PROF.EXE - TURN PROFILING OFF
	AH = 01h
Note:	SYS_PROF.EXE is the TSR portion of a profiler from Micro Cornucopia #47
SeeAlso: AH=00h"SYS_PROF",02h"SYS_PROF"
---------------------------------------------
INT 60 - FTP Packet Driver - BASIC FUNC - ACCESS TYPE
	AH = 02h
	AL = interface class
	BX = interface type
	DL = interface number
	DS:SI -> type
	CX = length of type
	ES:DI -> receiver
Return: CF set on error
	    DH = error code (see AX=01FFh)
	CF clear if successful
	    AX = handle	    	
SeeAlso: AH=03h"FTP"

Receiver is called with
	AX = subfunction
	    00h application to return pointer to buffer in ES:DI
		returned ES:DI = 0000h:0000h means throw away packet
	    01h copy completed
		DS:SI -> buffer
	BX = handle
	CX = buffer length
when a packet is received
---------------------------------------------
INT 60 - SYS_PROF.EXE - TURN PROFILING ON
	AH = 02h
Note:	SYS_PROF.EXE is the TSR portion of a profiler from Micro Cornucopia #47
SeeAlso: AH=00h"SYS_PROF",01h"SYS_PROF"
---------------------------------------------
INT 60 - FTP Packet Driver - BASIC FUNC - RELEASE TYPE
	AH = 03h
	BX = handle
Return: CF set on error
	   DH = error code (see AX=01FFh)
	CF clear if successful	
SeeAlso: AH=02h"FTP"
---------------------------------------------
INT 60 - SYS_PROF.EXE - GET ADDRESS OF PROFILING TABLE
	AH = 03h
Return: ES:BX -> profiling table
Note:	SYS_PROF.EXE is the TSR portion of a profiler from Micro Cornucopia #47
SeeAlso: AH=04h"SYS_PROF"
---------------------------------------------
INT 60 - FTP Packet Driver - BASIC FUNC - SEND PACKET
	AH = 04h
	DS:SI -> buffer
	CX = length
Return: CF set on error
	    DH = error code (see AX=01FFh)
	CF clear if successful
Note:	the buffer may be modified immediately upon return from this call
SeeAlso: AH=0Bh
---------------------------------------------
INT 60 - SYS_PROF.EXE - CLEAR PROFILING TABLE
	AH = 04h
Note:	SYS_PROF.EXE is the TSR portion of a profiler from Micro Cornucopia #47
SeeAlso: AH=03h"SYS_PROF"
---------------------------------------------
INT 60 - FTP Packet Driver - BASIC FUNC - TERMINATE DRIVER FOR HANDLE
	AH = 05h
	BX = handle
Return: CF set on error
	   DH = error code (see AX=01FFh)
	CF clear if successful
---------------------------------------------
INT 60 - FTP Packet Driver - BASIC FUNC - GET ADDRESS
	AH = 06h
	BX = handle
	ES:DI -> buffer
	CX = length
Return: CF set on error
	    DH = error code (see AX=01FFh)
	CF clear if successful
	    CX = length	
Note:	copies the local net address associated with the handle into the buffer
---------------------------------------------
INT 60 - FTP Packet Driver - BASIC FUNC - RESET INTERFACE
	AH = 07h
	BX = handle
Return: CF set on error
	    DH = error code (see AX=01FFh)
	CF clear if successful
---------------------------------------------
INT 60 - FTP Packet Driver 1.09+ - HIGH-PERF FUNC - GET PARAMETERS
	AH = 0Ah
Return: CF set on error
	    DH = error code (0Bh) (see AX=01FFh)
	CF clear if successful
	    ES:DI -> parameter table (see below)

Format of parameter table:
Offset	Size	Description
 00h	BYTE	major revision of packet driver spec driver conforms to
 01h	BYTE	minor revision of packet driver spec
 02h	BYTE	length of this structure in bytes
 03h	BYTE	length of a MAC-layer address
 04h	WORD	maximum transfer unit, including MAC headers
 06h	WORD	buffer size for multicast addr
 08h	WORD	number of receive buffers (one less than back-to-back MTU rcvs)
 0Ah	WORD	number of transmit buffers
 0Ch	WORD	interrupt number to hook for post-EOI processing, 00h=none
---------------------------------------------
INT 60 - FTP Packet Driver 1.09+ - HIGH-PERF FUNC - ASYNCHRONOUS SEND PACKET
	AH = 0Bh
	DS:SI -> buffer
	CX = length of buffer
	ES:DI -> FAR function to call when buffer becomes available
Return: CF set on error
	    DH = error code (0Bh,0Ch) (see AX=01FFh)
	CF clear if successful
Note:	unlike function 04h, the buffer is not available for modification as
	  soon as the call returns; the buffer may be queued by the driver and
	  not processed until later
SeeAlso: AH=04h"Packet Driver"

Completion function called with:
	AX = result
	    00h copy OK
	    nonzero error
	ES:DI -> buffer passed to INT 60/AH=0Bh call
---------------------------------------------
INT 60 - Banyan VINES, 3com - GET STATION ADDRESS
	AH = 0Ch
Return: AL = status
	    00h successful
		ES:SI -> 6-byte station address
	    02h semaphore service is unavailable
---------------------------------------------
INT 60 - 10-NET, Banyan VINES - LOCK AND WAIT
	AH = 11h
	AL = drive number or 0
	DX = number of seconds to wait
	ES:SI = Ethernet address or 0
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status
	    00h successful
	    01h timeout
	    02h server not responding
	    03h invalid semaphore name
	    04h semaphore list is full
	    05h invalid drive ID
	    06h invalid Ethernet address
	    07h not logged in
	    08h write to network failed
	    09h semaphore already logged for this CPU
SeeAlso: AH=12h,13h
---------------------------------------------
INT 60 - 10-NET, Banyan VINES - LOCK
	AH = 12h
	AL = drive number or 00h
	ES:SI = Ethernet address or 0000h:0000h
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status (see also AH=11h)
	    01h semaphore currently locked by another PC
Note:	unlike function 11h, this function returns immediately
SeeAlso: AH=11h,13h
---------------------------------------------
INT 60 - 10-NET, Banyan VINES - UNLOCK
	AH = 13h
	AL = drive number or 00h
	ES:SI = Ethernet address or 0000h:0000h
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status (see also AH=11h)
	    1 semaphore not locked
SeeAlso: AH=11h,12h
---------------------------------------------
INT 60 - FTP Packet Driver - EXTENDED FUNC - SET RECEIVE MODE
	AH = 14h
	BX = handle
	CX = mode
	    01h turn off receiver
	    02h receive only packets sent to this interface
	    03h mode 2 plus broadcast packets
	    04h mode 3 plus limited multicast packets
	    05h mode 3 plus all multicast packets
	    06h all packets
Return: CF set on error
	   DH = error code (01h,08h) (see AX=01FFh)
	CF clear if successful
SeeAlso: AH=15h
---------------------------------------------
INT 60 - FTP Packet Driver - EXTENDED FUNC - GET RECEIVE MODE
	AH = 15h
	BX = handle
Return: CF set on error
	    DH = error code (01h) (see AX=01FFh)
	CF clear if successful
	    AX = mode	
SeeAlso: AH=14h
---------------------------------------------
INT 60 - FTP Packet Driver - EXTENDED FUNC - SET MULTICAST LIST
	AH = 16h
	ES:DI -> multicast list
	CX = length of list in bytes
Return: CF set on error
	    DH = error code (06h,09h,0Eh) (see AX=01FFh)
	CF clear if successful
SeeAlso: AX=17h
---------------------------------------------
INT 60 - FTP Packet Driver - EXTENDED FUNC - GET MULTICAST LIST
	AH = 17h
Return: CF set on error
	    DH = error code (06h,09h) (see AX=01FFh)
	CF clear if successful
	    ES:DI -> multicast addresses (do not modify)
	    CX = bytes of multicast addresses currently in use
SeeAlso: AH=16h
---------------------------------------------
INT 60 - FTP Packet Driver - EXTENDED FUNC - GET STATISTICS
	AH = 18h
	BX = handle
Return: CF set on error
	    DH = error code (01h) (see AX=01FFh)
	CF clear if successful
	    DS:SI -> statistics (see below)

Format of statistics:
Offset	Size	Description
 00h	DWORD	packets in
 04h	DWORD	packets out
 08h	DWORD	bytes in
 0Ch	DWORD	bytes out
 10h	DWORD	errors in
 14h	DWORD	errors out
 18h	DWORD	packets dropped	
---------------------------------------------
INT 60 - FTP Packet Driver - EXTENDED FUNC - SET NETWORK ADDRESS
	AH = 19h
	ES:DI -> address
	CX = length of address
Return: CF set on error
	    DH = error code (0Dh,0Eh) (see AX=01FFh)
	CF clear if successful
	    CX = length
---------------------------------------------
INT 61 - reserved for user interrupt
---------------------------------------------
INT 61 - Adaptec and OMTI controllers - DRIVE 0 DATA
---------------------------------------------
INT 61 - Banyan VINES - "Sosock" - OPEN COMMUNICATIONS SOCKET
	AX = 0001h
	DS:DX -> communications control block (function 0001h)
Return: AX = status
	    0000h  successful
	    0001h  service not installed
	    0002h  invalid service ID
	    0098h  resource already in use
	    009Eh  address family does not exist
	    009Fh  socket type does not exist
	    00A0h  protocol does not exist
	    00A1h  no more sockets available
	    00A2h  no more buffer space available
Note:	BANYAN can use any interrupt from 60h through 66h.  The Banyan
	  interrupt handler is identified by the string "BANV" in the four
	  bytes immediately preceding the interrupt handler

Format of control block:
Offset	Size	Description
 00h	WORD	0001h
 02h	WORD	pointer to argument block
 04h	WORD	error return code
 06h  4 BYTEs	reserved

Format of argument block:
Offset	Size	Description
 00h	WORD	pointer to 2-byte buffer for socket identifier
 02h	WORD	address family
		0003h Banyan
 04h	WORD	socket type
		in address family 0003h
		    0001h IPC socket
		    0002h SPP socket
 06h	WORD	protocol number
		FFFFh default
 08h	WORD	pointer to 16-byte buffer for socket address
 0Ah	WORD	local port number
		0000h if service should assign transient port number
		0001h to 01FFh well-known port number (assigned by Banyan)

Format of IPC port:
Offset	Size	Description
 00h	WORD	address family (always 0003h for Banyan ports)
 04h  4 BYTEs	network number (server's serial number)
 06h	WORD	subnet number  (0001h = server, 8000h-FFFEh = PC)
 08h	WORD	port ID (0001h-01FFh for "well-known" ports)
 0Ah	BYTE	hop count
 0Bh  5 BYTEs	filler
---------------------------------------------
INT 61 - Banyan VINES - "Sosend" - INITIATE OUTPUT EVENT
	AX = 0001h
	DS:DX -> communications control block (function 0002h)
Return: AX = status
	    0000h  successful
	    0001h  service not installed
	    0002h  invalid service ID
	    0003h-000Ah reserved for BANV interface errors
	    0097h  invalid socket identifier
	    009Bh  destination node unreachable
	    009Ch  message overflow
	    009Dh  destination socket nonexistent
	    00A2h  no more buffer space
	    00A3h  timeout
	    00B1h  resource disconnect
Note:	BANYAN can use any interrupt from 60h through 66h.  The Banyan
	  interrupt handler is identified by the string "BANV" in the four
	  bytes immediately preceding the interrupt handler

Format of control block:
Offset	Size	Description
 00h	WORD	0002h
 02h	WORD	pointer to argument block (see below)
 04h	WORD	error return code
		0000h successful
		0097h invalid socket ID
		00A2h no more buffer space
		00A3h timeout event
		00A5h resource not available
		00A6h internal communication failure
		00B1h resource disconnect
 06h  4 BYTEs	reserved

Format of argument block:
Offset	Size	Description
 00h	WORD	routine metric
 02h	WORD	error return code
 04h	WORD	socket identifier
 06h	WORD	pointer to send buffer
 08h	WORD	length of send buffer
 0Ah	WORD	flags
		bit 0: async request
		    1: reliable message
		    3: end of user message received
		    4: vectored request (if set, send buffer contains buffer
			descriptors)
		    5: connection-specific receive
		    6: change to connection-specific receive mode
 0Ch 16 BYTEs	socket address (see below)
 1Ch	WORD	timeout value in multiples of 200ms
 1Eh	WORD	connection identifier
 20h	WORD	type of request
		0001h send message
		0002h establish a virtual connection
		0003h terminate a virtual connection

Format of buffer descriptor:
Offset	Size	Description
 00h	WORD	data segment
 02h	WORD	buffer pointer
 04h	WORD	buffer length
 06h	WORD	character count

Format of socket address for unreliable datagrams:
Offset	Size	Description
 00h	WORD	0003h	  address family
 02h	DWORD	FFFFFFFFh network number
 06h	WORD	FFFFh	  subnet number
 08h	WORD		  local port number
 0Ah	BYTE	00h-0Fh	  hop count
 0Bh  5 BYTEs	0000h	  filler
---------------------------------------------
INT 61 - Banyan VINES - "Sorec" - RECEIVE INPUT EVENT NOTIFICATION
	AX = 0001h
	DS:DX -> communications control block (function 0003h)
Return: AX = status
	    0000h  successful
	    0001h  service not installed
	    0002h  invalid service ID
	    0003h-000Ah reserved for BANV interface errors
	    0097h  invalid socket identifier
	    00A2h  no more buffer space
	    00A3h  timeout
Note:	BANYAN can use any interrupt from 60h through 66h.  The Banyan
	  interrupt handler is identified by the string "BANV" in the four
	  bytes immediately preceding the interrupt handler

Format of control block:
Offset	Size	Description
 00h	WORD	0003h
 02h	WORD	pointer to argument block (see below)
 04h	WORD	error return code
		0000h successful
		0097h invalid socket ID
		00A2h no more buffer space
		00A3h timeout event
		00A5h resource not available
		00A6h internal communication failure
		00B1h resource disconnect
 06h  4 BYTEs	reserved

Format of argument block:
Offset	Size	Description
 00h	WORD	character count
 02h	WORD	error return code
 04h	WORD	socket identifier
 06h	WORD	pointer to receive buffer
 08h	WORD	length of receive buffer
 0Ah	WORD	flags
		bit 0: async request
		    2: flush receive buffer on overflow
		    3: end of user message received
		    4: vectored request (if set, receive buffer contains buffer
			descriptors)
		    5: connection-specific receive
		    6: change to connection-specific receive mode
 0Ch 16 BYTEs	socket address
 1Ch	WORD	timeout value in multiples of 200ms
 1Eh	WORD	connection identifier
 20h	WORD	type of response
		0001h message received
		0002h virtual connection established
		0003h virtual connection terminated

Format of buffer descriptor:
Offset	Size	Description
 00h	WORD	data segment
 02h	WORD	buffer pointer
 04h	WORD	buffer length
 06h	WORD	character count
---------------------------------------------
INT 61 - Banyan VINES - "Soclose" - CLOSE A SOCKET
	AX = 0001h
	DS:DX -> communications control block (function 0004h)
Return: AX = status
	    0000h  successful
	    0001h  service not installed
	    0002h  invalid service ID
	    0003h-000Ah reserved for BANV interface errors
	    0097h  invalid socket identifier
Note:	BANYAN can use any interrupt from 60h through 66h.  The Banyan
	  interrupt handler is identified by the string "BANV" in the four
	  bytes immediately preceding the interrupt handler

Format of control block:
Offset	Size	Description
 00h	WORD	0004h
 02h	WORD	pointer to argument block (see below)
 04h	WORD	error return code
 06h  4 BYTEs	reserved

Format of argument block:
Offset	Size	Description
 00h	WORD	socket identifier
---------------------------------------------
INT 61 - Banyan VINES - "Sowait" - WAIT FOR ASYNCHRONOUS EVENT COMPLETION
	AX = 0001h
	DS:DX -> communications control block (function 0005h)
Return: AX = status
	    0000h  successful
	    0001h  service not installed
	    0002h  invalid service ID
	    0003h-000Ah reserved for BANV interface errors
	    00A2h  no more buffer space available
	    00A3h  timeout event
Notes:	BANYAN can use any interrupt from 60h through 66h.  The Banyan
	  interrupt handler is identified by the string "BANV" in the four
	  bytes immediately preceding the interrupt handler
	returns results for all asynchronous operations invoked from the
	  data segment used for this call

Format of control block:
Offset	Size	Description
 00h	WORD	0005h
 02h	WORD	pointer to argument block (see below)
 04h	WORD	error return code
 06h  4 BYTEs	reserved

Format of argument block:
Offset	Size	Description
 00h	WORD	pointer to WORD event pointer
 02h	WORD	timeout in multiples of 200ms, FFFFh = infinite
---------------------------------------------
INT 61 - Banyan VINES - "Sosession" - REGISTER APPLICATION WITH COMM SERVICE
	AX = 0001h
	DS:DX -> communications control block (function 0008h)
Return: AX = status
	    0000h  successful
	    00A2h  no more buffer space available
Note:	BANYAN can use any interrupt from 60h through 66h (default 61h).  The
	  Banyan interrupt handler is identified by the string "BANV" in the
	  four bytes immediately preceding the interrupt handler

Format of control block:
Offset	Size	Description
 00h	WORD	0008h
 02h	WORD	process type
		0001h transient process
		0002h resident process
 04h	WORD	error return code
 06h  4 BYTEs	reserved
---------------------------------------------
INT 61 - Banyan VINES - "Soint" - SET USER COMPLETION FUNCTION
	AX = 0001h
	DS:DX -> communications control block (function 000Bh)
Return: AX = status
	    0000h  successful
	    0001h  service not installed
	    0002h  invalid service ID
	    0003h-000Ah reserved for BANV interface errors
	    00A2h  no more buffer space available
Notes:	BANYAN can use any interrupt from 60h through 66h.  The Banyan
	  interrupt handler is identified by the string "BANV" in the four
	  bytes immediately preceding the interrupt handler
	FAR user function is invoked with SS,DS, and ES set to segment of
	  control block, and with the stack containing
		DWORD	return address
		WORD	argument pointer (sosend or sorec argument block)
		WORD	error return code
			0000h argument pointer is valid
			00A3h timeout

Format of control block:
Offset	Size	Description
 00h	WORD	000Bh
 02h	WORD	pointer to argument block (see below)
 04h	WORD	error return code
 06h  2 BYTEs	reserved
 08h	WORD	user CS register

Format of argument block:
Offset	Size	Description
 00h	WORD	pointer to user interrupt function	
 02h	WORD	pointer to user stack
 04h	WORD	initial timeout value in multiples of 200ms, FFFFh = infinite
---------------------------------------------
INT 61 - Banyan VINES - 3270 INTERFACE
	AX = 0002h
	BH = function
	    00h "pi2reset"  reset 3270/SNA or 3270/BSC driver
	    02h "pi2bsc" (3270/BSC only)
	    03h	"pi2get"    get information stored in 3270 resident driver
	    04h "pi2put"    store information in 3270 resident driver
	    05h "pi2gcur"   get current screen position
	    07h "pi2sdat"   send data keystroke
	    08h "pi2scom"   send command keystroke
	    0Ah "pi2field"  get field info for arbitrary screen positions
	    0Fh "pi2stat"   get logical unit/device status
	    12h "pi2nlus"   determine logical unit/device assignment
	    13h "pi2gate"   specifies comm port address to gateway service
	    14h "pi2attach" attach a logical unit/device
	    15h "pi2sdev"   save logical unit/device info in resident driver
			    (not supported in >3.0)
	    16h "pi2gdev"   get device information (not supported in >3.0)
	    17h "pi2luinfo" get info about specific logical unit/device
	    18h "pi2gerr"   get finer error detail
	    19h "pi2dhold"  (3270/SNA only)  holds a 3270 device
	    1Ah "pi2shut"   release memory-resident module
	    1Ch "pi2sprof"  save profile info in res driver (not supp in >3.0)
	    1Dh "pi2gprof"  get prevsly stored profile info (not supp in >3.0)
	DS:CX -> argument block (except BH=00h,1Ah)
Return: AX = status
	    0000h successful
	    000Bh invalid parameter or data does not fit data area
	    000Ch another code path currently active in resident driver
	    000Dh operation currently not allowed
	    0032h encountered connection disconnect error
	    0033h encountered "sosend" completion error
	    0034h encountered "sosend" communication error
	    0035h attach request refused.  extended error info via "pi2gerr":
			01h resource unavailable
			02h invalid type
			03h version mismatch
			04h invalid logical unit number
			05h error during ARL processing
			06h no access for user
	    0071h encountered "sosock" error
	    0072h encountered unrecognizable error
	    0073h encountered "sowait" error (extended info via "pi2gerr")
	    0074h encountered invalid type-of-request on "sowait"
	    0075h encountered "sorec" error (extended info via "pi2gerr")
	    0076h encountered "sorec" completion error (ext info via "pi2gerr")
	    0077h encountered connection request
	    0078h encountered unrecognizable data
	    0079h encountered unknown connection ID (ext info via "pi2gerr")
Notes:	Either 3270/SNA or 3270/BSC interface may use AX=0002h, depending on
	  which is loaded first.  The other interface will use AX=000Ah
	Status codes greater than 63h indicate an inconsistency in the 3270/SNA
	  or 3270/BSC resident driver, which must be reloaded by the user

Format of argument block for BH=03h,04h:
Offset	Size	Description
 00h	WORD	size of data area (max 256)
 02h  N BYTEs	data area

Format of argument block for BH=05h:
Offset	Size	Description
 00h	WORD	logical unit/device number
 02h	WORD	pointer to WORD buffer for cursor index
 04h	WORD	pointer to BYTE buffer for current field attribute

Format of argument block for BH=07h:
Offset	Size	Description
 00h	WORD	logical unit/device number
 02h	WORD	ASCII data byte
 04h	WORD	pointer to WORD count of characters which will need updating

Format of argument block for BH=08h:
Offset	Size	Description
 00h	WORD	logical unit/device number
 02h	WORD	keystroke
		0000h Enter
		0001h Clear
		0002h PA1
		0003h PA2
		0004h PA3
		0005h PF1
		...
		001Ch PF24
		001Dh CSELECT (cursor select)
		001Eh Insert
		001Fh Delete
		0020h EOField
		0021h EINPUT (erase input)
		0022h Reset
		0023h Attention
		0024h SysReq
		0025h Duplicate
		0026h Fieldmark
		0027h Home
		0028h NextLine
		0029h Tab
		002Ah BackTab
		002Bh cursor up
		002Ch cursor down
		002Dh cursor right
		002Eh cursor left
		002Fh double cursor right
		0030h double cursor left
		0031h PRINT
		0032h CANCEL
		0033h Backspace

Format of argument block for BH=0Ah:
Offset	Size	Description
 00h	WORD	logical unit/device number
 02h	WORD	screen index
 04h	WORD	pointer to WORD buffer for field length
 06h	WORD	pointer to WORD buffer for offset in screen of field start

Format of argument block for BH=0Fh:
Offset	Size	Description
 00h	WORD	logical unit/device number
 02h	WORD	clear mask (clear these bits of status after returning status)
 04h	WORD	pointer to WORD buffer for status
		bit 10: status modified
		bit  9: buffer modified
		bit  8: set cursor
		bit  5: sound alarm
		bits 0,1: size of print line for printer logical units
			00 unformatted line
			01 40-character line
			10 64-character line
			11 80-character line

Format of argument block for BH=12h:
Offset	Size	Description
 00h	WORD	pointer to WORD buffer for number of logical units or devices
 02h	WORD	pointer to WORD buffer for version number
 04h	WORD	pointer to 64-byte buffer for logical unit/device list

Format of argument block for BH=13h:
Offset	Size	Description
 00h 16 BYTEs	communications port address (see AX=0001h#"Sosock")

Format of argument block for BH=14h:
Offset	Size	Description
 00h	WORD	logical unit/device number 
		0000h attach any free device of the specified type
 02h	WORD	logical unit/device type
		(3270/SNA) 01h, 02h, or 03h
		(3270/BSC) 02h display
		(3270/BSC) 03h printer
 04h	WORD	pointer to WORD buffer for attached logical unit/device number

Format of argument block for BH=16h:
Offset	Size	Description
 00h	WORD	pointer to 18-byte buffer for device block (see below)
		first WORD must be set to desired logical unit/device number

Format of argument block for BH=17h:
Offset	Size	Description
 00h	WORD	logical unit/device number
 02h	WORD	pointer to information block in caller's DS (see below)

Format of argument block for BH=18h:
Offset	Size	Description
 00h	WORD	pointer to WORD buffer for major error code
 02h	WORD	pointer to WORD buffer for minor error code

Format of argument block for BH=19h:
Offset	Size	Description
 00h	WORD	logical unit/device number

Format of argument block for BH=1Ch,1Dh:
Offset	Size	Description
 00h	WORD	pointer to profile block in caller's DS (see below)

Format of device block, argument block for BH=15h:
Offset	Size	Description
 00h	WORD	logical unit/device number
 02h	WORD	logical unit/device type
 04h	WORD	display model number
 06h	WORD	numeric checking
 08h	WORD	status line
 0Ah	BYTE	unprotected normal field attribute
 0Bh	BYTE	unprotected intensified field attribute
 0Ch	BYTE	protected normal field attribute
 0Dh	BYTE	protected intensified field attribute
 0Eh	WORD	reserved
 10h	WORD	printer port number

Format of information block:
Offset	Size	Description
 00h	WORD	device model number
 02h	DWORD	screen buffer pointer
 06h	DWORD	status line pointer (see below)
 0Ah	DWORD	reserved

Format of status line:
Offset	Size	Description
 00h	BYTE	comm line status
		00h inactive
		01h active
 01h	BYTE	activation level
		01h physical unit activated
		02h logical unit also activated
		03h session is bound
 02h	BYTE	data traffic state
		00h inactive
		01h active
 03h	BYTE	screen ownership
		00h SLU->PLU sessoin owns screen
		01h SLU->SSCP session owns screen
 04h	BYTE	keyboard status
		00h UNLOCK - ready to accept data
		01h TIME - aid was struck
		02h SYSTEM - received response no restore
		03h FUNCTION - unavailable keyboard function
		04h INPUT - not currently used
		05h ENDFIELD - field filled in insert mode
		06h PROTECTED - attempt to enter in protected field
		07h NUMERIC - attempt to enter in numeric field
		08h PROGRAM - error in outbound data stream
 05h	BYTE	insert mode
		01h if in insert mode
 06h	BYTE	numeric
		01h if current screen buffer is numeric only
 07h	BYTE	printer status
		00h printer not assigned
		01h printer is inactive
		02h printer error
		03h currently printing
		04h printer is busy
		05h printer is very busy
 08h	BYTE	printer assignment
 09h	BYTE	maximum size of network name
 0Ah  N BYTEs	ASCIZ network name
	BYTE	maximum size of message window
      M BYTEs	null-terminated message window
	BYTE	code set
		00h EBCDIC
		01h ASCII
      M BYTEs	extended attributes
		01h extended attributes are in effect (stored at screen+1920)
			each extended attribute specifies
			bits 0,1: 00=normal, 01=blink, 10=reverse, 11=underscor
			bits 2-4: 000=default,001=blue,010=red,011=pink,
				  100=green,101=turquoise,110=yellow,111=white
	BYTE	extended color
		01h other than base color is in effect

Format of profile block:
Offset	Size	Description
 00h 64 BYTEs	gateway service name
 40h 16 BYTEs	gateway comm port address
 50h	WORD	primary logical unit number
 52h	WORD	secondary logical unit type
 54h	WORD	secondary logical unit number
 56h	WORD	printer assignment
 58h 50 BYTEs	keyboard definitions filename
---------------------------------------------
INT 61 - Banyan VINES - ASYNCHRONOUS TERMINAL EMULATION
	AX = 0003h
	DS:BX -> argument block with function number (see below)
Return: AX = status
	    0000h successful
	    000Bh invalid session ID
	    000Ch session not active
	    000Dh invalid request type
	    000Eh invalid parameters
	    000Fh out of heap space
	    0010h timeout on send
	    0011h Banyan communications error
	    0012h session not waiting for host
	    0013h session is active
	    0014h duplicate suspend session request
	    0015h no session suspended
	    0016h ring data buffer full
	    0017h printer error encountered
	    0018h Banyan communications error
	    0019h unable to make connection
	    001Ah no ring buffer specified at startup
	    001Bh service is down
	    001Ch invalid service name
	    001Dh service is closed
	    001Eh invalid connection name
	    001Fh max session limit reached for service
	    0020h access rights list for connection/dialout does not include
			this user
	    0021h service not responding
	    0022h missing telephone number

Format of argument block:
Offset	Size	Description
 00h	BYTE	session ID (00h)
 01h	BYTE	asynchronous interface request number
		00h initialize user buffer pointer information area
		01h send to host
		02h "control monitor"
		03h "flow control data": freeze/unfreeze display, ring buffer
		04h end active session
		05h set session parameter
		06h get session parameter
		07h set tab settings
		08h get tab settings
		09h refresh emulation screen
		0Ah suspend session temporarily
		0Bh restore previously suspended session
		0Ch set state of scroll lock checking
		0Dh exit emulation
		0Eh interrupt on character from host
		0Fh start a session
		10h start/stop printing of data received from host
		11h get file transfer parameters
		12h get connection information
		13h start/stop tracing data traffic in session
		14h interrupt on message from host
		15h reset error
---request=00h---
 02h	WORD	pointer to info area in caller's current DS
		Offset	Size	Description
		 00h	WORD	flags
				0000h don't read interface's data buffer
				0001h read data buffer
		 02h	DWORD	pointer to ring buffer
		 06h	WORD	length of ring buffer
		 08h	WORD	ring buffer offset to last byte read by caller
		 0Ah	DWORD	pointer to WORD containing offset of last byte
				  in ring buffer filled
		 0Eh	DWORD	pointer to screen buffer
		 12h	DWORD	pointer to field containing cursor position
		 16h	DWORD	pointer to terminal status area (see below)
---request=01h---
 02h	BYTE	type
		00h ASCII byte
		01h ASCII string
		02h terminal function code
		03h up arrow
		04h down arrow
		05h left arrow
		06h right arrow
		07h break
 03h  N BYTEs	type-specific info
		Offset	Size	Description
		---ASCII byte---
		 03h	BYTE	byte to send to host
		---ASCII string---
		 03h	WORD	length of string
		 05h	WORD	pointer to string
		---terminal function code (VT52/VT100)---
		 03h	BYTE	function code
				00h keypad 0
				01h keypad 1
				...
				09h keypad 9
				0Ah keypad -
				0Bh keypad ,
				0Ch keypad .
				0Dh keypad ENTER
				0Eh PF1
				0Fh PF2
				10h PF3
				11h PF4
		---terminal function code (IBM3101)---
		 03h	BYTE	function code
				00h PF1
				...
				07h PF8
				08h Home
---request=02h---
 02h	BYTE	display flag
		00h don't display data received from host
		01h display data
---request=03h---
 02h	BYTE	flow control flag
		00h allow characters to be put into display or ring buffer
		01h don't place any more characters into display or ring buffer
---request=05h,06h---
 02h	BYTE	parameter number
		00h line speed (00h=any, 01h=50, 02h=110, 03h=134.5, 04h=150,
			05h=300,06h=600,07h=1200,08h=2400,09h=4800, 0Ah=9600)
		01h parity (00h=none, 01h=odd, 02h=even)
		02h duplex (00h=full, 01h=half)
		03h character size (00h=7 bits, 01h=8 bits)
		04h stop bits (00h=1, 01h=2)
		05h XON/XOFF flow control (00h=no, 01h=yes)
		07h intercharacter delay in tenths of a second
		08h interline delay in tenths of a second
		09h auto linefeed (00h=no, 01h=yes)
		0Ah filter control characters (00h=no, 01h=yes)
		0Bh terminal type (00h=VT100,01h=glassTTY,02h=VT52,03h=IBM3101)
		0Ch auto wrap (00h=no, 01h=yes)
		0Dh cursor shape (00h=underscore, 01h=block)
		0Eh character set (00h=UK, 01h=US ASCII)
		0Fh printer port (00h=LPT1, 01h=LPT2, 02h=LPT3)
 03h	BYTE	parameter value (returned for 06h)
---request=07h,08h---
 02h	WORD	pointer to 80-byte buffer in caller's current DS
		  each byte = 00h if no tab, 01h if tab at that position
---request=0Ah---
 02h	WORD	size of session information to be saved
 04h	WORD	pointer to buffer in caller's DS
---request=0Bh---
 02h	WORD	size of buffer into which session info is restored
 04h	WORD	pointer to buffer in caller's DS
---request=0Ch---
 02h	BYTE	check_scroll_lock flag
		00h off
		01h on (display of host data stopped while ScrollLock on)
---request=0Eh,14h---
 02h	DWORD	pointer to routine to be called (0000h:0000h = don't call)
 06h	DWORD	stack pointer to use when call is made
---request=0Fh---
 02h	WORD	pointer to information area in caller's current DS
		Offset	Size	Description
		 00h	WORD	length of service name
		 02h	WORD	pointer to service name in caller's DS
		 04h	BYTE	type of connection
				(00h=connection name, 01h=dialout)
		 05h	WORD	length of connection name/telephone number
		 07h	WORD	pointer to connection name/telephone number
---request=10h---
 02h	WORD	print capture flag (00h=off, 01h=on)
---request=11h---
 02h	WORD	pointer to info area in caller's current DS
		Offset	Size	Description
		 00h	BYTE	protocol flag (00h none, 01h Kermit)
		 01h	BYTE	direction flag (00h send, 01h receive)
		 02h	BYTE	length of null-terminated PC filename
		 03h	DWORD	pointer to null-terminated PC filename
		 07h	BYTE	length of null-terminated host filename
		 08h	DWORD	pointer to null-terminated host filename
---request=12h---
 02h	WORD	pointer to info area in caller's current DS (see below)
		Offset	Size	Description
		 00h	WORD	length of service name (returned)
		 02h	WORD	pointer to 64-byte buffer for service name
		 04h	BYTE	type of connection
				00h connection name
				01h dialout
		 05h	WORD	length of connection name/telephone number
		 07h	WORD	pointer to 64-byte buffer for name/telno
		 09h	BYTE	server line number being used (returned)
---request=13h---
 02h	BYTE	trace flag (00h=off, 01h=on)

Format of terminal status area:
Offset	Size	Description
 00h	BYTE	status of session: 4Eh=oNline, 46h=oFfline, 57h=Waiting
 01h	BYTE	terminal type (00h=VT100, 01h=TTY, 02h=VT52, 03h=IBM3101)
 02h	BYTE	current keypad mode (VT100,VT52 only)
		4Eh ("N") numeric mode
		41h ("A") application mode
 03h  4 BYTEs	current state of LEDs (VT100 only)
		00h off
		01h on
 07h	WORD	line error count
 09h	WORD	primary error code
		0000h no error
		0001h unable to make connection
		0002h communications error, restart session
		0003h async terminal emulation service unavailable
		0004h lost carrier
		0005h all matching lines busy
		0006h no lines defined for connection name
		0007h no dial lines available on server
		0008h no matching dial lines available
		0009h out of heap space
		000Ah service error encountered
		000Bh timed out waiting to connect
		000Ch communications error
		000Dh communications error
		000Eh host want file transferred to/from PC
		000Fh host software changed session parameter
		0010h host software changed tap settings
		0011h host software changed LED indicator
		0012h host software changed display background (secondary error
			code 00h for white on black, 01h for black on white)
		0013h host software changed display option (secondary error
			code 00h for off, 01h for on)
		0014h communications error
		0015h communications error
		0016h unable to make connection
		0017h unable to make connection
 0Bh	WORD	secondary error code
---------------------------------------------
INT 61 - Banyan VINES - GET SERVER SERIAL NUMBER
	AX = 0004h
	DS:DX -> request block (function 0008h)
Return: AX = status
	    0000h server ID returned in request block
	    000Fh invalid drive
	    0015h drive not ready

Format of request block:
Offset	Size	Description
 00h	WORD	0008h
 02h	WORD	drive number (0=default, 1=A, ...)
 04h  6 BYTEs	buffer for server ID
---------------------------------------------
INT 61 - Banyan VINES - PRINTER CONTROL
	AX = 0005h
	DS:DX -> request block
Return: AX = status
	    0000h successful
	    0001h network software not installed or incompatible

Format of request block:
Offset	Size	Description
 00h	WORD	function
		0201h "endspool" all data for a print job has been sent
		0205h "getactive" get currently active printer port
 02h	WORD	number of active port (1-3)
 04h	WORD	??? (0 for func 0201h, 3 for func 0205h)
 06h	WORD	0000h
---------------------------------------------
INT 61 - Banyan VINES - GET PORTS FOR A SERVICE
	AX = 0007h
	BX = 0002h
	DS:DX -> StreetTalk service name
	DS:DI -> port record block (see below)
Return: AX = status
	    0000h successful
	    0001h PC network software not installed or incompatible
	    03E9h incorrect name syntax
	    03EAh organization name too long
	    03EBh group name too long
	    03ECh item name too long
	    03EDh StreetTalk name too long
	    03F3h organization not found
	    03F4h group not found
	    03F5h StreetTalk name not found
	    03F8h not a StreetTalk name
	    040Dh appropriate StreetTalk name unavailable

Format of port record block:
Offset	Size	Description
 00h	WORD	number of 17-byte elements
 02h 17 BYTEs	element (byte 00h = input port type, bytes 01h-10h = port)
		(see AX=0001h#"Sosock" for port format)
---------------------------------------------
INT 61 - Banyan VINES - VERIFY EXISTENCE OF NAME AND RETURN CANONICAL FORM
	AX = 0007h
	BX = 0004h
	DS:DX -> StreetTalk name of service
	DS:DI -> port record block (see below)
Return: AX = status
	    0000h successful
	    0001h PC network software not installed or incompatible
	    03E9h incorrect name syntax
	    03EAh organization name too long
	    03EBh group name too long
	    03ECh item name too long
	    03EDh StreetTalk name too long
	    03F3h organization not found
	    03F4h group not found
	    03F5h StreetTalk name not found
	    03F8h not a StreetTalk name
	    0409h modify access denied
	    040Dh appropriate StreetTalk name unavailable

Format of port record block:
Offset	Size	Description
 00h	WORD	number of 17-byte elements
 02h 17 BYTEs	element: byte 00h = input port type, 01h-10h = port
		(see AX=0001h#"Sosock" for port format)
---------------------------------------------
INT 61 - Banyan VINES - GET USER NAME
	AX = 0007h
	BX = 0005h
	DS:DX -> 64-byte buffer for user's StreetTalk name
Return: AX = status
	    0000h successful
	    0001h network software not installed or incompatible
Note:	if no user logged in, first byte of returned name will be 00h
---------------------------------------------
INT 61 - Banyan VINES - TRANSLATE ERROR INTO ASCII STRING
	AX = 0007h
	BX = 0006h
	SI = error code (>100)
	DS:DX -> 80-byte buffer for error text
Return: AX = status
	    0000h successful
	    0001h network software not installed or incompatible	    
---------------------------------------------
INT 61 - Banyan VINES - VERIFY EXISTENCE OF NAME AND RETURN CANONICAL FORM
	AX = 0007h
	BX = 0007h
	DS:DX -> NiceName block (see below)
Return: AX = status
	    0000h successful
	    0001h PC network software not installed or incompatible
	    03E9h incorrect name syntax
	    03EAh organization name too long
	    03EBh group name too long
	    03ECh item name too long
	    03EDh StreetTalk name too long
	    03F3h organization not found
	    03F4h group not found
	    03F5h StreetTalk name not found
	    03F8h not a StreetTalk name
	    040Dh appropriate StreetTalk name unavailable
SeeAlso: AX=0007h/BX=0008h

Format of NiceName block:
Offset	Size	Description
 00h	WORD	type of name
		0064h organization
		00C8h group
		012Ch item
 02h	WORD	pointer to ASCIZ input name
 04h	WORD	pointer to 64-byte buffer for output name
---------------------------------------------
INT 61 - Banyan VINES - ENUMERATE StreetTalk NAMES
	AX = 0007h
	BX = 0008h
	DS:DX -> enumerate block (see below)
Return: AX = status
	    0000h successful
	    0411h all matching names have been returned
	    0412h some groups unavailable, all available matches returned
Note:	each program using this call should continue until a nonzero status
	  is returned; otherwise, some resources will not be freed for several
	  hours
SeeAlso: AX=0007h/BX=0007h

Format of enumerate block:
Offset	Size	Description
 00h	WORD	return code
 02h	WORD	pointer to pattern string
 04h	WORD	enumerate type
		0064h organization
		00C8h group
		012Ch item
 06h	WORD	enumerate class
		0000h unspecified (return all matching items)
		0001h user names
		0002h service names
		0003h list names
		0004h nicknames
 08h	WORD	pointer to category criteria block (see below) or 0
 0Ah	WORD	pointer to array of 64-byte returned names
 0Ch	WORD	number of names returned
 0Eh  6 BYTEs	reserved for subsequent enumerated calls (set to zeros on first
		  call)

Format of category criteria block:
Offset	Size	Description
 00h	WORD	exclude flag
		0000h return only items with the specified categories
		0001h return all items except those with the given categories
 02h	WORD	number of categories
 04h	WORD	category 1 value
 06h	WORD	category 2 value
		...

Values for common service categories:
 0002h file service
 0003h print service
 0004h mail service
 0005h StreetTalk
 0006h time service
 0008h semaphore service
 0009h 3270/SNA service
 000Ah asynchronous terminal emulation service
 000Ch NETBIOS service
 000Dh PC-based service
---------------------------------------------
INT 61 - Banyan VINES - POST MESSAGE ON LOCAL DISPLAY
	AX = 0008h
	BX = 0002h
	CX = flags
	    bit 0: message will remain on screen until user presses ^X
	    bit 1: ring bell after displaying message
	    bit 2: blink
	DS:DX -> ASCIZ string to display (only first 80 chars used)
Return: AX = status
	    0000h successful
	    000Bh message display function currently busy
	    000Ch message queue full
Note:	queues up to three messages to be displayed on the bottom line
---------------------------------------------
INT 61 - Banyan VINES - INTERCEPT VINES 25th-LINE MESSAGES AT LOCAL PC
	AX = 0008h
	BX = 0003h
	DS:DX -> request block
Return: AX = status
	    0000h successful
	    0001h network software not installed or incompatible
Notes:	message handler should not call BIOS or DOS functions, and should
	  either call next handler or simply return
	to stop intercepting messages, set prev and next request blocks to
	  point at each other

Format of request block:
Offset	Size	Description
 00h	DWORD	pointer to user-written message handler
 04h	DWORD	pointer to next request block (filled in by VINES)
 08h	DWORD	pointer to previous request block (filled in by VINES)
 0Ch	DWORD	pointer to message storage area (filled by VINES) (see below)

Format of message storage area:
Offset	Size	Description
 00h 16 BYTEs	IPC port of message sender (see AX=0001h#"Sosock")
 10h	BYTE	message flags
 11h	WORD	reserved
 13h	BYTE	length of message
 14h 80 BYTEs	message text
---------------------------------------------
INT 61 - Banyan VINES - SECONDARY 3270 INTERFACE
	AX = 000Ah
Notes:	either 3270/SNA or 3270/BSC interface will use AX=000Ah, depending on
	  which is loaded second.  The first interface loaded will use AX=0002h
SeeAlso: INT 61/AX=0002h
---------------------------------------------
INT 61 - Banyan VINES - CHECK SERVICE
	AH = 01h
	AL = service ID
	    01h communications
	    02h primary 3270 emulation
	    03h async terminal emulation
	    04h file deflectoin
	    07h StreetTalk
	    08h environment
	    0Ah secondary 3270 emulation
	    0Bh semaphore service
	    0Ch 3270 emulation active status
	    0Dh 3270 keyboard interrupt simulator
Return: AX = status
	    0000h installed
	    0001h not installed
	    0002h invalid ID
---------------------------------------------
INT 61 - Banyan VINES - GET REVISION NUMBER
	AH = 02h
	DS:DX -> 2-byte buffer for result
Return: AX = 0000h installed
	    DS:DX buffer contains revision number as
		10000d * major_ver + 100d * minor_ver + patch_revision
---------------------------------------------
INT 61 - Sangoma CCIP (CCPOP 3270 resident module) INTERFACE
	BX:DX -> control block
---------------------------------------------
INT 62 - reserved for user interrupt
---------------------------------------------
INT 62 - Adaptec and OMTI controllers - DRIVE 0 DATA
---------------------------------------------
INT 63 - reserved for user interrupt
---------------------------------------------
INT 63 - Adaptec and OMTI controllers - DRIVE 0 DATA
---------------------------------------------
INT 63 - Oracle SQL Protected Mode Executive - ???
---------------------------------------------
INT 63 - 4+Power FLOPPY CONTROLLER - ORIGINAL INT 13/40
   the "4+Power" quad floppy controller BIOS hooks INT 13 (or INT 40 if INT 13
   has been moved there) and places the old value here
---------------------------------------------
INT 64 - reserved for user interrupt
---------------------------------------------
INT 64 - Adaptec controllers - DRIVE 1 DATA
---------------------------------------------
INT 64 - Oracle SQL Protected Mode Executive - ???
---------------------------------------------
INT 64 - Novell NetWare - LOW-LEVEL API
Note:	equivalent to INT 7A
---------------------------------------------
INT 64 - Data General DG10 - MicroECLIPSE COPROCESSOR INTERFACE
---------------------------------------------
INT 64 - Extended Batch Language v3.14+
	AH = function
	    00h to 5Fh chained to previous handler
	    60h to 6Dh reserved, return immediately
	    80h to FFh chained to previous handler
	    6Eh clear ??? counter/flag
	    6Fh return counter/flag that AH=6Eh clears
	    70h ???
		AL = ???
	    71h ???
		AL = ???
	    72h ???
	    73h insert byte at end of keyboard buffer
		AL = byte to insert
	    74h insert byte at front of keyboard buffer
		AL = byte to insert
	    75h ???
	    76h get keyboard "stack" status
		AL = 'K' if kbd read will read physical keyboard
		     'S' if it will read EBL internal keyboard buffer
		AH = ???
	    77h clear internal keyboard buffer
	    78h ???
		AL = ???
	    79h ???
	    7Ah ???
		AL = ???
	    7Bh ???
		AL = ???
	    7Ch ???
		AL = ???
	    7Dh ???
		AL = ???
	    7Eh clear buffer for ???
	    7Fh installation check
		Return: CX = version in BCD
			DI = segment of ???
			BX = segment of next program's PSP???
Notes:	Extended Batch Language is a batch-file enhancer by Seaware
	the chaining does not check whether the interrupt had been hooked
	  before, so if you try to chain when the previous vector was 
	  0000h:0000h, you'll be in trouble
---------------------------------------------
INT 65 - reserved for user interrupt
---------------------------------------------
INT 65 - Adaptec controllers - DRIVE 1 DATA
---------------------------------------------
INT 65 - Data General DG10 - MicroECLIPSE COPROCESSOR INTERFACE
---------------------------------------------
INT 65 - SD.COM v6.2
   The unregistered version of SD62.COM uses the low byte of this vector to
   count the number of invocations, displaying a registration reminder each
   time after the 20th use.
---------------------------------------------
INT 66 - reserved for user interrupt
---------------------------------------------
INT 66 - Adaptec controllers - DRIVE 1 DATA
---------------------------------------------
INT 66 - Data General DG10 - MicroECLIPSE COPROCESSOR INTERFACE
---------------------------------------------
INT 66 - THESPLUS - UNINSTALL
	AX = FFFEh
	BX = FFFEh
Return: only if unsuccessful
Note:	installation check is for the interrupt handler to begin with the bytes
	  FBh, 9Ch, and the string "THESPLUS" to appear at offset 0005h in the
	  interrupt handler segment.
---------------------------------------------
INT 67 - Adaptec controllers - DRIVE 1 DATA
---------------------------------------------
INT 67 - LIM EMS - GET MANAGER STATUS
	AH = 40h
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested by application
Note:	this call can be used only after establishing that the EMS driver is in
	  fact present
---------------------------------------------
INT 67 - LIM EMS - GET PAGE FRAME SEGMENT
	AH = 41h
Return: AH = 00h function successful
	    BX = segment of page frame
	AH = error code (see AH=40h)
---------------------------------------------
INT 67 - LIM EMS - GET NUMBER OF PAGES
	AH = 42h
Return: AH = 00h function successful
	    BX = number of unallocated pages
	    DX = total number of pages
	AH = error code (see AH=40h)
---------------------------------------------
INT 67 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY
	AH = 43h
	BX = number of logical pages to allocate
Return: AH = status
	    00h function successful
		DX = handle
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    85h no more handles available
	    87h more pages requested than physically exist
	    88h more pages requested than currently available
	    89h zero pages requested
SeeAlso: AH=45h
---------------------------------------------
INT 67 - LIM EMS - MAP MEMORY
	AH = 44h
	AL = physical page number (0-3)
	BX = logical page number
	DX = handle
Return: AH = status
	    00h function successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Ah invalid logical page number
	    8Bh illegal physical-page number
SeeAlso: AH=69h
---------------------------------------------
INT 67 - LIM EMS - RELEASE HANDLE AND MEMORY
	AH = 45h
	DX = EMM handle
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    86h error in save or restore of mapping context
SeeAlso: AH=43h
---------------------------------------------
INT 67 - LIM EMS - GET EMM VERSION
	AH = 46h
Return: AH = status
	    00h successful
		AL = EMM version number
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
---------------------------------------------
INT 67 - LIM EMS - SAVE MAPPING CONTEXT
	AH = 47h
	DX = handle
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Ch page-mapping hardware state save area is full
	    8Dh save of mapping context failed
SeeAlso: AH=47h
---------------------------------------------
INT 67 - LIM EMS - RESTORE MAPPING CONTEXT
	AH = 48h
	DX = handle
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Eh restore of mapping context failed
SeeAlso: AH=47h
---------------------------------------------
INT 67 - LIM EMS - reserved - GET I/O PORT ADDRESSES
	AH = 49h
Note:	defined in EMS 3.0, but undocumented in EMS 3.2
---------------------------------------------
INT 67 - LIM EMS - reserved - GET TRANSLATION ARRAY
	AH = 4Ah
Note:	defined in EMS 3.0, but undocumented in EMS 3.2
---------------------------------------------
INT 67 - LIM EMS - GET NUMBER OF EMM HANDLES
	AH = 4Bh
Return: AH = status
	    00h successful
		BX = number of EMM handles
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
---------------------------------------------
INT 67 - LIM EMS - GET PAGES OWNED BY HANDLE
	AH = 4Ch
	DX = EMM handle
Return: AH = status
	    00h successful
		BX = number of logical pages
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
SeeAlso: AH=4Dh
---------------------------------------------
INT 67 - LIM EMS - GET PAGES FOR ALL HANDLES
	AH = 4Dh
	ES:DI -> array to receive information
Return: AH = status
	    00h successful
		BX = number of active EMM handles
		array filled with 2-word entries, consisting of a handle
		  and the number of pages allocated to that handle
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
SeeAlso: AH=4Ch
---------------------------------------------
INT 67 - LIM EMS - GET OR SET PAGE MAP
	AH = 4Eh
	AL = 00h if getting mapping registers
	     01h if setting mapping registers
	     02h if getting and setting mapping registers at once
	     03h if getting size of page-mapping array
	DS:SI -> array holding information (AL=01/02)
	ES:DI -> array to receive information (AL=00/02)
Return: AH = status
	    00h successful
		AL = bytes in page-mapping array (AL=03h only)
		array pointed to by ES:DI receives mapping info (AL=00h/02h)
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction parameter
	    A3h contents of source array corrupted (EMS 4.0?)
Note:	this function was designed to be used by multitasking operating systems
	  and should not ordinarily be used by appplication software.
SeeAlso: AH=4Fh
---------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP
	AH = 4Fh
	AL = subfunction
	    00h get partial page map
	       DS:SI -> structure containing list of segments whose mapping
			contexts are to be saved
	       ES:DI -> array to receive page map
	    01h set partial page map
	       DS:SI -> structure containing saved partial page map
	    02h get size of partial page map
	       BX = number of mappable segments in the partial map to be saved
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Bh one of specified segments is not mappable
	    8Fh undefined subfunction parameter
	    A3h contents of partial page map corrupted or count of mappable
		segments exceeds total number of mappable segments in system
	AL = size of partial page map for subfunction 02h
SeeAlso: AH=4Eh
---------------------------------------------
INT 67 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
	AH = 50h
	AL = subfunction
	    00h
	    01h
	DX = handle
	CX = number of entries in array
	DS:SI -> mapping array
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Ah one or more logical pages are invalid
	    8Bh one or more physical pages are invalid
	    8Fh invalid subfunction
SeeAlso: AH=40h
---------------------------------------------
INT 67 - LIM EMS 4.0 - REALLOCATE PAGES
	AH = 51h
	DX = handle
	BX = number of pages to be allocated to handle
Return: BX = actual number of pages allocated to handle
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    87h more pages requested than present in system
	    88h more pages requested than currently available
---------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES
	AH = 52h
	AL = subfunction
	    00h get handle attributes
		Return: AL = attribute
			    00h handle is volatile
			    01h handle is nonvolatile
	    01h set handle attributes
		BL = new attribute (see returned AL)
	    02h get attribute capability
		Return: AL = attribute capability
			    00h only volatile handles supported
			    01h both volatile and non-volatile supported
	DX = handle
Return:	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Fh undefined subfunction
	    90h undefined attribute type
	    91h feature not supported
SeeAlso: AH=53h
---------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE NAME
	AH = 53h
	AL = subfunction
	    00h get handle name
	       ES:DI -> 8-byte handle name array
	    01h set handle name
	       DS:SI -> 8-byte handle name
	DX = handle
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    83h invalid handle
	    84h undefined function requested
	    8Fh undefined subfunction
	    A1h duplicate handle name
SeeAlso: AH=52h
---------------------------------------------
INT 67 - LIM EMS 4.0 - GET HANDLE DIRECTORY
	AH = 54h
	AL = subfunction
	    00h get handle directory
	       ES:DI -> buffer for handle directory
	    01h search for named handle
	       DS:SI -> 8-byte name
	    02h get total number of handles
Return: AL = number of entries in handle directory (subfunction 00h)
	DX = value of named handle (subfunction 01h)
	BX = total number of handles (subfunction 02h)
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction
	    A0h no such handle name
	    A1h a handle found had no name
---------------------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP
	AH = 55h
	AL = subfunction
	    00h physical page numbers provided by caller
	    01h segment addresses provided by caller
	DX = handle
	DS:SI -> structure containing map and jump address
Return: (at target address unless error)
	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    83h invalid handle
	    84h undefined function requested
	    8Ah invalid logical page number encountered
	    8Bh invalid physical page number encountered
	    8Fh invalid subfunction
SeeAlso: AH=56h
---------------------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL
	AH = 56h
	AL = subfunction
	    00h physical page numbers provided by caller
		DX = handle
		DS:SI -> structure containing page map and call address
	    01h segment addresses provided by caller
		DX = handle
		DS:SI -> structure containing page map and call address
	    02h get page map stack space required
		Return: BX = stack space required
Return: (if successful, the target address is called.  Use a RETF to return and
	 restore mapping context)
	AH = status (see AH=55h)
SeeAlso: AH=55h
---------------------------------------------
INT 67 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION
	AH = 57h
	AL = subfunction
	    00h move memory region
	    01h exchange memory region
	DS:SI -> structure describing source and destination
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    83h invalid handle
	    84h undefined function requested
	    8Ah invalid logical page number encountered
	    8Fh undefined subfunction
	    92h successful, but a portion of the source region has been
		overwritten
	    93h length of source or destination region exceeds length of region
		allocated to either source or destination handle
	    94h conventional and expanded memory regions overlap
	    95h offset within logical page exceeds size of logical page
	    96h region length exceeds 1M
	    97h source and destination EMS regions have same handle and overlap
	    98h memory source or destination type undefined
	    A2h attempted to wrap around 1M conventional address space
---------------------------------------------
INT 67 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY
	AH = 58h
	AL = subfunction
	    00h get mappable physical address array
		ES:DI -> buffer to be filled with array
	    01h get number of entries in m.p.a. array
Return: CX = number of entries in array
	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    84h undefined function requested
	    8Fh undefined subfunction
---------------------------------------------
INT 67 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION
	AH = 59h
	AL = subfunction
	    00h get hardware configuration array
		ES:DI -> buffer to be filled with array (see below)
	    01h get unallocated raw page count
		Return: BX = unallocated raw pages
			DX = total raw pages
Return:	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    84h undefined function requested
	    8Fh undefined subfunction
	    A4h access denied by operating system
Note:	subfunction 00h is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system

Format of hardware configuration array:
Offset	Size	Description
 00h	WORD	size of raw EMM pages in paragraphs
 02h	WORD	number of alternate register sets
 04h	WORD	size of mapping-context save area in bytes
 06h	WORD	number of register sets assignable to DMA
 08h	WORD	DMA operation type
		0000h DMA with alternate register sets
		0001h only one DMA register set
---------------------------------------------
INT 67 - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES
	AH = 5Ah
	AL = subfunction
	    00h allocate standard pages
	    01h allocate raw pages
	BX = number of pages to allocate
Return: DX = handle
	AH = status
	    00h successful
	    80h internal error
	    81h hardware failure
	    84h undefined function requested
	    85h no more handles available
	    87h insufficient memory pages in system
	    88h insufficient memory pages available
	    8Fh undefined subfunction
---------------------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET
	AH = 5Bh
	AL = subfunction
	    00h get alternate map register set
		Return: BL = current active alternate map register set number
			ES:DI -> map register context save area if BL=00h
	    01h set alternate map register set
		BL = new alternate map register set number
		ES:DI -> map register context save area if BL=0
	    02h get alternate map save array size
		Return: DX = array size in bytes
	    03h allocate alternate map register set
		Return: BL = number of map register set; 00h = not supported
	    04h deallocate alternate map register set
		BL = number of alternate map register set
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction
	    9Ah specified alternate map register set not supported
	    9Bh all alternate map register sets currently allocated
	    9Ch alternate map register sets not supported
	    9Dh undefined or unallocated alternate map register set
	    A3h source array corrupted
	    A4h operating system denied access
Note:	this function is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system
---------------------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS
	AH = 5Bh
	AL = subfunction
	    05h allocate DMA register set
		Return: BL = DMA register set number, 00h if not supported
	    06h enable DMA on alternate map register set
	       BL = DMA register set number
	       DL = DMA channel number
	    07h disable DMA on alternate map register set
	       BL = DMA register set number
	    08h deallocate DMA register set
	       BL = DMA register set number
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction
	    9Ah specified DMA register set not supported
	    9Bh all DMA register sets currently allocated
	    9Ch alternate DMA sets not supported
	    9Dh undefined or unallocated DMA register set
	    9Eh dedicated DMA channels not supported
	    9Fh specified dedicated DMA channel not supported
	    A3h source array corrupted
	    A4h operating system denied access
Note:	this function is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system
---------------------------------------------
INT 67 - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT
	AH = 5Ch
Return: AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
---------------------------------------------
INT 67 - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS
	AH = 5Dh
	AL = subfunction
	    00h enable OS Function Set
	    01h disable OS Function Set
	    02h return access key (resets memory manager, returns access key at
		next invocation)
	BX,CX = access key returned by first invocation
Return: BX,CX = access key, returned only on first invocation of function
	AH = status
	    00h successful
	    80h internal error
	    81h hardware malfunction
	    84h undefined function requested
	    8Fh undefined subfunction
	    A4h operating system denied access
---------------------------------------------
INT 67 - EEMS - GET PHYSICAL WINDOW ARRAY
	AH = 60h
	ES:DI -> buffer
Return: AH = status
	AL = number of entries
	buffer at ES:DI filled
---------------------------------------------
INT 67 - EEMS - GENERIC ACCELERATOR CARD SUPPORT
	AH = 61h
	???
Return: ???
Note:	can be used by accelerator card manufacturer to flush RAM cache,
	  ensuring that the cache accurately reflects what the processor would
	  see without the cache.
---------------------------------------------
INT 67 - EEMS - GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM
	AH = 68h
	ES:DI -> buffer
Return: AH = status
	AL = number of entries
	buffer at ES:DI filled
Note:	equivalent to LIM 4.0 function 58h
---------------------------------------------
INT 67 - EEMS - MAP PAGE INTO FRAME
	AH = 69h
	AL = frame number
	BX = page number
	DX = handle
Return: AH = status
Note:	similar to EMS function 44h
SeeAlso: AH=44h,50h,6Ah
---------------------------------------------
INT 67 - EEMS - PAGE MAPPING
	AH = 6Ah
	AL = subfunction
	    00h save partial page map
		CH = first page frame
		CL = number of frames
		ES:DI -> buffer which is to be filled
	    01h restore partial page map
		CH = first page frame
		CL = number of frames
		DI:SI -> previously saved page map
	    02h save and restore partial page map
		CH = first page frame
		CL = number of frames
		ES:DI = buffer for current page map
		DI:SI = new page map
	    03h get size of save array
		CH = first page frame
		CL = number of frames
		Return: AL = size of array in bytes
	    04h switch to standard map register setting
	    05h switch to alternate map register setting
	    06h deallocate pages mapped to frames in conventional memory
		CH = first page frame
		CL = number of frames
Return: AH = status
Note:	similar to EMS function 4Eh, except that a subrange of pages can be
	  specified
SeeAlso: AH=69h
---------------------------------------------
INT 67 - Virtual Control Program Interface - INSTALLATION CHECK
	AX = DE00h
Return: AH = 00h    VCPI is present
	    BH = major version number
	    BL = minor version number
	AH nonzero  VCPI not present
---------------------------------------------
INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE
	AX = DE01h
	ES:DI -> 4K page table buffer
	DS:SI -> three descriptor table entries in GDT
		first becomes code segment descriptor, other two for use by
		main control program
Return: AH = 00h successful
	    DI -> first unused page table entry in buffer
	    EBX -> protected mode entry point in code segment
	AH = nonzero  failed
---------------------------------------------
INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS
	AX = DE02h
Return: AH = 00h  successful
	    EDX = physical address of highest 4K memory page
	AH nonzero: failed
---------------------------------------------
INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES
	AX = DE03h
Return: AH = 00h  successful
	    EDX = number of free 4K pages
	AH nonzero: failed
Notes:	returns total number of pages available to ALL tasks in system
	also available in protected mode by calling the protected-mode VCPI
	  entry point
SeeAlso: AX=DE04h
---------------------------------------------
INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE
	AX = DE04h
Return: AH = 00h successful
	    EDX = physical address of allocated page
	AH nonzero: failed
Notes:	the client program is responsible for freeing all memory allocated
	  with this call before terminating
	also available in protected mode by calling the protected-mode VCPI
	  entry point
SeeAlso: AX=DE03h,DE05h
---------------------------------------------
INT 67 - Virtual Control Program Interface - FREE 4K PAGE
	AX = DE05h
	EDX = physical address of 4K page
Return: AH = 00h successful
	AH nonzero: failed
Note:	also available in protected mode by calling the protected-mode VCPI
	  entry point
SeeAlso: AX=DE04h
---------------------------------------------
INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB
	AX = DE06h
	CX = page number (linear address shifted right 12 bits)
Return: AH = 00h successful
	    EDX = physical address of page
	AH nonzero: invalid page number (AH = 8Bh recommended)
---------------------------------------------
INT 67 - Virtual Control Program Interface - READ CR0
	AX = DE07h
Return: AH = 00h
	EBX = value of Control Register 0
SeeAlso: AX=DE07h
---------------------------------------------
INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS
	AX = DE08h
	ES:DI -> array of 8 DWORDs
Return: AH = 00h
	buffer filled with DR0 first, DR7 last, DR4 and DR5 unused
SeeAlso: AX=DE09h
---------------------------------------------
INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS
	AX = DE09h
	ES:DI -> array of 8 DWORDs holding new values of debug registers
Return: AH = 00h
Note:	values for DR4 and DR5 ignored
SeeAlso: AX=DE08h
---------------------------------------------
INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Ah
Return: AH = 00h successful
	    BX = first vector used by master 8259 (IRQ0)
	    CX = first vector used by slave 8259 (IRQ8)
	AH nonzero: failed
Note:	CX is undefined in systems without a slave 8259
SeeAlso: AX=DE0Bh
---------------------------------------------
INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Bh
	BX = first vector used by master 8259
	CX = first vector used by slave 8259
	interrupts disabled
Return: AH = 00h successful
	AH nonzero: failed 
Notes:	This call merely informs the server that the client has changed the
	  interrupt mappings.  The client may not change the mappings if they
	  have already been changed by the server or another client, and is
	  responsible for restoring the original mappings before terminating.
SeeAlso: AX=DE0Ah
---------------------------------------------
INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE
	AX = DE0Ch
	ESI = linear address in first megabyte of values for system registers
	interrupts disabled
Return: interrupts disabled
	GDTR, IDTR, LDTR, TR loaded
	SS:ESP must have at least 16 bytes space, and the entry point is
		required to set up a new stack before enabling interrupts
	EAX, ESI, DS, ES, FS, GS destroyed
SeeAlso: INT 15/AH=89h

Note:	in protected mode, calling the protected-mode VCPI entry point with 
	  AX = DE0Ch
	  DS = segment selector from function DE01h
	  SS:ESP in first megabyte of linear memory
	  STACK:QWORD  return address from FAR call to 32-bit segment
		DWORD  EIP
		DWORD  CS
		DWORD  reserved for EFLAGS
		DWORD  ESP
		DWORD  SS
		DWORD  ES
		DWORD  DS
		DWORD  FS
		DWORD  GS
	  and interrupts disabled, will switch to virtual86 mode with
	  interrupts disabled, all segment registers loaded, and EAX destroyed.

Format of system register values for switch to protected mode:
Offset	Size	Description
 00h	DWORD	value for CR3
 04h	DWORD	linear address in first megabyte of value for GDTR
 08h	DWORD	linear address in first megabyte of value for IDTR
 0Ch	WORD	value for LDTR
 0Eh	WORD	value for TR
 10h	PWORD	CS:EIP of protected mode entry-point
---------------------------------------------
INT 67 - Sangoma CCPOP 3270 resident module
---------------------------------------------
INT 68 - APPC/PC
	AH = 01h
	DS:DX -> control block

Format of control block:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	verb (action)
 0Eh  6 BYTEs	00h
 14h	DWORD	(high byte first) return code (see below)
---if verb = 1B00h (DISPLAY)---
 18h	WORD	00h
 1Ah  8 BYTEs	(high byte first) logical unit ID
 22h  8 BYTEs	(high byte first) partner logical unit name
 2Ah  8 BYTEs	(high byte first) mode name
 32h	BYTE	logical unit session limit
 33h	BYTE	partner logical unit session limit
 34h	BYTE	mode maximum negotiable session limit
 35h	BYTE	current session limit
 36h	BYTE	minimum negotiated winner limit
 37h	BYTE	maximum negotiated loser limit
 38h	BYTE	active session count
 39h	BYTE	active CONWINNER session count
 3Ah	BYTE	active CONLOSER session count
 3Bh	BYTE	session termination count
 3Ch	BYTE	bit 7: SESSION_TERMINATION_TARGET_DRAIN
		bit 6: SESSION_TERMINATION_SOURCE_DRAIN
---if verb=2000h (Attach Physical Unit)---
 18h	WORD	00h
 1Ah	BYTE	version
 1Bh	BYTE	release
 1Ch  8 BYTEs	(high byte first) net name
 24h  8 BYTEs	(high byte first) physical unit name
 2Ch  8 BYTEs	00h
 34h	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh=don't log errors
 38h	DWORD	00h
 3Ch	BYTE	00h RETURN_CONTROL: COMPLETE
		01h RETURN_CONTROL: INCOMPLETE
---if verb=2100h (Attach Logical Unit)---
 18h	WORD	70  offset to partner logical unit record
 1Ah  8 BYTEs	(high byte first) logical unit name
 22h  8 BYTEs	(high byte first) logical unit ID
 2Ah	BYTE	logical unit local address
 2Bh	BYTE	logical unit session limit
 2Ch	DWORD	pointer to CREATE_TP_EXIT routine,
		FFFFFFFFh = reject incoming ALLOCATEs
		00000000h = queue ALLOCATEs
 30h	DWORD	00h
 34h	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh=don't log errors
 38h	DWORD	00h
 3Ch	BYTE	maximum TPs
 3Dh	BYTE	queue depth
 3Eh	DWORD	pointer to LU_LU_PASSWORD_EXIT routine, FFFFFFFFh=no pswd exit
 42h	DWORD	00h
 46h	WORD	total length of partner records
    for each partner logical unit:
	WORD	length of this partner logical unit record
	WORD	42  offset to mode records
      8 BYTEs	(high byte first) partner logical unit name
	BYTE	partner logical unit security capabilities
		bit 7: already verified
		bit 6: conversation level security
		bit 5: session level security
	BYTE	partner logical unit session limit
	WORD	partner logical unit maximum MC_SEND_LL
      8 BYTEs	(high byte first) partner logical unit DLC name
	BYTE	partner logical unit adapter number
     17 BYTEs	(counted string) partner logical unit adapter address
	WORD	total length of mode records
   for each mode:
	WORD	16  length of this mode record
      8 BYTEs	(high byte first) mode name
	WORD	RU_SIZE high bound
	WORD	RU_SIZE low bound
	BYTE	mode maximum negotiable session limit
	BYTE	pacing size for receive
---if verb=2200h (Detach Logical Unit)---
 18h  8 BYTEs	(high byte first) logical unit ID
 20h	BYTE	00h
---if verb=2700h (Detach Physical Unit)---
 18h	BYTE	00h  type: hard
		01h  type: soft
---if verb=2B00h (Activate DLC)---
 18h  8 BYTEs	(high byte first) DLC name
 20h	BYTE	adapter number

Values for return code:
	 0000h	successful
	 0001h	BAD_TP_ID
	 0002h	BAD_CONV_ID
	 0003h	bad logical unit ID
	 0008h	no physical unit attached
	 0110h	bad state
	 01B1h	BAD_PART_LUNAME
	 01B2h	bad mode name
	 0201h	physical unit already active
	 0211h	logical unit already active
	 0212h	BAD_PART_SESS
	 0213h	BAD_RU_SIZES
	 0214h	BAD_MODE_SESS
	 0216h	BAD_PACING_CNT
	 0219h	EXTREME_RUS
	 021Ah	SNASVCMG_1
	 0223h	SSCP_CONNECTED_LU
	 0230h	invalid change
	 0243h	too many TPs
	 0272h	adapter close failure
	 0281h	GET_ALLOC_BAD_TYPE
	 0282h	unsuccessful
	 0283h	DLC failure
	 0284h	unrecognized DLC
	 0286h	duplicate DLC
	 0301h	SSCP_PU_SESSION_NOT_ACTIVE
	 0302h	data exceeds RU size
	 0401h	invalid direction
	 0402h	invalid type
	 0403h	segment overlap
	 0404h	invalid first character
	 0405h	table error
	 0406h	conversion error
     F0010000h	APPC disabled
     F0020000h	APPC busy
     F0030000h	APPC abended
     F0040000h	incomplete

Routines defined by LU_LU_PASSWORD_EXIT, CREATE_TP_EXIT, and SYSTEM_LOG_EXIT
pointers are called by pushing the DWORD pointer to the verb on the stack and
then performing a FAR call.

Format of ACCESS_LU_LU_PW verb:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	1900h
 0Eh  8 BYTEs	(high byte first) logical unit ID
 16h  8 BYTEs	(high byte first) logical unit name
 1Eh  8 BYTEs	(high byte first) partner logical unit name
 26h 17 BYTEs	(counted string) partner fully qualified logical unit name
 37h	BYTE	password available (0=no, 1=yes)
 38h  8 BYTEs	password

Format of CREATE_TP verb:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	2300h
 0Eh  6 BYTEs	00h
 14h	DWORD	(high byte first) sense code
		00000000h	Ok
		080F6051h	SECURITY_NOT_VALID
		084B6031h	TP_NOT_AVAIL_RETRY
		084C0000h	TP_NOT_AVAIL_NO_RETRY
		10086021h	TP_NAME_NOT_RECOGNIZED
		10086034h	CONVERSATION_TYPE_MISMATCH
		10086041h	SYNC_LEVEL_NOT_SUPPORTED
 18h  8 BYTEs	(high byte first) TP ID
 20h  8 BYTEs	(high byte first) logical unit ID
 28h	DWORD	(high byte first) conversation ID
 2Ch	BYTE	0 basic conversation, 1 mapped conversation
 2Dh	BYTE	0 no sync level, 1 confirm
 2Eh	BYTE	reserved
 2Fh 65 BYTEs	(counted string) transaction program name
 70h  6 BYTEs	00h
 76h	WORD	length of ERROR_LOG_DATA to return
 78h	DWORD	pointer to ERROR_LOG_DATA buffer
 7Ch  8 BYTEs	(high byte first) partner logical unit name
 84h 18 BYTEs	(counted string) partner fully qualified logical unit name
 96h  8 BYTEs	(high byte first) mode name
 9Eh 12 BYTEs	00h
 AAh 11 BYTEs	(counted string) password
 B5h 11 BYTEs	(counted string) user ID
 C0h	BYTE	0 verification should be performed
		1 already verified

Format of SYSLOG verb:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	2600h
 0Eh 10 BYTEs	00h
 18h	WORD	(high byte first) type
 1Ah	DWORD	(high byte first) subtype
 1Eh	DWORD	pointer to ADDITIONAL_INFO
 22h	DWORD	(high byte first) conversation ID
 26h  8 BYTEs	(high byte first) TP ID
 2Eh  8 BYTEs	(high byte first) physical unit or logical unit name
 36h	WORD	length of data
 38h	DWORD	pointer to data
 3Ch	BYTE	00h
---------------------------------------------
INT 68 - APPC/PC
	AH = 02h
	DS:DX -> control block

Format of control block:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	verb (action)
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(high byte first) primary return code (see below)
 16h	DWORD	(high byte first) error code (see below)
 1Ah  8 BYTEs	(high byte first) TP_ID
 22h	DWORD	(high byte first) conversation ID
---if verb=0100h (Allocate or MC_Allocate)---
 26h	BYTE	(MC_Allocate only) 0 basic conversation
		  		   1 mapped conversation
 27h	BYTE	00h SYNC_LEVEL = none
		01h SYNC_LEVEL = confirm
 28h	WORD	0000h
 2Ah	BYTE	00h RETURN_CONTROL: when session allocated
		01h RETURN_CONTROL: immediate
		02h RETURN_CONTROL: when session free
 2Bh  8 BYTEs	00h
 33h  8 BYTEs	(high byte first) partner logical unit name
 3Bh  8 BYTEs	(high byte first) mode name
 43h 65 BYTEs	(counted string) TP name
 84h	BYTE	00h security: none
		01h security: same
		02h security: pgm
 85h 11 BYTEs	00h
 90h 11 BYTEs	(counted string) password
 9Bh 11 BYTEs	(counted string) user ID
 A6h	WORD	PIP_DATA length
 A8h	DWORD	pointer to PIP_DATA
---if verb=0300h (Confirm or MC_Confirm)---
 26h	BYTE  request to send received (0=no, 1=yes)
---if verb=0400h (Confirmed or MC_Confirmed), no additional fields---
---if verb=0500h (Deallocate or MC_Deallocate)---
 26h	BYTE	00h
 27h	BYTE	type 0 SYNC_LEVEL
		     1 FLUSH
		     2 ABEND_PROC
		     3 ABEND_SVC
		     4 ABEND_TIMER
		     5 ABEND
 28h	WORD	(MC_Deallocate only) length of error log data
 2Ah	DWORD	(MC_Deallocate only) pointer to error log data
---if verb=0600h (Flush or MC_Flush), no additional fields---
---if verb=0700h (Get_Attributes or MC_Get_Attributes)---
 26h  8 BYTEs	(high byte first) logical unit ID
 2Eh	BYTE	00h
 2Fh	BYTE	SYNC_LEVEL (0=none, 1=confirm)
 30h  8 BYTEs	(high byte first) mode name
 38h  8 BYTEs	(high byte first) own net name
 40h  8 BYTEs	(high byte first) own logical unit name
 48h  8 BYTEs	(high byte first) partner logical unit name
 50h 18 BYTEs	(counted string) partner's fully qualified logical unit name
 62h	BYTE	00h
 63h 11 BYTEs	(counted string) user ID
---if verb=0800h (Get_Type)---
 26h	BYTE	type (0=basic conversation, 1=mapped conversation)
---if verb=0900h (Post_on_Receipt)---
 26h	WORD	maximum length
 28h	BYTE	fill (0=buffer, 1=LL)
---if verb=0A00h (Prepare_to_Receive or MC_Prepare_to_Receive)---
 26h	BYTE	type (0=SYNC_LEVEL, 1=FLUSH)
 27h	BYTE	locks (0=short, 1=long)
---if verb=0B00h (Receive_and_Wait or MC_Receive_and_Wait)---
 26h	BYTE	what received
		00h data
		01h data complete
		02h data incomplete
		03h confirm
		04h confirm send
		05h confirm deallocate
		06h send
 27h	BYTE	(MC_Receive_and_Wait only) fill (0=buffer, 1=LL)
 28h	BYTE	Request_to_Send_Received (0=no, 1=yes)
 29h	WORD	maximum length
 2Bh	WORD	data length
 2Dh	DWORD	pointer to data
---if verb=0C00h (Receive_Immediate or MC_Receive_Immediate)---
 26h	BYTE	what received
		00h data
		01h data complete
		02h data incomplete
		03h confirm
		04h confirm send
		05h confirm deallocate
		06h send
 27h	BYTE	(MC_Receive_Immediate only) fill (0=buffer, 1=LL)
 28h	BYTE	Request_to_Send_Received (0=no, 1=yes)
 29h	WORD	maximum length
 2Bh	WORD	data length
 2Dh	DWORD	pointer to data
---if verb=0E00h (Request_to_Send or MC_Request_to_Send), no other fields---
---if verb=0F00h (Send_Data or MC_Send_Data)---
 26h	BYTE	request to send received (0=no, 1=yes)
 27h	BYTE	00h
 28h	WORD	data length
 2Ah	DWORD	pointer to data
---if verb=1000h (Send_Error or MC_Send_Error)---
 26h	BYTE	request to send received (0=no, 1=yes)
 27h	BYTE	type (0=program, 1=SVC)
 28h	DWORD	00h
 2Ch	WORD	(MC_Send_Error only) LOG_DATA length
 2Eh	DWORD	(MC_Send_Error only) pointer to LOG_DATA
---if verb=1200h (Test or MC_Test)---
 26h	BYTE	(MC_Test only) test (0=posted, 1=request_to_send received)
		Note: error code has different interpretations for:
			0 posted data
			1 posted not data (primary return code = 0)
			1 bad TP_ID (primary return code = 1)
---if verb=1300h (Wait)---
 26h	BYTE	number of conversations to wait on
		Note: error codes have interpretations as for 1200h above

Values for primary return code:
 0000h	successful
 0001h	parameter check
 0002h	state check
 0003h	allocation error
 0005h	deallocate abended
 0006h	deallocate abended program
 0007h	deallocate abended SVC
 0008h	deallocate abended timer
 0009h	deallocate normal return
 000Ah	data posting blocked
 000Bh	posting not active
 000Ch	PROG_ERROR_NO_TRUNC
 000Dh	PROG_ERROR_TRUNC
 000Eh	PROG_ERROR_PURGING
 000Fh	CONV_FAILURE_RETRY
 0010h	CONV_FAILURE_NO_RETRY
 0011h	SVC_ERROR_NO_TRUNC
 0012h	SVC_ERROR_TRUNC
 0013h	SVC_ERROR_PURGING
 0014h	unsuccessful
 0018h	CNOS partner logical unit reject
 0019h	conversation type mixed
 F001h	APPC disabled
 F002h	APPC busy
 F003h	APPC abended
 F004h	incomplete

Values for error code:
 0001h bad TP ID
 0002h bad conversation ID
 0004h allocation error, no retry
 0005h allocation error, retry
 0006h data area crosses segment boundary
 0010h bad TPN length
 0011h bad CONV length
 0012h bad SYNC level
 0013h bad security selection
 0014h bad return control
 0015h SEC_TOKENS too big
 0016h PIP_LEN incorrect
 0017h no use of SNASVCMG
 0018h unknown partner mode
 0031h confirm: SYNC_NONE
 0032h confirm: bad state
 0033h confirm: NOT_LL_BDY
 0041h confirmed: bad state
 0051h deallocate: bad type
 0052h deallocate: flush bad state
 0053h deallocate: confirm bad state
 0055h deallocate: NOT_LL_BDY
 0057h deallocate: log LL_WRONG
 0061h flush: not send state
 0091h post on receipt: invalid length
 0092h post on receipt: not in receive state
 0093h post on receipt: bad fill
 00A1h prepare to receive:invalid type
 00A2h prepare to receive: unfinished LL
 00A3h prepare to receive: not in send state
 00B1h receive and wait: bad state
 00B2h receive and wait: NOT_LL_BDY
 00B5h receive and wait: bad fill
 00C1h receive immediate: not in receive state
 00C4h receive immediate: bad fill
 00E1h request to send: not in receive state
 00F1h send data: bad LL
 00F2h send data: not in send state
 0102h send error: log LL wrong
 0103h send error: bad type
 0121h test: invalid type
 0122h test: not in receive state
---------------------------------------------
INT 68 - APPC/PC
	AH = 03h
	DS:DX -> control block (see below)

Format of control block:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	verb (action)
 0Eh  6 BYTEs	0
 14h	DWORD	(high byte first) return code (see AH=01h)
 18h	WORD	0
 1Ah  8 BYTEs	(high byte first) logical unit ID
---if verb=2400h (TP Started), control block continues---
 22h  8 BYTEs	(high byte first) TP ID
---if verb=2800h (Get ALLOCATE), control block continues---
 22h	BYTE	type
		00h dequeue
		01h test
 23h	DWORD	pointer to CREATE_TP record
---if verb=2A00h (Change Logical Unit). control block continues---
 22h	DWORD	pointer to CREATE_TP_EXIT routine
		FFFFFFFFh reject incoming ALLOCATEs
		00000000h queue ALLOCATEs
 26h	DWORD	00000000h
 2Ah	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh= don't log errors
 2Eh	DWORD	00000000h
 32h	BYTE	maximum TPs
 33h	BYTE	00h stop QUEUE_ALLOCATEs
		01h resume QUEUE_ALLOCATEs
 34h	DWORD	pointer to LU_LU_PASSWORD_EXIT routine, FFFFFFFFh = no exit
 38h	DWORD	00000000h
---------------------------------------------
INT 68 - APPC/PC
	AH = 04h
	DS:DX -> control block (see below)

Format of control block:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	verb (action)
		2500h TP_ENDED
		2900h TP_VALID
 0Eh  6 BYTEs	0
 14h	DWORD	(high byte first) return code (see AH=01h)
 18h	WORD	0
 1Ah  8 BYTEs	(high byte first) TP_ID
 22h	DWORD -> CREATE_TP record (only if verb = 2900h)
---------------------------------------------
INT 68 - APPC/PC - TRANSFER MSG DATA
	AH = 05h
	DS:DX -> control block (see below)

Format of control block:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	1C00h
 0Eh	BYTE	00h user defined
		01h NMVT
		02h alert subvectors
		03h PDSTATS subvectors
 0Fh  5 BYTEs	0
 14h	DWORD	(high byte first) return code (see AH=01h)
 18h 12 BYTEs	0
 24h	BYTE	if bit 0 clear, add correlation subvector
		if bit 1 clear, add product set ID subvector
		if bit 2 clear, do SYSLOG
		if bit 3 clear, send SSCP_PU_SESSION
 25h	BYTE	0
 26h	WORD	length of data
 28h  N BYTEs	data
---------------------------------------------
INT 68 - APPC/PC - CHANGE NUMBER OF SESSIONS
	AH = 06h
	DS:DX -> control block (see below)

Format of control block:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	1500h
 0Eh  6 BYTEs	0
 14h	WORD	(high byte first) primary return code (see AH=02h)
 16h	DWORD	(high byte first) secondary return code (see below, AH=01h)
 1Ah  8 BYTEs	(high byte first) logical unit ID
 22h  8 BYTEs	blanks
 2Ah  8 BYTEs	(high byte first) partner logical unit name
 32h  8 BYTEs	(high byte first) mode name
 3Ah	BYTE	bit 7: use MODE_NAME_SELECT_ALL rather than MODE_NAME
		bit 6: set negotiable values
 3Bh	BYTE	partner logical unit mode session limit
 3Ch	BYTE	minimum CONWINNERS_SOURCE
 3Dh	BYTE	maximum CONWINNERS_TARGET
 3Eh	BYTE	automatic activation
 3Fh	BYTE	0
 40h	BYTE	bit 7: drain target
		bit 6: drain source
		bit 5: target responsible, not source

Values for secondary return code (see also AH=01h):
  0000h accepted
  0001h negotiated
  0003h bad logical unit ID
  0004h allocation failure, no retry
  0005h allocation failure, retry
  0151h can't raise limits
  0153h all modes must reset
  0154h bad SNASVCMG limits
  0155h minimum greater than total
  0156h mode closed (prim return code = 1)
	CNOS mode closed (prim return code = 18h)
  0157h bad mode name (prim return code = 1)
	CNOS bad mode name (prim return code = 18h)
  0159h reset SNA drains
  015Ah single not SRC response
  015Bh bad partner logical unit
  015Ch exceeds maximum allowed
  015Dh change SRC drains
  015Eh logical unit detached
  015Fh CNOS command race reject
---------------------------------------------
INT 68 - APPC/PC - PASSTHROUGH
	AH = 07h
	DS:DX -> control block (format depends on application subsystem)
---------------------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE APPC
	AH = FAh
	AL bit 0 = 0 enable
		   1 disable
---------------------------------------------
INT 68 - APPC/PC - CONVERT
	AH = FBh
	DS:DX -> control block (see below)

Format of control block:
Offset	Size	Description
 00h 12 BYTEs	reserved
 0Ch	WORD	1A00h
 0Eh  6 BYTEs	0
 14h	DWORD	(high byte first) return code
 18h	BYTE	conversion
		   00h ASCII to EBCDIC
		   01h EBCDIC to ASCII
 19h	BYTE	character set
		   00h AE
		   01h A
		   02h G
 1Ah	WORD	length of string to convert
 1Ch	DWORD	pointer to source
 20h	DWORD	pointer to target
---------------------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE MESSAGE TRACING
	AH = FCh
	AL = 00h disable tracing
	   = 01h enable tracing
		DX = number of bytes to keep (0=all)
SeeAlso: AH=FDh
---------------------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE API VERB TRACING
	AH = FDh
	AL = 00h disable tracing
	     01h enable tracing
SeeAlso: AH=FCh,FEh
---------------------------------------------
INT 68 - APPC/PC - SET TRACE DESTINATION
	AH = FEh
	AL = trace destinations
	    bit 0  storage (DS:DX -> trace stats record)
	    bit 1  display
	    bit 2  file (trace written to file OUTPUT.PC)
	    bit 3  printer
SeeAlso: AH=FDh

Format of Trace Statistics Record:
Offset	Size	Description
 00h	DWORD	pointer to storage trace buffer
 04h	WORD	max number of 80-byte records in trace
 06h	WORD	(high-order byte first!) current record number (must init to 0)
 08h	DWORD	(high-order byte first!) number of records written (init to 0)
 0Ch	DWORD	reserved
Note:	do not move record while trace is active
---------------------------------------------
INT 68 - APPC/PC - SET PASSTHROUGH
	AH = FFh
	DS:DX -> passthrough exit routine
---------------------------------------------
INT 68 - Sangoma CCPOP 3270 resident module
---------------------------------------------
INT 69 - Zenith AT BIOS - ???
   called by INT 09 handler
---------------------------------------------
INT 69 - DECnet DOS CTERM - INSTALLATION CHECK
	AX = 0100h
Return: AL = FFh if present
SeeAlso: AX=010Fh
---------------------------------------------
INT 69 - DECnet DOS CTERM - SEND BYTE
	AX = 0101h
	BL = character
	DX = session handle
Return: AH >= 80h on error
SeeAlso: AX=0102h
---------------------------------------------
INT 69 - DECnet DOS CTERM - READ BYTE
	AX = 0102h
	DX = session handle
Return: AH >= 80h on error
	AH < 80h if successful
	    AL = character
SeeAlso: AX=0101h
---------------------------------------------
INT 69 - DECnet DOS CTERM - STATUS
	AX = 0103h
	DX = session handle
Return: AH status flags
	    bit 7 session has been aborted
		6 DECnet error
		1 trace data available
		0 receive data available
	AL = reason code if DECnet error
	    00h normal disconnect
	    01h unknown message from host
	    02h protocol violation from host
	    03h could not process the initiate message
	    04h error receiving message from host
	    05h error sending message to host
	    06h error checking for message from host
	    07h remote system does not support CTERM
	    08h remote system does not support correct protocol version
	    09h did not receive BIND message from host
	    0Ah could not send BIND message to host
	    0Bh no more sessions available
	    0Ch session does not exist
	    0Dh not enough memory to complete operation
	    0Eh connection has broken
SeeAlso: AX=0104h
---------------------------------------------
INT 69 - DECnet DOS CTERM - DECnet STATUS
	AX = 0104h
	DX = session handle
Return: AX = reason code (see AX=0103h)
Note:	use this call when AX=0103h returns a DECnet error
SeeAlso: AX=0103h
---------------------------------------------
INT 69 - DECnet DOS CTERM - OPEN SESSION
	AX = 0105h
	DS:BX -> ASCIZ node name
	ES:DX -> buffer for session control block (see INT 6A/AH=D0h)
Return: AX <= 0 on error
	AX > 0 session handle
SeeAlso: AX=0103h,AX=0106h,AX=010Ah
---------------------------------------------
INT 69 - DECnet DOS CTERM - CLOSE SESSION
	AX = 0106h
	DX = session handle
Return: AH = 00h good close
	   other error code (see AX=0103h)
SeeAlso: AX=0103h,AX=0105h
---------------------------------------------
INT 69 - DECnet DOS CTERM - GET SESSION CONTROL BLOCK SIZE
	AX = 010Ah
Return: AX = length of session control block in bytes
SeeAlso: AX=0105h
---------------------------------------------
INT 69 - DECnet DOS CTERM - GET DECnet SOCKET
	AX = 010Bh
	DX = session handle
Return: AX > 0  DECnet socket for the session
	   = 0  no match for handle
---------------------------------------------
INT 69 - DECnet DOS CTERM - DEINSTALL CTERM
	AX = 010Fh
Return: AH = 00h succesful uninstall
	   other error code
Note:	CTERM must have been the last TSR loaded in order to deinstall it
SeeAlso: AX=0100h
---------------------------------------------
INT 6A - OPTHELP.COM
Notes:	OPTHELP is an optionally-resident help system for SLR Systems's OPTASM
	  assembler
	may be configured to use any interrupt from 60h to 7Fh (default 6Ah)
---------------------------------------------
INT 6A - DECnet DOS - LOCAL AREA TRANSPORT PROGRAM
Note:	the 3 bytes preceding the interrupt handler are "LAT"; this serves as
	  the installation check
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - SEND BYTE
	AH = 01h
	AL = character
	DH = FFh
	DL = handle
Return: AH >= 80h on error
SeeAlso: AH=02h
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - READ BYTE
	AH = 02h
	DH = FFh
	DL = handle
Return: AH < 80h if successful
	    AL = character
	AH >= 80h on error
SeeAlso: AH=01h
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - STATUS
	AH = 03h
	DH = FFh
	DL = handle
Return: AH = status flags
	    bit 5 transmit buffer empty
		3 session in start state
		2 session not active
		1 unable to queue transmit data
		0 receive data available
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - OPEN SESSION
	AH = D0h
	AL = FFh no password
	   = 0Fh password at ES:DI
	DH = FFh
	DS:BX -> LAT session control block (see below)
	ES:DI -> 16-byte blank-padded password
Return: AH = 00h success
	    DL = handle
SeeAlso: AX=D000h

Format of LAT Session Control Block:
Offset	Size	Description
 00h 18 BYTEs	service name
 12h 18 BYTEs	node name (future use)
 24h 18 BYTEs	port name (future use)
 36h	DWORD	-> session stopped post routine
 3Ah	DWORD	-> service table overflow post routine
 3Eh	DWORD	-> transmit post routine
 42h	DWORD	-> receive post routine
 46h	WORD	session status
		04h circuit failure
		08h stop slot received
 48h	WORD	slot state (LAT driver use)
 4Ah	WORD	local credits (LAT driver use)
 4Ch	DWORD	-> VCB (LAT driver use)
 50h	WORD	backward slot (LAT driver use)
 52h	WORD	forward slot (LAT driver use)
 54h	WORD	remote slot ID (LAT driver use)
 56h	WORD	local slot ID (LAT driver use)
 58h	WORD	slot byte count (LAT driver use)
 5Ah	BYTE	remote credits (LAT driver use)
 5Bh 255 BYTEs	transmitted data slot
15Ah	BYTE	number of receive data slots (4 recommended)
15Bh	BYTE	number of occupied slots
15Ch	BYTE	index of next receive slot to use
15Dh	BYTE	index of current receive slot
15Eh	WORD	pointer to first received character
160h  N WORDs	pointers to receive slots (buffers); each is 259 bytes
Note:	set post routines to 0000h:0000h if polled operation will be used
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - CLOSE SESSION
	AX = D000h
	DH = FFh
	DL = handle
Return: AX = 0000h successful
	   = 0001h no such session
	   = 0002h session not running, try again later
SeeAlso: AH=D0h
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - SEND BREAK
	AX = D100h
	DH = FFh
	DL = handle
Return: AX = 0000h if successful
	AH bit 7 set is unable to send break
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - RESET LAT COUNTERS
	AX = D300h
	DH = FFh
SeeAlso: AX=D400h
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - COPY LAT COUNTERS
	AX = D400h
	DH = FFh
	CX = buffer size
	ES:BX -> buffer for LAT counters
Return: AX = 0000h counters copied into buffer
	   = FFFFh buffer too small
SeeAlso: AX=D300h
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - GET NEXT LAT SERVICE NAME
	AX = D500h
	DH = FFh
	ES:BX -> 17-byte buffer for name
Return: AH = 00h if successful
	   ES:BX buffer filled
	AX = FFFFh if end of table or no name available
Notes:	use this function to get the names of the hosts on the network
	successive calls are necessary to get all names
SeeAlso: AX=D600h
---------------------------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - LAT SERVICE TABLE RESET
	AX = D600h
	DH = FFh
Return: AX = number of service table entries
	BX = 0000h service table has not overflowed
	   = FFFFh service table has overflowed
SeeAlso: AX=D500h
---------------------------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - INSTALL CHECK
	AH = 02h
	AL nonzero
Return: AL = 00h if present and OK
---------------------------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - BUFFERED WRITE
	AX = 0000h
	CX = length
	ES:BX -> buffer
Return: CX = number of bytes written
---------------------------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - BUFFERED READ
	AX = 0100h
	CX = length of buffer
	ES:BX -> buffer
Return: CX = number of bytes read
---------------------------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - CONTROL
	AX = 0600h
	CX = command
	    02h send break
	    04h disconnect
	    06h hold
---------------------------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - GET STATUS
	AX = 0700h
Return: CH <> 00h if connection active
---------------------------------------------
INT 6B - Tandy SCHOOLMATE PLUS - API
	AH = 6Bh
	AL = E0h to FFh
---------------------------------------------
INT 6C - system resume vector (CONVERTIBLE)
---------------------------------------------
INT 6C - DOS 3.2 Realtime Clock update
---------------------------------------------
INT 6D - VGA - internal
Note:	used by IBM, Paradise, Video7, and NCR
---------------------------------------------
INT 6D - ATI VGA Wonder - VIDEO BIOS ENTRY POINT
   points at the original INT 10 entry point set up by the ATI BIOS
---------------------------------------------
INT 6D - DECnet DOS - DATA LINK LAYER PROGRAM
---------------------------------------------
INT 6E - DECnet DOS - DECnet NETWORK PROCESS API
Notes:	this is the main DECnet DOS access, and is described in Digital manual
	  AA-EB46B-TV ("DECnet-DOS Programmer's Reference Manual")
	there is a signature/data area immediately prior to the interrupt
	  handler which may be used as an installation check

Format of signature area:
Offset	Size	Description
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "DNP")
---------------------------------------------
INT 6F - HP ES-12 EXTENDED BIOS - READ CMOS MEMORY
	BP = 0012h
	AH = 22h
	BL = address of CMOS byte to read
Return: AH = status
	AL = byte read
	BP, DS destroyed
SeeAlso: BP=0012h/AH=24h
---------------------------------------------
INT 6F - HP ES-12 EXTENDED BIOS - WRITE CMOS MEMORY
	BP = 0012h
	AH = 24h
	BL = address of CMOS byte to write
	AL = new value
Return: AH = status
	BP, DS destroyed
SeeAlso: BP=0012h/AH=22h
---------------------------------------------
INT 6F - Novell NetWare - PCOX API (3270 PC terminal interface)
---------------------------------------------
INT 6F - 10-NET - LOGIN
	AH = 00h
	DS:DX -> login record
		8 BYTEs user name
		8 BYTEs password
	       12 BYTEs name of SuperStation
Return: CL = security level
	AX = status
	    0000h successful
	    01FFh time out on response
	    02FFh network (hardware) error
	    03FFh invalid password
	    04FFh local rexource not available
	    05FFh server resource not available
	    06FFh already logged in under different name
	    07FFh login security failure (node)
	    08FFh not logged in
	    09FFh position calc error
	    0AFFh receive subfunction not = send subfunction (i.e. read, write)
	    0BFFh request function not in range
	    0CFFh no more server file handle entries left
	    0DFFh no more shared file table entries left
	    0EFFh no more user file handle entries left
	    0FFFh chat permit not on
	    10FFh not a server on request
	    11FFh no transporter board error
	    12FFh time out on send
	    13FFh item not found (spool item not on queue)
	    14FFh dos access incompatible
	    15FFh record already locked
	    16FFh invalid parameter
	    17FFh record lock time out error
	    18FFh currently spooling to named device
	    19FFh dropped receive message (throttle)
	    1AFFh open sharing violation
	    1BFFh no more tuf entries left
	    1CFFh not file owner on open
	    1DFFh read security not passed
	    1EFFh write security not passed
	    1FFFh group security not passed
	    20FFh security file failure
	    21FFh activity file failure
	    22FFh spool cntrl file failure
	    23FFh device not mounted (spooling)
	    24FFh spool file has not been terminated
	    25FFh device not mounted or is not being shared
	    26FFh duplicate node id
	    27FFh file not found error
	    28FFh no more files
	    29FFh unknown internal system error
	    2AFFh print queue is full or corrupted
	    2BFFh invalid function
	    2CFFh invalid handle
	    2DFFh too many files opened
	    2EFFh path not found
	    2FFFh named file is active
/* I've gotten one submission which says FFxxh, and another with xxFFh */
/* I don't know which way around these should be, does somebody else know? */
	    FF01h timeout
	    FF02h network error
	    FF03h invalid password
	    FF04h no local buffer
	    FF05h superstation not available
	    FF06h node already logged in
	    FF07h login not valid from this node
	    FF08h node ID already in use
	    FF16h invalid parameter (bad length, invalid node ID, etc)
	    FF17h record locked by another user
	    FF18h sent message has been dropped
SeeAlso: AH-01h
---------------------------------------------
INT 6F - 10-NET - LOGOFF
	AH = 01h
	DS:DX -> superstation ID or nulls (12 bytes)
Return: CX = number of files closed
	AX = status (see AH=00h)
	    FF08h superstation ID not already logged in
SeeAlso: AH=00h
---------------------------------------------
INT 6F - 10-NET - STATUS OF NODE
	AH = 02h
	DS:DX -> 512-byte status record (see below)
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful

Format of node status record:
Offset	Size	Description
 00h  8 BYTEs	user name (0 if none)
 08h	BYTE	station type
		   00h workstation
		   01h superstation
		   02h gateway station
		   03h gateway active
		   04h logged into multiple superstations
		   05h reserved
 09h 24 BYTEs	list of superstations logged into more than one superstation
 21h 12 BYTEs	node ID
 2Dh	WORD	message count for this station (send for user node, receive for
		superstations)
---for superstations only---
 2Fh	WORD	drives allocated (bit 0=A:, bit 1=B:,...)
 31h	BYTE	user service flag
		bit 7: gate
		    6: print permit on
		    4: SUBMIT is on
		    3: mail waiting for node
		    2: calendar waiting for you
		    1: news waiting for you
		    0: mail waiting for you
 32h	BYTE	printers allocated (bit 0=LPT1,...)
 33h	BYTE	number of unprinted spool files
 34h	BYTE	number of opened files
 35h	BYTE	number of logged on nodes
 36h	BYTE	primary drive (1=A:)
 37h	BYTE	reserved
 38h  N BYTEs	list of logged on node IDs (each 12 bytes, max 37 IDs)
1F4h  3 BYTEs	time: sec/min/hrs
1F7h  3 BYTEs	date: day/mon/year-1980
---------------------------------------------
INT 6F - 10-NET - GET ADDRESS OF CONFIGURATION TABLE
	AH = 03h
	DS:DI -> node ID (optional)
Return: ES:BX -> configuration table 
SeeAlso: AH=13h

Format of configuration table:
Offset	Size	Description
-41	WORD	local device table address
-39	WORD	extended network error mapping table address
-37	WORD	shared device table address
-35	WORD	mounted device table address
-33	BYTE	receive buffer counter
-32	BYTE	collect buffer counter
-31	WORD	TUF address
-29	BYTE	enable flag
-28	BYTE	FCB keep flag
-27	WORD	reserved
---up to here, 10-Net v3.3---
-25	WORD	count of dropped Send6F
-23	WORD	buffer start address
-21	WORD	comm driver base address
-19	WORD	send/receive retry count
-17	BYTE	number of 550ms loops before timeout
-16	WORD	UFH address
-14	WORD	CDIR address
-12	WORD	LTAB address
-10	WORD	SFH address
-8	WORD	FTAB address
-6	WORD	RLTAB address
-4	WORD	SMI address
-2	WORD	NTAB address
 00h	WORD	address of first CT_DRV
 02h	BYTE	number of DRV entries
 03h  8 BYTEs	login name
 0Bh 12 BYTEs	node ID (blank-padded)
 17h  6 BYTEs	node address
 1Dh	BYTE	flag
 1Eh	BYTE	CT_CFLG (chat permit)
		bit 1: sound bell
		bit 0: CHAT permit
 1Fh	BYTE	CT_PSFLG
		bit 5: PRINT permit
		bit 4: KB initiated
		bit 3: CHAT called FOXPTRM
		bit 2: SUBMIT active
		bit 1: SUBMIT received
		bit 0: SUBMIT permit
 20h	BYTE	in 10Net flag
 21h	WORD	receive message count
 23h	WORD	send message count
 25h	WORD	retry count
 27h	WORD	failed count
 29h	WORD	driver errors
 2Bh	WORD	dropped responses/CHATs
 2Dh  9 BYTEs	LIST ID/NTAB address (3 entries--LPT1-3)
 36h  6 BYTEs	AUX ID/NTAB address (2 entries--COM1-2)
 3Ch	BYTE	active CB channel
 3Dh	BYTE	received 6F messages on queue
 3Eh  9 BYTEs	activity counters for channels 1-9
---beyond here, 10-Net v3.3---
 47h	BYTE	bit 0 = RS232 gate
		    1 = Send6F gate (user set)
 48h	DWORD	pointer into gate (user set)
 4Ch	DWORD	pointer into 10Net send
 50h  N WORDs	addresses of timer blocks
---------------------------------------------
INT 6F - 10-NET - SEND
	AH = 04h
	DS:BX -> record
		12 BYTEs receiving node's ID
			if first byte has high-order bit set, message is
			   directed to the CT_RGATE vector at the receiver
			if second byte is 00h, first byte is taken as a CB
			   channel number and delivered to all nodes on same
			   channel
		   WORD  length of data at DX
	DS:DX -> data (max 1024 bytes)
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
SeeAlso: AH=05h
---------------------------------------------
INT 6F - 10-NET - RECEIVE
	AH = 05h
	CX = number of seconds before timeout
	DS:DX -> receive buffer (see below)
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
	    AH = FEh if dequeued message is a CB message
SeeAlso: AH=04h

Format of receive buffer:
Offset	Size	Description
 00h 12 BYTEs	sending node's ID
 0Ch	WORD	length of message
 0Eh  N BYTEs	message (maximum 1024 bytes)
---------------------------------------------
INT 6F - 10-NET - LOCK HANDLE
	AH = 07h
	BX = file handle
	CX:DX = starting offset in file
	SI = record length
Return: CF set on error
	    AX = error code (see also AH=00h)
		0002h file not found
	CF clear if successful
SeeAlso: AH=08h, INT 21/AH=5Ch
---------------------------------------------
INT 6F - 10-NET - UNLOCK HANDLE
	AH = 08h
	BX = file handle
	AL = mode
	    00h unlock all
	    01h unlock record at CX:DX
Return: CF set on error
	    AX = error code (see also AH=00h)
		0002h file not found
	CF clear if successful
SeeAlso: AH=07h, INT 21/AH=5Ch
---------------------------------------------
INT 6F - 10-NET - SUBMIT
	AH = 09h
	DS:BX -> submit record (see below)

Format of submit record:
Offset	Size	Description
 00h 12 BYTEs	destination node ID (must be logged in)
 0Ch	WORD	length+2 of following 'command line' text
 0Eh  N BYTEs	command line text (<=100 bytes), system adds CR
---------------------------------------------
INT 6F - 10-NET - CHAT
	AH = 0Ah
	DS:BX -> control parameters (see below)
	DS:DX -> chat message (see below)

Format of control parameters:
Offset	Size	Description
 00h  8 BYTEs	sender ID, defaults to node's userID if nulls
 08h  8 BYTEs	destination user ID, 'EVERYONE' may be used
 10h 12 BYTEs	destination node ID

Format of chat message:
Offset	Size	Description
 00h	WORD	length+2 of following text
 02h  N BYTEs	text, max 101 bytes
---------------------------------------------
INT 6F - 10-NET - LOCK SEMAPHORE, RETURN IMMEDIATELY
	AH = 0Bh
	AL = drive number or 0
	ES:SI = Ethernet address or 0
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status
	    00h successful
	    01h semaphore currently locked
	    02h server not responding
	    03h invalid semaphore name
	    04h semaphore list is full
	    05h invalid drive ID
	    06h invalid Ethernet address
	    07h not logged in
	    08h write to network failed
	    09h semaphore already logged in this CPU
Note:	same as INT 60/AH=12h
SeeAlso: AH=0Ch,INT 60/AH=12h
---------------------------------------------
INT 6F - 10-NET - UNLOCK SEMAPHORE
	AH = 0Ch
	AL = drive number or 0
	ES:SI = Ethernet address or 0
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status (see also AH=0Bh)
	    01h semaphore not locked
Note:	same as INT 60/AH=13h
SeeAlso: AH=0Bh,INT 60/AH=13h
---------------------------------------------
INT 6F - 10-NET - WHO
	AH = 0Dh
	AL = type code
	    01h return superstations only
	    02h return non-superstations only
	    otherwise return all
	CX = length of data
	DS:DX -> array of records to be filled (see below)
Return: CL = number of records returned (responding stations)

Format of station record:
Offset	Size	Description
 00h 12 BYTEs	node ID
 0Ch	BYTE	flags
		bit 1 = workstation
		    2 = superstation
		    3 = xgate
		    4 = active gate
---if AL = 01h---
 0Dh	BYTE	version number
	WORD	level number of 10Net software in responding node
---if AL = 02h---
 0Dh  8 BYTEs	user ID
 15h	BYTE	version number
 16h	WORD	level number
---------------------------------------------
INT 6F - 10-NET - SPOOL/PRINT
	AH = 0Eh
	DS:DX -> spool/print record (see below)
Return: CF set on error
	    AX = error code (see also AH=00h)
		FF17h device not mounted
		FF18h already spooling to named device
	CF clear if successful

Format of Spool/Print record:
Offset	Size	Description
 00h	WORD	operation code
		   00h initiate spool
		   01h abort print
		   02h close spool
		   03h delete spool
		   04h print
		   05h get report info
		   06h set chat template
		   07h queue
		   08h return queue
		   09h queue non-spooled file for printing
 02h 11 BYTEs	file name in FCB format
---if operation code = 00h or 06h---
 0Dh	BYTE	notification
		bit 7: queue to top
		bit 6: do ID page
		bit 5: no form feed
		bit 4: reserved
		bit 3: explicity queuing only
		bit 2: notify at print completion
		bit 1: notify server operator/reply
		bit 0: notify at print start
 0Eh	BYTE	days to keep (FFh=forever)
 0Fh	BYTE	bits 0,1: device (1=LPT1)
		bits 4-7: remote drive to store spool file (1=A,...)
 10h	WORD	length of following data area
 12h  N BYTEs	up to 64 bytes of description
---if operation code = 03h---
 0Dh  8 BYTEs	user ID to associate with filename
---if operation code = 04h---
 0Dh	WORD	block number
 0Fh  8 BYTEs	user ID to associate with filename
---if operation code = 05h---
 0Dh	BYTE	RRN to start retrieve
 0Eh	BYTE	bits 0,1: local print device (LPTx)
		bit 3: if set, return entries for all users
 0Fh	WORD	length of following area
 11h  N BYTEs	up to 1500 bytes to receive $SCNTL records returned
---if operation code = 07h---
 0Dh	BYTE	queue number
 0Eh	BYTE	bits 0,1: local print device (LPTx)
 0Fh	WORD	number of bytes of test print to be done
 11h	BYTE	code: 01h print device
		      02h test print count
		      03h prn
---if operation code = 08h---
 0Dh	BYTE	queue location or $SCNTL location to start access
			returns next item for access:
				00h-7Fh queued items
				80h-FEh non-queued, non-printed items
				FFh	no more items
 0Eh	WORD	unused
 10h	WORD	length of following area
 12h  N BYTEs	up to 64 bytes to receive $SCNTL records
---if operation code = 09h---
 0Dh  3 BYTEs	unused
 10h  N BYTEs	path to non-spooled file to be queued for printing

Format of $SCNTL record:
Offset	Size	Description
 00h  8 BYTEs	user ID
 08h 11 BYTEs	filename in FCB format
 13h  6 BYTEs	node ID
 19h  3 BYTEs	creation date
 1Ch	BYTE	flags
		bit 7: queue to top
		    6: do ID page
		    5: no form feed at end
		    4: reserved
		    3: explicit queueing only
		    2: notify at completion
		    1: notify server operator/reply
		    0: notify at start
 1Dh	BYTE	retention time in days
 1Eh	BYTE	printing device (LPTx)
 1Fh  3 BYTEs	date last printed (0 = never)
 22h	BYTE	device containing spoolfile
 23h	WORD	bytes to print for test print
 25h	WORD	block number to start print
 27h	BYTE	reserved
---------------------------------------------
INT 6F - 10-NET - ATTACH/DETACH PRINTER
	AH = 10h
	AL = subfunction
	    00h initiate spooling if LPT1 is mounted
	    01h terminate spooling if LPT1 is mounted
SeeAlso: INT 21/AX=5D08h
---------------------------------------------
INT 6F - 10-NET - LOCK FCB
	AH = 11h
	AL = mode
	    01h sequential
	    02h random
	    03h random block
		CX = number of records
	DS:DX -> FCB
Return: CF set on error
	    AX = error code (see also AH=00h)
		2 file not found
	CF clear if successful
SeeAlso: AH=12h
---------------------------------------------
INT 6F - 10-NET - UNLOCK FCB
	AH = 12h
	AL = mode
	    00h sequential
	    01h random
	    02h random block
		CX = number of records
	DS:DX -> FCB
Return: CF set on error
	    AX = error code (see also AH=00h)
		2 file not found
	CF clear if successful
SeeAlso: AH=11h
---------------------------------------------
INT 6F - 10-NET v3.3 - GET REMOTE CONFIGURATION TABLE ADDRESS
	AH = 13h
	DS:DX -> node ID, 12 bytes blank-padded
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
	    ES:BX = configuration table address on given machine
SeeAlso: AH=03h
---------------------------------------------
INT 6F - 10-NET v3.3 - GET REMOTE MEMORY
	AH = 14h
	BX:SI = address of remote memory
	CX = length (<=1024 bytes)
	DS:DX -> node ID, 12 bytes blank-padded
	DS:DI -> area to receive remote memory image
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
	    CX = amount of memory copied to DS:SI
---------------------------------------------
INT 6F - 10-NET v3.3 - GET SHARED DEVICE ENTRY
	AX = 1501h
	BX = zero-based index
	DS:SI -> node ID, 12 bytes blank-padded
	ES:DI -> 85-byte buffer for shared device table entry (see below)
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
	    ES:DI buffer contains shared device table entry of BXth device:
SeeAlso: AX=1502h,1503h

Format of shared device table entry:
Offset	Size	Description
 00h  8 BYTEs	device
 08h  8 BYTEs	alias
 10h 64 BYTEs	path
 50h  8 BYTEs	password
 58h	BYTE	access
 59h  4 BYTEs	mask
---------------------------------------------
INT 6F - 10-NET v3.3 - SET SHARED DEVICE ENTRY
	AX = 1502h
	DS:SI -> node ID, 12 bytes blank-padded
	ES:DI -> valid shared device table entry
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
SeeAlso: AX=1501h,1503h
---------------------------------------------
INT 6F - 10-NET v3.3 - DELETE SHARED DEVICE ENTRY
	AX = 1503h
	BX = zero-based index
	DS:SI -> node ID, 12 bytes blank-padded
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
SeeAlso: AX=1501h,1502h
---------------------------------------------
INT 6F - 10-NET v3.3 - MOUNT
	AH = 17h
	AL = local drive number (0=A:)
	BL = remote drive letter or '1'..'3' for LPTn or '4' or '5' for COMx
	DS:DX -> node ID, 12 bytes blank-padded
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
SeeAlso: AH=18h
---------------------------------------------
INT 6F - 10-NET v3.3 - UNMOUNT
	AH = 18h
	AL = local drive number (0=A:)
	BL = type
	    00h	    disk
	    01h-03h LPTn
	    04h,05h COMx
Return: CF set on error
	    AX = error code (see AH=00h)
	CF clear if successful
SeeAlso: AH=17h
---------------------------------------------
INT 70 - IRQ8 - AT/XT286/PS50+ - REAL-TIME CLOCK
Note:	may be masked by setting bit 0 on I/O port A1h
SeeAlso: INT 58
---------------------------------------------
INT 71 - IRQ9 - AT/XT286/PS50+ - LAN ADAPTER 1
Notes:	may be masked by setting bit 1 on I/O port A1h
	rerouted to INT 0A by BIOS
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 0A, INT 59
---------------------------------------------
INT 72 - IRQ10 - AT/XT286/PS50+ - RESERVED
Note:	may be masked by setting bit 2 on I/O port A1h
SeeAlso: INT 5A
---------------------------------------------
INT 73 - IRQ11 - AT/XT286/PS50+ - RESERVED
Note:	may be masked by setting bit 3 on I/O port A1h
SeeAlso: INT 5B
---------------------------------------------
INT 74 - IRQ12 - PS50+ - MOUSE INTERRUPT
Notes:	may be masked by setting bit 4 on I/O port A1h
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 33, INT 5C
---------------------------------------------
INT 75 - IRQ13 - AT/XT286/PS50+ - 80287 ERROR
Notes:	may be masked by setting bit 5 on I/O port A1h
	rerouted to INT 02 by BIOS
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 5D
---------------------------------------------
INT 76 - IRQ14 - AT/XT286/PS50+ - FIXED DISK
Note:	may be masked by setting bit 6 on I/O port A1h
SeeAlso: INT 0E"IRQ6", INT 5E
---------------------------------------------
INT 77 - IRQ15 - AT/XT286/PS50+ - RESERVED
Note:	may be masked by setting bit 7 on I/O port A1h
SeeAlso: INT 5F
---------------------------------------------
INT 78 - not used
---------------------------------------------
INT 79 - AVATAR.SYS - FAST GET KEYSTROKE
Return: CF set if no keystroke available
	    AX = FFFFh
	CF clear if key pressed
	    AX = keystroke
Notes:	if a keystroke is available, it is removed from the keyboard buffer
	  before being returned
	AVATAR.SYS is a CON driver by George Adam Stanislav which interprets
	  AVATAR command codes just as ANSI.SYS interprets ANSI commands
SeeAlso: INT 29
---------------------------------------------
INT 7A - Novell NetWare - LOW-LEVEL API
	???
SeeAlso: INT 64
---------------------------------------------
INT 7A - Topware Network Operating System - ???
	AL = ???
	???
Return: ???
---------------------------------------------
INT 7A - AutoCAD Device Interface
	???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - CREATE A QUEUE
	AH = 04h
	???
Return: ???
SeeAlso: AH=06h
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - DELETE A QUEUE
	AH = 06h
	???
Return: ???
SeeAlso: AH=04h
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - SESSION SERVICES
	AH = 09h
	BX = 8020h (synchronous request)
	CX = 0000h
	DX = ID of session manager (SESSMGR)
	AL = service
	    01h get session ID
	    02h get session info
	    04h dettach from session
	    05h attach to session
	    06h get list of windows available
	    07h get environment of window
	    08h get 'PIF' (program information file) info
	    0Ah get base window ID
	    0Bh get cursor info
	ES:DI -> control block
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - KEYBOARD SERVICES
	AH = 09h
	BX = 8020h (synchronous request)
	CX = 0000h
	DX = ID of keyboard manager
	AL = service
	    01h connect to keyboard
	    02h disconnect from keyboard
	    03h read from keyboard
	    04h send keystroke to session
	    05h disable input
	    06h enable input
	    07h update status code
	ES:DI -> control block
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - WINDOW SERVICES
	AH = 09h
	BX = 8020h (synchronous request)
	CX = 00FFh
	DX = ID of window service controller (WSCTRL)
	AL = service
	    01h connect to WS control
	    02h disconnect from WS control
	    03h add a window
	    04h change window's position on screen
	    05h change window's size
	    06h change window's color
	    07h change window's position in the presentation space
	    08h hide/unhide toggle
	    09h enlarge/reduce toggle
	    0Ah change screen background color
	    0Bh get window's position on screen
	    0Ch get window's size
	    0Dh get window's color
	    0Eh get window's position in the presentation space
	    0Fh determine whether hidden
	    10h determine whether enlarged
	    11h get background color
	    12h get window names
	    13h delete all windows from profile
	    14h pick active window
	    15h redraw screen
	    16h redraw window
	    17h delete a window from profile
	    18h get active window
	    19h get active screen
	    1Ah get window data
	    1Bh change window data
	    1Ch select active screen
	ES:DI -> control block
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - PRESENTATION SPACE SERVICES
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of PCPSM
	AL = service
	    01h define presentation space
	    02h delete presentation space
	    03h display presentation space
	    04h position cursor in presentation space
	    05h change default presentation space
	ES:DI -> control block
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - 3270 EMULATION
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of 3270EML
	AL = service
	    01h connect
	    02h disconnect
	ES:DI -> control block
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - OPERATOR INFORMATION AREA
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of OIAM
	AL = service
	    01h read Operator Information Area
	    02h read OIA subset
	ES:DI -> control block
Return: ???
Note: the OIA is the 25th line on the Host session
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - TRANSLATE DATA
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of XLATE
	AL = service
	    01h translate from host characters to ASCII and vice versa
		(determined by control block byte 11)
	ES:DI -> control block
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - COPY SERVICE
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of copy service
	AL = service
	    01h copy string from one presentation space to another
	    02h copy block from one presentation space to another
	    03h connect to PC session for copy
	    04h disconnect PC session from copy
	ES:DI -> control block
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - Multi-DOS
	AH = 09h
	BX = 8020h
	CX = 00FFh
	ES:DI -> control block
	DX = ID of INDJQRY  
		get environment size
	   = ID of INDJASY
		request DOS functions from workstation
	   = ID of MEMORY
		AL = function
		    01h allocate memory
		    02h deallocate memory
		    03h modify allocated size
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - HOST SERVICES
	AH = 09h
	BX = 4000h for async request, 8028h for synchronous request
	CX = 0000h
	DX = ID of MFIC
	AL = service
	   01h connect to host
	   02h disconnect from host
	   03h read DFT structured data from host
	   04h write DFT structured data to host
	   05h create a host buffer
	ES:DI -> control block
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - GET DATA FROM A QUEUE
	AH = 13h
	???
Return: ???
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - RESOLVE A GATE NAME
	AH = 81h
	ES:DI -> 8-char blank-padded gate name
		"SESSMGR ", "KEYBOARD", "WSCTRL  ", "MFIC    ", "PCPSM	 ",
		"3270EML ", "COPY    ", "XLATE	 ", "OIAM    ", "MEMORY  ",
		"INDJQRY ", or "INDJASY "
Return: DX = gate ID
---------------------------------------------
INT 7A - IBM 3270 Workstation Program API - GET COMPLETION RESULTS
	AH = 83h
	???
Return: ???
---------------------------------------------
INT 7A - IBM Personal Communications/3270 - INSTALLATION CHECK
	AX = FDCBh
Return: DX:AX -> PCS/3270 signature block if loaded (see below)

Format of signature block:
Offset	Size	Description
 04h	WORD	PCS/3270 signature (5741h)
 06h	WORD	version (0501h = PCS/3270 v1.0)
---------------------------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL SEND/RECEIVE FUNCTION
	AX = FE01h
	???
Return: ???
SeeAlso: AX=FE02h
---------------------------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL SEND/RECEIVE FUNCTION
	AX = FE02h
	???
Return: ???
SeeAlso: AX=FE01h
---------------------------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL API INITIALIZATION
	AX = FF01h
	ES:DI -> API function handler routine
Return: CX = 1200h
SeeAlso: AX=FF02h,FF03h
---------------------------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL API TERMINATION
	AX = FF02h
Return: CX = 1200h
SeeAlso: AX=FF01h
---------------------------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL API INITIALIZATION
	AX = FF03h
	ES:DI -> send/receive function handler routine
Return: CX = 1200h
SeeAlso: AX=FF01h
---------------------------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL ???
	AX = FF04h
	ES:DI -> ???
Return: CX = 1200h
---------------------------------------------
INT 7B - Btrieve API
	DS:DX -> 38-byte parameter record (see below)
Return: return code field set
Note:	Btrieve sets low byte of vector to 33h; this serves as the installation
	  check

Format of Btrieve parameter record:
Offset	Size	Description
 00h	DWORD	pointer to data buffer
 04h	WORD	data buffer length
 06h	DWORD	pointer to 90-byte record containing positioning info
		(should be same for all calls for same file)
 0Ah	DWORD	pointer to 38-byte FCB info buffer
		(should be same for all calls for same file)
 0Eh	WORD	function code
		00h open
		01h close
		02h insert
		03h update
		04h delete
		05h get_equal
		06h get_next
		07h get_prev
		08h get_greater
		09h get_gr_eql
		0Ah get_less
		0Bh get_less_eq
		0Ch get_first
		0Dh get_last
		0Eh create
		0Fh stat
		10h extend
		11h set_dir: set directory information
		12h get_dir: get directory information
		13h begin_trans
		14h end_trans
		15h abort_trans
		16h get_pos: get record position number
		17h get_direct: get data by sending record position
		18h step_direct
		19h stop
		1Ah version
		1Bh unlock
		1Ch reset
		1Dh set owner
		1Eh clear owner
		1Fh create supplemental index
		20h drop supplemental index
		21h step first
		22h step last
		23h step next
		31h ???
		37h ???
		38h ???
		39h ???
		3Ah ???
		3Bh ???
		3Ch ???
		3Dh ???
		3Eh ???
		3Fh ???
		add 100 (64h) for a single-record wait lock (automatically
			released on next get)
		add 200 (C8h) for a single-record nowait lock (nowait lock
			returns error 54h or 55h if record already locked)
		add 300 (12Ch) for a multiple-record wait lock (not released
			until unlock called)
		add 400 (190h) for a multiple-record nowait lock (nowait lock
			returns error 54h or 55h if record already locked)
 10h	DWORD	pointer to file name/key buffer
 14h	BYTE	key length
 15h	BYTE	key number
 16h	DWORD	pointer to status code (see below)
 1Ah	WORD	interface code (version specific)

Values for status code:
 00h successful
 01h invalid operation
 02h I/O error
 03h file not open
 04h key value not found
 05h duplicate key value
 06h invalid key number
 07h different key number
 08h invalid positioning
 09h end of file
 0Ah modifiable key value error
 0Bh invalid file name
 0Ch file not found
 0Dh extended file error
 0Eh pre-image open error
 0Fh pre-image I/O error
 10h expansion error
 11h close error
 12h disk full
 13h unrecoverable error
 14h record manager inactive
 15h key buffer too short
 16h data buffer length overrun
 17h position block length
 18h page size error
 19h create I/O error
 1Ah number of keys
 1Bh invalid key position
 1Ch invalid record length
 1Dh invalid key length
 1Eh not a Btrieve file
 1Fh file already extended
 20h extended I/O error
 22h invalid extension name
 23h directory error
 24h transaction error
 25h transaction is active
 26h transaction control file I/O error
 27h end/abort transaction error
 28h transaction max files
 29h operation not allowed
 2Ah incomplete accelerated access
 2Bh invalid record address
 2Ch null key path
 2Dh inconsistent key flags
 2Eh access to file denied
 2Fh maximum open files
 30h invalid alternate sequence definition
 31h key type error
 32h owner already set
 33h invalid owner
 34h error writing cache
 35h invalid interface
 36h variable page error
 37h autoincrement error
 38h incomplete index
 39h expanded memory error
 3Ah compression buffer too short
 3Bh file already exists
 50h conflict
 51h lock error
 52h lost position
 53h read outside transaction
 54h record in use
 55h file in use
 56h file table full
 57h handle table full
 58h incompatible open mode
 5Dh incompatible lock type
 5Eh permission error
---------------------------------------------
INT 7B - Eicon Access API (3270/5250 gateways)
---------------------------------------------
INT 7C - IBM REXX88PC command language
	???
---------------------------------------------
INT 7D - not used
---------------------------------------------
INT 7E - not used
---------------------------------------------
INT 7F - HDILOAD.EXE - 8514/A VIDEO CONTROLLER INTERFACE
	AX = function
	    0105h get entry points
		Return: CF set on error
			CF clear if successful
			    CX:DX -> array of FAR pointers to entry points
Note:	most functions are invoked by pushing the DWORD parameter block pointer
	  and then performing a FAR call via the appropriate vector of the
	  entry point array

Function numbers: (do FAR call via entry_points+4*function)
 08h	HOPEN
 10h	HINT
 13h	HLDPAL
 15h	HBBW
 17h	HBBR
 18h	HBBCHN
 1Dh	HQMODE
 22h	HCLOSE
 30h	HINIT
 31h	HSYNC
 39h	HSPAL
 3Ah	HRPAL 
---------------------------------------------
INT 7F - Halo88 - API
	BX = function
		64h arc
		65h bar
		66h box
		67h circle
		68h clr
		69h default hatch style
		6Ah default line style
		6Bh delhcur
		6Ch delln / deltcur
		6Dh ellipse
		6Eh fill
		6Fh flood
		70h flood2
		71h init graphics
		72h init hcur
		73h init marker
		74h init tcur
		75h inqarc
		76h inqbknd
		77h inqclr
		78h inqerr
		79h inqgcur
		7Ah inqhcur
		7Bh inqmarker
		7Dh inqtcur
		7Eh inqtext
		7Fh lnabs
		80h lnrel
		81h markerabs
		82h markerrel
		83h moveabs
		84h movehcurabs
		85h movehcurrel
		86h moverel
		87h movetcurabs
		88h movetcurrel
		89h movefrom
		8Ah moveto
		8Bh pie
		8Ch polylnabs
		8Dh polylnrel
		8Eh ptabs
		8Fh ptrel
		91h setasp
		92h set color
		93h set font
		94h set hatch style
		95h set line style
		97h settext
		98h set text color
		99h btext
		9Ah setseg
		9Bh display
		9Ch setscreen
		9Eh close graphics
		9Fh ftinit
		A0h ftlocate
		A1h ftext
		A5h set viewport
		A6h set window
		A7h set world
		AAh ftcolor
		ACh initlp
		ADh inqasp
		AEh inqdev
		AFh inqdisplay
		B0h inqft
		B1h inqftcolor
		B2h inqinterlace
		B3h inqlpa
		B4h inqlpg
		B5h inqmode
		B6h inqscreen
		B7h inqversion
		B8h roam
		B9h scroll
		BAh setieee
		BBh set interlace
		BCh shift
		BDh start graphics
		BEh vpan
		CBh gwrite
		CCh gread
		CDh setxor
		CEh rbox
		CFh rcir
		D0h rlnabs
		D1h rlnrel
		D2h delbox
		D3h delcir
		D5h setseg2
		DCh worldoff
		DDh mapwtod
		DEh mapdtow
		DFh mapwton
		E0h mapntow
		E1h mapdton
		E2h mapntod
		E3h inqworld
		E4h inqviewport
		E5h set line width
		E6h lnjoint
		E7h set locator
		E8h read locator
		E9h setdev
		EBh setstext
		ECh setstclr
		EDh setstang
		EEh stext
		EFh inqstext
		F0h setdegree
		F1h inqstsize
		F2h polyfabs
		F3h polyfrel
		F4h inqdrange
		F5h inqstang
		F6h orglocator
		F7h inqlocator
		F8h inqarea
		F9h setipal
		FAh setborder
		FBh inqcrange
		FEh setclip
		FFh fcir
	       100h setcrange
	       101h setdrange
	       102h setlattr
	       103h polycabs
	       104h polycrel
	       108h memcom
	       109h memexp
	       10Ah memmov
	       10Eh movefx
	       10Fh movetx
	       110h inqrgb
	       111h save image
	       112h restore image
	       113h setapal
	       114h setxpal
	       118h inqtsize
	       12Eh gprint
	       130h setprn
	       131h setpattr
	       133h setbattr
	       135h pexpand
	       136h ptnorm
	       137h pfnorm
	       13Bh inqprn
	       13Ch lopen
	       13Dh lclose
	       13Eh lappend
	       13Fh lrecord
	       140h lswitch
	       142h inqfun
	       15Dh lsetup
	       15Eh lrest
	       15Fh lsave
	additional parameters on stack
Return: ???
Notes:	Halo88 is a suite of graphics routines
	according to Stuart Kemp, the code appears to make no provisions for
	   chaining
---------------------------------------------
INT 7F - HLLAPI (IBM 3270 High-Level Language API)
	AX = 0104h (HLLAPI gate ID)
	BX = 0000h
	DS:SI -> parameter control block (see below)
Return: parameter control block updated

Format of parameter control block:
Offset	Size	Description
 00h  3 BYTEs	signature = 'PCB'
 03h	BYTE	function number (see below)
 04h	WORD	segment of control string
 06h	WORD	offset of control string
 08h	WORD	length of control string, unless explicit end-of-str char set
 0Ah	BYTE	unused
 0Bh	WORD	return code
 0Dh	WORD	maximum length of control string

Values for function number:
 00h	Query system (Attachmate implementation only)
 01h	Connect presentation space
 02h	Disconnect presentation space
 03h	Send string of keystrokes as if typed from keyboard
 04h	Wait ~60s, returns status of presentation space
 05h	Copy current presentation space into a user-defined buffer
 06h	Search presentation space for first occurrence of a specified string
 07h	Query cursor location in current presentation space
 08h	Copy part or all of current presentation space into user buffer
 09h	Set session parameters; parameters vary by vendor
 0Ah	Get info on sessions currently connected
 0Bh	Lock current presentation space
 0Ch	Unlock previously locked presentation space
 0Dh	Return copy of operator info area (OIA) of current presentation space
 0Eh	get attribute byte for given position in the current presentation space
 0Fh	copy string of characters to the current presentation space
 10h	workstation control functions
 11h	storage manager functions, intended primarily for BASIC applications
 12h	set delay period in half-second intervals
 14h	get info on level of workstation support used
 15h	reset session parameters to default values
 16h	get detailed info on the current session
 17h	start host notification to application on presentation sp or OIA update
 18h	check host update when host notification enabled
 19h	stop host notification
 1Eh	search field within current presentation space for string
 1Fh	get first positionof a selected field in the current presentation space
 20h	get length of specified field
 21h	copy string into a specified field
 22h	copy specified field into a user-defined buffer
 23h	create alternate presentation space (IBM only), don't use with BASIC
 24h	switch to alternate presentation space (IBM only), not with BASIC
 25h	display cursor in specified area (IBM only), don't use with BASIC
 26h	display alternate presentation space (IBM only), don't use with BASIC
 27h	delete alternate presentation space (IBM only), don't use with BASIC
 32h	start intercepting keystrokes to allow filtering
 33h	get keystrokes after turning on interception
 34h	notify operator when keystroke rejected by filter subroutine
 35h	stop intercepting keystrokes
 5Ah	send file
 5Bh	receive file
 5Ch	run a program
 5Dh	execute DOS command
 63h	change presentation space position to PC display row/col or vice versa
 FFh	Get info on DCA implementation

Session Parameters for function 09h:
 ATTRIB		return attributes in hex
 NOATTRIB	return attributes as blanks
 CONPHYS	make physical connection
 CONLOG		only make logical connection
 EAB		copy extended attribute bytes along with data 
 NOEAB		copy data only
 ESC=n		set escape character to "n" (default '@')
 EOT=n		set end of string character (default 00h)
 FPAUSE		full-duration pause
 IPAUSE		interruptible pause
 STRLEN		use explicit string lengths
 STREOT		use terminated strings
 SRCHALL	search entire presentation space
 SRCHFROM	search from specified offset
 SRCHFRWD	search forward from position 1
 SRCHBKWD	search backward from last position in presentation space
 TWAIT		wait specified time for keyboard ready
 LWAIT		wait until keyboard ready
 NWAIT		no wait
 TRON		enable tracing
 TROFF		disable tracing
 AUTORESET	send reset before sending keys with function 03h
 NORESET	don't send reset
 QUIET		don't display messages sent with INT 21/AH=9
 NOQUIET	allow messages to be displayed
 TIMEOUT=n	set timeout in 30-second intervals, 0 = wait until ^Break
 XLATE		translate extended attribute bytes
 NOXLATE	don't translate
 NEWRET		use HLLAPI v3.0 return code conventions
 OLDRET		use HLLAPI v2.0 return code conventions
---------------------------------------------
INT 7F - CONVERGENT TECHNOLOGIES ClusterShare CTOS ACCESS VECTOR
	AL = request ID
	    01h "Request"/"RequestDirect"
		ES:BX -> pRq
		DX ignored
	    04h "Wait"
		ES:BX -> ppMsgRet
		DX = exchange
	    05h "AllocExch"
		ES:BX -> pExchRet
	    06h "DeAllocExch"
		DX = exchange
	    07h "Check"
		ES:BX -> ppMsgRet
		DX = exchange
	CX = 4354h ('CT')
Return: AX = status
	    0000h successful
---------------------------------------------
INT 80 - Q-PRO4 - ???
---------------------------------------------
INT 80 - reserved for BASIC
---------------------------------------------
INT 81 - reserved for BASIC
---------------------------------------------
INT 82 - reserved for BASIC
---------------------------------------------
INT 83 - reserved for BASIC
---------------------------------------------
INT 84 - reserved for BASIC
---------------------------------------------
INT 85 - reserved for BASIC
---------------------------------------------
INT 86 - Relocated (by NETBIOS) INT 18
---------------------------------------------
INT 86 - used by BASIC while in interpreter
---------------------------------------------
INT 86 - APL*PLUS/PC - Terminate APL session and return to DOS
---------------------------------------------
INT 87 - used by BASIC while in interpreter
---------------------------------------------
INT 87 - APL*PLUS/PC - ????
---------------------------------------------
INT 88 - used by BASIC while in interpreter
---------------------------------------------
INT 88 - APL*PLUS/PC - CREATE OBJECT OF ARBITRARY RANK OR SHAPE
	AL = 00h
	BX = STPTR of the variable to be assigned
	ES:SI -> model of type, rank, and shape (see below)
Return: ES:DI -> first data byte of object
	DX:CX = number of elements in the object
Format of shape model:
Offset	Size	Description
 00h	BYTE	type
		01h character (2-byte dimension sizes)
		02h integer (2-byte dimension sizes)
		08h floating point (2-byte dimension sizes)
		11h character (4-byte dimension sizes)
		12h integer (4-byte dimension sizes)
		18h floating point (4-byte dimension sizes)
 01h	BYTE	rank
 02h	WORD/DWORD first dimension of shape
 N	WORD/DWORD second dimension of shape
	...
---------------------------------------------
INT 88 - APL*PLUS/PC - CREATE CHARACTER SCALAR/VECTOR/MATRIX <64K IN SIZE
	AL = 01h
	AH = rank
	BX = STPTR of the variable to be assigned
	CX = first dimension (if any)
	DX = second dimension (if any)
Return: ES:DI -> object
	CX = number of elements in the object
Note:	each dimension must be 32767 or smaller
SeeAlso: AL=02h,08h
---------------------------------------------
INT 88 - APL*PLUS/PC - CREATE INTEGER SCALAR/VECTOR/MATRIX <64K IN SIZE
	AL = 02h
	AH = rank
	BX = STPTR of the variable to be assigned
	CX = first dimension (if any)
	DX = second dimension (if any)
Return: ES:DI -> object
	CX = number of elements in the object
Note:	each dimension must be 32767 or smaller
SeeAlso: AL=01h,08h
---------------------------------------------
INT 88 - APL*PLUS/PC - CREATE FLOATING POINT SCALAR/VECTOR/MATRIX <64K IN SIZE
	AL = 08h
	AH = rank
	BX = STPTR of the variable to be assigned
	CX = first dimension (if any)
	DX = second dimension (if any)
Return: ES:DI -> object
	CX = number of elements in the object
Note:	each dimension must be 32767 or smaller
SeeAlso: AL=01h,02h
---------------------------------------------
INT 88 - APL*PLUS/PC - FORCE OBJECT INTO REAL WORKSPACE FROM VIRTUAL
	AL = F5h
	BX = STPTR of object
---------------------------------------------
INT 88 - APL*PLUS/PC - MAKE NAME IMMUNE FROM OUTSWAPPING
	AL = F6h
	BX = STPTR of object
SeeAlso: AL=F7h,F8h
---------------------------------------------
INT 88 - APL*PLUS/PC - MAKE NAME ELIGIBLE FOR OUTSWAPPING
	AL = F7h
	BX = STPTR of object
SeeAlso: AL=F6h,F8h
---------------------------------------------
INT 88 - APL*PLUS/PC - REPORT WHETHER NAME IS ELIGIBLE FOR OUTSWAPPING
	AL = F8h
	BX = STPTR of object
Return:  BX = 0000h eligible
	      0001h not eligible
SeeAlso: AL=F6h,F7h
---------------------------------------------
INT 88 - APL*PLUS/PC - DETERMINE NAME STATUS
	AL = F9h
	ES:SI -> name
	CX = length of name
Return: CF set if name ill-formed or already in use
	    BX = STPTR if already in symbol table
	CF clear if name is available for use
	    BX = 0000h
Note:	does not force the name into the workspace
SeeAlso: AL=FEh,FFh
---------------------------------------------
INT 88 - APL*PLUS/PC - DETERMINE IF MEMORY AVAIL WITHOUT GARBAGE COLLECTION
	AL = FCh
	BX = amount of memory needed (paragraphs)
Return: CF clear if memory available
	CF set if a workspace compaction is required
SeeAlso: AL=FDh
---------------------------------------------
INT 88 - APL*PLUS/PC - PERFORM GARBAGE COLLECTION AND RETURN AVAILABLE MEMORY
	AL = FDh
Return: BX = number of paragraphs available in workspace
SeeAlso: AL=FCh
---------------------------------------------
INT 88 - APL*PLUS/PC - CREATE NAME
	AL = FEh
	ES:SI -> name
	CX = length of name
Return: BX = STPTR of name
	DX = interpreter's data segment
SeeAlso: AL=F9h,FFh
---------------------------------------------
INT 88 - APL*PLUS/PC - DETERMINE NAME STATUS
	AL = FFh
	ES:SI -> name
	CX = length of name
Return: CF set if name ill-formed or already in use
	    BX = STPTR if already in symbol table
	CF clear if name is available for use
	    BX = 0000h
Note:	forces the name into the workspace and makes it immune from outswapping
SeeAlso: AL=F9h,FEh
---------------------------------------------
INT 89 - used by BASIC while in interpreter
---------------------------------------------
INT 8A - used by BASIC while in interpreter
---------------------------------------------
INT 8A - APL*PLUS/PC - PRINT SCREEN
Note:	same as INT 05
SeeAlso: INT 05
---------------------------------------------
INT 8B - used by BASIC while in interpreter
---------------------------------------------
INT 8B - APL*PLUS/PC - BEEP
Note:	same as printing a ^G via INT 21/AH=02h
SeeAlso: INT 21/AH=02h
---------------------------------------------
INT 8C - used by BASIC while in interpreter
---------------------------------------------
INT 8C - CLEAR SCREEN MEMORY
	AX = 0000h do not save display attributes
	   = 0001h save attributes
---------------------------------------------
INT 8D - used by BASIC while in interpreter
---------------------------------------------
INT 8E - used by BASIC while in interpreter
---------------------------------------------
INT 8F - used by BASIC while in interpreter
---------------------------------------------
INT 90 - used by BASIC while in interpreter
---------------------------------------------
INT 90 - APL*PLUS/PC - USED BY PORT 10 PRINTER DRIVER
---------------------------------------------
INT 91 - used by BASIC while in interpreter
---------------------------------------------
INT 92 - used by BASIC while in interpreter
---------------------------------------------
INT 92 - Sangoma X.25 INTERFACE PROGRAM
	BX:DX -> control block
---------------------------------------------
INT 93 - used by BASIC while in interpreter
---------------------------------------------
INT 94 - used by BASIC while in interpreter
---------------------------------------------
INT 95 - used by BASIC while in interpreter
---------------------------------------------
INT 95 - APL*PLUS/PC - DETERMINE R= SPACE
Note:	use only when the R= option is invoked on entering APL
---------------------------------------------
INT 96 - used by BASIC while in interpreter
---------------------------------------------
INT 97 - used by BASIC while in interpreter
---------------------------------------------
INT 98 - used by BASIC while in interpreter
---------------------------------------------
INT 99 - used by BASIC while in interpreter
---------------------------------------------
INT 9A - used by BASIC while in interpreter
---------------------------------------------
INT 9B - used by BASIC while in interpreter
---------------------------------------------
INT 9C - used by BASIC while in interpreter
---------------------------------------------
INT 9D - used by BASIC while in interpreter
---------------------------------------------
INT 9E - used by BASIC while in interpreter
---------------------------------------------
INT 9F - used by BASIC while in interpreter
---------------------------------------------
INT A0 - used by BASIC while in interpreter
---------------------------------------------
INT A0 - APL*PLUS/PC - USED BY APL/GSS*CGI GRAPHICS INTERFACE
SeeAlso: INT 59
---------------------------------------------
INT A1 - used by BASIC while in interpreter
---------------------------------------------
INT A2 - used by BASIC while in interpreter
---------------------------------------------
INT A3 - used by BASIC while in interpreter
---------------------------------------------
INT A4 - used by BASIC while in interpreter
---------------------------------------------
INT A4 - Right Hand Man API
	function number in AH
Note: Right-Hand Man is a TSR desk-top utility, and only hooks this interrupt
	while popped up
---------------------------------------------
INT A5 - used by BASIC while in interpreter
---------------------------------------------
INT A6 - used by BASIC while in interpreter
---------------------------------------------
INT A7 - used by BASIC while in interpreter
---------------------------------------------
INT A8 - used by BASIC while in interpreter
---------------------------------------------
INT A9 - used by BASIC while in interpreter
---------------------------------------------
INT AA - used by BASIC while in interpreter
---------------------------------------------
INT AB - used by BASIC while in interpreter
---------------------------------------------
INT AC - used by BASIC while in interpreter
---------------------------------------------
INT AD - used by BASIC while in interpreter
---------------------------------------------
INT AE - used by BASIC while in interpreter
---------------------------------------------
INT AF - used by BASIC while in interpreter
---------------------------------------------
INT B0 - used by BASIC while in interpreter
---------------------------------------------
INT B1 - used by BASIC while in interpreter
---------------------------------------------
INT B2 - used by BASIC while in interpreter
---------------------------------------------
INT B3 - used by BASIC while in interpreter
---------------------------------------------
INT B3 - ZIPKEY - GET VERSION
	AH = 70h
Return: AH = major version
	AL = minor version
	CL = number of states and territories in current database
	DH = year of current database - 1900
	DL = month of current database's file date
Notes:	if installed, the string "ZIPKEY" is present at offset 75h in the
	  interrupt handler's segment, and the byte at 7Bh contains the API
	  version number (currently 00h)
	ZIPKEY is a resident ZIPCODE database by Eric Isaacson
---------------------------------------------
INT B3 - ZIPKEY - CONVERT TWO-LETTER ABBREVIATION TO STATE CODE
	AH = 71h
	BX = abbreviation, in either case
Return: CF set on error
	    AL = FFh
	CF clear if successful
	    AL = ZIPKEY state code
SeeAlso: AH=72h
---------------------------------------------
INT B3 - ZIPKEY - CONVERT STATE CODE TO TWO-LETTER ABBREVIATION
	AH = 72h
	BL = ZIPKEY state code
Return: CF set on error
	CF clear if successful
	    AX = abbreviation, in upper case
SeeAlso: AH=71h,73h
---------------------------------------------
INT B3 - ZIPKEY - CONVERT STATE CODE TO STATE NAME
	AH = 73h
	BL = ZIPKEY state code
	ES:DI -> buffer for name
Return: CF set on error
	CF clear if successful
	    ES:DI points one byte beyond end of name
SeeAlso: AH=72h
---------------------------------------------
INT B3 - ZIPKEY - CONVERT ZIPCODE TO ASCII DIGITS
	AH = 74h
	DX = zipcode region (0-999)
	CH = last two digits of zipcode (0-99)
	ES:DI -> buffer
Return: CF set on error
	CF clear if successful
	    ES:DI points one byte beyond end of digit string
---------------------------------------------
INT B3 - ZIPKEY - LOOK UP STATE CODE FOR ZIPCODE
	AH = 75h
	DX = zipcode region (0-999)
	CH = last two digits of zipcode (0-99)
Return: CF set on error (zipcode not found)
	    AL = suggested state code, FFh if none
	CF clear if successful
	    AL = ZIPKEY state code
SeeAlso: AH=76h,79h
---------------------------------------------
INT B3 - ZIPKEY - LOOK UP CITY AND STATE FOR ZIPCODE
	AH = 76h
	DX = zipcode region (0-999)
	CH = last two digits of zipcode (0-99)
	ES:DI -> buffer for name
Return: CF set on error
	    AL = suggested state code, FFh if none
	    ES:DI buffer filled with suggested city name
	CF clear if successful
	    AL = ZIPKEY state code
	    ES:DI points one byte beyond end of name
SeeAlso: AH=75h,78h
---------------------------------------------
INT B3 - ZIPKEY - PLAY BACK EXIT KEY FOR ENTRY WITH GIVEN ZIPCODE
	AH = 77h
	DX = zipcode region (0-999)
	CH = last two digits of zipcode (0-99)
	BX = 16-bit BIOS keycode for a defined ZIPKEY alternate exit key
Return: CF set on error
	CF clear if successful	
	    zipcode specification as defined by the BX keystroke is placed in
	      keyboard buffer, as if the user had popped up ZIPKEY and exited
	      by pressing the key specified by BX
---------------------------------------------
INT B3 - ZIPKEY - LOOK UP ZIPCODES FOR A GIVEN STATE AND CITY
	AH = 78h
	BL = ZIPKEY state code
	DS:SI -> city name, terminated with 0Dh if complete name, 00h if prefix
Return: BH = number of matching entries (set to 51 if more than 50)
	DX = zipcode region of first match (0-999)
	CL = last two digits of first zipcode in the range (0-99)
	CH = last two digits of last zipcode in the range (0-99)
SeeAlso: AH=79h,7Ah
---------------------------------------------
INT B3 - ZIPKEY - LOOK UP ZIPCODES FOR A GIVEN CITY
	AH = 79h
	BL = ZIPKEY state code of first state to search
	DS:SI -> city name, terminated with 0Dh if complete name, 00h if prefix
Return:	AL = ZIPKEY state code of first matching state
	BH = number of matching entries (set to 51 if more than 50)
	DX = zipcode region of first match (0-999)
	CL = last two digits of first zipcode in first range (0-99)
	CH = last two digits of last zipcode in first range (0-99)
Note:	to find all matching cities, repeat search with BL set to one more than
	  the returned AL
SeeAlso: AH=78h,7Ah
---------------------------------------------
INT B3 - ZIPKEY - FETCH AN ENTRY FROM A PREVIOUS LOOKUP
	AH = 7Ah
	BL = case number (0 to one less than value returned in BH by lookup)
Return: AL = ZIPKEY state code
	DX = zipcode region (0-999)
	CL = last two digits of first zipcode in the range (0-99)
	CH = last two digits of last zipcode in the range (0-99)
SeeAlso: AH=78h,79h
---------------------------------------------
INT B3 - ZIPKEY - GET VALUES NEEDED TO SAVE ZIPKEY CONTEXT
	AH = 7Bh
Return: BL = maximum number of characters for a city name
	BH = ZIPKEY state code for last city-name search
	    FFh if none
	CX:DX = internal code identifying last city search
SeeAlso: AH=7Ch
---------------------------------------------
INT B3 - ZIPKEY - RESTORE ZIPKEY CONTEXT
	AH = 7Ch
	BL = maximum number of characters for a city name
	BH = ZIPKEY state code for last city-name search
	    FFh if none
	CX:DX = internal code returned by AH=7Bh
Return: CF set on error
	CF clear if successful
SeeAlso: AH=7Bh
---------------------------------------------
INT B3 - ZIPKEY - REQUEST POP UP
	AH = 7Dh
	BL = index number to simulate pressing a hotkey
	    FFh for immediate popup with no playback on return
Return: CF set on error
	    AL = FDh already busy with another request
	       = FEh illegal function
	CF clear if successful
	    window popped up and was closed by the user
---------------------------------------------
INT B3 - ZIPKEY - GET NAME OF PRIMARY CITY FOR A ZIPCODE REGION
	AH = 7Eh
	DX = zipcode region (0-999)
	ES:DI -> buffer for name
Return: CF set on error
	    AL = FFh region does not exist
	CF clear if successful
	    AL = ZIPKEY state code
	    ES:DI points one byte beyond end of name
---------------------------------------------
INT B3 - ZIPKEY - ENABLE/DISABLE HOTKEYS
	AH = 7Fh
	BL = function
	    00h turn off hotkeys
	    01h turn on hotkeys
	    02h return hotkey status
	    03h toggle hotkey status
Return: AL = hotkey status
	    00h off
	    01h on
---------------------------------------------
INT B4 - used by BASIC while in interpreter
---------------------------------------------
INT B5 - used by BASIC while in interpreter
---------------------------------------------
INT B6 - used by BASIC while in interpreter
---------------------------------------------
INT B7 - used by BASIC while in interpreter
---------------------------------------------
INT B8 - used by BASIC while in interpreter
---------------------------------------------
INT B9 - used by BASIC while in interpreter
---------------------------------------------
INT BA - used by BASIC while in interpreter
---------------------------------------------
INT BB - used by BASIC while in interpreter
---------------------------------------------
INT BC - used by BASIC while in interpreter
---------------------------------------------
INT BD - used by BASIC while in interpreter
---------------------------------------------
INT BE - used by BASIC while in interpreter
---------------------------------------------
INT BF - used by BASIC while in interpreter
---------------------------------------------
INT C0 - used by BASIC while in interpreter
---------------------------------------------
INT C1 - used by BASIC while in interpreter
---------------------------------------------
INT C2 - used by BASIC while in interpreter
---------------------------------------------
INT C3 - used by BASIC while in interpreter
---------------------------------------------
INT C4 - used by BASIC while in interpreter
---------------------------------------------
INT C5 - used by BASIC while in interpreter
---------------------------------------------
INT C6 - used by BASIC while in interpreter
---------------------------------------------
INT C6 - APL*PLUS/PC - IDENTICAL TO INT 86
Note:	STSC moved its interrupts from 86h-8Ch to C6h-CCh, but did not delete
	  the older interrupts
---------------------------------------------
INT C7 - used by BASIC while in interpreter
---------------------------------------------
INT C7 - APL*PLUS/PC - ???
---------------------------------------------
INT C8 - used by BASIC while in interpreter
---------------------------------------------
INT C8 - APL*PLUS/PC - IDENTICAL TO INT 88
Note:	STSC moved its interrupts from 86h-8Ch to C6h-CCh, but did not delete
	  the older interrupts
---------------------------------------------
INT C9 - used by BASIC while in interpreter
---------------------------------------------
INT C9 - APL*PLUS/PC - ???
---------------------------------------------
INT CA - used by BASIC while in interpreter
---------------------------------------------
INT CA - APL*PLUS/PC - IDENTICAL TO INT 8A
Note:	STSC moved its interrupts from 86h-8Ch to C6h-CCh, but did not delete
	  the older interrupts
---------------------------------------------
INT CB - used by BASIC while in interpreter
---------------------------------------------
INT CB - APL*PLUS/PC - IDENTICAL TO INT 8B
Note:	STSC moved its interrupts from 86h-8Ch to C6h-CCh, but did not delete
	  the older interrupts
---------------------------------------------
INT CC - used by BASIC while in interpreter
---------------------------------------------
INT CC - APL*PLUS/PC - IDENTICAL TO INT 8C
Note:	STSC moved its interrupts from 86h-8Ch to C6h-CCh, but did not delete
	  the older interrupts
---------------------------------------------
INT CD - used by BASIC while in interpreter
---------------------------------------------
INT CD - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT CE - used by BASIC while in interpreter
---------------------------------------------
INT CE - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT CF - used by BASIC while in interpreter
---------------------------------------------
INT CF - APL*PLUS/PC - DEFAULT LOW-RESOLUTION TIMER FOR QUAD MF FUNCTION
---------------------------------------------
INT D0 - used by BASIC while in interpreter
---------------------------------------------
INT D0 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D1 - used by BASIC while in interpreter
---------------------------------------------
INT D1 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D2 - used by BASIC while in interpreter
---------------------------------------------
INT D2 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D3 - used by BASIC while in interpreter
---------------------------------------------
INT D3 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D4 - used by BASIC while in interpreter
---------------------------------------------
INT D4 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D5 - used by BASIC while in interpreter
---------------------------------------------
INT D5 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D6 - used by BASIC while in interpreter
---------------------------------------------
INT D6 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D7 - used by BASIC while in interpreter
---------------------------------------------
INT D7 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D8 - used by BASIC while in interpreter
---------------------------------------------
INT D8 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT D9 - used by BASIC while in interpreter
---------------------------------------------
INT D9 - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT DA - used by BASIC while in interpreter
---------------------------------------------
INT DA - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT DB - used by BASIC while in interpreter
---------------------------------------------
INT DB - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT DC - used by BASIC while in interpreter
---------------------------------------------
INT DC - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT DD - used by BASIC while in interpreter
---------------------------------------------
INT DD - STSC APL*PLUS/PC - MAY BE USED IN FUTURE RELEASES
---------------------------------------------
INT DE - used by BASIC while in interpreter
---------------------------------------------
INT DE - APL*PLUS/PC - ???
Note:	appears to be the same as INT 16
---------------------------------------------
INT DF - used by BASIC while in interpreter
---------------------------------------------
INT DF - APL*PLUS/PC - SAME AS INT 10
SeeAlso: INT 10
---------------------------------------------
INT E0 - CP/M-86 function calls
---------------------------------------------
INT E0 - used by BASIC while in interpreter
---------------------------------------------
INT E0 - APL*PLUS/PC - RESTIME HIGH-RESOLUTION TIMER FOR QUAD MF FUNCTION
---------------------------------------------
INT E1 - used by BASIC while in interpreter
---------------------------------------------
INT E2 - used by BASIC while in interpreter
---------------------------------------------
INT E3 - used by BASIC while in interpreter
---------------------------------------------
INT E4 - Logitech Modula v2.0 - MonitorEntry
	AX = 0005h
	BX = priority
SeeAlso: AX=0006h
---------------------------------------------
INT E4 - Logitech Modula v2.0 - MonitorExit
	AX = 0006h
SeeAlso: AX=0005h
---------------------------------------------
INT E4 - used by BASIC while in interpreter
---------------------------------------------
INT E5 - used by BASIC while in interpreter
---------------------------------------------
INT E6 - used by BASIC while in interpreter
---------------------------------------------
INT E7 - used by BASIC while in interpreter
---------------------------------------------
INT E8 - used by BASIC while in interpreter
---------------------------------------------
INT E9 - used by BASIC while in interpreter
---------------------------------------------
INT EA - used by BASIC while in interpreter
---------------------------------------------
INT EB - used by BASIC while in interpreter
---------------------------------------------
INT EC - used by BASIC while in interpreter
---------------------------------------------
INT ED - used by BASIC while in interpreter
---------------------------------------------
INT EE - used by BASIC while in interpreter
---------------------------------------------
INT EF - used by BASIC while in interpreter
---------------------------------------------
INT EF - compiled BASIC - ORIGINAL INT 09 VECTOR
---------------------------------------------
INT EF - GEM - INTERFACE
	CX = 0473h
	DS:DX -> GEM parameter block
---------------------------------------------
INT F0 - used by BASIC while in interpreter
---------------------------------------------
INT F0 - compiled BASIC - ORIGINAL INT 08 VECTOR
---------------------------------------------
INT F1 - reserved for user interrupt
---------------------------------------------
INT F1 - SPEECH.COM - CONVERT TEXT STRING TO SPEECH
	DS:BX -> '$'-terminated text string
Note:	SPEECH.COM is a resident text-to-speech converter by Douglas Sisco
---------------------------------------------
INT F2 - reserved for user interrupt
---------------------------------------------
INT F3 - reserved for user interrupt
---------------------------------------------
INT F4 - reserved for user interrupt
---------------------------------------------
INT F5 - reserved for user interrupt
---------------------------------------------
INT F6 - reserved for user interrupt
---------------------------------------------
INT F7 - reserved for user interrupt
---------------------------------------------
INT F8 - 10 ms INTERVAL TIMER (TANDY???)
---------------------------------------------
INT F9 - reserved for user interrupt
---------------------------------------------
INT FA - USART READY (RS-232C) (TANDY???)
---------------------------------------------
INT FB - USART Rx READY (keyboard) (TANDY???)
---------------------------------------------
INT FC - reserved for user interrupt
---------------------------------------------
INT FD - reserved for user interrupt
---------------------------------------------
INT FE - AT/XT286/PS50+ - destroyed by return from protected mode
---------------------------------------------
INT FF - AT/XT286/PS50+ - destroyed by return from protected mode
---------------------------------------------
INT FF - Z100 - WARM BOOT
---------------------------------------------
Please redistribute the following files unmodified as a group, in an archive
named INTER590:
	INTERRUP.1ST	the read-me file, containing credits, availability info
	INTERRUP.A	INT 00 through INT 1F
	INTERRUP.B	INT 20 through INT 27
	INTERRUP.C	INT 28 through INT 5F
	INTERRUP.D	INT 60 through INT FF
	INTERRUP.PRI	a brief introduction to interrupts
	INTPRINT.COM	a simple formatter that also generates the list summary
	INTPRINT.DOC	instructions for INTPRINT
	INTPRINT.C	source code for INTPRINT
	MEMORY.LST	format of the BIOS data area
This compilation is Copyright (c) 1989, 1990 Ralf Brown
---------------------------------------------
ARPA: ralf@cs.cmu.edu
UUCP: {ucbvax,harvard}!cs.cmu.edu!ralf
BIT:  ralf%cs.cmu.edu@cmuccvma
FIDO: Ralf Brown 1:129/3.1
	or post a message to the DR_DEBUG echo
CIS:  >INTERNET:ralf@cs.cmu.edu
