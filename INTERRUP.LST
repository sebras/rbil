While you may want to remove the following header from this file for
your own use, please do not redistribute the file without it, so that
credit may be given where credit is due.
-----------------------------------------------------------
Last edited 12/5/87

This list is the result of the time and effort of a large number of people,
among them
     Janet Jack        January 1985  (original list)
     J. Weaver Jr.     January 1985
     John Cooper       February 1985
     Skip Gilbrech     February 1985
     Bob Jack
     Jim Kyle          April 1985
     John Ruschmeyer   <ihnp4!vax135!petsd!moncol!john> August 1985
     Bill Frolik       <ihnp4!hplabs!hp-pcd!bill>       August 1985
     Ross M. Greenberg <greenber%timeinc.uucp@brl.arpa> August 1985

     Dan Lanciani  <ddl@harvard.*>   TANDY function calls
     Ralf Brown    <ralf@cs.cmu.edu> INT 24h and DOS func 59h error codes
     Dan Davison   <dd@lanl.gov>     DOS 3.3 function calls      11/87
     Bill White    <wwhite@teknowledge-vaxc.arpa> DOS 3.3        11/87
     Richard Hargrove <killer!richardh@harvard.harvard.edu> EGA  11/87
     Vincent Broman <broman@bugs.nosc.mil> Cordata BIOS/Minix    12/87

Information on the INT 10h functions supported by the EGA BIOS was derived
from the article "Graphic Enhancement" found in the April 1985 _PC Tech
Journal_, pages 58ff., and is marked with the string {ega}. jrh.

Information on functions unique to the Portable PC and the Convertible was
derived from a similar list compiled by David E. Powell, and added by
Ralf Brown on 11/14/87.

Information on LIM EMS 3.2 functions was derived from _Advanced_MSDOS_, by
Ray Duncan. Added by Ralf Brown 11/19/87.

Information on LIM EMS 4.0 functions was derived from the transcription of
the specification by Dick Flanagan and Ben Lomond.  Added by Ralf Brown,
11/20/87
-----------------------------------------------------------
If you know any information which is not in this list, or which is
incorrect, please let me know!

               Ralf Brown
         Arpa: ralf@cs.cmu.edu
         UUCP: {uunet,ucbvax,harvard}!cs.cmu.edu!ralf
         BIT:  ralf%cs.cmu.edu@cmuccvma
         FIDO: Ralf Brown at 1:129/31  (more subject to change than the others)
-----------------------------------------------------------
INT 0 - DIVIDE ERROR
   Automatically called at end of DIV or IDIV operation that results in
   error.  Normally set by DOS to display an error message and abort the
   program.
-----------------------------------------------------------
INT 1 - SINGLE-STEP
   Generated at end of each machine instruction if TF bit in FLAGS is set.
   This is what makes the T command of DEBUG work for single-stepping.  Is
   not generated after MOV to segment register or POP of segment register
   (unless you have a very early 8088 with a microcode bug).
-----------------------------------------------------------
INT 2 - NMI (Non Maskable Interrupt)
   Generated by NMI signal in hardware. Used in IBM for memory parity
   error trapping.
-----------------------------------------------------------
INT 3 - 1-BYTE INTERRUPT
   Generated by opcode 0CCh. Similar to 8080's RST instruction.  Generally
   used to set breakpoints for DEBUG.
-----------------------------------------------------------
INT 4 - Overflow (internal interrupt)
   Generated by INTO instruction if OF flag is set. If flag is not set,
   INTO is effectively a NOP. Used to trap any arithmetic errors when
   program is ready to handle them rather than immediately when they occur.
-----------------------------------------------------------
INT 5 - Print-Screen Key
   Automatically called by keyboard scan when print-screen key is pressed.
   Normally executes routine to print the screen, but may call any routine
   that can safely be executed from inside the keyboard scanner.  Status
   and result byte for default handler is at address 0050:0000.
-----------------------------------------------------------
INT 5 - BOUND check failed (80286 internal interrupt)
-----------------------------------------------------------
INT 6 - Undefined Opcode (80286 internal interrupt)
-----------------------------------------------------------
INT 7 - No Math Unit Available (80286 protected-mode internal)
-----------------------------------------------------------
INT 8 thru 0F - Vectored Hardware Lines
   In IBM, these 8 interrupts are generated in response to IRQ 0 through
   IRQ 7 (if enabled via port 21h).
                                         [Tandy 1000]
        IRQ0  -  timer interrupt
        IRQ1  -  keyboard interrupt
        IRQ2  -  EGA vertical retrace    [fixed disk]
        IRQ3  -  serial port 2 (com2:)
        IRQ4  -  serial port 1 (com1:)
        IRQ5  -  fixed disk              [60 Hz ram refresh]
                 (LPT2 on PC/AT)
        IRQ6  -  diskette interrupt
        IRQ7  -  PPI interrupt (lpt1:, lpt2:)
-----------------------------------------------------------
INT 8 - Double Fault (80286 protected-mode internal)
-----------------------------------------------------------
INT 9 - Math Unit Protection Fault (80286 protected-mode internal)
-----------------------------------------------------------
INT 0A - Invalid Task State Segment (80286 protected-mode internal)
-----------------------------------------------------------
INT 0B - Not Present (80286 protected-mode internal)
-----------------------------------------------------------
INT 0C - Stack Fault (80286 protected-mode internal)
-----------------------------------------------------------
INT 0D - General Protection Violation (80286 internal interrupt)
         Called in real mode when an instruction attempts to access a word
         operand located at offset 0FFFFh
-----------------------------------------------------------
INT 0E - Page Fault (80386 native-mode internal)
-----------------------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE
        AH = 0
        AL = mode
            0 = 40x25 B&W
            1 = 40x25 color
            2 = 80x25 B&W
            3 = 80x25 color
            4 = 320x200 graphics, 4 color
            5 = 320x200 graphics, 4-tone gray scale
            6 = 640x200 graphics, B&W
            7 = monochrome
            8 = 160x200 graphics, 16 color (PCjr/Tandy 1000)
            9 = 320x200 graphics, 16 color(PCjr/Tandy 1000)
           0Ah = 640x200 graphics, 4 color (PCjr/Tandy 1000)
           0Bh = reserved (used internally by EGA BIOS)
           0Ch = reserved (used internally by EGA BIOS)
           0Dh = 320x200 graphics, 16 color (EGA)
           0Eh = 640x200 graphics, 16 color (EGA)
           0Fh = 640x350 graphics, monochrome (EGA)
           10h = 640x350 graphics, 4 or 16 color (EGA)
           11h = ???x??? graphics, ??? colors (VGA)
           12h = ???x??? graphics, ??? colors (VGA)
           13h = ???x??? graphics, ??? colors (VGA)
           30h = ???x??? (AT&T 6300)
           40h = 640x400 graphics (AT&T 6300)
           60h = 400 line graphics+80 column text (Corona/Cordata BIOS v4.10+)
           61h = 400 line graphics (Corona/Cordata BIOS v4.10+)
           74h = 640x400 graphics (Toshiba 3100)
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR CHARACTERISTICS
        AH = 1
        CH bits 5-6 = blink attribute
                     (00=normal, 01=invisible, 10 = slow, 11=fast)
        CH bits 0-4 = start line for cursor in char. cell
        CL bits 0-4 = end line for cursor in char. cell
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
        AH = 2
        DH,DL = row, column (0,0 = upper left)
        BH = page number
            0 in graphics modes
            0-3 in modes 2&3
            0-7 in modes 0&1
-----------------------------------------------------------
INT 10 - VIDEO - READ CURSOR POSITION
        AH = 3
        BH = page number
            0 in graphics modes
            0-3 in modes 2&3
            0-7 in modes 0&1
Return: DH = row
        DL = column
        CH = cursor start line
        CL = cursor end line
-----------------------------------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION
        AH = 4
Return: AH = 0: light pen switch not activated
        AH = 1: light pen values in registers
            DH = row of current position
            DL = column of current position
            CH = raster line (0-199) {ega} old graphics modes
            CX = {ega} raster line (0-nnn) new graphics modes
            BX = pixel column (0-319 or 0-639)
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DISPLAY PAGE
        AH = 5
        AL =
            0-7: new page value for modes 0 & 1
            0-3: new page value for modes 2 & 3
            80h: read CRT/CPU page registers [PCjr only]
            81h: set CPU page register to value in BL [PCjr only]
            82h: set CRT page register to value in BH [PCjr only]
            83h: set both display registers [PCjr only]
            {Corona/Cordata BIOS v4.10+}
            0: set address of graphics bitmap buffer (video modes 60h,61h)
               BX = segment of buffer
            0Fh: get address of graphics bitmap buffer (video modes 60h,61h)
Return: BH = CRT page register (if AL >= 80h)
        BL = CPU page register (if AL >= 80h)
        DX = segment of graphics bitmap buffer (video modes 60h,61h; AL=0Fh)
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE UP
        AH = 6
        AL = number of lines to scroll window (0 = blank whole window)
        BH = attributes to be used on blanked lines
        CH,CL = row,column of upper left corner of window to scroll
        DH,DL = row,column of lower right corner of window
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE DOWN
        AH = 7
        AL = number of lines to scroll window (0 = blank whole window)
        BH = attributes to be used on blanked lines
        CH,CL = row,column of upper left corner of window to scroll
        DH,DL = row,column of lower right corner of window
-----------------------------------------------------------
INT 10 - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
        AH = 8
        BH = display page
Return: AL = character
        AH = attribute of character (alpha modes)
-----------------------------------------------------------
INT 10 - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POS
        AH = 9
        AL = character
        BH = display page - alpha mode
        BL = attributes of char (alpha modes) or color (graphics modes)
             if bit 7 == 1 in graphics mode, character is xor'ed onto screen
        CX = number of times to write character
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POS
        AH = 0Ah
        AL = character
        BH = display page - alpha mode
        BL = color of character (graphics mode)
        CX = number of times to write character
             {ega} in graphics modes, replication count in CX works correctly
             only if all character written are contains on the same row
-----------------------------------------------------------
INT 10 - VIDEO - SET COLOR PALETTE
        {ega} CGA-compatible modes
        AH = 0Bh
        BH = palette color ID
        BL = color to be used with color ID
        {ega} (graphics modes)
        if BH == 0, BL contains background and border colors (0-15)
        if BH == 1, BL contains palette being selected (0-1)
              (text modes)
        if BH == 0, BL contains border color (0-15) only
                    {ega} BL contains border color (0-15) and high-intensity
                    background color (16-31)
-----------------------------------------------------------
INT 10 - VIDEO - WRITE DOT ON SCREEN
        AH = 0Ch
        AL = color of dot (0/1 in mode 6, 0-3 in modes 4 and 5)
             if bit 7 set, new color will be XORed with current pixel
        DX = row (0 - 199)
        CX = column (0 - 319 in modes 4/5, 0 - 639 in mode 6)
        Note: video modes 4-6 only
-----------------------------------------------------------
INT 10 - VIDEO - READ DOT ON SCREEN
        AH = 0Dh
        CX = column (0 - 319 or 639)
        DX = row (0 - 199)
Return: AL = color read
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
        AH = 0Eh
        AL = character
        BH = display page (alpha modes)
        BL = foreground color (graphics modes)
-----------------------------------------------------------
INT 10 - VIDEO - GET CURRENT VIDEO MODE
        AH = 0Fh
Return: AH = number of columns on screen
        AL = current video mode
        BH = current active display page
-----------------------------------------------------------
INT 10 - VIDEO - SET PALETTE REGISTERS (PCjr, TANDY 1000, {ega})
        AH = 10h
        AL = 0: set palette register
                BL = palette register to set
                BH = color value to store
        AL = 1: set border color register
                BH = color value to store
        AL = 2: set all palette registers
                ES:DX = pointer to 17-byte list
                        bytes 0-15 = values for palette regs. 0-15
                        byte 16 = value for border register
        {ega}
        AL = 3: toggle intensity/blinking bit
                BL = 0: enable intensity
                BL = 1: enable blink
-----------------------------------------------------------
INT 10 - Character generator functions {ega}
        AH = 11h
        The following functions will cause a mode set, completely resetting
        the video environment, but without clearing the video buffer
        AL = 00h, 10h: load user-specified patterns
            ES:BP = pointer to user table
            CX    = count of patterns to store
            DX    = character offset into map 2 block
            BL    = block to load in map 2
            BH    = number of bytes per character pattern
        AL = 01h, 11h: load ROM monochrome patterns (8 by 14)
            BL    = block to load
        AL = 02h, 12h: load ROM 8 by 8 double-dot patterns
            BL    = block to load
        AL = 03h: set block specifier
            BL    = block specifier
        The routines called with AL=1x are designed to be called only
        immediately after a mode set and are similar to the routines called
        with AL=0x, except that:
              Page 0 must be active.
              Bytes/character is recalculated.
              Max character rows is recalculated.
              CRT buffer length is recalculated.
              CRTC registers are reprogrammed as follows:
                     R09 = bytes/char-1 ; max scan line (mode 7 only)
                     R0A = bytes/char-2 ; cursor start
                     R0B = 0            ; cursor end
                     R12 = ((rows+1)*(bytes/char))-1 ; vertical display end
                     R14 = bytes/char   ; underline loc
                           (*** BUG: should be 1 less ***)
        The following functions are meant to be called only after a mode set:
        AL = 20h: user 8 by 8 graphics characters (INT 1FH)
            ES:BP = pointer to user table
        AL = 21h: user graphics characters
            ES:BP = pointer to user table
            CX    = bytes per character
            BL    = row specifier
                   0: user set - DL = number of rows
                   1: 14 rows
                   2: 25 rows
                   3: 43 rows
        AL = 22h: ROM 8 by 14 set
            BL    = row specifier
        AL = 23h: ROM 8 by 8 double dot
            BL    = row specifier
        AL = 30h: return information
            BH    = pointer specifier
                   0: INT 1Fh pointer
                   1: INT 44h pointer
                   2: ROM 8 by 14 character font pointer
                   3: ROM 8 by 8 double dot font pointer
                   4: ROM 8 by 8 DD font (top half)
                   5: ROM alpha alternate (9 by 14) pointer
            Returns: ES:BP = specified pointer value
                     CX    = bytes/character
                     DL    = character rows on screen
-----------------------------------------------------------
INT 10 - Alternate function select {ega}
        AH = 12h
        BL = 10h: return EGA information
             Returns:
             BH = 0: color mode in effect (3Dx)
                  1: mono mode in effect (3Bx)
             BL = 0:  64k bytes memory installed
                  1: 128k bytes memory installed
                  2: 192k bytes memory installed
                  3: 256k bytes memory installed
             CH = feature bits
             CL = switch settings
        BL = 20h: select alternate print screen routine
-----------------------------------------------------------
INT 10 - WRITE STRING (PC/AT ONLY)
        AH = 13h
        AL = mode
            bit 0: set in order to move cursor after write
            bit 1: set if string contains alternating characters and attributes
        BL = attribute if AL bit 1 clear
        BH = display page number
        DH,DL = row,column of starting cursor position
        CX = length of string
        ES:BP = pointer to start of string
-----------------------------------------------------------
INT 10 - LOAD LCD CHARACTER FONT (CONVERTIBLE ONLY)
        AH = 14h
        AL = 0 load user-specified font
            ES:DI = pointer to character font
            BH = number of bytes per character
            BL = 0: load main font (block 0)
                 1: load alternate font (block 1)
            CX = number of characters to store
            DX = character offset into RAM font area
        AL = 1 load system rom default font
            BL = 0: load main font (block 0)
                 1: load alternate font (block 1)
        AL = 2 set mapping of LCD high intensity attributes
            BL = 0: ignore high intensity attribute
                 1: map high intensity to underscore
                 2: map high intensity to revrese video
                 3: map high intensity to selected alternate font
-----------------------------------------------------------
INT 10 - GET PHYSICAL DISPLAY PARAMETERS (CONVERTIBLE ONLY)
        AH = 15h
Return: AX = alternate display adapter type
        ES:DI = pointer to parameter table
               word 0: monitor model number
                    1: vertical pixels per meter
                    2: horizontal pixels per meter
                    3: total vertical pixels
                    4: total horizontal pixels
                    5: horizontal pixel separation in micrometers
                    6: vertical pixel separation in micrometers
-----------------------------------------------------------
INT 10 - GET VIDEO RAM ADDRESS [TANDY 1000]
        AH = 70h
Return: AX  = segment address of the following
        [BX] = offset address of green plane
        [CX] = segment address of green plane
        [DX] = segment address of red/blue plane
               (red offset = 0, blue offset = 4000)
-----------------------------------------------------------
INT 10 - GET INCRAM ADDRESSES [TANDY 1000]
        AH = 71h
Return: AX  = segment address of the following
        [BX] = segment address of INCRAM
        [CX] = offset address of INCRAM
-----------------------------------------------------------
INT 10 - SCROLL SCREEN RIGHT [TANDY 1000]
        AH = 72h
        AL = number of columns blanked at left of window
             0 = blank entire window
        BH = attributes to be used on blank columns
        CH,CL = row, column of upper left corner of window
        DH,DL = row, column of lower right corner
----------------------------------------------------------
INT 10 - SCROLL SCREEN LEFT [TANDY 1000]
        AH = 73h
        AL = number of columns blanked at right of window
             0 = blank entire window
        BH = attributes to be used on blank columns
        CH,CL = row, column of upper left corner of window
        DH,DL = row, column of lower right corner
-----------------------------------------------------------
INT 10 - Get Video Buffer (TopView/DESQview/TaskView)
        AH = FEh
        ES:DI = segment:offset of assumed video buffer
Return: ES:DI = segment:offset of actual video buffer
-----------------------------------------------------------
INT 10 - Update Video Buffer (TopView/DESQview/TaskView)
        AH = FFh
        CX = number of sequential characters that have been modified
        DI = offset of first character that has been modified
        ES = segment of video buffer
-----------------------------------------------------------
INT 11 - EQUIPMENT DETERMINATION
Return: AX = "equipment flag" bits
            0       diskette installed
            1       8087 present
            2,3     always = 11
            4,5     initial video mode
                    01 = 40x25 COLOR
                    10 = 80x25 COLOR
                    11 = 80X25 IBM monochrome
            6,7     number of diskette drives (only if bit 0 = 1)
                    00 = 1, 01 = 2
            8       0 = dma present, 1= no dma on system (PCjr?)
            9,10,11 number of RS232 cards
            12      game I/O attached
            13      serial printer installed (IBM-PCjr)
                    internal modem installed (Convertible)
            14,15   number of printers
-----------------------------------------------------------
INT 12 - MEMORY SIZE
Return: AX = number of contiguous 1K blocks of memory
-----------------------------------------------------------
INT 13 - RESET DISK SYSTEM
        AH = 0
-----------------------------------------------------------
INT 13 - STATUS OF DISK SYSTEM
        AH = 1
Return: AL = status
            00h = successful completion
            01h = bad command
            02h = address mark not found
            03h = write attempted on write-protected disk
            04h = sector not found
            05h = reset failed (hard disk)
            06h = diskette changed
            07h = parameter act. failed (hard disk)
            08h = DMA overrun
            09h = DMA across 64K boundary
            0Ah = bad sector detected (hard disk)
            0Bh = bad track detected (hard disk)
            0Ch = unsupported track
            10h = bad CRC/ECC
            11h = data ECC corrected
            20h = controller failure
            40h = seek failed
            80h = time out
            AAh = drive not ready (hard disk)
            BBh = undefined error (hard disk)
-----------------------------------------------------------
INT 13 - READ SECTORS INTO MEMORY
        AH = 2
        AL = number of sectors to read
        CH = track (for hard disk, bits 8,9 in high bits of CL)
        CL = sector
        DH = head
        DL = drive
        ES:BX = address of buffer to fill
Return: CF = set if error occurred
        AH = status (see AH=1 above)
        AL = number of sectors read
-----------------------------------------------------------
INT 13 - WRITES SECTORS FROM MEMORY
        AH = 3
        AL = number of sectors to write
        CH = track (for hard disk, bits 8,9 in high bits of CL)
        CL = sector
        DH = head
        DL = drive
        ES:BX = address of buffer
Return: CF = set if error occurred
        AH = status (see AH=1 above)
        AL = number of sectors written
-----------------------------------------------------------
INT 13 - VERIFY SECTORS
        AH = 4
        AL = number of sectors to verify
        CH = track (for hard disk, bits 8,9 in high bits of CL)
        CL = sector
        DH = head
        DL = drive
Return: CF = set if error occurred
        AH = status (see AH=1 above)
        AL = number of sectors verified
-----------------------------------------------------------
INT 13 - FORMAT DISKETTE TRACK (FLOPPY)
        AH = 5
        AL = number of sectors to create on this track
        CH = track
        CL = sector
        DH = head
        DL = drive
        ES:BX = pointer to array of 4-byte address fields
               byte 1 = track
               byte 2 = head
               byte 3 = sector
               byte 4 = bytes/sector  0=128, 1=256, 2=512, 3=1024
Return: CF set if error occurred
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FORMAT TRACK (HARD DISK)
        AH = 5
        AL = interleave value (XT only)
        ES:BX = 512-byte format buffer
                the first 2*(sectors/track) bytes contain F,N for each sector
                   F = 00 for good sector, 80h for bad sector
                   N = sector number
        CH = cylinder number (bits 8,9 in high bits of CL)
        CL = sector number
        DH = head
        DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT, PORTABLE ONLY)
        AH = 6
        AL = interleave value (XT only)
        ES:BX = 512-byte format buffer
                the first 2*(sectors/track) bytes contain F,N for each sector
                   F = 00 for good sector, 80h for bad sector
                   N = sector number
        CH = cylinder number (bits 8,9 in high bits of CL)
        CL = sector number
        DH = head
        DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FORMAT DRIVE STARTING AT GIVEN TRACK (XT, PORTABLE ONLY)
        AH = 7
        AL = interleave value (XT only)
        ES:BX = 512-byte format buffer, see AH=6 above
        CH = cylinder number (bits 8,9 in high bits of CL)
        CL = sector number
        DH = head
        DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - GET CURRENT DRIVE PARAMETERS (PC/XT and PC/AT)
        AH = 8
        DL = DRIVE NUMBER
Return: CF set on error
        AH = status code (see AH=1 above)
        DL = number of consecutive acknowledging drives
        DH = maximum value for head number
        CL = maximum value fo sector number
        CH = maximum value for cylinder number
-----------------------------------------------------------
INT 13 - INITIALIZE TWO FIXED DISK BASE TABLES (PC/AT ONLY)
        AH = 9
Return: CF set on error
        AH = status code (see AH=1 above)
        INT 41h points to table for drive 0
        INT 46h points to table for drive 1
-----------------------------------------------------------
INT 13 - READ LONG (PC/AT ONLY)
        AH = 0Ah
        DL = drive ID
        DH = head
        CH = cylinder (bits 8,9 in high bits of CL)
        CL = sector
        ES:BX = pointer to buffer to fill
Return: CF set on error
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - WRITE LONG (PC/AT ONLY)
        AH = 0Bh
        DL = drive ID
        DH = head
        CH = cylinder (bits 8,9 in high bits of CL)
        CL = sector
        ES:BX = pointer to buffer containing data
Return: CF set on error
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - SEEK TO CYLINDER (PC/XT and PC/AT)
        AH = 0Ch
        DL = drive ID
        DH = head
        CH = cylinder (bits 8,9 in high bits of CL)
Return: CF set on error
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - ALTERNATE DISK RESET (PC/XT and PC/AT)
        AH = 0Dh
        DL = drive ID
Return: CF set on error
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - READ SECTOR BUFFER (XT, PORTABLE ONLY)
        AH = 0Eh
        AL = number of sectors
        CH = cylinder (bits 8,9 in top two bits of CL)
        CL = sector number
        DH = head number
        DL = drive number
        ES:BX = pointer to buffer
Return: AL = number of sectors actually transferred
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - WITE SECTOR BUFFER (XT, PORTABLE ONLY)
        AH = 0Fh
        AL = number of sectors
        CH = cylinder (bits 8,9 in top two bits of CL)
        CL = sector number
        DH = head number
        DL = drive number
        ES:BX = pointer to buffer
Return: AL = number of sectors actually transferred
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - TEST FOR DRIVE READY (PC/AT ONLY)
        AH = 10h
        DL = drive ID
Return: CF set on error
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - RECALIBRATE DRIVE (PC/XT and PC/AT)
        AH = 11h
        DL = drive ID
Return: CF set on error
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - CONTROLER RAM DIAGNOSTIC (XT, PORTABLE ONLY)
        AH = 12h
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - DRIVE DIAGNOSTIC (XT, PORTABLE ONLY)
        AH = 13h
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - CONTROLLER DIAGNOSTICS (PC/AT ONLY)
        AH = 14h
Return: CF set on error
        AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - GET DISK TYPE (PC/AT ONLY)
        AH = 15h
        DL = drive ID
Return: AH = disk type
            0 = disk not there
            1 = floppy, no change detection present
            2 = floppy with change detection
            3 = fixed disk
               CX:DX = number of 512-byte sectors
-----------------------------------------------------------
INT 13 - CHANGE OF DISK STATUS (PC/AT ONLY)
        AH = 16h
        DL = drive to check
Return: AH = disk change status
            0 = no disk change
            6 = disk changed
-----------------------------------------------------------
INT 13 - SET DISK TYPE (PC/AT ONLY)
        AH = 17h
        AL = disk type
            00 = no disk
            01 = regular disk in regular drive
            02 = regular disk in high-capacity drive
            03 = high-capacity disk in high-capacity drive
        DL = drive ID
-----------------------------------------------------------
INT 13 - SET MEDIA TYPE FOR FORMAT (PORTABLE? CONVERTIBLE? XT286?)
        AH = 18h
        DL = drive number
        CH = lower 8 bits of number of tracks
        CL = sectors per track (bits 0-5)
             top 2 bits of number of tracks (bits 6,7)
Return: AH = 00h  requested combination supported
             01h  function not available
             0Ch  not supported or druve type unknown
             80h  there is no disk in the drive
        ES:DI = pointer to 11-byte parameter table
-----------------------------------------------------------
INT 13 - PARK FIXED DISK HEADS (XT MODEL 286 ONLY)
        AH = 19h
-----------------------------------------------------------
INT 14 - SERIAL I/O - INITIALIZE USART
        AH = 0
        AL = initializing parameters
            7 - 6 - 5      4 - 3     2    1 - 0
            -BAUD RATE-    PARITY   STOP   WORD
                                    BITS  LENGTH
            000  110 BD    00 none  0-1   10 - 7
            001  150 BD    01 odd   1-2   11 - 8
            010  300 BD    11 even
            011  600 BD
            100 1200 BD
            101 2400 BD
            110 4800 BD
            111 9600 BD (4800 ON PCjr)
        DX = port number
Return: AX port status--see below
-----------------------------------------------------------
INT 14 - SERIAL I/O - TRANSMIT CHARACTER
        AH = 1
        AL = character
        DX = port number
Return: AH = RS-232 status code bits
            0: data ready
            1: overrun error
            2: parity error
            3: framing error
            4: break detected
            5: transmission buffer register empty
            6: transmission shift register empty
            7: time out--if set, other bits invalid
        AL = modem status bits
            0: delta Clear-To-Send
            1: delta Data-Set-Ready
            2: trailing edge of ring detected
            3: change, receive line signal detected
            4: Clear-To-Send
            5: Data-Set-Ready
            6: ring detected
            7: receive line signal detected
-----------------------------------------------------------
INT 14 - SERIAL I/O - RECEIVE CHARACTER
        AH = 2
Return: AL = character received
        AH = RS-232 status code (see above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - GET USART STATUS
        AH = 3
Return: AH = RS-232 status code (see above)
        AL = modem status code (see above)
-----------------------------------------------------------
INT 14 - EXTENDED INITIALIZE (CONVERTIBLE?)
        AH = 4
        AL = break status
            0 if break
            1 if no break
        BH = parity
            0 no parity
            1 odd parity
            2 even parity
            3 stick parity odd
            4 stick parity even
        BL = number of stop bits
            0: one stop bit
            1: two stop bits (1.5 if 5 bit word length)
        CH = word length
            0: 5 bits
            1: 6 bits
            2: 7 bits
            3: 8 bits
        CL = baud rate
            0: 110
            1: 150
            2: 300
            3: 600
            4: 1200
            5: 2400
            6: 4800
            7: 9600
            8: 19200
Return: AL = modem status (see above)
        AH = line control status (see above)
-----------------------------------------------------------
INT 14 - EXTENDD COMMUNICATION PORT CONTROL (CONVERTIBLE?)
        AH = 5
        AL = 0 read modem control register
              Return: BL = modem control register (see below)
                      AH = status
        AL = 1 write modem control register
              BL = modem control register
                  bit 0: data terminal ready
                  bit 1: request to send
                  bit 2: OUT1
                  bit 3: OUT2
                  bit 4: LOOP
                  bits 5-7 reserved
              Return: AH = status
-----------------------------------------------------------
INT 15 - TURN ON CASSETTE MOTOR
        AH = 0
-----------------------------------------------------------
INT 15 - TURN OFF CASSETTE MOTOR
        AH = 1
-----------------------------------------------------------
INT 15 - READ DATA BLOCKS FROM CASSETTE
        AH = 2
        CX = count of bytes
        ES:BX = pointer to data area
Return: CF set on error
        DX = count of bytes read
        ES:BX = pointer past last byte read
-----------------------------------------------------------
INT 15 - WRITE DATA BLOCKS TO CASSETTE
        AH = 3
        CX = count of bytes to write
        ES:BX = pointer to data area
Return: ES:BX = pointer past last byte written
-----------------------------------------------------------
INT 15 - DESQview/TopView/TaskView - Give up CPU time
        AX = 1000h
Return: after other process(es) run
-----------------------------------------------------------
INT 15 - DESQview/TopView/TaskView - Get Version
        AX = 1022h
        BX = 0
Return: BX nonzero, TopView or compat loaded
           TaskView returns BX = 0001h
-----------------------------------------------------------
INT 15 - DESQview/TopView/TaskView commands
        AH = 11h
        AL = various
-----------------------------------------------------------
INT 15 - DESQview/TopView/TaskView commands
        AH = 12h
        AL = various
-----------------------------------------------------------
INT 15 - PRINT.COM - Internal
        AH = 20h
        AL = subfunction
            00h ???
            01h ???
Note: sets or resets some flags which affect what PRINT does when it tries
to access the disk
-----------------------------------------------------------
INT 15 - READ/MODIFY PROFILES (CONVERTIBLE ONLY)
        AH = 40h
        AL = subfunction
            0: get system profile in CX and BX
            1: set system profile from CX and BX
            2: get internal modem profile in BX
            3: set internal modem profile from BX
-----------------------------------------------------------
INT 15 - WAIT ON EXTERNAL EVENT (CONVERTIBLE ONLY)
        AH = 41h
        AL = condition type
            bits 0-2: condition to wait for
                      0 = any external event
                      1 = compare and return if equal
                      2 = compare and return if not equal
                      3 = test and return if not zero
                      4 = test and return if zero
            bit 3:    reserved
            bit 4:    1=port address, 0=user byte
            bits 5-7: reserved
        BH = condition compare or mask value
        BL = timeout value times 55 milliseconds
            0 means no timeout
        DX = I/O port address if AL bit 4 set
        ES:DI = pointer to user byte if AL bit 4 clear
-----------------------------------------------------------
INT 15 - REQUEST SYSTEM POWER OFF (CONVERTIBLE ONLY)
        AH = 42h
        AL = 0 to use system profile
             1 to foce suspend regardless of system profile
-----------------------------------------------------------
INT 15 - READ SYSTEM STATUS (CONVERTIBLE ONLY)
        AH = 43h
Return: AL = status bits
            bit 0: LCD detached
            bit 1: reserved
            bit 2: RS232/parallel adapter powered on
            bit 3: internal modem powered on
            bit 4: power activated by alarm
            bit 5: standby power lost
            bit 6: extern apower in use
            bit 7: power low
-----------------------------------------------------------
INT 15 - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE ONLY)
        AH = 44h
        AL = 0 to power off
             1 to power on
-----------------------------------------------------------
INT 15 - KEYBOARD INTERCEPT (CONVERTIBLE ONLY)
        AH = 4Fh
        AL = scan code
        CF set
Return: AL = scan code
        CF set
(Called by INT 9 handler to translate scan codes)
-----------------------------------------------------------
INT 15 - DEVICE OPEN (PC/AT ONLY)
        AH = 80h
        BX = device ID
        CX = process type
-----------------------------------------------------------
INT 15 - DEVICE CLOSE (PC/AT ONLY)
        AH = 81h
        BX = device ID
        CX = process type
-----------------------------------------------------------
INT 15 - DEVICE PROGRAM TERMINATE (PC/AT ONLY)
        AH = 82h
        BX = device ID
-----------------------------------------------------------
INT 15 - EVENT WAIT (PC/AT ONLY)
        AH = 83h
        AL = SUBSERVICE
            0 = set interval
            1 = cancel
        ES:BX = pointer to event flag (bit 7 set when interval expires)
        CX,DX = number of microseconds to wait (only accurate to 977 us)
Return: CF set if function already busy
-----------------------------------------------------------
INT 15 - READ JOYSTICK SWITCH SETTINGS (PC/AT ONLY)
        AH = 84h
        DX = 0
Return: AL = switch settings (bits 7-4)
-----------------------------------------------------------
INT 15 - READ JOYSTICK INPUTS (PC/AT ONLY)
        AH = 84h
        DX = 1
Return: AX = A(x) value
        BX = A(y) value
        CX = B(x) value
        DX = B(y) value
-----------------------------------------------------------
INT 15 - SYSTEM REQUEST KEY PRESS (PC/AT ONLY)
        AH = 85h  (called by keyboard decode routine)
Return: AL = 00 press
        AL = 01 release
-----------------------------------------------------------
INT 15 - WAIT (PC/AT AND AFTER)
        AH = 86h
        CX,DX = number of microseconds to wait (only accurate to 977 us)
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - BLOCK MOVE   (286/386 machines only)
        AH = 87h
        CX = number of words to move
        ES:SI = pointer to global descriptor table
               offset 0h  null descriptor
                      8h  uninitialized, will be made into GDT descriptor
                     10h  descriptor for source of move
                     18h  descriptor for destination of move
                     20h  uninitialized, used by BIOS
                     28h  uninitialized, will be made into SS descriptor
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - GET MEMORY SIZE  (286/386 machines only)
        AH = 88h
Return: AX = memory size
-----------------------------------------------------------
INT 15 - SWITCH TO VIRTUAL MODE (PC/AT ONLY)
        AH = 89h
        BL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)
        BH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)
        DS:SI = pointer to GDT for protected mode
               offset 0h  null descriptor
                      8h  GDT descriptor
                     10h  IDT descriptor
                     18h  DS
                     20h  ES
                     28h  SS
                     30h  CS
                     38h  uninitialized, used to build descriptor for BIOS CS
        CX = offset into protected-mode CS to jump to
Return: CF set on error
           AH = 0FFh  error enabling address line 20
-----------------------------------------------------------
INT 15 - DEVICE BUSY LOOP (PC/AT ONLY)
        AH = 90h
        AL = TYPE CODE
            00h: disk
            01h: diskette
            02h: keybaord
            80h: network (ES:BX = NCB)
            FCh: disk reset
            FDh: diskette motor start
            FEh: printer
Return: CF set if wait time satisfied
-----------------------------------------------------------
INT 15 - SET FLAG AND COMPLETE INTERRUPT
        AH = 91h
        AL = type code, see AH=90h above
-----------------------------------------------------------
INT 15 - GET SYSTEM CONFIGURATION (XT after 1/10/86, PC Conv, XT286, PS/2)
        AH = C0h
Return: CF = 1 if BIOS doesn't support call
        ES:BX pointer to ROM table
             byte_count  dw   ?   ; number of bytes following
             model       db   ?   ; PC=ff, XT=fe or fb, PCjr = fd, etc, etc
             submodel    db   ?   ; distingushes between AT and XT/286, etc.
             BIOS_rev    db   ?   ; 0 for first release, 1 for 2nd, etc.
             featbyte    db   ?   ; 80h = DMA channel 3 used by hd BIOS
                                  ; 40h = 2nd 8259 installed
                                  ; 20h = Real-Time Clock installed
                                  ; 10h = INT 15h called upon INT 9h
                                  ;  8h = wait for external event supported
                                  ;  4h = extended BIOS area allocated at 640K
                                  ;  2h = bus is Micro Channel instead of PC
                                  ;  1h   reserved
-----------------------------------------------------------
INT 15 - DESQview ? - ???
        AH = C2h
        AL = subfunction
            00h ???
               BH = ???
            01h set something to default values
            02h ???
               BH = ???
            03h ???
               BH = ???
            04h points to RET instruction
            05h same as 01h, but also takes input value in BH
               BH = ???
            06h ???
               BH = 01h or 02h stored, otherwise ignored
            07h ???
               ES:BX = pointer to ???
               Return: AL = 00h
Note: the values in BH for those functions that take it as input are stored
      in different locations for each subfunction
-----------------------------------------------------------
INT 15 - DESQview (TopView?) - ???
        AH = 0DEh
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - READ CHAR FROM BUFFER - WAIT IF EMPTY
        AH = 0
Return: AH = scan code
        AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - CHECK BUFFER - DO NOT CLEAR
        AH = 1
Return: ZF = 0 character in buffer
            AH = scan code
            AL = character
        ZF = 1 no character in buffer
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - GET SHIFT STATUS
        AH = 2
        AL = shift status bits
            0 = right shift key depressed
            1 = left shift key depressed
            2 = CTRL depressed
            3 = ALT depressed
            4 = SCROLL LOCK active
            5 = NUM LOCK active
            6 = CAPS LOCK active
            7 = INSERT state active
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - SET DELAYS (PCjr, AT, PS/2)
        AH = 3
        AL = 0: reset typematic (PCjr)
        AL = 1: increase initial delay (PCjr)
        AL = 2: increase continuing delay (PCjr)
        AL = 3: increase both delays (PCjr)
        AL = 4: turn off typematic (PCjr)
        AL = 5: Set typematic rate (AT or PS/2)
          BH = 00 - 03 for delays of 250ms, 500ms, 750ms, or 1s
          BL = 00 - 1F for typematic rates of 30cps down to 2cps
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - KEYCLICK (PCjr ONLY)
        AH = 4
        AL = 0: click off
        AL = 1: click on
-----------------------------------------------------------
INT 16 - KEYBOARD - Write to keyboard buffer (AT or PS/2 with enhanced kbd)
        AH = 5
        CH = scan code
        CL = character
Return: AL = 1 if buffer full
-----------------------------------------------------------
INT 16 - KEYBOARD - Get enhanced keystroke (AT or PS/2 with enhanced kbd)
        AH = 10h
Return: AH = scan code
        AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - Check enhanced keystroke (AT or PS/2 with enhanced kbd)
        AH = 11h
Return: ZF = 0 if keystroke available
            AH = scan code \ meaningless if ZF = 1
            AL = character /
        ZF = 1 if kbd buffer empty
-----------------------------------------------------------
INT 16 - KEYBOARD - Get enhanced shift flags (AT or PS/2 with enhanced kbd)
        AH = 12h
Return: AL (same as for AH=02)
           bit 7: Ins ON
           bit 6: CapsLock ON
           bit 5: NumLock ON
           bit 4: ScrollLock ON
           bit 3: Either ALT key down
           bit 2: Either CTRL key down
           bit 1: Left shift key down
           bit 0: Right shift key down
        AH
           bit 7: SysReq key down
           bit 6: CapsLock key down
           bit 5: NumLock key down
           bit 4: ScrollLock key down
           bit 3: Right Alt key down
           bit 2: Right Ctrl key down
           bit 1: Left Alt key down
           bit 0: Right Alt key down
-----------------------------------------------------------
INT 17 - OUTPUT CHARACTER TO PRINTER
        AH = 0
        AL = character
Return: AH = status bits
            0 = time out
            1 = unused
            2 = unused
            3 = I/O error
            4 = selected
            5 = out of paper
            6 = acknowledge
            7 = not busy
-----------------------------------------------------------
INT 17 - INITIALIZE PRINTER
        AH = 1
Return: AH = status (see above)
-----------------------------------------------------------
INT 17 - STATUS OF PRINTER
        AH = 2
Return: AH = status (see above)
-----------------------------------------------------------
INT 18 - TRANSFER TO ROM BASIC
   causes transfer to ROM-bases BASIC (IBM-PC)
   often reboots a compatible; often has no effect at all
-----------------------------------------------------------
INT 19 - DISK BOOT
   causes reboot of disk system (no memory test performed)
-----------------------------------------------------------
INT 1A - GET TIME OF DAY
        AH = 0
Return: CX = high (most signif.) portion of clock count
        DX = low (least signif.) portion of clock count
        AL = 0 if clock was read or written (via AH=0,1)
               within the current 24-hour period
               Otherwise, AL > 0
-----------------------------------------------------------
INT 1A - SET TIME OF DAY
        AH = 1
        CX = high (most signif.) portion of clock count
        DX = low (least signif.) portion of clock count
-----------------------------------------------------------
INT 1A - READ REAL TIME CLOCK (PC/AT ONLY)
        AH = 2
Return: CH = hours
        CL = minutes
        DH = seconds
-----------------------------------------------------------
INT 1A - SET REAL TIME CLOCK (PC/AT ONLY)
        AH = 3
        CH = hours
        CL = minutes
        DH = seconds
        DL = 1, if daylight savings; 0 if standard time
-----------------------------------------------------------
INT 1A - READ DATE FROM REAL TIME CLOCK (PC/AT ONLY)
        AH = 4
Return: DL = day
        DH = month
        CL = year
        CH = century (19 or 20)
-----------------------------------------------------------
INT 1A - SET DATE IN REAL TIME CLOCK (PC/AT ONLY)
        AH = 5
        DL = day
        DH = month
        CL = year
        CH = century (19 or 20)
-----------------------------------------------------------
INT 1A - SET ALARM (PC/AT ONLY)
        AH = 6
        CH = hours
        CL = minutes
        DH = seconds
Return: CF set if alarm already set or clock inoperable
        INT 4Ah will be called when alarm goes off
-----------------------------------------------------------
INT 1A - RESET ALARM (PC/AT ONLY)
        AH = 7
-----------------------------------------------------------
INT 1A - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE ONLY)
        AH = 8
        CH = hours in BCD
        CL = minutes in BCD
        DH = seconds in BCD
-----------------------------------------------------------
INT 1A - READ RTC ALARM TIME AND STATUS (CONVERTIBLE ONLY)
        AH = 9
Return: CH = hours in BCD
        CL = minutes in BCD
        DH = seconds in BCD
        DL = alarm status
            0  alarm not enabled
            1  alarm enabled but will not power up system
            2  alarm will power up system
-----------------------------------------------------------
INT 1A - SET UP SOUND MULTIPLEXOR (PCjr ONLY)
        AH = 80h
        AL = 0 source is 8253 channel 2
             1 source is cassette input
             2 source is I/O channle "Audio IN"
             3 source is sound generator chip
-----------------------------------------------------------
INT 1B - CTRL-BREAK KEY
   This interrupt is called when the keyboard scanner of the IBM
   machines detects CTRL and BREAK pressed at the same time. It
   normally points to a short routine in DOS which sets the
   Ctrl-C flag, thus invoking INT 23h the next time DOS checks
   for Ctrl-C.
-----------------------------------------------------------
INT 1C - CLOCK TICK
   This interrupt is called (in the IBM) at the end of each time-update
   operation by the real-time clock routines. It normally points to an
   IRET.
-----------------------------------------------------------
INT 1D -> 6845 Video Init tables
        table for modes 0 and 1   \
        table for modes 2 and 3    \ each table is 16 bytes long and
        table for modes 4,5, and 6 / contains values for 6845 registers
        table for mode 7          /
        4 words -- size of video RAM for modes 0/1, 2/3, 4/5, and 6/7
        8 bytes -- number of columns in each mode
        8 bytes -- video controller mode byte for each mode
-----------------------------------------------------------
INT 1E -> Diskette Params (BASE TABLE)
Default at f000:efc7
        db      step rate & head unload times
        db      head load time & DMA
        db      motor off time
        db      sector size (0->128, 1->256, 2->512, 3->1024)
        db      last sector number (8 or 9 typical)
        db      inter-sector gap size on read/write (42 typical)
        db      data transfer length (255 typical)
        db      inter-sector gap size on format (80 typical)
        db      sector fill on format (f6 typical)
        db      head-settle time ms (typical 25, 2.10->15)
        db      motor start-up time (1/8 secs) (typical 4, 2.10->2)
-----------------------------------------------------------
INT 1F -> Pointer to Graphics Set 2--contains bitmaps for high 128 chars
-----------------------------------------------------------
INT 20 - Minix - SEND/RECEIVE MESSAGE
        AX = process ID of other process
        BX = pointer to message
        CX = 1 send
             2 receive
             3 send&receive
Note: the message contains the system call number (numbered as in V7 Unix(tm))
      and the call parameters
-----------------------------------------------------------
INT 20 - DOS - PROGRAM TERMINATION
returns to DOS
-----------------------------------------------------------
INT 21 - PROGRAM TERMINATION
        AH = 00h
Same action as INT 20; returns to DOS.
-----------------------------------------------------------
INT 21 - KEYBOARD INPUT
        AH = 01h
Return: AL = character read
-----------------------------------------------------------
INT 21 - DISPLAY OUTPUT
        AH = 02h
        DL = character
-----------------------------------------------------------
INT 21 - AUX Input
        AH = 03h
Return: AL = character read
-----------------------------------------------------------
INT 21 - AUX Output
        AH = 04h
        DL = character to send
-----------------------------------------------------------
INT 21 - PRINTER OUTPUT
        AH = 05h
        DL = character to print
-----------------------------------------------------------
INT 21 - DIRECT CONSOLE I/O - CHARACTER OUTPUT
        AH = 06h
        DL = character <> FFh
-----------------------------------------------------------
INT 21 - DIRECT CONSOLE I/O - CHARACTER INPUT
        AH = 06h
        DL = 0FFh
Return: ZF set   = no character
        ZF clear = character recieved
                  AL = character
Note: Character is echoed to STDOUT if received.
-----------------------------------------------------------
INT 21 - Direct STDIN Input, no echo
        Reg AH = 07h
Note: same as Function 6 for input but char not echoed
-----------------------------------------------------------
INT 21 - KEYBOARD INPUT - NO ECHO
        AH = 08h
Return: AL = character
-----------------------------------------------------------
INT 21 - PRINT STRING
        AH = 09h
        DS:DX = address of string terminated by "$"
-----------------------------------------------------------
INT 21 - BUFFERED KEYBOARD INPUT
        AH = 0Ah
        DS:DX = address of buffer
Note: first byte of buffer must contain maximum length
      on return the second byte contains actual length, third and
        subsequent bytes contain the input line
-----------------------------------------------------------
INT 21 - CHECK STANDARD INPUT STATUS
        AH = 0Bh
Return: AL = FFh if character available
             00h if no character
-----------------------------------------------------------
INT 21 - Clear Keyboard Buffer
        AH = 0Ch
        AL must be 1, 6, 7, 8, or 0Ah.
  Flushes all typeahead input, then executes function specified
by AL (by moving it to AH and repeating the INT 21 call).
  If AL contains a value not in the list above, the keyboard buffer is
flushed and no other action is taken.
-----------------------------------------------------------
INT 21 - Disk Reset
        AH = 0Dh
Flushes all disk buffers.
-----------------------------------------------------------
INT 21 - SELECT DISK
        AH = 0Eh
        DL = new default drive number (0 = A, 1 = B, etc.)
Return: AL = number of logical drives
-----------------------------------------------------------
INT 21 - OPEN DISK FILE
        AH = 0Fh
        DS:DX = address of FCB
Return: AL = 00h file found
             FFh file not found
-----------------------------------------------------------
INT 21 - CLOSE DISK FILE
        AH = 10h
        DS:DX = address of FCB
Return: AL = 00h directory update successful
             FFh file not found in directory
-----------------------------------------------------------
INT 21 - Search First using FCB
        AH = 11h
        DS:DX = address of FCB
Return: AL =
            00h = file found
            FFh = file not found
If file found, FCB is created at DTA address and
set up to OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - Search Next using FCB
        AH = 12h
        DS:DX = address of FCB
Return: AL =
            00h = file found
            FFh = file not found
If file found, FCB is created at DTA address and
set up to OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - Delete File via FCB
        AH = 13h
        DS:DX = address of FCB
Return: AL =
            00h = file found
            FFh = file not found
-----------------------------------------------------------
INT 21 - SEQUENTIAL DISK FILE READ
        AH = 14h
        DS:DX = address of FCB
Return: AL =
            0 = successful read
            1 = end of file
            2 = data transfer area too small
            3 = partial record, EOF
-----------------------------------------------------------
INT 21 - SEQUENTIAL DISK RECORD WRITE
        AH = 15h
        DS:DX = address of FCB
Return: AL =
            0 = successful write
            1 = disk full
            2 = data transfer area too small
-----------------------------------------------------------
INT 21 - CREATE A DISK FILE
        AH = 16h
        DS:DX = address of FCB
Return: AL =
            00h = successful creation
            FFh = directory full
-----------------------------------------------------------
INT 21 - Rename File via FCB
        AH = 17h
        DS:DX = address of FCB
        FCB contains new name starting at byte 17h.
Return: AL =
            00h = file found
            FFh = file not found
-----------------------------------------------------------
INT 21 - Internal - does nothing
        AH = 18h
Return: AL = 0
-----------------------------------------------------------
INT 21 - Default Disk Number
        AH = 19h
Return: AL = current drive number (letter - 'A')
-----------------------------------------------------------
INT 21 - SET DISK TRANSFER AREA ADDRESS
        AH = 1Ah
        DS:DX = address of buffer
-----------------------------------------------------------
INT 21 - Default Drive Disk Size
        AH = 1Bh
Return: DS:BX points to FAT ID byte
        DX = number of allocation units on disk
        AL = number of sectors per allocation unit (cluster)
        CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - Specific Drive's Disk Size
        AH = 1Ch
        DL = Drive Number to check
Return: DS:BX points to FAT ID byte
        DX = number of allocation units on disk
        AL = number of sectors per allocation unit (cluster)
        CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - Internal - does nothing
        AH = 1Dh
Return: AL = 0
-----------------------------------------------------------
INT 21 - Internal - does nothing
        AH = 1Eh
Return: AL = 0
-----------------------------------------------------------
INT 21 - Internal - GET DEFAULT DRIVE PARAMETER BLOCK
        AH = 1Fh
Return: AL = 00h No Error
             FFh Error
        (DS:BX) = ADDRESS OF DRIVE PARAMETER BLOCK.
Note: for DOS 2.x and 3.x, this just invokes function 32h with DL = 0
-----------------------------------------------------------
INT 21 - Internal - does nothing
        AH = 20h
Return: AL = 0
-----------------------------------------------------------
INT 21 - RANDOM DISK RECORD READ
        AH = 21h
        DS:DX = address of FCB
Return: AL =
            0 = successful read
            1 = end of file
            2 = data transfer area too small
            3 = partial record, EOF
-----------------------------------------------------------
INT 21 - Random Disk Write
        AH = 22h
Same setup as Random Read, but writes to disk
-----------------------------------------------------------
INT 21 - FILE SIZE
        AH = 23h
        DS:DX = address of FCB
Return: AL =
            00h = file found
            FFh = file not found
FCB SET TO NO. OF RECORDS
-----------------------------------------------------------
INT 21 - Set Random Record Field
        AH = 24h
        DS:DX = address of FCB
Return: Random Record Field of FCB is set to be same as Current Block
        and Current Record.
Note: FCB must be OPEN already
-----------------------------------------------------------
INT 21 - Set Interrupt Vector
        AH = 25h
        AL = interrupt number
        DS:DX = new vector to be used for specified interrupt
-----------------------------------------------------------
INT 21 - Create PSP
        AH = 26h
        DX = Segment number to set up PSP at
Current PSP is copied to specified segment
-----------------------------------------------------------
INT 21 - RANDOM BLOCK READ
        AH = 27h
        DS:DX = address of FCB
        CX = number of records to be read
Return: AL =
            0 = successful read
            1 = end of file
            2 = data transfer area too small
            3 = partial record, EOF
-----------------------------------------------------------
INT 21 - RANDOM BLOCK WRITE
        AH = 28h
        DS:DX = address of FCB
        CX = number of records to be written
             if zero, truncate file to current random file position
Return: AL =
            0 = successful write
            1 = disk full
            2 = data transfer area too small
-----------------------------------------------------------
INT 21 - Parse Filename
        AH = 29h
        DS:SI = pointer to string to parse
        ES:DI = pointer to memory to fill with unopened FCB
        AL = bit mask to control parsing
            0 = 0: parsing stops if file separator found
                1: leading separator ignored
            1 = 0: drive number in FCB set to default drive if not present
                   in string
                1: drive number in FCB not changed
            2 = 0: filename in FCB set to blanks if no filename in string
                1: filename in FCB not changed if string does not contain
                   a filename
            3 = 0: extension in FCB set to blanks if no extension in string
                1: extension left unchanged
Return: AL = 00: no wildcards in name or extension
             01: wildcards appeared
        DS:SI = pointer to first byte after parsed string
        ES:DI = unopened FCB
-----------------------------------------------------------
INT 21 - GET CURRENT DATE
        AH = 2Ah
Return: DL = day
        DH = month
        CX = year
        AL = day of the week (0=Sunday, 1=Monday, etc.)
-----------------------------------------------------------
INT 21 - Set CURRENT DATE
        AH = 2Bh
        DL = day
        DH = month
        CX = year
Return: AL = 0 if no error
        AL = 0FFh if bad value sent to routine
        (DOS 3.3 also sets CMOS clock)
        (DESQview also accepts CX = 4445h and DX = 5351h, i.e. 'DESQ' as valid)
-----------------------------------------------------------
INT 21 - GET CURRENT TIME
        AH = 2Ch
Return: CH = hours
        CL = minutes
        DH = seconds
        DL = hundredths of seconds
Note: time is updated approximately every 5/100 second
-----------------------------------------------------------
INT 21 - Set CURRENT TIME
        AH = 2Dh
        CH = hours
        CL = minutes
        DH = seconds
        DL = hundredths of seconds
Return: AL = 0 if no error
        AL = 0ffH if bad value sent to routine
        (DOS 3.3 also sets CMOS clock)
-----------------------------------------------------------
INT 21 - Set Verify Flag
        AH = 2Eh
        DL = 0
        AL = 1 if VERIFY on
        AL = 0 if VERIFY off
-----------------------------------------------------------
INT 21 - Get Disk Transfer Area Address
        AH = 2Fh
Return: ES:BX = address of DTA
-----------------------------------------------------------
INT 21 - Get DOS Version
        AH = 30h
Return: AL = Major Version number
        AH = Minor Version number
        BH = OEM number
        BL:CX = 24-bit user number
-----------------------------------------------------------
INT 21 - TERMINATE BUT STAY RESIDENT
        AH = 31h
        AL = exit code
        DX = program size, in paragraphs
-----------------------------------------------------------
INT 21 - Internal - GET DRIVE PARAMETER BLOCK
        AH = 32h
        DL = drive number
            0 = default, 1 = A, etc.
Return: AL = 0FFh if invalid drive number, else
        DS:BX = address of drive parameter block.

                STRUCTURE OF DOS DRIVE PARAMETER BLOCK:

DPBLOCK         STRUCT          ;OFFSET
DISK_OFFSET     DB      ?       ;  0.  drive number (0 = A, etc.)
UNIT_OFFSET     DB      ?       ;  1.  unit number within device driver
SECTOR_SIZE     DW      ?       ;  2.  number of bytes per sector
MAX_CLUSTER     DB      ?       ;  4.  largest sector number in cluster
                                ;      add one for number of sectors/cluster
LOG2_SECTORS    DB      ?       ;  5.  log base two of the cluster size
RESERVED        DW      ?       ;  6.  number of reserved (boot) sectors
FAT_COUNT       DB      ?       ;  8.  number of copies of the FAT
ROOT_COUNT      DW      ?       ;  9.  number of root directory entries
DATA_START      DW      ?       ; 11.  first data sector on medium
MAX_NUMBER      DW      ?       ; 13.  largest possible cluster number
                                ;      subtract one for number of data clusters
FAT_SECTORS     DB      ?       ; 15.  number of sectors in one FAT copy
ROOT_START      DW      ?       ; 16.  first sector of root directory
DEVICE_ADDR     DD      ?       ; 18.  address of device driver for this drive
DESCRIPTOR      DB      ?       ; 22.  media descriptor byte for medium
VALID_BYTE      DB      ?       ; 23.  0FFh indicates block must be rebuilt
NEXT_BLOCK      DD      ?       ; 24.  address of next device block in list

;       FROM THIS POINT ON, DOS 3 DIFFERS FROM 2:

                IF      DOS2
DIR_START       DW      ?       ; 28.  starting cluster of current directory
                                ;      zero indicates the root directory
PATH_NAME       DB      64 DUP (?)
                                ; 30.  ASCIIZ current directory path string
                ELSE    DOS3
;               on my XT, this was always:
                DW      0
                DW      0FFFFh
                ENDIF
DPBLOCK         ENDS
-----------------------------------------------------------
INT 21 - Get or Set CONTROL-BREAK
        AH = 33h
        AL = subfunction
            00h Get
            01h Put
               DL = 0 for OFF or 1 for ON
            02h internal, called by PRINT.COM (DOS 3.1)
Return: DL = current BREAK setting if AL = 00h
            0 BREAK=OFF
            1 BREAK=ON
        AL = FFh if error
-----------------------------------------------------------
INT 21 - Internal - Return CritSectFlag Pointer
        AH = 34h
Return: ES:BX points to DOS "Critical Section Flag"
Notes:
   When byte pointed to is zero, DOS is supposed to be
   safe to interrupt. NOT RELIABLE according to Chris Dunford.

   Examination of DOS 2.10 code in this area indicates that the
   byte immediately FOLLOWING this "Critical Section Flag" must
   be 00 to permit the PRINT.COM interrupt to be called.

   For DOS 3.0 and 3.1 (except COMPAQ DOS 3.0), the byte BEFORE
   the "Critical Section Flag" must be zero, and for COMPAQ DOS 3.0,
   the byte 01AAh before it must be zero.
-----------------------------------------------------------
INT 21 - Get Interrupt Vector
        AH = 35h
        AL = interrupt number
Return: ES:BX = value of interrupt vector
-----------------------------------------------------------
INT 21 - DISK SPACE
        AH = 36h
        DL = drive code (0 = default, 1 = A, 2 = B, etc.)
Return: AX = number of sectors per cluster
             or 0FFFFh if invalid drive
        BX = number of available clusters
        CX = bytes per sector
        DX = total clusters
Note: multiply AX x CX x BX for free space on disk
      multiply AX x CX x DX for total disk space
-----------------------------------------------------------
INT 21 - Internal - switchar/availdev
        AH = 37h
        AL = subfunction
           0 Read switch character (returns current character in DL)
           1 Set switch character (specify new character in DL)
           2 (DOS 2.x only) Read device availability (as set by function AL=3)
           3 (DOS 2.x only) Set device availability, where:
             DL = 0 means /DEV/ must preceed device names
             DL <> 0 means /DEV/ need not preceed device names
Return: DL = Switch character (if AL=0 or 1)
             Device availability flag (if AL=2 or 3)
        AL=0FFh means the value in AL was not in the range 0-3.
-----------------------------------------------------------
INT 21 - Get Country-Dependent Information
        AH = 38h
  DOS 2.x
        AL = 0  get current-country info
        DS:DX = segment:offset of buffer for returned info
Return: BX = country code
        buffer at DS:DX filled as follows:
           bytes 0-1 = date format   0 = USA    mm dd yy
                                     1 = Europe dd mm yy
                                     2 = Japan  yy mm dd
           byte 2    = currency symbol
           byte 3    = 00h
           byte 4    = thousands separator char
           byte 5    = 00h
           byte 6    = decimal separator char
           byte 7    = 00h
           bytes 8-1Fh reserved

  DOS 3.x
        AL = 0 for current country
        AL = 01h thru 0FEh for specific country with code <255
        AL = 0FFh for specific country with code >= 255
           BX = 16-bit country code
        DS:DX = segment:offset of buffer for returned info
        DX = 0FFFFh if setting country code, rather than getting info
Return: (if DX <> 0FFFFh)
        BX = country code
        DS:DX filled in:
              bytes 0-1 = date format (see above)
              bytes 2-6 = currency symbol string, ASCIZ
              byte 7    = thousands seaprator char
              byte 8    = 00h
              byte 9    = decimal separator char
              byte 0Ah  = 00h
              byte 0Bh  = date separator char
              byte 0Ch  = 00h
              byte 0Dh  = time separator char
              byte 0Eh  = 00h
              byte 0Fh  = currency format
                           bit 1 = number of spaces between value and curr sym
                           bit 0 = 0 if currency symbol precedes value
                                   1 if currency symbol follows value
              byte 10h  = number of digits after decimal in currency
              byte 11h  = time format
                           bit 0 = 0 if 12-hour clock
                                   1 if 24-hour clock
              bytes 12h-15h = address of case map routine (FAR CALL)
              byte 16h  = data-list separator char
              byte 17h  = 00h
              bytes 18h-21h reserved
      If error:
        CF set
        AX = error code
-----------------------------------------------------------
INT 21 - CREATE A SUBDIRECTORY (MKDIR)
        AH = 39h
        DS:DX = address of ASCIIZ pathname
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - REMOVE A DIRECTORY ENTRY (RMDIR)
        AH = 3Ah
        DS:DX = address of ASCIIZ pathname
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - CHANGE THE CURRENT DIRECTORY (CHDIR)
        AH = 3Bh
        DS:DX = address of ASCIIZ directory name
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - CREATE A FILE WITH HANDLE (CREAT)
        AH = 3Ch
        CX = attributes for file
        DS:DX = address of ASCIZ filename
Return: CF = 1 if error
            AX = Error Code
        CF = 0 successful
            AX = file handle
-----------------------------------------------------------
INT 21 - OPEN DISK FILE WITH HANDLE
        AH = 3Dh
        AL = access code
            0 = Read Only
            1 = Write Only
            2 = Read/Write
        AL bits 7-3 = file-sharing modes (DOS 3.x)
            bit 7    = inheritance flag, set for no inheritance
            bits 4-6 = sharing mode
                      000 compatibility mode
                      001 exclusive (deny all)
                      010 write access denied (deny write)
                      011 read access denied (deny read)
                      100 full access permitted (deny none)
            bit 3    = reserved, should be zero
        DS:DX = address of ASCIZ filename
        DX = OFFSET ADDRESS OF ASCIIZ
Return: CF = 1 if error
            AX = Error Code
        CF = 0 successful
            AX = file handle
-----------------------------------------------------------
INT 21 - CLOSE A FILE WITH HANDLE
        AH = 3Eh
        BX = file handle
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - READ FROM FILE WITH HANDLE
        AH = 3Fh
        BX = file handle
        CX = number of bytes to read
        DS:DX = address of buffer
Return: CF = 1 if error
            AX = Error Code
        CF = 0 successful
            AX = number of bytes read
-----------------------------------------------------------
INT 21 - WRITE TO FILE WITH HANDLE
        AH = 40h
        BX = file handle
        CX = number of bytes to write
        DS:DX = pointer to buffer
Return: CF = 1 if error
            AX = Error Code
        CF = 0 successful
            AX = number of bytes written
-----------------------------------------------------------
INT 21 - DELETE A FILE (UNLINK)
        AH = 41h
        DS:DX = pointer to ASCIIZ name of file to delete
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - MOVE FILE READ/WRITE POINTER (LSEEK)
        AH = 42h
        AL = method value
            0 = offset from beginning of file
            1 = offset from present location
            2 = offset from end of file
        BX = file handle
        CX:DX = offset in bytes
Return: CF = 1 if error
            AX = Error Code
        CF = 0 successful
            DX:AX = new offset
-----------------------------------------------------------
INT 21 - GET/PUT FILE ATTRIBUTES (CHMOD)
        AH = 43h
        AL =
            0 = get file attributes
            1 = put file attributes
               CX = file attribute bits
                   0 = read only
                   1 = hidden file
                   2 = system file
                   3 = volume label
                   4 = subdirectory
                   5 = written since backup
        DX = pointer to ASCIIZ file name
Return: CF = 1 if error
            AX = Error Code if any
        CX = file attributes on get
-----------------------------------------------------------
INT 21 - IOCTL
        AH = 44h
        AL =
           0 = Get device information (DX)
           1 = Set device information (DL, DH = 0)
               DX BITS =
                 0 = console input device
                 1 = console output device
                 2 = null device
                 3 = clock device
                 5 = binary mode
                 6 = EOF
                 7 = device is character device if set
                     if not, EOF = 0 if channel has been written
                     bits 0-5 are block device number
                12 = network device
                14 = can process control strings (AL=2-5, can only be read)
                15 reserved
           2 = Read CX bytes to DS:DX from BX control chan
           3 = Write CX bytes from DS:DX from BX control chan
           4 = as 2 but for drive BL
           5 = as 3 but for drive BL
               AX = number of bytes transfered
           6 = Get input status
           7 = Get output status
               AX = FFH for ready or 00h for not ready
           8 = Is block device BL changeable? (DOS 3)
               AX = 0 = yes
           9 = Is logical device BL local? (DOS 3)
               DX (attribute word) bit 12 (1000h) = 0 = yes
          10 = Is handle BX local? (DOS 3)
               DX (attribute word) bit 15 (8000h) = 0 = yes
          11 = Change sharing retry count to DX (def 3), (DOS 3.x)
               delay CX (def 1)
          12 = General IOCTL (DOS 3.3 [3.2?])
        BX = file handle (or BL = drive number w/0 = default)
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Create Duplicate Handle (DUP)
        AH = 45h
        BX = file handle to duplicate
Return: CF = 1 if error
            AX = Error Code
        CF = 0 successful
            AX = new file handle
-----------------------------------------------------------
INT 21 - Force Duplicate Handle (FORCDUP) (DUP2)
        AH = 46h
        BX = Existing file handle
        CX = new file handle
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Get Current Directory
        AH = 47h
        DL = drive (0=default, 1=A, etc.)
        DS:SI points to 64-byte buffer area
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Allocate Memory
        AH = 48h
        BX = number of 16-byte paragraphs desired
Return: CF = 1 if error
            AX = Error Code
            BX = Maximum available
        CF = 0 successful
            AX = segment of allocated memory block
-----------------------------------------------------------
INT 21 - Free Memory
        AH = 49h
        ES = Segment address of area to be freed
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Adjust Block Size (SETBLOCK)
        AH = 4Ah
        ES = Segment address of block to change
        BX = New size in paragraphs
Return: CF = 1 if error
            AX = Error Code
            BX = Maximum size possible for the block
-----------------------------------------------------------
INT 21 - Load or Execute (EXEC)
        AH = 4Bh
        AL = subfunction
            0 = load and execute program
            2 = load (Internal) but do not execute
            3 = load overlay; do not create PSP
        DS:DX = filename
        ES:BX = parameter block
               AL =
                0 => word segment environment pointer
                     dword command line pointer
                     dword FCB 1
                     dword FCB 2
                3 => word segment load address
                     word segment relocation factor
Return: CF = 1 if error
            AX = Error Code

struct exec {
        unsigned exec_magic;    /* 0x4d, 0x5a signature */
        unsigned exec_isr;      /* image size remainder (mod 512) */
        unsigned exec_size;     /* file size in pages (512) */
        unsigned exec_nrel;     /* number of relocation items */
        unsigned exec_hsize;    /* header size in paragraphs */
        unsigned exec_min;      /* minimum extra paragraphs */
        unsigned exec_max;      /* maximum extra paragraphs */
        unsigned exec_ss;       /* stack segment */
        unsigned exec_sp;       /* stack offset */
        unsigned exec_cksum;    /* word checksum of entire file */
        unsigned exec_pc;       /* initial pc */
        unsigned exec_cs;       /* code segment */
        unsigned exec_orel;     /* offset of relocation table */
        unsigned exec_ovno;     /* overlay number */
};
-----------------------------------------------------------
INT 21 - Quit With Exit Code (EXIT)
        AH = 4Ch
        AL = exit code
Return: never returns
-----------------------------------------------------------
INT 21 - GET EXIT CODE OF SUBPROGRAM (WAIT)
        AH = 4Dh
Return: AL = exit code of subprogram (functions 31h or 4Ch)
        AH = circumstance which caused termination
            0 = Terminate/abort
            1 = Control-C
            2 = Hard error
            3 = Terminate and stay resident
-----------------------------------------------------------
INT 21 - Find First ASCIIZ (FIND FIRST)
        AH = 4Eh
        CX = search attributes
        DS:DX = pointer to ASCIIZ filename
Return: CF = 1 if error
            AX = Error Code if any
        (DTA) = data block
-----------------------------------------------------------
INT 21 - Find Next ASCIIZ (FIND NEXT)
        AH = 4Fh
Return: CF = 1 if error
            AX = Error Code
        (DTA) = data block
-----------------------------------------------------------
INT 21 - Internal - Set PSP Segment
        AH = 50h
        BX = Segment address of new PSP
Note: under DOS 2.xx, this function cannot be invoked inside an INT 28h
handler
-----------------------------------------------------------
INT 21 - Internal - Get PSP Segment
        AH = 51h
Return: BX = Current PSP Segment

struct psp {
        char psp_int20[2];      /* 00h: exit */
        unsigned psp_msize;     /* 02h: memory size in paragraphs */
        char psp_res0[1];       /* 04h: XXX (0) */
        char psp_dos[5];        /* 05h: far call to dos */
        int (*psp_term)();      /* 0ah: terminate address */
        unsigned psp_tseg;      /* 0ch: terminate segment */
        int (*psp_break)();     /* 0eh: break address */
        unsigned psp_bseg;      /* 10h: break segment */
        int (*psp_error)();     /* 12h: error address */
        unsigned psp_eseg;      /* 14h: error segment */
        unsigned psp_ppsp;      /* 16h: parent psp segment */
        char psp_ofile[20];     /* 18h: open files, 0xff = unused */
        unsigned psp_envp;      /* 2ch: environment segment */
        char psp_res2[4];       /* 2eh: XXX */
        int psp_nfiles;         /* 32h: max open files */
        char *psp_aofile;       /* 34h: ofile address */
        unsigned psp_aoseg;     /* 36h: ofile segment */
        char psp_res3[24];      /* 38h: XXX */
        char psp_int21[3];      /* 50h: int 21, far return */
        char psp_res4[2];       /* 53h: XXX */
        char psp_xfcb1[7];      /* 55h: FCB #1 extension */
        char psp_fcb1[9];       /* 5ch: FCB #1 */
        char psp_xfcb2[7];      /* 65h: FCB #2 extension */
        char psp_fcb2[20];      /* 6ch: FCB #2 */
        char psp_dma[128];      /* 80h: Command Tail */
};
Note: under DOS 2.xx, this function cannot be invoked inside an INT 28h
handler
-----------------------------------------------------------
INT 21 - Internal - Get Disk List
        AH = 52h
Return: ES:BX points to DOS list of lists

List of Lists:
Bytes   Value
-2&-1   Segment of first memory control block
0-3     Pointer to first DOS disk block (see func 36h)
4-7     Partially Unknown. Pointer to a device driver. Maybe first
               resident driver?
8-B     Pointer to CLOCK$ device driver, whether installable or
               resident
C-F     Pointer to actual CON: device driver, whether installable
               or resident
-----DOS 2.x
10      Number of logical drives in system
11-12   Maximum bytes/block of any block device
13-16   unknown
17      Beginning (not a pointer. The real beginning!) of NUL device
           driver. This is the first device on DOS's linked list
           of device drivers.
-----DOS 3.x
10-11   Maximum bytes/block of any block device (0200h)
12-15   Unknown. Pointer to current directory block????
16-19   Partially Undefined: Pointer to array of drive info:
               51h bytes per drive, starting with A: ...
               00-3F Current path as ASCIIZ, starting with 'x:\'
               40-43 Unknown. I see zeros always
               44    Unknown. Flags? I see 40h, except for
                       entry after last valid entry = 00h
               45-48 Pointer to DOS Disk Block for this drive
               49-4A Unknown. Current track or block? -1 if never
                       accessed.
               4B-4E Unknown. I see -1 always
               4F-52 Unknown. I see 2 always
1A-1D   Unknown. Pointer to data area, maybe including cluster
               allocation table?
1E-1F   Unknown. I see zero always
20      Number of block devices.
21      Value of LASTDRIVE command in CONFIG.SYS (default 5)
22      Beginning (not a pointer. The real beginning!) of NUL device
           driver. This is the first device on DOS's linked list
           of device drivers.
-----------------------------------------------------------
INT 21 - Internal - Translate BPB
        AH = 53h
        DS:SI points to BPB (Bios Parameter Block)
        ES:BP points to area for DOS Disk Block
Translates BPB (Bios Parameter Block, see below)
into a DOS Disk Block (see function call 32h).

BPB
Bytes   Value
0-1     Bytes/sector. Get from DDB bytes 2-3.
2       Sectors/cluster. Get from: (DDB byte 4) + 1
3-4     Reserved sectors. Get from: DDB bytes 6-7
5       Number of FATs. Get from: DDB byte 8
6-7     Number of root dir entries. Get from: DDB bytes 9-A
8-9     Total # of sectors. Get from:
        ((DDB bytes D-E) - 1) * (sectors per cluster (BPB byte 2))
          + (DDB Bytes B-C)
A       Media descriptor byte. Get from: DDB byte 16
B-C     Number of sectors/FAT. Get from: DDB byte F
-----------------------------------------------------------
INT 21 - Get Verify Flag
        AH = 54h
Return: AL = 0 if flag OFF
        AL = 1 if flag ON
-----------------------------------------------------------
INT 21 - Internal - Create PSP
        AH = 55h
        DX = Segment number to set up PSP at
Note: Like FN 26h but creates "child" PSP rather than copying existing one.
-----------------------------------------------------------
INT 21 - RENAME A FILE
        AH = 56h
        DS:DX = pointer to ASCIZ old name
        ES:DI = pointer to ASCIZ new name
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Get/Put Date/Time
        AH = 57h
        AL = function code
            0 = get date and time
            1 = set date and time
               CX = time to be set
               DX = date to be set
        BX = file handle
Return: CF = 1 if error
            AX = Error Code
        CX = time of last write (if AL = 0)
        DX = date of last write (if AL = 0)
-----------------------------------------------------------
INT 21 - Get/Set allocation strategy (DOS 3.x)
        AH = 58h
        AL = function code
            0 = get allocation strategy
            1 = set allocation strategy
               BL = strategy code
                   0 first fit (use first memory block large enough)
                   1 best fit (use smallest memory block large enough)
                   2 last fit (use high part of last usable memory block)
Return: CF = 1 error
            AX = Error Code
        CF = 0 successful
            AX = strategy code
Note: the Set subfunction accepts any value in BL; 2 or greater means last fit.
      the Get subfunction returns the last value set, so programs should check
      whether the value is >= 2, not just equal to 2.
-----------------------------------------------------------
INT 21 - GET EXTENDED ERROR CODE (DOS 3.X)
        AH = 59h
        BX = version code (0000 for DOS 3.0)
Return: AX = extended error code
        BH = class of error
        BL = suggested action code
        CH = locus (where error occurred)
Error codes:
        01 function number invalid
        02 file not found
        03 path not found
        04 too many open files
        05 access denied
        06 invalid handle
        07 memory control block destroyed
        08 insufficient memory
        09 memory block address invalid
        0A environment invalid
        0B format invalid
        0C access code invalid
        0D data invalid
        0F invalid drive
        10 attempted to remove current directory
        11 not same device
        12 no more files
        13 disk write-protected
        14 unknown unit
        15 drive not ready
        16 unknown command
        17 data error (CRC)
        18 bad request structure length
        19 seek error
        1A unknwon media type
        1B sector not found
        1C printer out of paper
        1D write fault
        1E read fault
        1F general failure
        20 sharing violation
        21 lock violation
        22 disk change invalid
        23 FCB unavailable
        24-31 reserved
        32 Network request not supported (DOS 3.1 + MS Networks)
        33 Remote computer not listening
        34 Duplicate name on network
        35 Network name not found
        36 Network busy
        37 Network device no longer exists
        38 Network BIOS command limit exceeded
        39 Network adapter hardware error
        3A Incorrect response from network
        3B Unexpected network error
        3C Incompatible remote adapter
        3D Print queue full
        3E Queue not full
        3F Not enough space to print file
        40 Network name was deleted
        41 Network: Access denied
        42 Network device type incorrect
        43 Network name not found
        44 Network name limit exceeded
        45 Network BIOS session limit exceeded
        46 Temporarily paused
        47 Network request not accepted
        48 Print/disk redirection paused (DOS 3.1 + MS Networks)
        49-4F reserved
        50 file exists
        51 reserved
        52 cannot make directory
        53 fail on INT 24h
Error Classes:
        01 out of resource
        02 temporary situation
        03 authorization (denied access)
        04 internal
        05 hardware failure
        06 system failure
        07 application program error
        08 not found
        09 bad format
        0A locked
        0B media error
        0C already exists
        0D unknown
Suggested Action:
        01 retry
        02 delayed retry
        03 prompt user
        04 abort after cleanup
        05 immediate abort
        06 ignore
        07 retry after user intervention
Error Locus:
        01 unknown or not appropriate
        02 block device
        03 network related
        04 serial device
        05 memory related
-----------------------------------------------------------
INT 21 - CREATE TMEPORARY FILE (DOS 3.x)
        AH = 5Ah
        DS:DX = pointer to ASCIZ directory path name
        CX = file attribute
Return: CF = 1 if error
            AX = Error Code if any
        DS:DX = path name
Note: The file created is not truly "temporary".  It MUST be removed
      by the user.
-----------------------------------------------------------
INT 21 - CREATE NEW FILE (DOS 3.x)
        AH = 5Bh
        DS:DX = pointer to ASCIZ directory path name
        CX = file attribute
Return: CF = 1 if error
            AX = Error Code if any
        DS:DX = path name
Note: Unlike function 3Ch, function 5Bh will fail if the file already
      exists.
-----------------------------------------------------------
INT 21 - LOCK/UNLOCK FILE ACCESS (DOS 3.x)
        AH = 5Ch
        AL = 0 if lock
             1 if unlock
        BX = file handle
        CX:DX = starting offset of region to lock
        SI:DI = size of region to lock
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Internal - Get address of critical error flag
        AX = 5D06h
Return: DS:SI = pointer to critical error flag
        CX = ???
        DX = ???
Note: this call also does a lot of other work in addition to returning
   the pointer
-----------------------------------------------------------
INT 21 - Internal - Unknown
        AH = 5Dh
        AL = subfunction
             07h: ???
             08h: (used by COMMAND.COM)
             09h: (used by COMMAND.COM)
-----------------------------------------------------------
INT 21 - Get Machine Name (DOS 3.1 + Microsoft Networks)
        AX = 5E00h
        DS:DX -> buffer for ASCIIZ name
Return: CF = 1 if error
            AX = Error Code
        CH = 0 if name not defined
        CL = NETBIOS name number
        DS:DX -> pointer to identifier if CH <> 0
-----------------------------------------------------------
INT 21 - Set Printer Setup (DOS 3.1 + Microsoft Networks)
        AX = 5E02h
        BX = Redirection list index
        CX = length of setup string <= 64
        DS:SI -> string buffer
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Get Printer Setup (DOS 3.1 + Microsoft Networks)
        AX = 5E03h
        BX = Redirection list index
        ES:DI -> string buffer
Return: CF = 1 if error
            AX = Error Code
        CX = length of setup string <= 64
-----------------------------------------------------------
INT 21 - Get Redirection List Entry (DOS 3.1 + Microsoft Networks)
        AX = 5F02h
        BX = Redirection list index
        DS:SI -> 16 char local device name buffer
        ES:DI -> 128 char network name buffer
Return: CF = 1 if error
            AX = Error Code
        BH = Device status flag (BIT 0 = 0 if valid)
        BL = device type (03 if printer, 04 if drive)
        CX = stored parameter value
Note: DX and BP are destroyed by this call!
-----------------------------------------------------------
INT 21 - Redirect Device (DOS 3.1 + Microsoft Networks)
        AX = 5F03h
        BL = device type
                03 = printer device
                04 = file device
        CX = stored parameter value
        DS:SI -> source device name
        ES:DI -> destination ASCIIZ network path + ASCIIZ password
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Cancel Redirection (DOS 3.1 + Microsoft Networks)
        AX = 5F04h
        DS:SI -> device name or network path
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 21 - Internal - Resolve path string to fully qualified path string
        AH = 60h
        DI:SI = relative path strings
        ES:DI = buffer for fully qualified name
Return: buffer filled with qualified name
        may return error code, unknown.
-----------------------------------------------------------
INT 21 - Internal - Unused (DOS 3.x)
        AH = 61h
Return: AL = 0
-----------------------------------------------------------
INT 21 - GET PSP ADDRESS (DOS 3.x)
        AH = 62h
Return: BX = segment address of PSP
-----------------------------------------------------------
INT 21 - GET LEAD BYTE TABLE (DOS 2.25 only)
        AH = 63h
        AL = subfunction
             0 = get system lead byte table
             1 = set/clear interim console flag
                DL = 1/0 to set/clear interim console flag
             2 = get interim console flag
Return: DS:SI -> lead byte table (AL = 0)
        DL = interim console flag (AL = 2)
-----------------------------------------------------------
INT 21 - Internal - unknown (DOS 3.3)
        AH = 64h
-----------------------------------------------------------
INT 21 - GET EXTENDED COUNTRY INFORMATION (DOS 3.3)
        AH = 65h
        AL = info ID (1 - 6)
        BX = code page (-1=global code page)
        DX = country ID (-1=current country)
        ES:DI = pointer to country information buffer
        CX = size of buffer
Return: AX = error code if carry set, otherwise
        CX = size of country information returned
        ES:DI = pointer to country information:
               1 BYTE info ID
               if info ID <> 1
                  1 DWORD pointer to information
               if info ID == 1
                  1 WORD size
                  1 WORD country ID
                  1 WORD code page
                 34 BYTE see function 38h
-----------------------------------------------------------
INT 21 - GET/SET GLOBAL CODE PAGE TABLE (DOS 3.3)
        AH = 66h
        AL = 00h get global code page
             Return: AX = error code if carry flag set
                     BX = active code page
                     DX = system code page
           = 01h set global page
             BX = active code page
             DX = system code page (active page at boot time)
             Return: AX = error code if carry flag set
-----------------------------------------------------------
INT 21 - SET HANDLE COUNT (DOS 3.3)
        AH = 67h
        BX = desired number of handles (max 255)
Return: Carry clear if ok
        Carry set if error (and error code in AX)
-----------------------------------------------------------
INT 21 - COMMIT FILE - WRITE ALL BUFFERED DATA TO DISK (DOS 3.3)
        AH = 68h
        BX = file handle
Return: carry flag set on error (and error code in AX)
-----------------------------------------------------------
INT 21 - DoubleDos -
        AX = E400h
Return: AL <> 0 if DoubleDos is active
-----------------------------------------------------------
INT 21 - DoubleDos - Turn off Task Switching
        AH = EAh
Return: task switching turned off
-----------------------------------------------------------
INT 21 - DoubleDos - Turn on Task Switching
        AH = EBh
Return: task switching turned on
-----------------------------------------------------------
INT 21 - DoubleDos - Get Virtual Screen Address
        AH = ECh
Return: ES = segment of virtual screen
Note: Screen address can change if task-switching is on!!
-----------------------------------------------------------
INT 21 - DoubleDos - Give away time to other tasks
        AH = EEh
        AL = number of 55ms time slices to give away
Return: returns after giving away time slices
-----------------------------------------------------------
INT 21 - CED installable commands
        AH = 0FFh
           AL = 0 add installable command
             BL = mode - bit 0 = 1 callable from DOS prompt
                         bit 1 = 1 callable from application
             DS:SI pointer to CR-terminated command name
             ES:DI pointer to FAR routine entry point
           AL = 1 remove installable command
             DS:SI pointer to CR-terminated command name
           AL = 2 reserved, may be used to test for CED installation
Return: CF set on error
            AX = 01h invalid function
                 02h command not found (subfunction 1 only)
                 08h insufficient memory (subfunction 0 only)
                 0Eh bad data (subfunction 0 only)
        AH = 0FFh if CED not installed
-----------------------------------------------------------
INT 22 - TERMINATE ADDRESS
   FAR (DWORD) address of routine to be executed when program
   "returns to DOS".  Should NEVER be called directly.
-----------------------------------------------------------
INT 23 - CONTROL "C" EXIT ADDRESS
   Automatically called from keyboard scanner when CTRL-C or
   CTRL-BREAK is detected. Normally aborts program and returns
   to DOS, but may be changed.
-----------------------------------------------------------
INT 24 - FATAL ERROR ABORT ADDRESS
   Automatically called upon detection of unrecoverable
   disk error. Normally prints "Abort, Retry, or Ignore?" message
   and takes the reply, but may be changed if desired.

Provides the following values in registers on entry to interrupt handler:
        AH: bit 7 = 0 disk I/O error
                  = 1 other error -- if block device, bad FAT
                                  -- if char device, code in DI
            bit 6  unused
            bit 5 = 1 if Ignore allowed, 0 if not (DOS 3.2?)
            bit 4 = 1 if Retry allowed, 0 if not (DOS 3.2?)
            bit 3 = 1 if Fail allowed, 0 if not (DOS 3.2+)
            bit 2 \ disk area of error  00 = DOS area  01 = FAT
            bit 1 /                     10 = root dir  11 = data area
            bit 0 = 1 if write, 0 if read
        AL = drive number if AH bit 7 = 1, otherwise undefined
        BP:SI = address of device header for which error occurred
            block device if high bit of BP:SI+4 = 1
        low byte of DI:
           00h write-protect error
           01h unknown unit
           02h drive not ready
           03h unknown command
           04h data error (bad CRC)
           05h bad request structure length
           06h seek error
           07h unknown media type
           08h sector not found
           09h printer out of paper
           0Ah write fault
           0Bh read fault
           0Ch general failure
           0Fh invalid disk change (DOS 3.x)
Handler must return
        AL = 00 ignore error
           = 01 retry operation
           = 02 terminate program through INT 22h
           = 03 fail system call in progress (DOS 3.2+)
-----------------------------------------------------------
INT 25 - ABSOLUTE DISK READ
        AL = Drive number (0=A, 1=B, etc)
        DS:BX = Disk Transfer Address (buffer)
        CX = Number of sectors to read
        DX = First relative sector to read
Return: CF = 1 if error
            AL = error code issued to INT 24h in low half of DI
            AH = 80h if attachment failed to respond
                 40h if seek operation failed
                 20h if controller failed
                 10h if data error (bad CRC)
                 08h if DMA failure
                 04h if requested sector not found
                 03h if write-protected disk
                 02h if bad address mark
                 01h if bad command
Note: ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 26 - ABSOLUTE DISK WRITE
        AL = Drive number (0=A, 1=B, etc)
        DS:BX = Disk Transfer Address (buffer)
        CX = Number of sectors to write
        DX = First relative sector to write
Return: CF = 1 if error
            AL = error code issued to INT 24h in low half of DI
            AH = same error codes as for INT 25h
Note: ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 27 - TERMINATE BUT STAY RESIDENT
        CS = current program segment
        DX = last program byte + 1
-----------------------------------------------------------
INT 28 - Internal - Keyboard Busy Loop
   This interrupt is called from inside the "get input from keyboard"
   routine in DOS, if and only if it is safe to use INT 21 to access
   the disk at that time. It is used primarily by the PRINT.COM
   routines and TSR programs, but any number of other routines could
   be chained to it by saving the original vector, and calling it
   with a FAR call (or just JMPing to it) at the end of the new
   routine.

   The INT 28h handler may invoke any INT 21h function except functions
   00h through 0Ch (and 50h/51h under DOS 2.xx).

   Until some program installs its own routine, this interrupt vector
   simply points to an IRET opcode.
-----------------------------------------------------------
INT 29 - Internal - Fast Putchar
   This interrupt is called from the DOS output routines if output
   is going to a device rather than a file, and the device driver's
   attribute word has bit 3 (04h) set to "1".
-----------------------------------------------------------
INT 2A - Network Installation Check (Microsoft Networks)
        AH = 00h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2A - Check Direct I/O (Microsoft Networks)
        AX = 0300h
        DS:SI -> ASCIIZ disk device name
Return: CF == 0 if allowed
-----------------------------------------------------------
INT 2A - Execute NETBIOS (Microsoft Networks)
        AH = 04h
        AL = 0 for error retry, 1 for no retry
        ES:BX -> NCB
Return: AX = 0 for no error
        AH = 1, AL = error code
-----------------------------------------------------------
INT 2A - Get Network Resource Information (Microsoft Networks)
        AX = 0500h
Return: AX = reserved
        BX = number of network names
        CX = number of commands
        DX = number of sessions
-----------------------------------------------------------
INT 2A - Unknown
        AH = 82h
Return: ???
Note: Called by the INT 21h function dispatcher in DOS 3.10
-----------------------------------------------------------
INT 2B - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2C - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2D - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2E - Internal - Execute Command
        ES:SI -> counted CR-terminated command string

The top-level command.com executes the command; all registers
are destroyed as in exec.
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Installation Check
        AX = 0100h
Return: AL =
            FFh installed
            01h not installed, not OK to install
            00h not installed, OK to install
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Submit file
        AX = 0101h
        DS:DX -> packet of one byte level and DWORD file pointer
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Remove file
        AX = 0102h
        DS:DX -> file name (wildcards allowed)
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Remove all files
        AX = 0103h
Return: CF = 1 if error
            AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Hold queue/Get status
        AX = 0104h
Return: CF = 1 if error
            AX = Error Code
                01h function invalid
                02h file not found
                03h path not found
                04h too many open files
                05h access denied
                08h queue full
                09h spooler busy
                0Ch name too long
                0Fh drive invalid
        DX = Error count
        DS:SI -> print queue (null-string terminated
                 list of 64-byte ASCIZ file names)
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Restart queue
        AX = 0105h
Return: Flag CF = 1 if error
        AX = Error Code if any
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN Installation Check
        AX = 0600h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN
        AX = 0601h XXX
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal
        AH = 10h XXX
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal
        AH = 11h XXX
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal
        AH = 12h XXX
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND Installation Check
        AX = B700h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND
        AX = B701h XXX
-----------------------------------------------------------
INT 2F - Multiplexor - Network Program Installation Check
        AX = B800h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - Get Current Post Address
        AX = B803h
Return: ES:BX = post address
-----------------------------------------------------------
INT 2F - Multiplexor - Set New Post Address
        AX = B804h
        ES:BX = new post address
-----------------------------------------------------------
INT 30 -> (NOT A VECTOR!) FAR jump instruction for CP/M-style calls
INT 31
-----------------------------------------------------------
INT 32 -> not used
-----------------------------------------------------------
INT 33 -> USED BY MICROSOFT MOUSE
-----------------------------------------------------------
INT 40 -> Relocated (by fixed disk) Floppy Handler (original INT 13h)
-----------------------------------------------------------
INT 41 -> Fixed Disk Params
        dw      cylinders
        db      heads
        dw      0
        dw      write pre-comp
        db      0
        db      0 "control byte"
        db      0, 0, 0
        dw      landing zone
        db      sectors/track
        db      0
-----------------------------------------------------------
INT 42 -> Relocated (by EGA) Video Handler (original INT 10h)
-----------------------------------------------------------
INT 43 -> EGA Initialization Params
-----------------------------------------------------------
INT 44 -> EGA/PCjr fonts
-----------------------------------------------------------
INT 45 -> reserved
-----------------------------------------------------------
INT 46 -> Secondary Fixed Disk Params (see INT 41h)
-----------------------------------------------------------
INT 47 -> reserved
-----------------------------------------------------------
INT 48 -> PCjr Cordless Keyboard Translation
-----------------------------------------------------------
INT 49 -> PCjr Non-keyboard Scan Code Translation Table
-----------------------------------------------------------
INT 4A -> AT User Alarm
-----------------------------------------------------------
INT 4B -> reserved
-----------------------------------------------------------
INT 4C -> reserved
-----------------------------------------------------------
INT 4D -> reserved
-----------------------------------------------------------
INT 4E -> reserved
-----------------------------------------------------------
INT 4F -> reserved
-----------------------------------------------------------
INT 50-57 -> IRQ0-IRQ7 relocated by DESQview
-----------------------------------------------------------
INT 58 -> reserved
-----------------------------------------------------------
INT 59 -> reserved
-----------------------------------------------------------
INT 5A -> reserved
-----------------------------------------------------------
INT 5B -> reserved
-----------------------------------------------------------
INT 5C - NETBIOS interface
        ES:BX -> Network Control Block
-----------------------------------------------------------
INT 5D -> reserved
-----------------------------------------------------------
INT 5E -> reserved
-----------------------------------------------------------
INT 5F -> reserved
-----------------------------------------------------------
INT 60-67 -> reserved for user interrupts
-----------------------------------------------------------
INT 67 - LIM EMS - Get Manager Status
        AH = 40h
Return: AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            84h undefined function requested by application
Note: this call can be used only after establishing that the EMS driver
      is in fact present
-----------------------------------------------------------
INT 67 - LIM EMS - Get Page Frame Segment
        AH = 41h
Return: AH = 00h function successful
            BX = segment of page frame
        AH = error code (see AH=40h above)
-----------------------------------------------------------
INT 67 - LIM EMS - Get Number of Pages
        AH = 42h
Return: AH = 00h function successful
            BX = number of unallocated pages
            DX = total number of pages
        AH = error code (see AH=40h above)
-----------------------------------------------------------
INT 67 - LIM EMS - Get Handle and Allocate Memory
        AH = 43h
        BX = number of logical pages to allocate
Return: AH = status
            00h function successful
                DX = handle
            80h internal error
            81h hardware malfunction
            84h undefined function requested
            85h no more handles available
            87h more pages requested than physically exist
            88h more pages requested than currently available
            89h zero pages requested
-----------------------------------------------------------
INT 67 - LIM EMS - Map Memory
        AH = 44h
        AL = physical page number (0-3)
        BX = logical page number
        DX = handle
Return: AH = status
            00h function successful
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
            8Ah invalid logical page number
            8Bh illegal physical-page number
-----------------------------------------------------------
INT 67 - LIM EMS - Release Handle and Memory
        AH = 45h
        DX = EMM handle
Return: AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
            86h error in save or restore of mapping context
-----------------------------------------------------------
INT 67 - LIM EMS - Get EMM Version
        AH = 46h
Return: AH = status
            00h successful
                AL = EMM version number
            80h internal error
            81h hardware malfunction
            84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - Save Mapping Context
        AH = 47h
        DX = handle
Return: AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
            8Ch page-mapping hardware state save area is full
            8Dh save of mapping context failed
-----------------------------------------------------------
INT 67 - LIM EMS - Restore Maping Context
        AH = 48h
        DX = handle
Return: AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
            8Eh restore of mapping context failed
-----------------------------------------------------------
INT 67 - LIM EMS - reserved
        AH = 49h
Note: defined in EMS 3.0, but undocumented in EMS 3.2
-----------------------------------------------------------
INT 67 - LIM EMS - reserved
        AH = 4Ah
Note: defined in EMS 3.0, but undocumented in EMS 3.2
-----------------------------------------------------------
INT 67 - LIM EMS - Get Number of EMM Handles
        AH = 4Bh
Return: AH = status
            00h successful
                BX = number of EMM handles
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - Get Pages Owned by Handle
        AH = 4Ch
        DX = EMM handle
Return: AH = status
            00h successful
                BX = number of logical pages
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - Get Pages for All Handles
        AH = 4Dh
        ES:DI = pointer to array to receive information
Return: AH = status
            00h successful
                BX = number of active EMM handles
                array filled with 2-word entries, consisting of a handle
                  and the number of pages allocated to that handle
            80h internal error
            81h hardware malfunction
            84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - Get or Set Page Map
        AH = 4Eh
        AL = 00h if getting mapping registers
             01h if setting mapping registers
             02h if getting and setting mapping registers at once
             03h if getting size of page-mapping array
        DS:SI = pointer to array holding information (AL=01/02)
        ES:DI = pointer to array to receive information (AL=00/02)
Return: AH = status
            00h successful
                AL = bytes in page-mapping array (subfunction 03h only)
                array pointed to by ES:DI receives mapping info (AL=00/02)
            80h internal error
            81h hardware malfunction
            84h undefined function requested
            8Fh undefined subfunction parameter
            A3h contents of source array corrupted (EMS 4.0?)
Note: this function was designed to be used by multitasking operating systems
      and should not ordinarily be used by appplication software.
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Get/Set Partial Page Map
        AH = 4Fh
        AL = subfunction
            00h get partial page map
               DS:SI = pointer to structure containing list of segments whose
                       mapping contexts are to be saved
               ES:DI = pointer to array to receive page map
            01h set partial page map
               DS:SI = pointer to structure containing saved partial page map
            02h get size of partial page map
               BX = number of mappable segments in the partial map to be saved
Return: AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            84h undefined function requested
            8Bh one of specified segments is not mappable
            8Fh undefined subfunction parameter
            A3h contents of partial page map corrupted or count of mappable
                segments exceeds total number of mappable segments in system
        AL = size of partial page map for subfunction 02h
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Map/Unmap Multiple Handle Pages
        AH = 50h
        AL = subfunction
            00h
            01h
        DX = handle
        CX = number of entries in array
        DS:SI = pointer to mapping array
Return: AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
            8Ah one or more logical pages are invalid
            8Bh one or more physical pages are invalid
            8Fh invalid subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Reallocate Pages
        AH = 51h
        DX = handle
        BX = number of pages to be allocated to handle
Return: BX = actual number of pages allocated to handle
        AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
            87h more pages requested than present in system
            88h more pages requested than currently available
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Get/Set Handle Attributes
        AH = 52h
        AL = subfunction
            00h get handle attributes
            01h set handle attributes
               BL = new attribute (see returned AL)
            02h get attribute capability
        DX = handle
Return: AL = attribute (for subfunction 00h)
            00h handle is volatile
            01h handle is nonvolatile
        AL = attribute capability (for subfunction 02h)
            00h only volatile handles supported
            01h both volatile and non-volatile supported
        AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
            8Fh undefined subfunction
            90h undefined attribute type
            91h feature not supported

        AH = 53h
        AL = subfunction
            00h get handle name
               ES:DI = pointer to 8-byte handle name array
            01h set handle name
               DS:SI = pointer to 8-byte handle name
        DX = handle
Return: AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            83h invalid handle
            84h undefined function requested
            8Fh undefined subfunction
            A1h duplicate handle name
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Get Handle Directory
        AH = 54h
        AL = subfunction
            00h get handle directory
               ES:DI = pointer to buffer for handle directory
            01h search for named handle
               DS:SI = pointer to 8-byte name
            02h get total number of handles
Return: AL = number of entries in handle directory (subfunction 00h)
        DX = value of named handle (subfunction 01h)
        BX = total number of handles (subfunction 02h)
        AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            84h undefined function requested
            8Fh undefined subfunction
            A0h no such handle name
            A1h a handle found had no name
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Alter Page Map and Jump
        AH = 55h
        AL = subfunction
            00h physical page numbers provided by caller
            01h segment addresses provided by caller
        DX = handle
        DS:SI = pointer to structure containing map and jump address
Return: (at target address unless error)
        AH = status
            00h successful
            80h internal error
            81h hardware failure
            83h invalid handle
            84h undefined function requested
            8Ah invalid logical page number encountered
            8Bh invalid physical page number encountered
            8Fh invalid subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Alter Page Map and Call
        AH = 56h
        AL = subfunction
            00h physical page numbers provided by caller
               DX = handle
               DS:SI = pointer to structure containing page map and call address
            01h segment addresses provided by caller
               DX = handle
               DS:SI = pointer to structure containing page map and call address
            02h get page map stack space required
Return: (if successful, the target address is called.  Use a RETF to return and
         restore mapping context)
        BX = stack space required (subfunction 02h)
        AH = status
            00h successful
            80h internal error
            81h hardware failure
            83h invalid handle
            84h undefined function requested
            8Ah invalid logical page number encountered
            8Bh invalid physical page number encountered
            8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Move/Exchange Memory Region
        AH = 57h
        AL = subfunction
            00h move memory region
            01h exchange memory region
        DS:SI = pointer to structure describing source and destination
Return: AH = status
            00h successful
            80h internal error
            81h hardware failure
            83h invalid handle
            84h undefined function requested
            8Ah invalid logical page number encountered
            8Fh undefined subfunction
            92h successful, but a portion of the source region has been
                overwritten
            93h length of source or destination region exceeds length of region
                allocated to either source or destination handle
            94h conventional and expanded memory regions overlap
            95h offset within logical page exceeds size of logical page
            96h region length exceeds 1M
            97h source and destination EMS regions have same handle and overlap
            98h memory source or destination type undefined
            A2h attempted to wrap around 1M conventional address space
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Get Mappable Physical Address Array
        AH = 58h
        AL = subfunction
            00h get mappable physical address array
               ES:DI = pointer to buffer to be filled with array
            01h get number of entries in m.p.a. array
Return: CX = number of entries in array
        AH = status
            00h successful
            80h internal error
            81h hardware failure
            84h undefined function requested
            8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Get Expanded Memory Hardware Information
        AH = 59h
        AL = subfunction
            00h get hardware configuration array
               ES:DI = pointer to buffer to be filled with array
            01h get unallocated raw page count
Return: BX = unallocated raw pages (subfunction 01h)
        DX = total raw pages (subfunction 01h)
        AH = status
            00h successful
            80h internal error
            81h hardware failure
            84h undefined function requested
            8Fh undefined subfunction
            A4h access denied by operating system
Note: subfunction 00h is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Allocate Standard/Raw Pages
        AH = 5Ah
        AL = subfunction
            00h allocate standard pages
            01h allocate raw pages
        BX = number of pages to allocate
Return: DX = handle
        AH = status
            00h successful
            80h internal error
            81h hardware failure
            84h undefined function requested
            85h no more handles available
            87h insufficient memory pages in system
            88h insufficient memory pages available
            8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Alternate Map Register Set
        AH = 5Bh
        AL = subfunction
            00h get alternate map register set
            01h set alternate map register set
               BL = new alternate map register set number
               ES:DI = pointer to map register context save area if BL=0
            02h get alternate map save array size
            03h allocate alternate map register set
            04h deallocate alternate map register set
               BL = number of alternate map register set
Return: BL = current active alternate map register set number if nonzero (AL=0)
        ES:DI = pointer to a map register context save area if BL=0 (AL=0)
        DX = array size in bytes (subfunction 02h)
        BL = number of alternate map register set; zero if not supported (AL=3)
        AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            84h undefined function requested
            8Fh undefined subfunction
            9Ah specified alternate map register set not supported
            9Bh all alternate map register sets currently allocated
            9Ch alternate map register sets not supported
            9Dh undefined or unallocated alternate map register set
            A3h source array corrupted
            A4h operating system denied access
Note: this function is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Alternate Map Register Set - DMA registers
        AH = 5Bh
        AL = subfunction
            05h allocate DMA register set
            06h enable DMA on alternate map register set
               BL = DMA register set number
               DL = DMA channel number
            07h disable DMA on alternate map register set
               BL = DMA register set number
            08h deallocate DMA register set
               BL = DMA register set number
Return: BL = DMA register set number; zero if not supported (subfunction 05h)
        AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            84h undefined function requested
            8Fh undefined subfunction
            9Ah specified DMA register set not supported
            9Bh all DMA register sets currently allocated
            9Ch alternate DMA sets not supported
            9Dh undefined or unallocated DMA register set
            9Eh dedicated DMA channels not supported
            9Fh specified dedicated DMA channel not supported
            A3h source array corrupted
            A4h operating system denied access
Note: this function is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Prepare Expanded Memory Hardware for Warm Boot
        AH = 5Ch
Return: AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - Enable/Disable OS Function Set Functions
        AH = 5Dh
        AL = subfunction
            00h enable OS Function Set
            01h disable OS Function Set
            02h return access key (resets memory manager, returns access key at
                next invocation)
        BX,CX = access key returned by first invocation
Return: BX,CX = access key, returned only on first invocation of function
        AH = status
            00h successful
            80h internal error
            81h hardware malfunction
            84h undefined function requested
            8Fh undefined subfunction
            A4h operating system denied access
-----------------------------------------------------------
INT 68 -> unused
-----------------------------------------------------------
INT 69 -> unused
-----------------------------------------------------------
INT 6A -> unused
-----------------------------------------------------------
INT 6B -> unused
-----------------------------------------------------------
INT 6C -> unused
-----------------------------------------------------------
INT 6D -> unused
-----------------------------------------------------------
INT 6E -> unused
-----------------------------------------------------------
INT 6F -> unused
-----------------------------------------------------------
INT 70 thru 77 - AT Vectored Hardware Lines
        IRQ8    -       real-time clock
        IRQ9    -       LAN adapter 1 (rerouted to INT 0Ah by BIOS)
        IRQ10   -       reserved
        IRQ11   -       reserved
        IRQ12   -       reserved
        IRQ13   -       80287 error (rerouted to INT 2 by BIOS)
        IRQ14   -       fixed disk
        IRQ15   -       reserved
-----------------------------------------------------------
INT 86 - Relocated (by NETBIOS) INT 18
-----------------------------------------------------------
INT E4 - Logitech Modula v2.0 - MonitorEntry
        AX = 5
        BX = priority
-----------------------------------------------------------
INT E4 - Logitech Modula v2.0 - MonitorExit
        AX = 6
-----------------------------------------------------------
INT F8 - INTERVAL TIMER (10 MSEC)
-----------------------------------------------------------
INT FA - USART READY (RS-232C)
-----------------------------------------------------------
INT FB - USART Rx READY (keyboard)
-----------------------------------------------------------

                                                 INT 67 - LIM EMS 4.0 - Get/Set Handle Name
*-*-*---------cut-----------cut----------------cut--------------*-*-*
Append part 3 here.

--
{harvard,uunet,ucbvax}!b.gp.cs.cmu.edu!ralf -=-=- AT&T: (412)268-3053 (school)
ARPA: RALF@B.GP.CS.CMU.EDU |"Tolerance means excusing the mistakes others make.
FIDO: Ralf Brown at 129/31 | Tact means not noticing them." --Arthur Schnitzler
                                                                                                                                                                                                                