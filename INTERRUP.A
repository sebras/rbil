Interrupt List		Release 90.1	Last change 1/6/90
This compilation is Copyright (c) 1989, 1990 Ralf Brown
---------------------------------------------
Please redistribute the following files unmodified as a group, in an archive
named INTER190:
	INTERRUP.1ST	the read-me file, containing credits, availability info
	INTERRUP.A	INT 00 through INT 27 \ total 274 pages at 60 lines
	INTERRUP.B	INT 28 through INT FF / per page, 296 with INTPRINT -p
	INTERRUP.PRI	a brief introduction to interrupts
	INTPRINT.COM	a simple formatter that also generates the list summary
	INTPRINT.DOC	instructions for INTPRINT
	INTPRINT.C	source code for INTPRINT
---------------------------------------------
If you notice any mistakes or omissions, please let me know!  It is only with
YOUR help that the list can continue to grow at the current rate.

Please read the file INTERRUP.1ST before asking me any questions.  You may find
that it's already been addressed.

	 Ralf Brown

ARPA: ralf@cs.cmu.edu
UUCP: {ucbvax,harvard}!cs.cmu.edu!ralf
BIT:  ralf%cs.cmu.edu@cmuccvb
FIDO: Ralf Brown 1:129/46 (new address!)
	or post a message to the DR_DEBUG echo
CIS:  >INTERNET:ralf@cs.cmu.edu 

I reply to all submissions and inquiries, but some of my replies bounce because
of bad return paths.  If you don't get a response from me within a reasonable
period of time, send it again with a better return path (starting at harvard or
ucbvax for UUCP, from the ARPA Internet for others).
---------------------------------------------
See INTERRUP.1ST for the key to system abbreviations and a list of the
trademarks mentioned here.
---------------------------------------------
DISCLAIMER:  I verify the information contained in this list to the best of my
ability, but I cannot be held responsible for any problems caused by use or
misuse of the information, especially for those functions not officially 
documented.  If it is marked "internal", you should check it carefully to make
sure it works the same way in your version of the software (and please let me
know whether or not it works the same way).  Information marked with "???" is
known to be incomplete or guesswork.
---------------------------------------------
The use of -> instead of = signifies that the indicated register or register
pair contains a pointer to the specified item, rather than the item itself
---------------------------------------------
INT 00 - internal hardware - DIVIDE ERROR
   Automatically called at end of DIV or IDIV operation that results in error
   or overflow.   Normally set by DOS to display an error message and abort
   the program.
Notes:	on an 8086/8088, the return address points to the following instruction
	on an 80286/80386, the return address points to the divide instruction
SeeAlso: INT 04
---------------------------------------------
INT 01 - internal hardware - SINGLE-STEP
   generated at end of each machine instruction if TF bit in FLAGS is set
Notes:	this is what makes the T command of DEBUG work for single-stepping
	not generated after MOV to segment register or POP of segment register
	  (unless you have a very early 8088 with a microcode bug)
SeeAlso: INT 03
---------------------------------------------
INT 01 - internal hardware - DEBUGGING EXCEPTIONS (80386)
   Instruction address breakpoint fault - will return to execute instruction
   Data address breakpoint trap - will return to following instruction
   General detect fault, debug registers in use
   Task-switch breakpoint trap
---------------------------------------------
INT 02 - external hardware - NMI (NON-MASKABLE INTERRUPT)
   Generated by NMI signal in hardware.  This signal has various uses:

   Breakout switch on hardware debuggers
   Parity error: all except Jr and CONV
   Coprocessor interrupt: all except Jr and CONV
   Keyboard interrupt: Jr, CONV
   I/O channel check: CONV, PS50+
   Disk-controller power-on request: CONV
   System suspend: CONV
   Real-time clock: CONV
   System watch-dog timer, time-out interrupt: PS50+
   DMA timer time-out interrupt: PS50+
---------------------------------------------
INT 03 - ONE-BYTE INTERRUPT
   generated by opcode CCh
Notes:	generally used to set breakpoints for debuggers
	also used by Turbo Pascal versions 1,2,3 when {$U+} specified
SeeAlso: INT 01
---------------------------------------------
INT 04 - internal hardware - OVERFLOW
   Generated by INTO instruction if OF flag is set.  If flag is not set, INTO
   is effectively a NOP.
Note:	used to trap any arithmetic errors before the erroneous results
	  propagate further through the computation
SeeAlso: INT 00
---------------------------------------------
INT 05 - PRINT-SCREEN KEY
   automatically called by keyboard scanner when print-screen key is pressed
Notes:	normally executes routine to print the screen, but may call any routine
	  that can safely be executed from inside the keyboard scanner
	status and result byte for default handler is at address 0050:0000
	  00h not active
	  01h PrtSc in progress
	  FFh last PrtSc encountered error
---------------------------------------------
INT 05 - internal hardware - BOUND CHECK FAILED (80186+)
   Generated by BOUND instruction when the value to be tested is less than the
   indicated lower bound or greater than the indicated upper bound.  Returning
   from this interrupt re-executes the failing BOUND instruction.
---------------------------------------------
INT 06 - internal hardware - UNDEFINED OPCODE (80286+)
---------------------------------------------
INT 07 - internal hardware - NO MATH UNIT AVAILABLE (80286+)
   automatically called if a coprocessor instruction is encountered when no
   coprocessor is installed
Note:	can be used to emulate a numeric coprocessor in software
---------------------------------------------
INT 08 - IRQ0 - TIMER INTERRUPT
   Generated 18.2 times per second, this interrupt is used to keep the
   time-of-day clock updated.  Programs which need to be invoked regularly
   should use INT 1C unless they need to reprogram the timer while still
   keeping the time-of-day clock running at the proper rate.
SeeAlso: INT 1C
---------------------------------------------
INT 08 - internal hardware - DOUBLE FAULT (80286+ protected mode)
   Called when multiple exceptions occur on one instruction, or an exception
   occurs in an exception handler.  If an exception occurs in the double fault
   handler, the CPU goes into SHUTDOWN mode (which circuitry in the PC/AT
   converts to a reset).
---------------------------------------------
INT 09 - IRQ1 - KEYBOARD INTERRUPT
   Generated when data is received from the keyboard.  This is normally a scan
   code, but may also be an ACK or NAK of a command on AT-class keyboards.
SeeAlso: INT 15/AH=4Fh, INT 15/AH=85h, INT 16, INT 1B
---------------------------------------------
INT 09 - internal hardware - MATH UNIT PROTECTION FAULT (80286+ protected mode)
---------------------------------------------
INT 0A - IRQ2 - EGA VERTICAL RETRACE
Notes:	the TOPS and PCnet adapters use this interrupt request line by default
	DOS 3.2 revectors IRQ2 to a stack-switching routine
	on ATs and above, the physical data line for IRQ2 is labeled IRQ9 and
	  connects to the slave 8259.  The BIOS redirects the interrupt for
	  IRQ9 back here.
SeeAlso: INT 71
---------------------------------------------
INT 0A - IRQ2 - Tandy 1000 HARD DISK
---------------------------------------------
INT 0A - IRQ2 - ROLAND MPU MIDI INTERFACE
Note:	newer Roland cards and MIDI interfaces by other manufacturers use
	  a jumper-selectable IRQ, but software and hardware generally defaults
	  to IRQ2
---------------------------------------------
INT 0A - internal hardware - INVALID TASK STATE SEGMENT (80286+ protected-mode)
---------------------------------------------
INT 0B - IRQ3 - COM2 INTERRUPT
Notes:	the TOPS and PCnet adapters use this interrupt request line as an
	  alternate
	on PS/2's, COM2 through COM8 share this interrupt on many PC's, COM4
	  shares this interrupt
SeeAlso: INT 0C
---------------------------------------------
INT 0B - internal hardware - NOT PRESENT (80286+ protected-mode)
   Generated when loading a segment register if the segment descriptor
   indicates that the segment is not currently in memory.  May be used to
   implement virtual memory.
---------------------------------------------
INT 0C - IRQ4 - COM1 INTERRUPT
Note:	on many PC's, COM3 shares this interrupt
SeeAlso: INT 0B
---------------------------------------------
INT 0C - internal hardware - STACK FAULT (80286+)
   Generated on stack overflow/underflow in protected mode.
   Note that the 80286 will shut down in real mode if SP=1 before a push.  On
   the PC AT and compatibles, external circuitry generates a reset on shutdown.
---------------------------------------------
INT 0D - IRQ5 - FIXED DISK (PC), LPT2 (AT/PS)
---------------------------------------------
INT 0D - IRQ5 - Tandy 1000 60Hhz RAM REFRESH
---------------------------------------------
INT 0D - internal hardware - GENERAL PROTECTION VIOLATION (80286+)
   Called in real mode when an instruction attempts to access a word operand
   located at offset FFFFh or a PUSH MEM or POP MEM instruction contains an
   invalid bit encoding in the second byte, or an instruction exceeds the
   maximum length allowed (10 bytes for 80286, 15 bytes for 80386)
---------------------------------------------
INT 0E - IRQ6 - DISKETTE INTERRUPT
   Generated by floppy disk controller on completion of an operation
---------------------------------------------
INT 0E - internal hardware - PAGE FAULT (80386 native mode)
   used to implement virtual memory
---------------------------------------------
INT 0F - IRQ7 - PRINTER INTERRUPT
   Generated by the LPT1 printer adapter when printer becomes ready.
Notes:	most printer adapters do not reliably generate this interrupt.
	the 8259 interrupt controller generates an interrupt corresponding to
	  IRQ7 when an error condition occurs
---------------------------------------------
INT 10 - internal hardware - COPROCESSOR ERROR (80286+)
   Generated by the CPU when the -ERROR pin is asserted by the coprocessor.
   AT's and clones usually wire the coprocessor to use IRQ13, but not all
   get it right.
---------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE
	AH = 00h
	AL = mode (graphics mode if graphics resolution listed)
		 text  pixel graphic colors disp scrn  system
		 resol	box  resoltn	    page addr
	   00h = 40x25	8x8	     B&W      8	 B800 CGA
	       = 40x25	8x14	     B&W      8	 B800 ATI VIP
	   01h = 40x25	8x8	      16      8	 B800 CGA
	       = 40x25	8x14	      16      8	 B800 ATI VIP
	   02h = 80x25	8x8	     B&W      4	 B800 CGA
	       = 80x25	8x8	     B&W      8	 B800 EGA,MCGA,VGA
	       = 80x25	8x14	     B&W      8	 B800 ATI VIP
	   03h = 80x25	8x8	      16      4	 B800 CGA
	       = 80x25	8x8	      16      8	 B800 EGA,MCGA,VGA
	   04h = 40x25	8x8  320x200   4      1	 B800 CGA
	   05h = 40x25	8x8  320x200 4 gray   1	 B800 CGA
	   06h = 80x25	8x8  640x200 B&W      1	 B800 CGA
	   07h = 80x25	9x14	     mono     1	 B000 MDA,Hercules
	       = 80x25			      8	      EGA,VGA
	       = 80x25	9x14	     mono	 B000 ATI VIP
	   08h = 20x25	8x8  160x200  16	 B800 PCjr,Tandy 1000
	       = 132x25 8x8           16         B800 ATI EGA Wonder **
	       = 132x25 8x8          mono        B000 ATI EGA Wonder **
	   09h = 40x25	8x8  320x200  16	 B800 PCjr,Tandy 1000
	   0Ah = 80x25	8x8  640x200   4	 B800 PCjr,Tandy 1000
	   0Bh = reserved (used internally by EGA BIOS)
	   0Ch = reserved (used internally by EGA BIOS)
	   0Dh = 40x25	8x8  320x200  16      8	 A000 EGA,VGA
	   0Eh = 80x25	8x8  640x200  16      4	 A000 EGA,VGA
	   0Fh = 80x25	8x14 640x350 mono     2	 A000 EGA,VGA
	   10h = 80x25	8x14 640x350 4or16    2	 A000 EGA,VGA
	   11h = 80x30	8x16 640x480 mono	 A000 VGA,MCGA,ATI EGA,ATI VIP
	   12h = 80x30	8x16 640x480 16/256k	 A000 VGA,ATI VIP
	       = 80x30	8x16 640x480 16/64	 A000 ATI EGA Wonder
	   13h = 40x25	8x8  320x200 256/256k	 A000 VGA,MCGA,ATI VIP
	   14h = 80x25	8x8  640x200		      Lava Chrome II EGA
	       =	     640x400  16	      Tecmar VGA/AD
	   15h = 80x25	8x14 640x350		      Lava Chrome II EGA
	   16h = 80x25	8x14 640x350		      Lava Chrome II EGA
	       =	     800x600  16	      Tecmar VGA/AD
	   17h = 80x34	8x14 640x480		      Lava Chrome II EGA
	       = 132x25				      Tecmar VGA/AD
	   18h = 132x44 8x8	     mono	      Tseng Labs EVA
	       = 80x34	8x14 640x480		      Lava Chrome II EGA
	       =	     1024x768 16	      Tecmar VGA/AD
	   19h = 132x25 8x14	     mono	      Tseng Labs EVA
	   1Ah = 132x28 8x13	     mono	      Tseng Labs EVA
	       =	     640x350 256	      Tecmar VGA/AD
	   1Bh =	     640x400 256	      Tecmar VGA/AD
	   1Ch =	     640x480 256	      Tecmar VGA/AD
	   1Dh =	     800x600 256	      Tecmar VGA/AD
	   22h = 132x44 8x8			      Tseng Labs EVA
	       = 132x44 8x8			      Ahead Systems EGA2001
	       = 132x43				      Allstar Peacock (VGA)
	       = 132x44 	      16	      Orchid Prodesigner VGA
	   23h = 132x25 6x14			      Tseng Labs EVA
	       = 132x25 8x14			      Ahead Systems EGA2001
	       = 132x25 8x8	      16	 B800 ATI EGA Wonder,ATI VIP
	       = 132x28				      Allstar Peacock (VGA)
	       = 132x28		      16	      Orchid Prodesigner VGA
	   24h = 132x28 6x13			      Tseng Labs EVA
	       = 132x25				      Allstar Peacock (VGA)
	       = 132x25		      16	      Orchid Prodesigner VGA
	   25h = 80x60	8x8  640x480		      Tseng Labs EVA
	       =	     640x480  16	      VEGA VGA
	       = 80x60  8x8  640x480  16	 A000 Orchid Prodesigner VGA
	   26h = 80x60	8x8			      Tseng Labs EVA
	       = 80x60	8x8  640x480		      Ahead Systems EGA2001
	       = 80x60				      Allstar Peacock (VGA)
	       = 80x60   	      16	      Orchid ProDesigner VGA
	   27h =	     720x512  16	      VEGA VGA
	       =             720x512  16	      Genoa
	       = 132x25 8x8	     mono	 B000 ATI EGA Wonder,ATI VIP
	   28h = ???x???			      VEGA VGA
	   29h =	     800x600  16	      VEGA VGA
	       = 100x37 8x16 800x600  16	 A000 Orchid
	       =	     800x600  16	 A000 STB,Genoa,Sigma
	       =	     800x600  16	      Allstar Peacock (VGA)
	   2Ah = 100x40 			      Allstar Peacock (VGA)
	       = 100x40 8x16	      16	      Orchid Prodesigner VGA
	   2Dh =	     640x350 256	      VEGA VGA
	       =	     640x350 256/256k	 A000 Orchid, Genoa, STB
	   2Eh =	     640x480 256	      VEGA VGA
	       = 80x30  8x16 640x480 256/256k	 A000 Orchid
	       =	     640x480 256/256k	 A000 STB,Genoa,Sigma
	   2Fh =	     720x512 256	      VEGA VGA
	       =	     720x512 256	      Genoa
	   30h =	     800x600 256	      VEGA VGA
	       = 100x37 8x16 800x600 256/256k	 A000 Orchid 
	       =	     800x600 256/256k	 A000 STB,Genoa,Sigma
	       =	     720x350   2	      3270 PC
	       =	     ???x???		 B800 AT&T 6300
	   33h = 132x44 8x8	      16	 B800 ATI EGA Wonder,ATI VIP
	   36h =	     960x720  16	      VEGA VGA
	       =	     960x720  16	      STB
	   37h =	    1024x768  16	      VEGA VGA
	       = 128x48 8x16 1024x768 16	 A000 Orchid
	       =	    1024x768  16	 A000 STB,Genoa,Sigma
	       = 132x44 8x8	     mono	 B800 ATI EGA Wonder,ATI VIP
	   40h = 80x25	8x16 640x400   2      1  B800 AT&T 6300, AT&T VDC600
	       = 80x25	8x16 640x400   2      1  B800 Compaq Portable
	       = 80x43				      VEGA VGA, Tecmar VGA/AD
	       = 80x43				      Video7 V-RAM VGA
	       = 80x43				      Tatung VGA
	   41h =	     640x200  16      1	      AT&T 6300
	       = 132x25 			      VEGA VGA
	       = 132x25				      Tatung VGA
	       = 132x25				      Video7 V-RAM VGA
	   42h = 80x25	8x16 640x400  16	      AT&T 6300, AT&T VDC600
	       = 132x43 			      VEGA VGA
	       = 132x43				      Tatung VGA
	       = 132x43				      Video7 V-RAM VGA
	   43h = unsupported 640x200 of 640x400 viewport  AT&T 6300
	       = 80x60				      VEGA VGA
	       = 80x60				      Tatung VGA
	       = 80x60				      Video7 V-RAM VGA
	   44h = disable VDC and DEB output	      AT&T 6300
	       = 100x60 			      VEGA VGA
	       = 100x60 			      Tatung VGA
	       = 100x60				      Video7 V-RAM VGA
	   45h = 132x28				      Tatung VGA
	       = 132x28				      Video7 V-RAM VGA
	   46h = 100x40 8x15 800x600   2	      AT&T VDC600
	   47h = 100x37 8x16 800x600  16	      AT&T VDC600
	   48h = 80x50	8x8  640x400   2	 B800 AT&T 6300, AT&T VDC600
	   49h = 80x30	8x16 640x480		      Lava Chrome II EGA
	   4Dh = 120x25 			      VEGA VGA
	   4Eh = 120x43 			      VEGA VGA
	   4Fh = 132x25 			      VEGA VGA
	   50h = 132x25 9x14	     mono	      Ahead Systems EGA2001
	       = 80x30	8x16 640x480  16	      Paradise EGA-480
	       = 80x43		     mono	      VEGA VGA
	       =	     640x480 mono???	      Taxan 565 EGA
	       = 80x34				      Lava Chrome II EGA
	   51h = 80x30	8x16			      Paradise EGA-480
	       = 80x30				      Lava Chrome II EGA
	       = 80x34	8x14 640x480  16	      ATI EGA Wonder
	       = 132x25 	     mono	      VEGA VGA
	   52h = 132x44 9x8	     mono	      Ahead Systems EGA2001
	       = 132x43 	     mono	      VEGA VGA
	       = 94x29	8x14 752x410  16	      ATI EGA Wonder
	       = 80x60				      Lava Chrome II EGA
	   53h = 100x40 8x14 800x560  16	      ATI EGA Wonder,ATI VIP
	       = 132x43 			      Lava Chrome II EGA
	   54h = 132x43 8x8			      Paradise EGA-480
	       = 132x43 7x9	     16/256k	 B800 Paradise VGA
	       = 132x43 8x9	     16/256k	 B800 Paradise VGA on multisync
	       = 132x43				      Taxan 565 EGA
	       = 132x43				      AST VGA Plus
	       = 132x43				      Hewlett-Packard D1180A
	       = 132x43 7x9	      16	      AT&T VDC600
	       = 132x25 			      Lava Chrome II EGA
	       = 100x42 8x14 800x600  16	 A000 ATI EGA Wonder, VGA Wondr
	   55h = 132x25 8x14			      Paradise EGA-480
	       = 132x25 7x16	     16/256k	 B800 Paradise VGA
	       = 132x25 8x16	     16/256k	 B800 Paradise VGA on multisync
	       = 132x25				      Taxan 565 EGA
	       = 132x25				      AST VGA Plus
	       = 132x25				      Hewlett-Packard D1180A
	       = 132x25 7x16	      16	      AT&T VDC600
	       = 80x66	8x8	     16/256k	 A000 ATI VIP
	       = 94x29	8x14 752x410		      Lava Chrome II EGA
	   56h = 132x43 8x8	     3???     2	 B000 NSI Smart EGA+
	       = 132x43 7x9	       4	 B000 Paradise VGA
	       = 132x43 8x9	       4	 B000 Paradise VGA on multisync
	       = 132x43 	     mono	      Taxan 565 EGA
	       = 132x43 7x9	       2	      AT&T VDC600
	   57h = 132x25 8x14	     3???     4  B000 NSI Smart EGA+
	       = 132x25 7x16	       4	 B000 Paradise VGA
	       = 132x25 8x16	       4	 B000 Paradise VGA on multisync
	       = 132x25 	     mono	      Taxan 565 EGA
	       = 132x25 7x16	       2	      AT&T VDC600
	   58h = 100x75 8x8  800x600 16/256k	 A000 Paradise VGA
	       = 100x75 8x8  800x600  16	      AT&T VDC600
	       = 80x33	8x14	      16	 B800 ATI EGA Wonder,ATI VIP
	       =	     800x600  16	      AST VGA Plus, Compaq VGA
	       =             800x600  16	      Dell VGA
	       =	     800x600  16	      Hewlett-Packard D1180A
	   59h = 100x75 8x8  800x600   2	 A000 Paradise VGA
	       = 100x75 8x8  800x600   2	      AT&T VDC600
	       = 80x66	8x8	     16/256k	 A000 ATI VIP
	       =	     800x600   2	      AST VGA Plus, Compaq VGA
	       =	     800x600   2	      Dell VGA
	       =	     800x600   2	      Hewlett-Packard D1180A
	   5Bh =	     800x600  16	      Maxxon, SEFCO TVGA
	   5Ch =	     640x400 256	      Logix, ATI Prism Elite
	       =	     640x400 256	      Maxxon, SEFCO TVGA
	   5Dh =	     640x480 256	      Logix, ATI Prism Elite
	       =	     640x480 256	      Maxxon, SEFCO TVGA
	   5Eh =	     640x400 256	      Paradise VGA,VEGA VGA
	       =	     640x400 256	      AST VGA Plus
	       =	     640x400 256	      Compaq VGA, Dell VGA
	       = 80x25	8x16 640x400 256	      AT&T VDC600
	       =	     800x600  16	      Logix, ATI Prism Elite
	   5Fh =	     640x480 256	      Paradise VGA
	       =	     640x480 256	      AST VGA Plus
	       =	     640x480 256	      Compaq VGA, Dell VGA
	       =	     640x480 256	      Hewlett-Packard D1180A
	       = 80x30	8x16 640x480 256	      AT&T VDC600 (512K)
	       =	    1024x768  16	      Logix, ATI Prism Elite
	       =	    1024x768  16	      Maxxon
	   60h = 80x???      ???x400		      Corona/Cordata BIOS 4.10+
	       =	     752x410		      VEGA VGA
	       =	     752x410  16	      Tatung VGA
	       =	     752x410  16	      Video7 V-RAM VGA
	   61h =	     ???x400		      Corona/Cordata BIOS 4.10+
	       =	     720x540		      VEGA VGA
	       =	     720x540  16	      Tatung VGA
	       =	     720x540  16	      Video7 V-RAM VGA
	       =	     640x400 256	 A000 ATI VGA Wonder
	   62h =	     800x600		      VEGA VGA
	       =	     800x600  16	      Tatung VGA
	       =	     800x600  16	      Video7 V-RAM VGA
	       =	     640x480 256	 A000 ATI VGA Wonder
	   63h =	    1024x768   2	      Video7 V-RAM VGA
	       =	     800x600 256	 A000 ATI VGA Wonder
	   64h =	    1024x768   4	      Video7 V-RAM VGA
	   65h =	    1024x768  16	      Video7 V-RAM VGA
	       =	    1024x768  16	 A000 ATI VGA Wonder
	   66h =	     640x400 256	      Tatung VGA
	       =	     640x400 256	      Video7 V-RAM VGA
	   67h =	     640x480 256	      Video7 V-RAM VGA
	       =	    1024x768   4	 A000 ATI VGA Wonder
	   69h =	     720x540 256	      Video7 V-RAM VGA
	   6Ah =	     800x600  16	      VESA standard interface
	   70h = extended mode set (see AX=0070h)     Everex Micro Enhancer EGA
	   71h = 100x35 8x16 800x600 16of64	 A000 NSI Smart EGA+
	   74h =	     640x400   2	 B800 Toshiba 3100 AT&T mode
	   7Ch =             512x512  16	      Genoa
	   7Dh =	     512x512 256	      Genoa
	   7Eh = special mode set (see AX=007Eh)      Paradise VGA, AT&T VDC600
	   7Fh = special function set (see AX=007Fh)  Paradise VGA, AT&T VDC600
	   82h = 80x25		     B&W	      AT&T VDC overlay mode *
	   83h = 80x25				      AT&T VDC overlay mode *
	   86h =	     640x200 B&W	      AT&T VDC overlay mode *
	   C0h =	     640x400   2/prog pallet  AT&T VDC overlay mode *
	   C4h = disable output 		      AT&T VDC overlay mode *
	   D0h =	     640x400   2	 B800 DEC VAXmate AT&T mode

 *  for AT&T VDC overlay modes, BL contains the DEB mode, which may be 06h,
	  40h, or 44h
 ** for ATI EGA Wonder, mode 08h is only valid if SMS.COM is loaded resident.
    SMS maps mode 08h to mode 27h if the byte at location 0040:0063 is 0B4h,
    otherwise to mode 23h, thus selecting the appropriate (monochrome or color)
    132x25 character mode.
Notes:	IBM standard modes do not clear the screen if the high bit of AL is set
SeeAlso: AX=0070h,6F05h
---------------------------------------------
INT 10 - VIDEO - Everex Micro Enhancer EGA - EXTENDED MODE SET
	AX = 0070h
	BL = mode (graphics mode if graphics resolution listed)
		 text  pixel graphic color disp scrn  monitor
		 resol	box  resoltn	   page addr
	   00h =	     640x480  16	      multisync'ing
	   01h =	     752x410  16	      multisync'ing
	   02h =             800x600  16	      multisync'ing
	   03h = 80x34				      multisync'ing
	   04h = 80x60				      multisync'ing
	   05h = 94x29				      multisync'ing
	   06h = 94x51				      multisync'ing
	   07h = reserved
	   08h = reserved
	   09h = 80x44				      EGA
	   0Ah = 132x25 			      EGA
	   0Bh = 132x44 			      EGA
	   0Ch = 132x25 			      CGA
	   0Dh = 80x44				      mono
	   0Eh = 132x25 			      mono
	   0Fh = 132x44 			      mono
	   10h = reserved
	   11h =            1280x350   4
	   12h =	    1280x600   4
	   13h =             640x350 256
	   14h =	     640x400 256
	   15h =	     512x480 256
---------------------------------------------
INT 10 - VIDEO - Paradise VGA, AT&T VDC600 - SET SPECIAL MODE
	AX = 007Eh
	BX = The horizontal dimension of the mode desired
	CX = The vertical dimension of the mode desired
	     (both BX/CX in pixels for graphics modes, rows for alpha modes)
	DX = The number of colors of the mode desired
	     (use 0 for monochrome modes)
Return: BH = 7Eh if successful (Paradise VGA)
	AL = 7Eh if successful (AT&T VDC600)
---------------------------------------------
INT 10 - VIDEO - Paradise VGA, AT&T VDC600 - EXTENDED FUNCTIONS
	AX = 007Fh
	BH = 00h  set VGA operation
	BH = 01h  set non-VGA operation
	    color modes (0,1,2,3,4,5,6) will set non-VGA CGA operation.
	    monochrome mode 7 will set non-VGA MDA/Hercules operation.
	BH = 02h  query mode status
	    Return: BL = 00h if operating in VGA mode, 01h if non-VGA mode.
		    CH = total video RAM size in 64k byte units.
		    CL = video RAM used by the current mode.
	BH = 03h  lock current mode
	    allows current mode (VGA or non-VGA) to survive re-boot.
	BH = 04h  enter CGA mode (AT&T VDC600 only)
	BH = 05h  enter MDA mode (AT&T VDC600 only)
	BH = 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh  WRITE PARADISE REGISTERS 0,1,2,3,4,5
		(port 03CEh indices 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh)
	    BL = value to set in the paradise register.
	BH = 1Ah,1Bh,1Ch,1Dh,1Eh,1Fh READ PARADISE REGISTERS 0,1,2,3,4,5
		(port 03CEh indices 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh)
	    Return: BL = value of the paradise register.
		    BH = 7Fh if successful.
Return: AL = 7Fh if successful (AT&T VDC600)
---------------------------------------------
INT 10 - VIDEO - SET CURSOR CHARACTERISTICS
	AH = 01h
	CH bits 0-4 = start line for cursor in character cell
	   bits 5-6 = blink attribute
		     (00=normal, 01=invisible, 10=slow, 11=fast)
	CL bits 0-4 = end line for cursor in character cell
Note:	buggy on EGA systems--BIOS remaps cursor shape in 43 line modes, but
	  returns unmapped cursor shape
SeeAlso: AH=03h
---------------------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
	AH = 02h
	DH,DL = row, column (0,0 = upper left)
	BH = page number
	    0 in graphics modes
	    0-3 in modes 2&3
	    0-7 in modes 0&1
SeeAlso: AH=03h
---------------------------------------------
INT 10 - VIDEO - READ CURSOR POSITION
	AH = 03h
	BH = page number
	    0 in graphics modes
	    0-3 in modes 2&3
	    0-7 in modes 0&1
Return: DH,DL = row,column
	CH = cursor start line
	CL = cursor end line
SeeAlso: AH=01h,02h
---------------------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION (all but PS)
	AH = 04h
Return: AH = 00h light pen switch not activated
	   = 01h light pen values in registers
	    DH,DL = row,column of current position
	    CH = raster line (0-199) (EGA) old graphics modes
	    CX = (EGA) raster line (0-nnn) new graphics modes
	    BX = pixel column (0-319 or 0-639)
---------------------------------------------
INT 10 - VIDEO - SELECT DISPLAY PAGE
	AH = 05h
	AL = display page
	    0-7  for modes 0 & 1
	    0-3  for modes 2 & 3
SeeAlso: AH=0Fh
---------------------------------------------
INT 10 - PCjr VIDEO - CRT/CPU PAGE REGISTERS
	AH = 05h
	AL =
	    80h read CRT/CPU page registers
	    81h set CPU page register
		BL = new page register value
	    82h set CRT page register
		BH = new page register value
	    83h set both display registers
		BL = new CPU page register
		BH = new CRT page register
Return: BH = CRT page register
	BL = CPU page register
---------------------------------------------
INT 10 - VIDEO - GRAPHICS BITMAP BUFFER (Corona/Cordata BIOS v4.10+)
	AH = 05h
	AL =
	    00h set address of graphics bitmap buffer (video modes 60h,61h)
		BX = segment of buffer
	    0Fh get address of graphics bitmap buffer (video modes 60h,61h)
		Return: DX = segment of graphics bitmap buffer
---------------------------------------------
INT 10 - VIDEO - SCROLL PAGE UP
	AH = 06h
	AL = number of lines to scroll window (0 = blank whole window)
	BH = attributes to be used on blanked lines
	CH,CL = row,column of upper left corner of window to scroll
	DH,DL = row,column of lower right corner of window
Warning: some implementations have a bug which destroys BP
---------------------------------------------
INT 10 - VIDEO - SCROLL PAGE DOWN
	AH = 07h
	AL = number of lines to scroll window (0 = blank whole window)
	BH = attributes to be used on blanked lines
	CH,CL = row,column of upper left corner of window to scroll
	DH,DL = row,column of lower right corner of window
Warning: some implementations have a bug which destroys BP
---------------------------------------------
INT 10 - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
	AH = 08h
	BH = display page
Return: AL = character
	AH = attribute of character (alpha modes)
SeeAlso: AH=09h
---------------------------------------------
INT 10 - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
	AH = 09h
	AL = character
	BH = display page
	BL = attributes of character (alpha modes) or color (graphics modes)
	     if bit 7 set in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
Note:	all characters are displayed, including CR, LF, and BS
SeeAlso: AH=08h
---------------------------------------------
INT 10 - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
	AH = 0Ah
	AL = character
	BH = display page - alpha mode
	BL = color of character (graphics mode, PCjr only)
	     if bit 7 set in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
	     (EGA) in graphics modes, replication count in CX works correctly
	     only if all character written are contains on the same row
Note:	all characters are displayed, including CR, LF, and BS
SeeAlso: AH=08h
---------------------------------------------
INT 10 - VIDEO - SET COLOR PALETTE
	AH = 0Bh
	BH = 00h
	    BL = border color (0-15) (text modes)
		 border color and background color (graphics modes)
	    (EGA)
	    BL = border color (0-15) and high-intensity background color
		  (16-31??? maybe should be high nybble?)
	BH = 01h
	    BL = palette (0-3)
---------------------------------------------
INT 10 - VIDEO - WRITE DOT ON SCREEN
	AH = 0Ch
	AL = color of dot (0/1 in mode 6, 0-3 in modes 4 and 5)
	     if bit 7 set, new color will be XORed with current pixel
	BH = display page (ignored if mode only supports one page)
	CX = column
	DX = row
Note:	only valid in graphics modes
SeeAlso: AH=0Dh
---------------------------------------------
INT 10 - VIDEO - READ DOT ON SCREEN
	AH = 0Dh
	BH = display page (ignored if mode only supports one page)
	CX = column
	DX = row
Return: AL = color read
Note:	only valid in graphics modes
SeeAlso: AH=0Ch
---------------------------------------------
INT 10 - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
	AH = 0Eh
	AL = character
	BH = display page (alpha modes)
	BL = foreground color (graphics modes)
Note:	characters 07h (BEL), 08h (BS), 0Ah (LF), and 0Dh (CR) are interpreted
	  and do the expected things
SeeAlso: AH=02h,0Ah
---------------------------------------------
INT 10 - VIDEO - GET CURRENT VIDEO MODE
	AH = 0Fh
Return: AH = number of columns on screen
	AL = current video mode (see INT 10/AH=00h)
	BH = current active display page
Note:	if mode was set with bit 7 set ("no blanking"), the returned mode will
	also have bit 7 set
SeeAlso: AH=00h,05h
---------------------------------------------
INT 10 - VIDEO - SET PALETTE REGISTER (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1000h
	BL = palette register to set
	BH = color value to store
Note:	on MCGA, only BX = 0712h is supported
---------------------------------------------
INT 10 - VIDEO - SET BORDER COLOR REGISTER (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1001h
	BH = color value to store
---------------------------------------------
INT 10 - VIDEO - SET ALL PALETTE REGISTERS (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1002h
	ES:DX -> 17-byte palette register list (see below)

Format of palette register list:
Offset	Size	Description
 00h 16 BYTEs	values for palette registers 0-15
 10h	BYTE	value for border color register
---------------------------------------------
INT 10 - VIDEO - TOGGLE INTENSITY/BLINKING BIT (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1003h
	BL = 00h enable intensity
	   = 01h enable blink
---------------------------------------------
INT 10 - VIDEO - GET INDIVIDUAL PALETTE REGISTER (VGA)
	AX = 1007h
	BL = palette register number
Return: BH = palette register value
---------------------------------------------
INT 10 - VIDEO - READ OVERSCAN (BORDER COLOR) REGISTER (VGA)
	AX = 1008h
Return: BH = value
---------------------------------------------
INT 10 - VIDEO - READ ALL PALETTE REGISTERS AND OVERSCAN REGISTER (VGA)
	AX = 1009h
	ES:DX -> 17-byte buffer (see AX=1002h)
---------------------------------------------
INT 10 - VIDEO - SET INDIVIDUAL DAC REGISTER (EGA, VGA/MCGA)
	AX = 1010h
	BX = register number
	CH = new value for green (0-63)
	CL = new value for blue (0-63)
	DH = new value for red (0-63)
---------------------------------------------
INT 10 - VIDEO - SET BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)
	AX = 1012h
	BX = starting color register
	CX = number of registers to set
	ES:DX -> table of 3*CX bytes where each 3 byte group represents one
		 byte each of red, green and blue (0-63)
---------------------------------------------
INT 10 - VIDEO - SELECT VIDEO DAC COLOR PAGE (VGA)
	AX = 1013h
	BL = 00h Select paging mode
		BH = 00h Select 4 blocks of 64
		BH = 01h Select 16 blocks of 16
	BL = 01h Select Page
		BH = page number (00h to 03h) or (00h to 0Fh)
Note:	not valid in mode 13h
---------------------------------------------
INT 10 - VIDEO - READ INDIVIDUAL DAC REGISTER (EGA, VGA/MCGA)
	AX = 1015h
	BL = palette register number
Return: DH = red value
	CH = green value
	CL = blue value
---------------------------------------------
INT 10 - VIDEO - READ BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)
	AX = 1017h
	BX = starting palette register
	CX = number of palette registers to read
	ES:DX -> buffer (3 * CX bytes in size) (see also AX=1012h)
Return: CX number of red, green and blue triples in buffer
---------------------------------------------
INT 10 - VIDEO - undocumented - SET PEL MASK (EGA, VGA/MCGA)
	AX = 1018h
	BL = new PEL value
---------------------------------------------
INT 10 - VIDEO - undocumented - READ PEL MASK (EGA, VGA/MCGA)
	AX = 1019h
Return:	BL = value read
---------------------------------------------
INT 10 - VIDEO - GET VIDEO DAC COLOR-PAGE STATE (VGA)
	AX = 101Ah
Return: BL = paging mode
	    00h four pages of 64
	    01h sixteen pages of 16
	BH = current page
---------------------------------------------
INT 10 - VIDEO - PERFORM GRAY-SCALE SUMMING (EGA, VGA/MCGA)
	AX = 101Bh
	BX = starting palette register
	CX = number of registers to convert
---------------------------------------------
INT 10 - VIDEO - TEXT-MODE CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
	AH = 11h
	The following functions will cause a mode set, completely resetting
	the video environment, but without clearing the video buffer
	AL = 00h, 10h: load user-specified patterns
	    ES:BP -> user table
	    CX	  = count of patterns to store
	    DX	  = character offset into map 2 block
	    BL	  = block to load in map 2
	    BH	  = number of bytes per character pattern
	AL = 01h, 11h: load ROM monochrome patterns (8 by 14)
	    BL	  = block to load
	AL = 02h, 12h: load ROM 8 by 8 double-dot patterns
	    BL	  = block to load
	AL = 03h: set block specifier
	    BL	  = block specifier
		   (EGA/MCGA) bits 0,1 = block selected by chars with attribute
					 bit 3 = 0
			      bits 2,3 = block selected by chars with attribute
					 bit 3 = 1
		   (VGA) bits 0,1,4 = block selected by attribute bit 3 = 0
			 bits 2,3,5 = block selected by attribute bit 3 = 1
	AL = 04h, 14h: load ROM 8x16 character set (VGA)
	The routines called with AL=1xh are designed to be called only
	immediately after a mode set and are similar to the routines called
	with AL=0xh, except that:
	      Page 0 must be active.
	      Bytes/character is recalculated.
	      Max character rows is recalculated.
	      CRT buffer length is recalculated.
	      CRTC registers are reprogrammed as follows:
		     R09 = bytes/char-1 ; max scan line (mode 7 only)
		     R0A = bytes/char-2 ; cursor start
		     R0B = 0		; cursor end
		     R12 = ((rows+1)*(bytes/char))-1 ; vertical display end
		     R14 = bytes/char	; underline loc
			   (*** BUG: should be 1 less ***)
---------------------------------------------
INT 10 - VIDEO - GRAPHICS-MODE CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
	AH = 11h
	AL = 20h: set user 8 by 8 graphics characters (INT 1Fh)
	    ES:BP -> user table
	AL = 21h: set user graphics characters
	    ES:BP -> user table
	    CX	  = bytes per character
	    BL	  = row specifier
		   00h user set
		      DL = number of rows
		   01h 14 rows
		   02h 25 rows
		   03h 43 rows
	AL = 22h: ROM 8 by 14 set
	    BL = row specifier
	AL = 23h: ROM 8 by 8 double dot
	    BL = row specifier
	AL = 24h: load 8x16 graphics characters (VGA/MCGA)
	    BL = row specifier
Note:	these functions are meant to be called only after a mode set
---------------------------------------------
INT 10 - VIDEO - GET FONT INFORMATION (EGA, MCGA, VGA)
	AX = 1130h
	BH = pointer specifier
	    00h INT 1Fh pointer
	    01h INT 44h pointer
	    02h ROM 8 by 14 character font pointer
	    03h ROM 8 by 8 double dot font pointer
	    04h ROM 8 by 8 DD font (top half)
	    05h ROM alpha alternate (9 by 14) pointer
Return: ES:BP = specified pointer
	CX    = bytes/character
	DL    = character rows on screen
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA) - GET EGA INFO
	AH = 12h
	BL = 10h
Return: BH = 00h color mode in effect (I/O port 3Dxh)
  	     01h mono mode in effect (I/O port 3Bxh)
	BL = 00h  64k bytes memory installed
	     01h 128k bytes memory installed
	     02h 192k bytes memory installed
	     03h 256k bytes memory installed
	CH = feature bits
	CL = switch settings
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS,EGA,VGA,MCGA) - ALTERNATE PRTSC
	AH = 12h
	BL = 20h  select alternate print screen routine
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA) - SELECT VERTICAL RESOLUTION
	AH = 12h
	BL = 30h
	AL = vertical resolution
	     00h 200 scan lines
	     01h 350 scan lines
	     02h 400 scan lines
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - PALETTE LOADING
	AH = 12h
	BL = 31h
	AL = 00h enable default palette loading
	     01h disable default palette loading
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - VIDEO ADDRESSING
	AH = 12h
	BL = 32h
	AL = 00h enable video addressing
	     01h disable video addressing
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - GRAY-SCALE SUMMING
	AH = 12h
	BL = 33h
	AL = 00h enable gray scale summing
	     01h disable gray scale summing
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA) - CURSOR EMULATION
	AH = 12h
	BL = 34h
	AL = 00h enable alphanumeric cursor emulation
	     01h disable alphanumeric cursor emulation
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS) - DISPLAY-SWITCH INTERFACE
	AH = 12h
	BL = 35h
	AL = 00h initial adapter video off
	     01h initial planar video on
	     02h switch active video off
	     03h switch inactive video on
	     80h *UNDOCUMENTED* set system board video active flag
	ES:DX = buffer (128 byte save area if AL = 0, 2 or 3)
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, VGA) - VIDEO REFRESH CONTROL
	AH = 12h
	BL = 36h
	AL = 00h enable refresh
	     01h disable refresh
Return: AL = 12h if function supported
---------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNC SELECT (ATI,Tatung,Taxan) - ENHANCED FEATURES
	AH = 12h
	BH = 55h
	BL = subfunction
	    00h disabled enhanced features
	    01h enable enhanced features
	    02h get status
		Return: AL = status flags
			    bit 3: set if enhanced features enabled
			    bits 7-5 monitor type
				000 PS/2 mono
				001 PS/2 color
				010 multi-sync
				011 Taxan 650 25kHz
				100 RGB
				101 mono
				110 EGA
				111 Compaq internal
	    03h disable register trapping (CGA emulation)
	    04h enable register trapping
	    05h program mode described by table at ES:BP
	    06h get mode table
		AL = video mode
		Return: ES:BP -> table suitable for mode AL (and subfnc BL=05h)
			BP = FFFFh on error
---------------------------------------------
INT 10 - VIDEO - WRITE STRING (AT,XT286,PS,EGA,VGA)
	AH = 13h
	AL = mode
	    bit 1: set if string contains alternating characters and attributes
	    bit 0: set in order to move cursor after write
	BL = attribute if AL bit 1 clear
	BH = display page number
	DH,DL = row,column of starting cursor position
	CX = length of string
	ES:BP -> start of string
Note:	recognizes CR, LF, BS, and bell
SeeAlso: AH=09h,0Ah
---------------------------------------------
INT 10 - VIDEO - LOAD USER-SPECIFIED LCD CHARACTER FONT (CONVERTIBLE)
	AX = 1400h
	ES:DI -> character font
	BH = number of bytes per character
	BL = 00h load main font (block 0)
	     01h load alternate font (block 1)
	CX = number of characters to store
	DX = character offset into RAM font area
---------------------------------------------
INT 10 - VIDEO - LOAD SYSTEM ROM DEFAULT LCD CHARACTER FONT (CONVERTIBLE)
	AX = 1401h
	BL = 00h load main font (block 0)
	     01h load alternate font (block 1)
---------------------------------------------
INT 10 - VIDEO - SET MAPPING OF LCD HIGH INTENSITY ATTRIBUTES (CONVERTIBLE)
	AX = 1402h
	BL = 00h ignore high intensity attribute
	     01h map high intensity to underscore
	     02h map high intensity to reverse video
	     03h map high intensity to selected alternate font
---------------------------------------------
INT 10 - VIDEO - GET PHYSICAL DISPLAY PARAMETERS (CONVERTIBLE)
	AH = 15h
Return: AX = alternate display adapter type
	    0000h none
	    5140h LCD
	    5153h CGA
	    5151h mono
	ES:DI -> parameter table (see below)

Format of display parameter table:
Offset	Size	Description
 00h	WORD	monitor model number
 02h	WORD	vertical pixels per meter
 04h	WORD	horizontal pixels per meter
 06h	WORD	total vertical pixels
 08h	WORD	total horizontal pixels
 0Ah	WORD	horizontal pixel separation in micrometers
 0Ch	WORD	vertical pixel separation in micrometers
---------------------------------------------
INT 10 - VIDEO - SET SUPERIMPOSE MODE (Sperry PC)
	AH = 15h
	AL = superimpose mode
	    00h show graphics screen
	    01h show text screen
	    02h show text screen superimposed on graphics screen
---------------------------------------------
INT 10 - VIDEO - DISPLAY COMBINATION (PS,VGA/MCGA)
	AH = 1Ah
	AL = 00h read display combination code
		Return: BL = active display code (see below)
			BH = alternate display code
	     01h set display combination code
		BL = active display code (see below)
		BH = alternate display code
Return: AL = 1Ah if function was supported

Values for display combination code:
	00h no display
	01h monochrome adapter w/ monochrome display
	02h CGA w/ color display
	03h reserved
	04h EGA w/ color display
	05h EGA w/ monochrome display
	06h PGA w/ color display
	07h VGA w/ monochrome analog display
	08h VGA w/ color analog display
	09h reserved
	0Ah MCGA w/ digital color display
	0Bh MCGA w/ monochrome analog display
	0Ch MCGA w/ color analog display
	FFh unknown display type
---------------------------------------------
INT 10 - VIDEO - FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)
	AH = 1Bh
	BX = implementation type
	   = 0000h return funtionality/state information
	ES:DI -> 64 byte buffer for state information (see below)
Return: AL = 1Bh if function supported
	    ES:DI buffer filled with state information

Format of state information:
Offset	Size	Description
 00h	DWORD	address of static funtionality table (see below)
 04h	BYTE	video mode in effect
 05h	WORD	number of columns
 07h	WORD	length of regen buffer in bytes
 09h	WORD	starting address of regen buffer
 0Bh	WORD	cursor position for page 0
 0Dh	WORD	cursor position for page 1
 0Fh	WORD	cursor position for page 2
 11h	WORD	cursor position for page 3
 13h	WORD	cursor position for page 4
 15h	WORD	cursor position for page 5
 17h	WORD	cursor position for page 6
 19h	WORD	cursor position for page 7
 1Bh	WORD	cursor type
 1Dh	BYTE	active display page
 1Eh	WORD	CRTC port address
 20h	BYTE	current setting of register (3?8)
 21h	BYTE	current setting of register (3?9)
 22h	BYTE	number of rows
 23h	WORD	bytes/character
 25h	BYTE	DCC of active display
 26h	BYTE	DCC of alternate display
 27h	WORD	number of colors supported in current mode
 29h	WORD	number of pages supported in current mode
 2Ah	BYTE	number of scan lines active
		(0,1,2,3) = (200,350,400,480)
 2Bh	BYTE	primary character block
 2Ch	BYTE	secondary character block
 2Dh	BYTE	miscellaneous flags
		bit 0 all modes on all displays on
		    1 gray summing on
		    2 monochrome display attached
		    3 default palette loading disabled
		    4 cursor emulation enabled
		    5 0 = intensity; 1 = blinking
		    6 reserved
		    7 reserved
 2Eh  3 BYTEs	reserved
 31h	BYTE	video memory available
		00h = 64K, 01h = 128K, 02h = 192K, 03h = 256K
 32h	BYTE	save pointer state flags
		bit 0 512 character set active
		    1 dynamic save area present
		    2 alpha font override active
		    3 graphics font override active
		    4 palette override active
		    5 DCC override active
		    6 reserved
		    7 reserved
 33h 13 BYTEs	reserved

Format of Static Functionality Table:
Offset	Size	Description
 00h	BYTE	modes supported #1
		bit 0 to bit 7 = 1 modes 0,1,2,3,4,5,6 supported
 01h	BYTE	modes supported #2
		bit 0 to bit 7 = 1 modes 8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh supported
 02h	BYTE	modes supported #3
		bit 0 to bit 3 = 1 modes 10h,11h,12h,13h supported
		bit 4 to bit 7 reserved
 03h  4 BYTEs	reserved
 07h	BYTE	scan lines supported
		bit 0 to bit 2 = 1 if scan lines 200,350,400 supported
 08h	BYTE	total number of character blocks available in text modes
 09h	BYTE	maximum number of active character blocks in text modes
 0Ah	BYTE	miscellaneous function flags #1
		bit 0 all modes on all displays function supported
		    1 gray summing function supported
		    2 character font loading function supported
		    3 default palette loading enable/disable supported
		    4 cursor emulation function supported
		    5 EGA palette present
		    6 color palette present
		    7 color paging function supported
 0Bh	BYTE	miscellaneous function flags #2
		bit 0 light pen supported
		    1 save/restore state function 1Ch supported
		    2 intensity blinking function supported
		    3 Display Combination Code supported
		  4-7 reserved
 0Ch	WORD	reserved
 0Eh	BYTE	save pointer function flags
		bit 0 512 character set supported
		    1 dynamic save area supported
		    2 alpha font override supported
		    3 graphics font override supported
		    4 palette override supported
		    5 DCC extension supported
		    6 reserved
		    7 reserved
 0Fh	BYTE	reserved
---------------------------------------------
INT 10 - VIDEO - SAVE/RESTORE VIDEO STATE (PS50+,VGA)
	AH = 1Ch
	AL = 00h return state buffer size
		Return: BX = number of 64 byte blocks needed
	     01h save video state
		ES:BX -> buffer
	     02h restore video state
		ES:BX -> buffer containing previously saved state
	CX = requested states
	     bit 0 video hardware
		 1 BIOS data areas
		 2 color registers and DAC state
	      3-15 reserved
Return: AL = 1Ch if function supported
---------------------------------------------
INT 10 - VIDEO - SET GRAPHICS MODE (Hercules GRAFIX)
	AH = 40h
---------------------------------------------
INT 10 - VIDEO - SET TEXT MODE (Hercules GRAFIX)
	AH = 41h
---------------------------------------------
INT 10 - VIDEO - CLEAR CURRENT PAGE (Hercules GRAFIX)
	AH = 42h
---------------------------------------------
INT 10 - VIDEO - SELECT DRAWING PAGE (Hercules GRAFIX)
	AH = 43h
	AL = page number (0,1)
---------------------------------------------
INT 10 - VIDEO - SELECT DRAWING FUNCTION (Hercules GRAFIX)
	AH = 44h
	AL = drawing function
	    00h clear pixels
	    01h set pixels
	    02h invert pixels
---------------------------------------------
INT 10 - VIDEO - SELECT PAGE TO DISPLAY (Hercules GRAFIX)
	AH = 45h
	AL = page number (0,1)
---------------------------------------------
INT 10 - VIDEO - DRAW ONE PIXEL (Hercules GRAFIX)
	AH = 46h
	DI = x (0-720)
	BP = y (0-347)
Note:	function 44h determines operation and function 43h which page to use
---------------------------------------------
INT 10 - VIDEO - FIND PIXEL VALUE (Hercules GRAFIX)
	AH = 47h
	DI = x (0-720)
	BP = y (0-347)
Return: AL = 00h pixel clear
	AL = 01h pixel set
Note:	function 43h specifies which page is used
---------------------------------------------
INT 10 - VIDEO - MOVE TO POINT (Hercules GRAFIX)
	AH = 48h
	DI = x (0-720)
	BP = y (0-347)
---------------------------------------------
INT 10 - VIDEO - DRAW TO POINT (Hercules GRAFIX)
	AH = 49h
	DI = x (0-720)
	BP = y (0-347)
Note:	function 48h or 49h specify first point, 44h operation and 43h page to
	  use
---------------------------------------------
INT 10 - VIDEO - BLOCK FILL (Hercules GRAFIX)
	AH = 4Ah
	DI = x coordinate of lower left corner
	BP = y coordinate of lower left corner
	BX = height in pixels
	CX = width in pixels
Note:	draws a solid rectangle
---------------------------------------------
INT 10 - VIDEO - DISPLAY CHARACTER (Hercules GRAFIX)
	AH = 4Bh
	AL = character to display
	DI = x (0-720)
	BP = y (0-347)
Note:	unlike the other BIOS character functions character position is
	  specified in pixels rather than rows and columns
---------------------------------------------
INT 10 - VIDEO - DRAW ARC (Hercules GRAFIX)
	AH = 4Ch
	AL = quadrant (1 = upper right, 2 = upper left, etc)
	DI = x coordinate of center
	BP = y coordinate of center
	BX = radius
---------------------------------------------
INT 10 - VIDEO - DRAW CIRCLE (Hercules GRAFIX)
	AH = 4Dh
	DI = x of center
	BP = y of center
	BX = radius
---------------------------------------------
INT 10 - VIDEO - FILL AREA (Hercules GRAFIX)
	AH = 4Eh
	DI = x coordinate of an interior point
	BP = y coordinate of an interior point
Notes:	fills convex polygonal areas
	the first fill makes the figure solid, the second erases it
---------------------------------------------
INT 10 - SCROLOCK.COM - INSTALLATION CHECK
	AH = 50h
Return: BX = 1954h if installed
	    AL = 00 if inactive, nonzero if active
Note:	SCROLOCK is a utility supplied with System Enhancement Associates' ARC
---------------------------------------------
INT 10 - SCROLOCK.COM - ENABLE/DISABLE
	AH = 51h
	AL = state
	    00h disable
	    nonzero enable
Note:	SCROLOCK is a utility supplied with System Enhancement Associates' ARC
---------------------------------------------
INT 10 - VIDEO - ATI EGA Wonder Super Switch Installation check
	AX = 5555h
Return: AX = AAAAh    if installed
	BX:CX = address of ??? routine in SMS.COM resident portion
Note:	Super Switch (SMS.COM) is a video mode switch program supplied with
	  ATI EGA Wonder. It also maps video mode 08h to 27h or 23h
SeeAlso: INT 10/AH=00h
---------------------------------------------
INT 10 - Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES
	AX = 6A00h
	BX = 0000h
	CX = 0000h
	DX = buffer length (may be 0)
	ES:DI -> buffer
Return: BX = number of bytes stored in buffer
	CX = bytes required for all descriptions (0 if no DGIS)
Note:	buffer contains descriptions and addresses of DGIS-compatible
	  display(s) and printer(s)
---------------------------------------------
INT 10 - DGIS - REDIRECT CHARACTER OUTPUT
	AX = 6A01h
	CX = 0000h
	ES:DI = address of device to send INT 10 output to
Return: CX = 0000h  output could not be redirected
	     else INT 10h output now routed to requested display
---------------------------------------------
INT 10 - DGIS - INQUIRE INT 10 OUTPUT DEVICE
	AX = 6A02h
	ES:DI = 0000h:0000h
Return: ES:DI = 0000h:0000h  if current display is non-DGIS
		else address of the current DGIS INT 10 display
---------------------------------------------
INT 10 - VIDEO - INSTALLATION CHECK (Video7 VGA,VEGA VGA)
        AX = 6F00h
Return: BX = 5637h ('V7') indicates Video7 VGA/VEGA VGA extensions are present
---------------------------------------------
INT 10 - VIDEO - GETINFO (Video7 VGA,VEGA VGA)
        AX = 6F01h
Return: AL = monitor type code (VEGA VGA only)
        AH = status register information
             bit  0 = display enable
			0 = display enabled
			1 = vertical or horizontal retrace in progress
             bit  1 = light pen flip flop set
             bit  2 = light pen switch activated
             bit  3 = vertical sync
             bit  4 = monitor resolution
			0 = high resolution (>200 lines)
			1 = low resolution (<=200 lines)
             bit  5 = display type
			0 = color
			1 = monochrome
	     bits6,7= diagnostic bits
Note:	bits 0-3 are the same as the EGA/VGA status register bits 0-3
---------------------------------------------
INT 10 - VIDEO - GET MODE AND SCREEN RESOLUTION (Video7 VGA, VEGA VGA)
        AX = 6F04h
Return: AL = current video mode (see AX=6F05h)
        BX = horizontal columns (text) or pixels (graphics)
        CX = vertical columns (text) or pixels (graphics)
---------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE (Video7 VGA, VEGA EXTENDED EGA/VGA)
	AX = 6F05h
	BL = mode (graphics mode if graphics resolution listed)
		 text  pixel graphic color disp scrn  system
		 resol	box  resoltn	   page addr
	   00h-13h = standard IBM modes
	   40h = 80x43  8x8			     Video7/VEGA VGA
	   41h = 132x25 8x14			     Video7/VEGA VGA
	   42h = 132x43 8x8			     Video7/VEGA VGA
	   43h = 80x60  8x8			     Video7/VEGA VGA
	   44h = 100x60 8x8			     Video7/VEGA VGA
	   45h = 132x28 8x8			     Video7/VEGA VGA
	   60h =	     752x410  16	     Video7 VGA, VEGA VGA
	   61h =	     720x540  16	     Video7 VGA, VEGA VGA
	   62h =	     800x600  16	     Video7 VGA, VEGA Ext EGA
	   63h =	    1024x768   2	     Video7 VGA
	   64h =	    1024x768   4	     Video7 VGA
	   65h =	    1024x768  16	     Video7 VGA, VEGA Ext EGA
	   66h =	     640x400 256	     Video7 VGA, VEGA Ext VGA
	   67h =	     640x480 256	     Video7 VGA, VEGA Ext VGA
	   68h =	     720x540 256	     Video7 VGA, VEGA Ext VGA
	   69h =	     800x600 256	     Video7 VGA, VEGA Ext VGA
	   70h =	     752x410  16gray	     Video7 VGA, VEGA VGA
	   71h =	     720x540  16gray	     Video7 VGA, VEGA VGA
	   72h =	     800x600  16gray	     Video7 VGA
	   73h =	    1024x768   2gray	     Video7 VGA
	   74h =	    1024x768   4gray	     Video7 VGA
	   75h =	    1024x768  16gray	     Video7 VGA
	   76h =	     640x400 256gray	     Video7 VGA
	   77h =	     640x480 256gray	     Video7 VGA
	   78h =	     720x540 256gray	     Video7 VGA
	   79h =	     800x600 256gray	     (future)
SeeAlso: AH=00h
---------------------------------------------
INT 10 - VIDEO - SELECT AUTOSWITCH MODE (V7VGA,VEGA VGA)
        AX = 6F06h
        BL = Autoswitch mode select
             00h select EGA/VGA-only modes
             01h select Autoswitched VGA/EGA/CGA/MGA modes
             02h select 'bootup' CGA/MGA modes
        BH = enable/disable (00h enable, 01h = disable selection)
---------------------------------------------
INT 10 - VIDEO - GET VIDEO MEMORY CONFIGURATION (V7VGA,VEGA VGA)
        AX = 6F07h
Return: AL = 6Fh
        AH = bits 0-6 = number of 256K blocks of video memory
             bit 7    = DRAM/VRAM (0: DRAM, 1: VRAM)
        BH = chip revision (SR8F) (S/C Chip in VEGA VGA)
        BL = chip revision (SR8E) (G/A Chip in VEGA VGA)
        CX = 0000h
---------------------------------------------
INT 10 - VIDEO - GET VIDEO RAM ADDRESS (TANDY 1000)
	AH = 70h
Return: AX  = segment address of the following
	[BX] = offset address of green plane
	[CX] = segment address of green plane
	[DX] = segment address of red/blue plane
	       (red offset = 0, blue offset = 4000)
---------------------------------------------
INT 10 - VIDEO - GET INCRAM ADDRESSES (TANDY 1000)
	AH = 71h
Return: AX  = segment address of the following
	[BX] = segment address of INCRAM
	[CX] = offset address of INCRAM
---------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN RIGHT (TANDY 1000)
	AH = 72h
	AL = number of columns blanked at left of window
	     00h = blank entire window
	BH = attributes to be used on blank columns
	CH,CL = row, column of upper left corner of window
	DH,DL = row, column of lower right corner
SeeAlso: AH=73h
--------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN LEFT (TANDY 1000)
	AH = 73h
	AL = number of columns blanked at right of window
	     00h = blank entire window
	BH = attributes to be used on blank columns
	CH,CL = row, column of upper left corner of window
	DH,DL = row, column of lower right corner
SeeAlso: AH=72h
---------------------------------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - SET ??? HANDLER
	AH = 80h
	DX = 4456h ('DV')
	ES:DI -> FAR subroutine to be called on ???
Return: DS = segment of DESQview data structure for video buffer
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
	the subroutine seems to be called when the DESQview menu is accessed;
	  on entry, AL = 3 or 4
---------------------------------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - GET ???
	AH = 81h
	DX = 4456h ('DV')
Return: ES = segment of DESQview data structure for video buffer
	    BYTE ES:[0] = current window number in DV 2.0x
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
---------------------------------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - GET CURRENT WINDOW INFO
	AH = 82h
	DX = 4456h ('DV')
Return: DS = segment in DESQview for data structure
	     in DV 2.00,
		  BYTE DS:[0] = window number
		  WORD DS:[1] = segment of other data structure
		  WORD DS:[3] = segment of window's object handle
	ES = segment of DESQview data structure for video buffer
	AL = current window number
	AH = ???
	BL = direct screen writes
	    00h program does not do direct writes
	    01h program does direct writes, so shadow buffer not usable
	BH = ???
	CL = current video mode
	CH = ???
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SELECT EXTERNAL MONITOR
	AX = BF00h
Note:	all registers preserved and the internal monitor is blanked
	the external monitor becomes the active monitor
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SELECT INTERNAL MONITOR
	AX = BF01h
Note:	all registers preserved and the external monitor is blanked
	the internal monitor becomes the active monitor
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SET MASTER MODE OF CURRENT CTRLR
	AX = BF02h
	BH = master mode
	    04h CGA
	    05h EGA
	    07h MDA
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - GET ENVIRONMENT
	AX = BF03h
	BX = 0000h
Return: BH = active monitor
	    00h = external
	    01h = internal
	BL = master mode
	    00h = switchable VDU not present
	    04h = CGA
	    05h = EGA
	    07h = MDA
	CH = 00h (reserved)
	CL = switchable VDU mode supported
	    bit  0   = CGA supported
	    bits 1,2 = reserved (1)
	    bit  3   = MDA supported
	    bits 4-7 = reserved (1)
	DH = internal monitor type
	    00h = none
	    01h = Dual-mode monitor
	    02h = 5153 RGB monitor
	    03h = Compaq Color monitor
	    04h = 640x400 flat panel
	DL = external monitor type
	    00h = none
	    01h = dual-mode monitor
	    02h = 5153 RGB monitor
	    03h = Compaq Color monitor
	    04h = 640x400 flat panel
---------------------------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SET MODE SWITCH DELAY
	AX = BF04h
	BH = 00h enable delay
	     01h disable delay
---------------------------------------------
INT 10 - VIDEO - MSHERC.COM - INSTALLATION CHECK???
	AH = EFh
Return: DL = video adapter type
	    00h original Hercules
	    01h ???
	    02h ???
	    FFh non-Hercules 
	DH = ???
Note:	MSHERC.COM is a support program for Microsoft Quick-C which makes its
	  graphics library compatible with a Hercules card by adding video
	  modes 08h and 88h, and supporting text in the new graphics modes.
	  While in mode 08h or 88h, INT 10 supports the Hercules card much
	  like a CGA.
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ ONE REGISTER
	AH = F0h
	BL = register number
	BH = 00h
	DX = group index
	    Pointer/data chips
	       00h CRT Controller (25 reg) 3B4h mono modes, 3D4h color modes
	       08h Sequencer (5 registers) 3C4h
	       10h Graphics Controller (9 registers) 3CEh
	       18h Attribute Controller (20 registers) 3C0h
	    Single registers
	       20h Miscellaneous Output register 3C2h
	       28h Feature Control register (3BAh mono modes, 3DAh color modes)
	       30h Graphics 1 Position register 3CCh
	       38h Graphics 2 Position register 3CAh
Return: BL = data
SeeAlso: AH=F1h
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE ONE REGISTER
	AH = F1h
	DX = group index (see AH=F0h)
	    if single register:
		BL = value to write
	    otherwise
		BL = register number
		BH = value to write
Return: BL = data
SeeAlso: AH=F0h
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER RANGE
	AH = F2h
	CH = starting register number
	CL = Number of registers (>1)
	DX = group index
	     00h CRTC (3B4h mono modes, 3D4h color modes)
	     08h Sequencer 3C4h
	     10h Graphics Controller 3CEh
	     18h Attribute Controller 3C0h
	ES:BX -> buffer, CL bytes
SeeAlso: AH=F3h
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE REGISTER RANGE
	AH = F3h
	CH = starting register
	CL = number of registers (>1)
	DX = group index (see AH=F2h)
	ES:BX -> buffer, CL bytes
SeeAlso: AH=F2h
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER SET
	AH = F4h
	CX = number of registers to read (>1)
	ES:BX -> table of records (see below)
Return: register values in table filled in
SeeAlso: AH=F5h

Format of entries in table of register records:
Offset	Size	Description
 00h	WORD	group index
		Pointer/data chips
		   00h CRTC (3B4h mono modes, 3D4h color modes)
		   08h Sequencer 3C4h
		   10h Graphics Controller 3CEh
		   18h Attribute Controller 3C0h
		Single registers
		   20h Miscellaneous Output register 3C2h
		   28h Feature Control register (3BAh mono modes, 3DAh color)
		   30h Graphics 1 Position register 3CCh
		   38h Graphics 2 Position register 3CAh
 02h	BYTE	register number (0 for single registers)
 03h	BYTE	register value
---------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE REGISTER SET
	AH = F5h
	CX = number of registers to write (>1)
	ES:BX -> table of records (see AH=F4h)
--------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - REVERT TO DEFAULT REGISTERS
	AH = F6h
--------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - DEFINE DEFAULT REGISTER TABLE
	AH = F7h
	DX = port number
	   Pointer/data chips
	      00h CRTC (3B4h mono modes, 3D4h color modes)
	      08h Sequencer 3C4h
	      10h Graphics Controller 3CEh
	      18h Attribute Controller 3C0h
	   Single registers
	      20h Miscellaneous Output register 3C2h
	      28h Feature Control register (3BAh mono modes, 3DAh color modes)
	      30h Graphics 1 Position register 3CCh
	      38h Graphics 2 Position register 3CAh
	ES:BX -> table of one-byte entries, one byte to be written to each
		 register
--------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - INTERROGATE DRIVER
	AH = FAh
	BX = 0000h
Return: BX = 0000h if mouse driver not present
	ES:BX -> EGA Register Interface version number, if present:
	    byte 0 = major release number
	    byte 1 = minor release number
--------------------------------------------
INT 10 - FASTBUFF.COM - INSTALLATION CHECK
	AH = FAh
Return: AX = 00FAh if installed
	    ES = segment of resident code
Note:	FASTBUFF.COM is a keyboard speedup/screen blanking utility by David
	  Steiner
--------------------------------------------
INT 10 - VIDEO (TopView) - GET VIDEO BUFFER
	AH = FEh
	ES:DI = segment:offset of assumed video buffer
Return: ES:DI = segment:offset of actual video buffer
Notes:	if no multitasker is installed, ES:DI is returned unchanged
	TopView requires a call to AH=FFh to notify if that the screen has
	  changed; DESQview will check for changes itself until the first call
	  to AH=FFh
SeeAlso: INT 15/AX=1024h
---------------------------------------------
INT 10 - VIDEO (TopView) - UPDATE REAL SCREEN FROM VIDEO BUFFER
	AH = FFh
	CX = number of sequential characters that have been modified
	DI = offset of first character that has been modified
	ES = segment of video buffer
Note:	avoid CX=0
---------------------------------------------
INT 11 - EQUIPMENT DETERMINATION
Return: AX = equipment flag bits
	    0	  diskette installed
	    1	  8087 present
	    2	  mouse installed (PS2 only)
	    2,3   number of 16K banks of RAM on motherboard (PC only)
		  number of 64K banks of RAM on motherboard (XT only)
		  always = 11 on AT and above
	    4,5   initial video mode
		  01 = 40x25 color
		  10 = 80x25 color
		  11 = 80X25 IBM monochrome
	    6,7   number of diskette drives (only if bit 0 = 1)
		  00 = 1, 01 = 2, 10 = 3, 11 = 4
	    8	  0 = DMA present
		  1 = no DMA on system (PCjr, some Tandy 1000s, 1400LT)
	    9-11  number of RS232 cards
	    12	  game I/O attached
	    13	  serial printer installed (PCjr)
		  internal modem installed (PC/Convertible)
	    14,15 number of printers
---------------------------------------------
INT 12 - MEMORY SIZE
Return: AX = number of contiguous 1K blocks of memory
---------------------------------------------
INT 13 - DISK - RESET DISK SYSTEM
	AH = 00h
	DL = drive (if bit 7 is set both hard disks and floppy disks reset)
Note:	forces controller to recalibrate drive heads (seek to track 0)
SeeAlso: AH=0Dh
---------------------------------------------
INT 13 - DISK - STATUS OF DISK SYSTEM
	AH = 01h
Return: AL = status of last disk operation
	    00h = successful completion
	    01h = bad command
	    02h = address mark not found
	    03h = write attempted on write-protected disk
	    04h = sector not found
	    05h = reset failed (hard disk)
	    06h = diskette changed
	    07h = parameter act. failed (hard disk)
	    08h = DMA overrun (floppy disk)
	    09h = DMA across 64K boundary
	    0Ah = bad sector detected (hard disk)
	    0Bh = bad track detected (hard disk)
	    0Ch = unsupported track
	    0Dh = invalid number of sectors on format (hard disk)
	    0Eh = control data address mark detected (hard disk)
	    0Fh = DMA arbitration error (hard disk)
	    10h = bad CRC/ECC
	    11h = data ECC corrected (hard disk)
	    20h = controller failure
	    40h = seek failed
	    80h = time out
	    AAh = drive not ready (hard disk)
	    BBh = undefined error (hard disk)
	    CCh = write fault (hard disk)
	    E0h = status register error (hard disk)
	    FFh = sense operation failed (hard disk)
---------------------------------------------
INT 13 - DISK - READ SECTORS INTO MEMORY
	AH = 02h
	AL = number of sectors to read
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector
	DH = head
	DL = drive
	ES:BX -> buffer to fill
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors read
Notes:	results undefined if attempting to read zero sectors
	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=03h,0Ah
---------------------------------------------
INT 13 - DISK - WRITE SECTORS FROM MEMORY
	AH = 03h
	AL = number of sectors to write
	CH = track (if hard disk, bits 8,9 in high bits of CL)
	CL = sector (if hard disk, high two bits are high bits of track #)
	DH = head
	DL = drive
	ES:BX -> buffer
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors written
Notes:	results undefined if attempting to write zero sectors
	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=02h,0Bh
---------------------------------------------
INT 13 - DISK - VERIFY SECTORS
	AH = 04h
	AL = number of sectors to verify
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector
	DH = head
	DL = drive
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors verified
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
---------------------------------------------
INT 13 - FLOPPY - FORMAT TRACK
	AH = 05h
	AL = number of sectors to create on this track
	CH = track
	CL = sector
	DH = head
	DL = drive
	ES:BX -> array of 4-byte address fields
		BYTE	track
		BYTE	head
	        BYTE	sector
		BYTE	bytes/sector  0=128, 1=256, 2=512, 3=1024
Return: CF set if error occurred
	AH = status code (see AH=01h)
---------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK
	AH = 05h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer
		the first 2*(sectors/track) bytes contain F,N for each sector
		   F = 00 for good sector, 80h for bad sector
		   N = sector number
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
---------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)
	AH = 06h
	AL = interleave value
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
---------------------------------------------
INT 13 - FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)
	AH = 07h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer (see AH=05h)
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Note:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=1Ah
---------------------------------------------
INT 13 - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
	AH = 08h
	DL = drive number
Return: CF set on error
	AH = status code (see AH=01h)
	BL = drive type (see AH=17h) (AT/PS2 floppies only)
	DL = number of consecutive acknowledging drives
	DH = maximum value for head number
	CL = maximum value for sector number (bits 0-5)
	CH = maximum value for cylinder number (highest bits in bits 6,7 of CL)
	ES:DI -> drive parameter table
---------------------------------------------
INT 13 - FIXED DISK - INITIALIZE TWO FIXED DISK BASE TABLES (XT,AT,XT286,PS)
	AH = 09h
Return: CF set on error
	AH = status code (see AH=01h)
	INT 41h points to table for drive 0
	INT 46h points to table for drive 1
---------------------------------------------
INT 13 - FIXED DISK - READ LONG (XT,AT,XT286,PS)
	AH = 0Ah
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
	CL = sector
	ES:BX -> buffer to fill
Return: CF set on error
	AH = status code (see AH=01h)
	AL = number of sectors read
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=02h,0Bh
---------------------------------------------
INT 13 - FIXED DISK - WRITE LONG (XT,AT,XT286,PS)
	AH = 0Bh
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
	CL = sector
	ES:BX -> buffer containing data
Return: CF set on error
	AH = status code (see AH=01h)
	AL = number of sectors written
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=03h,0Ah
---------------------------------------------
INT 13 - FIXED DISK - SEEK TO CYLINDER (XT,AT,XT286,PS)
	AH = 0Ch
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
Return: CF set on error
	AH = status code (see AH=01h)
---------------------------------------------
INT 13 - FIXED DISK - ALTERNATE DISK RESET (XT,AT,XT286,PS)
	AH = 0Dh
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
Note:	not for PS/2 ESDI drives
SeeAlso: AH=00h
---------------------------------------------
INT 13 - FIXED DISK - READ SECTOR BUFFER (XT,PS)
	AH = 0Eh
	ES:BX -> buffer
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	transfers controller's sector buffer.  No data is read from the drive
	used for diagnostics only on PS/2 systems
SeeAlso: AH=0Ah
---------------------------------------------
INT 13 - FIXED DISK - WRITE SECTOR BUFFER (XT,PS)
	AH = 0Fh
	ES:BX -> buffer
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	should be called before formatting to initialize the controller's
	  sector buffer.
	used for diagnostics only on PS/2 systems
SeeAlso: AH=0Bh
---------------------------------------------
INT 13 - FIXED DISK - TEST FOR DRIVE READY (XT,AT,XT286,PS)
	AH = 10h
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
---------------------------------------------
INT 13 - FIXED DISK - RECALIBRATE DRIVE (XT,AT,XT286,PS)
	AH = 11h
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
SeeAlso: AH=19h
---------------------------------------------
INT 13 - FIXED DISK - CONTROLER RAM DIAGNOSTIC (XT,PS)
	AH = 12h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=13h,14h
---------------------------------------------
INT 13 - FIXED DISK - DRIVE DIAGNOSTIC (XT,PS)
	AH = 13h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=12h,14h
---------------------------------------------
INT 13 - FIXED DISK - CONTROLLER DIAGNOSTICS (XT,AT,XT286,PS)
	AH = 14h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=12h,13h
---------------------------------------------
INT 13 - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
	AH = 15h
	DL = drive ID
Return: CF set on error
	AH = disk type
	    00h = disk not there
	    01h = floppy, no change detection present
	    02h = floppy with change detection
	    03h = fixed disk
	       CX:DX = number of 512-byte sectors
SeeAlso: AH=17h
---------------------------------------------
INT 13 - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
	AH = 16h
	DL = drive to check
Return: AH = disk change status
	    00h = no disk change
	    06h = disk changed
---------------------------------------------
INT 13 - DISK - SET TYPE (AT,XT2,XT286,CONV,PS)
	AH = 17h
	AL = disk type
	    00h = no disk
	    01h = regular disk in regular drive
	    02h = regular disk in high-capacity drive
	    03h = high-capacity disk in high-capacity drive
	    04h = 720K disk in 720K drive
	DL = drive ID
Note:	I assume that 05h and 06h are 720K in 1.44M and 1.44M in 1.44M
SeeAlso: AH=15h
---------------------------------------------
INT 13 - DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
	AH = 18h
	DL = drive number
	CH = lower 8 bits of number of tracks
	CL = sectors per track (bits 0-5)
	     top 2 bits of number of tracks (bits 6,7)
Return: AH = 00h  requested combination supported
	     01h  function not available
	     0Ch  not supported or drive type unknown
	     80h  there is no disk in the drive
	ES:DI -> 11-byte parameter table
SeeAlso: AH=05h,07h,17h
---------------------------------------------
INT 13 - FIXED DISK - PARK HEADS (XT286,PS)
	AH = 19h
	DL = drive
Return: CF set on error
	AH = status (see AH=01h)
SeeAlso: AH=11h
---------------------------------------------
INT 13 - ESDI FIXED DISK - FORMAT UNIT (PS)
	AH = 1Ah
	AL = defect table count
	CL = format modifiers
	    bit 4: generate periodic interrupt
	    bit 3: perform surface analysis
	    bit 2: update secondary defect map
	    bit 1: ignore secondary defect map
	    bit 0: ignore primary defect map
	DL = drive
	ES:BX -> defect table
Return: CF set on error
	AH = status (see AH=01h)
Note:	if periodic interrupt selected, INT 15h/AH=0Fh is called after each
	  cylinder is formatted
SeeAlso: AH=07h
---------------------------------------------
INT 13 - ESDI FIXED DISK - GET MANUFACTURING HEADER
	AH = 1Bh
	AL = number of record
	DL = drive
	ES:BX -> buffer for manufacturing header (defect list)
Return: CF set on error
	    AH = status
Note:	manufacturing header format (Defect Map Record format) can be found
	  in IBM 70MB, 115MB Fixed Disk Drives Technical Reference
---------------------------------------------
INT 13 - ESDI FIXED DISK - GET DEVICE CONFIGURATION
	AX = 1C0Ah
	DL = drive
	ES:BX -> buffer for device configuration (drive physical parameter)
Return: CF set on error
	    AH = status
Note:	device configuration format can be found in IBM ESDI Fixed Disk Drive
	  Adapter/A Technical Reference
---------------------------------------------
INT 13 - ESDI FIXED DISK - GET ADAPTER CONFIGURATION
	AX = 1C0Bh
	ES:BX -> buffer for adapter configuration
Return: CF set on error
	    AH = status
---------------------------------------------
INT 13 - ESDI FIXED DISK - GET POS INFORMATION
	AX = 1C0Ch
	ES:BX -> POS information
Return: CF set on error
	    AH = status
---------------------------------------------
INT 13 - ESDI FIXED DISK - TRANSLATE RBA TO ABA
	AX = 1C0Eh
	CH = low 8 bits of cylinder number
	CL = sector number, high two bits of cylinder number in bits 6 and 7
	DH = head number
	DL = drive number
	ES:BX -> ABA number
Return: CF set on error
	    AH = status
Note:	ABA (absolute block address) format can be found in IBM ESDI Adapter
	  Technical Reference by using it's Device Configuration Status Block
---------------------------------------------
INT 13 - IBMCACHE.SYS - CACHE STATUS
	AH = 1Dh
	AL = subfunction
	    01h get status record
		DL = drive???
		Return: ES:BX -> status record
			CF set on error
			    AH = error code
	    02h set cache status
		ES:BX -> status record
		DL = drive???
		Return: CF set on error

Format of status record:
Offset	Size	Description
 00h	DWORD	total number of read requests
 04h	DWORD	total number of hits
 08h	DWORD	number of physical disk reads
 0Ch	DWORD	total number of sectors requested by physical disk reads
 10h  6 bytes	???
 16h	DWORD	pointer to start of error list
 1Ah	DWORD	pointer to end of error list
 1Eh	WORD	???
 20h	BYTE	using extended memory if nonzero
 21h	BYTE	???
 22h  4 BYTEs	ASCII version number
 26h	WORD	cache size in K
 28h	WORD	sectors per page

Format of error list:
Offset	Size	Description
 00h	DWORD	relative block address of bad page
 04h	BYTE	drive
 05h	BYTE	sector bit-map
 06h	WORD	next error
---------------------------------------------
INT 13 - DISK - ??? (Western Digital "Super BIOS")
	AH = 20h
	???
Return: ???
Note:	seems to return some kind of status
---------------------------------------------
INT 13 - QCACHE - DISMOUNT
	AX = 20FFh
Return: ???
---------------------------------------------
INT 13 - QCACHE - FLUSH CACHE
	AH = 21h
Return: ???
---------------------------------------------
INT 13 - QCACHE - ENABLE/DISABLE CACHE
	AH = 22h
	AL = 00h disable cache
	     01h enable cache
---------------------------------------------
INT 13 - QCACHE - SET SECTORS
	AH = 24h
	BX = number of sectors
Return: ???
---------------------------------------------
INT 13 - QCACHE - SET FLUSH INTERVAL
	AH = 25h
	BC = interval
Return: ???
---------------------------------------------
INT 13 - QCACHE - INSTALLATION CHECK
	AH = 27h
	BX = 0000h
Return: BX nonzero if installed
---------------------------------------------
INT 13 - QCACHE - SET BUFFER SIZE
	AH = 2Ah
	AL = buffer size
Return: ???
---------------------------------------------
INT 13 - QCACHE - SET BUFFERED WRITES
	AH = 2Ch
	AL = state
	    00h disable
	    01h enable
Return: ???
---------------------------------------------
INT 13 - QCACHE - SET BUFFERED READ
	AH = 2Dh
	AL = state
	    00h disable
	    01h enable
Return: ???
---------------------------------------------
INT 13 - QCACHE - SET FLUSH COUNT
	AH = 2Eh
	BX = flush count
Return: ???
---------------------------------------------
INT 13 - QCACHE - GET INFO
	AH = 30h
	AL = what to get
	    00h system info
	    01h drive info
	DS:DX -> buffer for info
Return: ???
---------------------------------------------
INT 13 - SWBIOS - SET 1024 CYLINDER FLAG
	AH = EEh
	DL = drive number (80h, 81h)
Return: CF clear
	   AH = 00h
Notes:	the following INT 13 call will interpret the cylinder number as 1024
	  less than the desired cylinder
	flag cleared by all INT 13 calls except AH=EEh
	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
---------------------------------------------
INT 13 - SWBIOS - INSTALLATION CHECK
	AH = F9h
	DL = drive number (80h,81h)
Return: CF clear 
	    DX = configuration word
		bit 15 set if other SWBIOS extensions available
	CF set on error
Note:	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
---------------------------------------------
INT 13 - SWBIOS - GET EXTENDED CYLINDER COUNT
	AH = FEh
	DL = drive number (80h, 81h)
Return: CF clear
	DX = number of cylinders beyond 1024 on drive
Notes:	standard INT 13/AH=08h will return a cylinder count truncated to 1024
	BIOS without this extension would return count modulo 1024
	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
---------------------------------------------
INT 14 - SERIAL I/O - INITIALIZE USART
	AH = 00h
	AL = initializing parameters
	    7 - 6 - 5	   4 - 3     2	  1 - 0
	    -BAUD RATE-    PARITY   STOP   WORD
				    BITS  LENGTH
	    000  110 bd    00 none  0: 1   00: 5
	    001  150 bd    01 odd   1: 2   01: 6
	    010  300 bd    11 even	   10: 7
	    011  600 bd 		   11: 8
	    100 1200 bd
	    101 2400 bd
	    110 4800 bd
	    111 9600 bd (4800 on PCjr)
	DX = port number (0-3)
Return: AH = RS-232 status code bits
	    0: data ready
	    1: overrun error
	    2: parity error
	    3: framing error
	    4: break detected
	    5: transmission buffer register empty
	    6: transmission shift register empty
	    7: time out--if set, other bits invalid
	AL = modem status bits
	    0: delta Clear-To-Send
	    1: delta Data-Set-Ready
	    2: trailing edge of ring detected
	    3: change in receive line signal detected
	    4: Clear-To-Send
	    5: Data-Set-Ready
	    6: ring detected
	    7: receive line signal detected
SeeAlso: AH=05h
---------------------------------------------
INT 14 - FOSSIL (Fido/Opus/Seadog Standard Interface Level) - INITIALIZE
	AH = 00h
	AL = initializing parameters
	    7 - 6 - 5	   4 - 3     2	  1 - 0
	    -BAUD RATE-    PARITY   STOP   WORD
				    BITS  LENGTH
	    000 19200 bd   00 none  0: 1  00: 5
	    001 38400 bd   01 odd   1: 2  01: 6
	    010   300 bd   11 even	  10: 7
	    011   600 bd		  11: 8
	    100  1200 bd
	    101  2400 bd
	    110  4800 bd
	    111  9600 bd (4800 on PCjr)
	DX = port number (0-3 or FFh if only performing non-I/O setup)
Return: AH = RS-232 status code bits
	    0: RDA - input data is available in buffer
	    1: OVRN - data has been lost
	    5: THRE - room is available in output buffer
	    6: TSRE - output buffer empty
	AL = modem status bits
	    3: always 1
	    7: DCD - carrier detect
---------------------------------------------
INT 14 - SERIAL I/O - TRANSMIT CHARACTER
	AH = 01h
	AL = character
	DX = port number (0-3)
Return: AX = port status (see AH=00h)
---------------------------------------------
INT 14 - SERIAL I/O - RECEIVE CHARACTER
	AH = 02h
	DX = port number (0-3)
Return: AL = character received
	AH = RS-232 status code (see AH=00h)
Note:	will timeout if DSR is not asserted, even if function 03h returns
	  data ready
---------------------------------------------
INT 14 - FOSSIL - RECEIVE CHARACTER WITH WAIT
	AH = 02h
	DX = port number (0-3)
Return: AL = character received
	AH = 00h
---------------------------------------------
INT 14 - SERIAL I/O - GET USART STATUS
	AH = 03h
	DX = port number (0-3)
Return: AX = port status code (see AH=00h)
---------------------------------------------
INT 14 - SERIAL I/O - EXTENDED INITIALIZE (CONVERTIBLE,PS)
	AH = 04h
	AL = break status
	    00h if break
	    01h if no break
	BH = parity
	    00h no parity
	    01h odd parity
	    02h even parity
	    03h stick parity odd
	    04h stick parity even
	BL = number of stop bits
	    00h one stop bit
	    01h two stop bits (1.5 if 5 bit word length)
	CH = word length
	    00h 5 bits
	    01h 6 bits
	    02h 7 bits
	    03h 8 bits
	CL = bps rate
	    00h 110
	    01h 150
	    02h 300
	    03h 600
	    04h 1200
	    05h 2400
	    06h 4800
	    07h 9600
	    08h 19200
	DX = port number
Return: AX = port status code (see AH=00h)
---------------------------------------------
INT 14 - FOSSIL - INITIALIZE DRIVER
	AH = 04h
	DX = port number
	optionally BX=4F50h
		   ES:CX -> byte to be set upon ^C
Return: AX = 1954h (if successful)
	BL = maximum function number supported (excluding 7Eh and above)
	BH = revision of FOSSIL supported
	DTR is raised
Note:	the word at offset 6 in the interrupt handler contains 1954h, and the
	  following byte contains the maximum function number supported
---------------------------------------------
INT 14 - SERIAL I/O - EXTENDED COMMUNICATION PORT CONTROL (CONVERTIBLE,PS)
	AH = 05h
	AL = 00h read modem control register
	      Return: BL = modem control register (see below)
		      AH = status
	AL = 01h write modem control register
	      BL = modem control register
		  bit 0: data terminal ready
		  bit 1: request to send
		  bit 2: OUT1
		  bit 3: OUT2
		  bit 4: LOOP
		  bits 5-7 reserved
	      Return: AX = status
	DX = port number
SeeAlso: AH=00h
---------------------------------------------
INT 14 - FOSSIL - DEINITIALIZE DRIVER
	AH = 05h
	DX = port number
Return: none
	DTR is not affected
---------------------------------------------
INT 14 - FOSSIL - RAISE/LOWER DTR
	AH = 06h
	DX = port
	AL = DTR state to be set
	    00h = lower
	    01h = raise
---------------------------------------------
INT 14 - FOSSIL - RETURN TIMER TICK PARAMETERS
	AH = 07h
Return: AL = timer tick interrupt number
	AH = ticks per second on interrupt number in AL
	DX = approximate number of milliseconds per tick
---------------------------------------------
INT 14 - FOSSIL - FLUSH OUTPUT BUFFER WAITING TILL ALL OUTPUT IS DONE
	AH = 08h
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - PURGE OUTPUT BUFFER THROWING AWAY ALL PENDING OUTPUT
	AH = 09h
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - PURGE INTPUT BUFFER THROWING AWAY ALL PENDING INPUT
	AH = 0Ah
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - TRANSMIT NO WAIT
	AH = 0Bh
	AL = character
	DX = port number
Return: AX = 0000h character not accepted
	   = 0001h character accepted
---------------------------------------------
INT 14 - FOSSIL - NON-DESTRUCTIVE READ AHEAD
	AH = 0Ch
	DX = port number
Return: AX = FFFFh character not available
	AX = 00xxh character xx available
---------------------------------------------
INT 14 - FOSSIL - KEYBOARD READ WITHOUT WAIT
	AH = 0Dh
Return: AX = FFFFh character not available
	   = xxyyh standard IBM-style scan code
---------------------------------------------
INT 14 - FOSSIL - KEYBOARD READ WITH WAIT
	AH = 0Eh
Return: AX = xxyyh standard IBM-style scan code
---------------------------------------------
INT 14 - FOSSIL - ENABLE/DISABLE FLOW CONTROL
	AH = 0Fh
	AL = bit mask describing flow control requested
	    0: xon/xoff on transmit (watch for xoff while sending)
	    1: CTS/RTS (CTS on transmit/RTS on receive)
	    2: reserved
	    3: xon/xoff on receive (send xoff when buffer near full)
	    4-7: all 1
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - EXTENDED ^C/^K CHECKING AND TRANSMIT ON/OFF
	AH = 10h
	AL = bit mask
	    0: enable/disable ^C/^K checking
	    1: enable/disable the transmitter
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - SET CURRENT CURSOR LOCATION
	AH = 11h
	DH = row
	DL = column
Note:	this is the same as INT 10/AH=02h
---------------------------------------------
INT 14 - FOSSIL - READ CURRENT CURSOR LOCATION
	AH = 12h
Return: DH = row
	DL = column
Note:	this is the same as INT 10/AH=03h
---------------------------------------------
INT 14 - FOSSIL - SINGLE CHARACTER ANSI WRITE TO SCREEN
	AH = 13h
	AL = character
Note:	should not be called if it is unsafe to call DOS
---------------------------------------------
INT 14 - FOSSIL - ENABLE OR DISABLE WATCHDOG PROCESSING
	AH = 14h
	AL = 01h enable watchdog
	     00h disable watchdog
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - WRITE CHARACTER TO SCREEN USING BIOS SUPPORT ROUTINES
	AH = 15h
	AL = character
---------------------------------------------
INT 14 - FOSSIL - INSERT/DELETE FUNCTION FROM TIMER TICK CHAIN
	AH = 16h
	AL = function
	    00h = delete
	    01h = add
	ES:DX -> routine to call
Return: AX = 0000h successful
	     0001h unsuccessful
---------------------------------------------
INT 14 - FOSSIL - REBOOT SYSTEM
	AH = 17h
	AL = method
	    00h = cold boot
	    01h = warm boot
---------------------------------------------
INT 14 - FOSSIL - READ BLOCK
	AH = 18h
	CX = maximum number of characters to transfer
	DX = port number
	ES:DI -> user buffer
Return: AX = number of characters transfered
---------------------------------------------
INT 14 - FOSSIL - WRITE BLOCK
	AH = 19h
	CX = maximum number of characters to transfer
	DX = port number
	ES:DI -> user buffer
Return: AX = number of characters transfered
---------------------------------------------
INT 14 - FOSSIL - BREAK BEGIN OR END
	AH = 1Ah
	AL = 00h stop sending 'break'
	     01h start sending 'break'
	DX = port number
---------------------------------------------
INT 14 - FOSSIL - RETURN INFORMATION ABOUT THE DRIVER
	AH = 1Bh
	DX = port number
	CX = size of user buffer
	ES:DI -> user buffer for driver info (see below)
Return: AX = number of characters transferred

Format of driver info:
Offset	Size	Description
 00h	WORD	size of structure in bytes
 02h	BYTE	FOSSIL spec driver conforms to
 03h	BYTE	revision level of this specific driver
 04h	DWORD	pointer to ASCIZ identification string
 08h	WORD	size of the input buffer
 0Ah	WORD	number of bytes left in buffer
 0Ch	WORD	size of the output buffer
 0Eh	WORD	number of bytes left in buffer
 10h	BYTE	width of screen
 11h	BYTE	length of screen
 12h	BYTE	actual baud rate, computer to modem
---------------------------------------------
INT 14 - FOSSIL - INSTALL AN EXTERNAL APPLICATION FUNCTION
	AH = 7Eh
	AL = code assigned to external application
	ES:DX -> entry point
Return: AX = 1954h
	BL = code assigned to application (same as input AL)
	DH = 00h failed
	     01h successful
---------------------------------------------
INT 14 - FOSSIL - REMOVE AN EXTERNAL APPLICATION FUNCTION
	AH = 7Fh
	AL = code assigned to external application
	ES:DX -> entry point
Return: AX = 1954h
	BL = code assigned to application (same as input AL)
	DH = 00h failed
	     01h successful
---------------------------------------------
INT 14 - COURIERS.COM - INSTALLATION CHECK
	AH = 80h
Return: AH = E8h if loaded
Note:	COURIERS is a TSR utility by PC Magazine
---------------------------------------------
INT 14 - COURIERS.COM - CHECK IF PORT BUSY
	AH = 81h
	AL = port number (1-4)
Return: AH = 00h port available
	     01h port exists but already in use
	     02h port nonexistent
Note:	COURIERS is a TSR utility by PC Magazine
SeeAlso: AH=83h,8Dh
---------------------------------------------
INT 14 - COURIERS.COM - CONFIGURE PORT
	AH = 82h
	AL = port number (1-4)
	BX = speed (bps)
	CX = bit flags
	    bit 0: enable input flow control
	    bit 1: enable output flow control
	    bit 2: use X.PC protocol (not yet implemented)
SeeAlso: AH=8Ch
---------------------------------------------
INT 14 - COURIERS.COM - START INPUT
	AH = 83h
	ES:BX -> circular input buffer
	CX = length of buffer 
		(should be at least 128 bytes if input flow control enabled)
SeeAlso: AH=87h,8Dh
---------------------------------------------
INT 14 - COURIERS.COM - READ CHARACTER
	AH = 84h
Return: ZF set if no characters available
	ZF clear
	   AL = character
	   AH = modem status bits
		bit 7: set on input buffer overflow
SeeAlso: AH=86h,89h
---------------------------------------------
INT 14 - COURIERS.COM - FLUSH PENDING INPUT
	AH = 85h
SeeAlso: AH=88h
---------------------------------------------
INT 14 - COURIERS.COM - START OUTPUT
	AH = 86h
	ES:BX -> output buffer
	CX = length of output buffer
SeeAlso: AH=83h
---------------------------------------------
INT 14 - COURIERS.COM - OUTPUT STATUS
	AH = 87h
Return: AX = number of unsent characters
---------------------------------------------
INT 14 - COURIERS.COM - ABORT OUTPUT
	AH = 88h
SeeAlso: AH=85h
---------------------------------------------
INT 14 - COURIERS.COM - SEND SINGLE CHARACTER
	AH = 89h
	CL = character to send
SeeAlso: AH=84h
---------------------------------------------
INT 14 - COURIERS.COM - SEND BREAK
	AH = 8Ah
---------------------------------------------
INT 14 - COURIERS.COM - SET SPEED
	AH = 8Ch
	BX = speed in bps
SeeAlso: AH=82h
---------------------------------------------
INT 14 - COURIERS.COM - DECONFIGURE PORT
	AH = 8Dh
SeeAlso: AH=82h
---------------------------------------------
INT 15 - CASSETTE - TURN ON MOTOR (PC,Jr)
	AH = 00h
Return: CF set on error, AH = 86h if no cassette present
---------------------------------------------
INT 15 - VMiX v2+ - INSTALLATION CHECK???
	AH = 00h
Return: DX = 0798h???
---------------------------------------------
INT 15 - CASSETTE - TURN OFF MOTOR (PC,Jr)
	AH = 01h
Return: CF set on error, AH = 86h if no cassette present
---------------------------------------------
INT 15 - VMiX - I/O CHANNEL OBJECT MANAGER
	AH = 01h
	STACK: WORD  object ID of requestor
	       DWORD pointer to name of requested method
	       WORD  arg1
	       WORD  arg2
	       WORD  arg3
	       WORD  arg4
Return: DX:AX??? -> IRP structure or 0000h:0000h 
---------------------------------------------
INT 15 - CASSETTE - READ DATA BLOCKS (PC,Jr)
	AH = 02h
	CX = count of bytes
	ES:BX -> data area
Return: CF set on error
	AH = status
	    01h CRC error
	    02h bad tape signals
	    04h no data
	    80h invalid command
	    86h no cassette present
	DX = count of bytes read
	ES:BX = pointer past last byte read
---------------------------------------------
INT 15 - VMiX - MEMORY OBJECT MANAGER
	AH = 02h
	STACK:	WORD	object ID of requestor
		DWORD	pointer to name of requested method
		WORD	arg1
		WORD	arg2
		WORD	arg3
		WORD	arg4
		WORD	arg5
Return: DX:AX??? = pointer to memory block
---------------------------------------------
INT 15 - CASSETTE - WRITE DATA BLOCKS (PC,Jr)
	AH = 03h
	CX = count of bytes to write
	ES:BX -> data area
Return: CF set on error
	   AH = status (see AH=02h)
	ES:BX = pointer past last byte written
	CX = 0
---------------------------------------------
INT 15 - VMiX - PROMPTED CONSOLE INPUT
	AH = 03h
	STACK:	DWORD	pointer to ASCII prompt
		WORD	field outline character
		WORD	length of input field
		DWORD	address of pointer to input buffer
		WORD	number of characters input
Return: AX = length of input (input buffer is padded with blanks)
---------------------------------------------
INT 15 - VMiX - VPRINTF
	AH = 04h
	STACK:	DWORD	control string
		DWORD	array of arguments
---------------------------------------------
INT 15 - VMiX - GET PROCESS ID OF CURRENT PROCESS
	AH = 05h
Return: AX = process ID
---------------------------------------------
INT 15 - VMiX - GET POINTER TO PROCESS CONTROL BLOCK
	AH = 06h
	STACK:	WORD	process ID
Return: DX:AX??? -> process control block
---------------------------------------------
INT 15 - VMiX - GET POINTER TO OBJECT CONTROL BLOCK
	AH = 07h
	STACK:	WORD	object type
Return: DX:AX??? -> object control block
---------------------------------------------
INT 15 - VMiX - GET CHANNEL CONTROL BLOCK
	AH = 08h
	STACK:	WORD	channel ID
Return: DX:AX??? -> channel control block
---------------------------------------------
INT 15 - VMiX - GET ID OF QUEUED ELEMENT
	AH = 09h
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	subqueue ID
Return: AX = ID
---------------------------------------------
INT 15 - VMiX - GET ID OF NEXT QUEUED ELEMENT
	AH = 0Ah
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	ID of current element in queue chain
Return: AX = ID of next element
---------------------------------------------
INT 15 - VMiX - GET TOTAL NUMBER OF ACTIVE PROCESSES
	AH = 0Bh
Return: AX = number of active processes
---------------------------------------------
INT 15 - VMiX - GET POINTER TO PROCESS TSS STACK
	AH = 0Ch
	STACK:	WORD	process ID
Return: DX:AX??? -> TSS stack store
---------------------------------------------
INT 15 - VMiX - START A CHILD PROCESS JOB SHELL
	AH = 0Dh
	STACK:	DWORD	ASCIZ string starting with requested I/O channel and
			followed by standard VMiX shell command string
Return: AX = status
---------------------------------------------
INT 15 - VMiX - TERMINATE PROCESS
	AH = 0Eh
	STACK:	WORD	process ID
Return: AX = status
---------------------------------------------
INT 15 - SYSTEM - FORMAT UNIT PERIODIC INTERRUPT (PS ESDI drives only)
	AH = 0Fh
	AL = phase code
	    00h reserved
	    01h surface analysis
	    02h formatting
Return: CF clear if formatting should continue, set if it should terminate
Note:	called during ESDI drive formatting after each cylinder is completed
SeeAlso: INT 13/AH=1Ah
---------------------------------------------
INT 15 - VMiX - GET KEY FIELD OF QUEUED ELEMENT
	AH = 0Fh
	STACK:	WORD	queue ID (0 = process queue, 1 = object q, 3 = type q)
		WORD	ID of element in queue chain
Return: AX = key
---------------------------------------------
INT 15 - VMiX - EXECUTE FUNCTION IN PROTECTED MODE
	AH = 10h
	STACK:	DWORD	pointer to function
	      N	WORDs	function args
Return: ???
---------------------------------------------
INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME
	AX = 1000h
Return: after other processes run
---------------------------------------------
INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = 1001h
	BX = number of bytes to allocate
Return: ES:DI -> block of memory
SeeAlso: AX=1002h,DE0Ch
---------------------------------------------
INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = 1002h
	ES:DI -> previously allocated block
Return: block freed
SeeAlso: AX=1001h,DE0Dh
---------------------------------------------
INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN
	AX = 1003h
	BH = attribute
	BL = character
	DX = segment of object handle for window
Note:	BX=0 does not display anything, it only positions the hardware cursor
---------------------------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 04h thru 12h
Return: pops up "Programming error" window in DV 2.x
---------------------------------------------
INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1013h
	ES:DI -> FAR service routine
Return: BX = bit mask indicating which bit was allocated
	     0000h if no more bits available
SeeAlso: AX=1014h,1015h
---------------------------------------------
INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1014h
	BX = bit mask from INT 15/AX=1013h
SeeAlso: AX=1013h,1015h
---------------------------------------------
INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS
	AX = 1015h
	BX = bit mask for interrupts to post
Return: indicated routines will be called: (DV 2.0x) at next task switch
					   (DV 2.2x) immediately
SeeAlso: AX=1013h,1014h
---------------------------------------------
INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE
	AX = 1016h
	ES:DI = possible object handle
Return: BX = FFFFh if ES:DI is a valid object handle
	     0000h if ES:DI is not
SeeAlso: AX=DE14h
---------------------------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AX = 1017h
Return: pops up "Programming error" window in DV 2.x
---------------------------------------------
INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION
	AX = 1018h
	BH = column
	BL = row
	ES = segment of object handle for window below which to search
	     0000h = start search with topmost window
Return: ES = segment of object handle for window which is visible at the
	     indicated position, or covered by indicated window
---------------------------------------------
INT 15 - TopView - "SOUND" - MAKE TONE
	AX = 1019h
	BX = frequency in Hertz
	CX = duration in clock ticks (18.2 ticks/sec)
Return: immediately, tone continues to completion
Notes:	if another tone is already playing, the new tone does not start until
	  completion of the previous one.  In DV 2.00, it is possible to enqueue
	  about 32 tones before the process is blocked until a note completes.
	in DV 2.00, the lowest tone allowed is 20 Hz
---------------------------------------------
INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK
	AX = 101Ah
Return: stack switched
SeeAlso: AX=1025h
---------------------------------------------
INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION
	AX = 101Bh
Return: task-switching temporarily disabled
Note:	will not task-switch until END CRITICAL REGION (AX = 101Ch) called
SeeAlso: AX=101Ch
---------------------------------------------
INT 15 - TopView - "ENDC" - END CRITICAL REGION
	AX = 101Ch
Return: task-switching enabled
SeeAlso: AX=101Bh
---------------------------------------------
INT 15 - TopView - "STOP" - STOP TASK
	AX = 101Dh
	ES = segment of object handle for task to be stopped
	     (== handle of main window for that task)
Return: indicated task will no longer get CPU time
Note:	at least in DV 2.00, this function is ignored unless the indicated task
	  is the current task.
SeeAlso: AX=101Eh,102Bh
---------------------------------------------
INT 15 - TopView - "START" - START TASK
	AX = 101Eh
	ES = segment of object handle for task to be started
	     (== handle of main window for that task)
Return: indicated task is started up again
SeeAlso: AX=101Dh,102Bh
---------------------------------------------
INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW
	AX = 101Fh
	BX = bit fields
	     bits 0-12: number of characters to display
	     bits 13,14: which mouse button may be pressed to remove window
			 00 = either
			 01 = left
			 10 = right
			 11 = either
	     bit 15: beep if 1
	DS:DI -> text of message
	CH = width of error window (0 = default)
	CL = height of error window (0 = default)
	DX = segment of object handle
Return: BX = status: 1 = left button, 2 = right, 27 = ESC pressed
Note:	window remains on-screen until ESC or indicated mouse button is pressed
---------------------------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.0x
	AX = 1020h
Return: pops up "Programming error" window in DV 2.0x
---------------------------------------------
INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK
	AX = 1021h
	BX = segment of object handle for task to interrupt
	DX:CX -> FAR routine to jump to next time task is run
Return: nothing
Note:	the current ES, DS, SI, DI, and BP are passed to the FAR routine
---------------------------------------------
INT 15 - TopView - "GETVER" - GET VERSION
	AX = 1022h
	BX = 0
Return: BX nonzero, TopView or compatible loaded
	(BL = major version, BH = minor version)
Notes:	TaskView returns BX = 0001h, DESQview 2.0 returns BX = 0A01h
---------------------------------------------
INT 15 - TopView - "POSWIN" - POSITION WINDOW
	AX = 1023h
	BX = segment of object handle for parent window within which to
	     position the window (0 = full screen)
	ES = segment of object handle for window to be positioned
	DL = bit flags
	     bits 0,1: horizontal position
		00 = current
		01 = center
		10 = left
		11 = right
	     bits 2,3: vertical position
		00 = current
		01 = center
		10 = top
		11 = bottom
	     bit 4: don't redraw screen if set
	     bits 5-7 not used
	CH = number of columns to offset from position specified by DL
	CL = number of rows to offset from position specified by DL
Return: nothing
---------------------------------------------
INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO
	AX = 1024h
	BX = segment of object handle for window
	      (0 = use default)
Return: ES:DI -> virtual screen
	CX = size of virtual screen in bytes
	DL = 00h text screen
	     01h graphics screen
SeeAlso: INT 10/AH=FEh
---------------------------------------------
INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK
	AX = 1025h
Return: stack switched back
Note:	call only after having switched to private stack
SeeAlso: AX=101Ah
---------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 26h thru 2Ah
Return: pops up "Programming error" window in DV 2.x
---------------------------------------------
INT 15 - DESQview 2.0 (TopView???) - "POSTTASK" - AWAKEN TASK
	AX = 102Bh
	BX = segment of object handle for task
Return: nothing
SeeAlso: AX=101Dh,101Eh
---------------------------------------------
INT 15 - DESQview 2.0 (TopView???) - START NEW APPLICATION IN NEW PROCESS
	AX = 102Ch
	ES:DI -> contents of .PIF/.DVP file (see below)
	BX = size of .PIF/.DVP info
Return: BX = segment of object handle for new task
	     0000h on error

Format of .PIF/.DVP file:
Offset	Size	Description
 00h	WORD	reserved (0)
 02h 30 BYTEs	program title (blank-padded)
 20h	WORD	maximum memory to allocate to partition in K
 22h	WORD	minimum memory required in K
 24h 64 BYTEs	ASCIZ program pathname
 64h    BYTE	default drive letter ('A',...)
 65h 64 BYTEs	ASCIZ default directory name
 A5h 64 BYTEs	ASCIZ program parameters
 E5h	BYTE	initial screen mode (0-7)
 E6h	BYTE	number of text pages used
 E7h	BYTE	number of first interrupt to save
 E8h	BYTE	number of last interrupt to save
 E9h	BYTE	rows in virtual screen buffer
 EAh	BYTE	columns in virtual screen buffer
 EBh	BYTE	initial window position, row
 ECh	BYTE	initial window position, column
 EDh	WORD	system memory in K
 EFh 64 BYTEs	ASCIZ shared program name
12Fh 64 BYTEs	ASCIZ shared program data file
16Fh    BYTE	flags1
		bit 7: writes text directly to screen
		bit 6: runs in foreground only
		bit 5: uses math coprocessor
		bit 4: accesses system keyboard buffer directly
		bits 3-1: reserved (0)
		bit 0: swappable
170h	BYTE	flags2
		bit 6: uses command-line parameters in field at A5h
		bit 5: swaps interrupt vectors
---information unique to .DVP files---
171h  2 BYTEs	keys to use on open menu
173h	WORD	size of script buffer in bytes
175h	WORD	automatically give up CPU after this many tests for keyboard
		input in one clock tick (0 = never)
177h	BYTE	nonzero = "uses own colors"
178h	BYTE	nonzero if application swappable
179h  3 BYTEs	reserved (0)
17Ch	BYTE	nonzero to automatically close on exit
17Dh	BYTE	nonzero if copy-protect floppy is required
---information unique to DESQview 2.0+---
17Eh	BYTE	.DVP version number
		00h DESQview 1.2+
		01h DESQview 2.0+
		02h DESQview 2.2+
17Fh	BYTE	reserved (0)
180h	BYTE	initial number of rows in physical window
181h	BYTE	initial number of columns in physical window
182h	WORD	maximum expanded memory to allow, in K
184h	BYTE	flags3
		bit 7: automatically assign window position
		bit 5: maximum memory value has been specified
		bit 4: disallow "Close" command
		bit 3: foreground-only when doing graphics
		bit 2: don't virtualize
185h	BYTE	keyboard conflict level (0-4)
186h	BYTE	number of graphics pages used
187h	WORD	extra system memory size
189h	BYTE	initial screen mode (FFh = default)
---information unique to DESQview 2.2+---
18Ah	BYTE	serial port usage
		FFh uses all serial ports
		00h no serial ports
		01h only COM1
		02h only COM2
18Bh	BYTE	flags4
		bit 7: automatically close application on exit if .COM or .EXE
			specified
		bit 6: swappable if not using serial ports
		bit 3: virtualize text
		bit 2: virtualize graphics
		bit 1: share CPU when foreground
		bit 0: share EGA when foreground and zoomed
18Ch	BYTE	protection level for 386 machines
18Dh 19 BYTEs	reserved (0)
---------------------------------------------
INT 15 - DESQview 2.0 - KEYBOARD MOUSE CONTROL
	AX = 102Dh
	BL = subfunction
	     00h determine whether using keyboard mouse
		Return: BL = 00h using real mouse
			     01h using keyboard mouse
	     01h turn keyboard mouse on
	     02h turn keyboard mouse off
---------------------------------------------
INT 15 - TopView commands
	AH = 11h
	AL = various
Note:	in DESQview 2.x, these function calls are identical to AH=DEh, so
	  see those below
SeeAlso: AH=DEh
---------------------------------------------
INT 15 - VMiX - EXECUTE SHELL SYSTEM COMMANDS
	AH = 11h
	STACK:	DWORD	pointer to ASCIZ string containing and VMiX shell
			request (max len = 127)
Return: AX = status
---------------------------------------------
INT 15 - DESQview 2.2 - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = 1117h
	BX = 0000h	get current mapping context without setting
	     nonzero	set new mapping context
Return: BX = mapping context in effect before call
Notes:	this function differs from AX = DE17h
	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	Caller need not be running under DESQview
---------------------------------------------
INT 15 - DESQview - XDV.COM - INSTALLATION CHECK
	AX = 11DEh
Return: CF clear if installed
	    AX = segment at which XDV is located
---------------------------------------------
INT 15 - VMiX - PUT PROCESS TO SLEEP
	AH = 12h
	STACK:	WORD	process ID
Return: AX = status
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE
	AH = 12h
	BH = 00h
	BL = which handle to return
	    00h handle in DWORD on top of stack
	    01h current task's window handle
	    02h given task's mailbox handle (task's handle on stack)
	    03h current task's mailbox handle
	    04h given task's keyboard handle (task's handle on stack)
	    05h current task's keyboard object handle
	    06h given task's OBJECTQ handle (task's handle on stack)
	    07h current task's OBJECTQ handle
	    08h   \
	      thru > return 0000:0000
	    10h   /
Return: DWORD on top of stack is object handle
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT
	AH = 12h
	BH = 01h
	BL = object
	    00h (DV 2.0x only) handle is DWORD on top of stack
	    01h (DV 2.0x only) use task's window handle
	    02h (DV 2.0x only) given task's mailbox (task's handle on stack)
	    03h (DV 2.0x only) current task's mailbox
	    04h (DV 2.0x only) given task's keyboard (task's handle on stack)
	    05h (DV 2.0x only) current task's keyboard object
	    08h WINDOW class
	    09h MAILBOX class
	    0Ah KEYBOARD class
	    0Bh TIMER object (counts down 32-bit time in 10ms increments)
	    0Fh POINTER object
	    10h PANEL object
	STACK: (if window object or WINDOW class)
	       DWORD address to jump to (no new task if high word == 0)
	       DWORD (reserved) 0 = non-task window, FFFFh = task window
	       DWORD bytes for task's private stack (FFFFh == default of 0100h)
	       DWORD bytes system memory allocation (0 == none, -1 == default)
	       DWORD window size, columns
	       DWORD window size, rows
	       DWORD length of window title
	       DWORD address of window title
Return: DWORD on top of stack is new object handle
Note:	if a new task is created, it is started with
	  AX = BX = CX = SI = DI = BP = 0
	  DX = segment of parent's object handle
	  DS = ES = SS = segment of private stack (and new task's handle)
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT
	AH = 12h
	BH = 02h
	BL = object
	    00h handle in DWORD on top of stack
		window: close window and free
		timer: free timer
		panel: free panel object
		pointer: free pointer
	    01h task's window handle - kills task, never returns
	    02h given task's mailbox (task's handle on top of stack)
	    03h current task's mailbox
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's keyboard object
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY
	AH = 12h
	BX = 0300h
	STACK: DWORD handle of panel object
Return: STACK: DWORD length of directory
	       DWORD address of directory

Format of panel file:
Offset	Size	Descriptoin
 00h  2 BYTEs	C0h C3h
 02h	BYTE	number of panels in file
 03h	for each panel in file:
	    8 BYTEs  blank-padded panel name
	      DWORD  panel offset in file
	      WORD   panel length
	data for panels (each consists of one or more window/query/manager
	streams)
	    first byte of each panel must be 1Bh, fifth byte must be E5h
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDR" - GET OBJECT HANDLE
	AH = 12h
	BH = 03h
	BL = object
	    00h handle in DWORD on top of stack
	    02h sender of last msg read from mailbox (task's handle on stack)
	    03h sender of last msg read from current task's mailbox
Return: DWORD on stack is handle
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - WAIT FOR TIMER TO EXPIRE
	AH = 12h
	BX = 0400h
	STACK: DWORD timer's handle
Return: STACK: DWORD time in 1/100 sec since midnight when timer expires
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD
	AH = 12h
	BH = 04h
	BL = object
	    00h handle is DWORD on top of stack
		window: read next logical line
		mailbox: wait for and get next message
		pointer: wait for and get next message
	    01h read the next logical line from task's default window
	    02h get next message from mailbox (task's handle on top of stack)
	    03h get next message from current task's mailbox
	    04h get the next input from keyboard (handle on top of stack)
	    05h get the next input from task's default keyboard
	    06h wait for input from any object in OBJECTQ (handle on stack)
	    07h wait for input from any object in task's default OBJECTQ
Return: STACK: (if objectq) DWORD handle of object with input
	       (otherwise)  DWORD number of bytes
			    DWORD address
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW
	AH = 12h
	BX = 0400h
	STACK: DWORD handle of panel object
	       DWORD window's handle or 0
	       DWORD length of panel name
	       DWORD pointer to panel name
Return: STACK: DWORD handle of created keyboard or 0
	       DWORD handle of window which was used
Notes:	status of APPLY may be checked with STATUS message
	panel MUST have the following format
	  first byte must be 1Bh (i.e. must start with a stream)
	  first opcode in stream must be E5h
	    single byte arg of opcode is interpreted thus:
	      bit 7  \	11 means create new window
	      bit 6  /	10 means create new field table for existing window
			01 means use existing window and field table
	      bit 5 if set, panel contains a field table 
			(creates a new keyboard and puts it in field mode)
	      bit 4 if set, panel contains input fields
	      bit 3 if set, panel contains select fields but no input fields
--------------------------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE TO OBJECT
	AH = 12h
	BH = 05h
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer to end at a specified time
		pointer: move pointer icon to specified position
	    02h send message by value/status=0 to mbox (task's handle on stack)
	    03h send message by value/status=0 to current task's mailbox
	    04h add input buffer to KEYBOARD queue (handle on top of stack)
	    05h add input buffer to task's default KEYBOARD queue
	    06h add an object to OBJECTQ (handle on top of stack)
	    07h add an object to task's default OBJECTQ
	STACK: (if mailbox)  DWORD length
			     DWORD address
	       (if keyboard) DWORD status (such as scan code)
			     DWORD length
			     DWORD address
	       (if objectq)  DWORD handle of object to add
	       (if timer)    DWORD 1/100ths seconds since midnight (actually
				   only accurate to 1/18 sec)
	       (if pointer)  DWORD column relative to origin of window
			     DWORD row relative to origin of window
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO WINDOW
	AH = 12h
	BH = 05h
	BL = object
	    00h DWORD on top of stack is window handle
	    01h write string to task's default window
	STACK: DWORD object handle if handle passed on stack
	       DWORD total length of string (high word == 0)
	       DWORD address of string to display
Return: indicated actions performed
	a. non-control characters are displayed
	b. CR/LF/BS/Tab cause the usual cursor movement
	c. ESC starts a data structure with additional commands
Note:	service routine will pop stack

Data Structure:
	MAGIC  DB  1Bh
	MODE   DB  ?   ; 00h, 01h, 10h, 14h-1Fh legal
	LENGTH DW  ?   ; length of remainder in bytes
	var-length fields follow, each an OPCODE followed by
	     zero or more args

MODE 00h (set or display values) "WINDOW STREAM"
    Opcodes:args
	00h  display 20h blanks with the default attribute
	01h-1Fh display OPCODE blanks with the default attribute
	20h  display char with default attribute 20h times
	     BYTE char to repeat
	21h-3Fh display char with default attribute OPCODE-20h times
	     BYTE char to repeat
	40h  display 20h blanks with specified attribute
	     BYTE attribute of blanks
	41h-5Fh display OPCODE-40h blanks with specified attribute
	     BYTE attribute of blanks
	60h  display next 20h characters
	     20h BYTES characters to display
	61h-7Fh display next OPCODE-60h characters
	     N BYTES characters to display
	80h-87h  display N blanks with default attribute
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	88h-8Fh display N copies of the character
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE character to repeat
	90h-97h  display N blanks with specified attribute
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE attribute
	98h-9FH  display string at logical cursor pos
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     N BYTES string to display
	A0h  set logical cursor row
	     BYTE row number (0 is top)
	A1h  set logical cursor column
	     BYTE column number (0 is leftmost)
	A2h  set top edge of scrolling region
	     BYTE row
	A3h  set left edge of scrolling region
	     BYTE column
	A4h  set row of physical window position
	     BYTE line
	A5h  set column of physical window position
	     BYTE column
	A6h  set height of physical window
	     BYTE #rows
	A7h  set width of physical window
	     BYTE #columns
	A8h  set viewport row
	     BYTE row
	A9h  set viewport column
	     BYTE column
	AAh  set virtual screen height
	     BYTE rows
	ABh  set virtual screen width
	     BYTE columns
	ACh-AEh  unused
	AFh  set compatible/preferred video modes
	     BYTE compatibility/preference mask
		bit 7	compatible with monochrome
		bit 6	compatible with color text, EGA/VGA graphics
		bit 5	compatible with medium-resolution CGA graphics
		bit 4	compatible with high-resolution CGA graphics
		bit 3	prefer monochrome
		bit 2	prefer color text, EGA/VGA graphics
		bit 1	prefer medium-resolution CGA graphics
		bit 0	prefer high-resolution CGA graphics
	B0h  move logical cursor down
	     BYTE #rows (signed, negative values move up)
	B1h  move logical cursor right
	     BYTE #cols (signed, negative values move left)
	B2h  shift top edge of scrolling region
	     BYTE #rows (signed)
	B3h  shift left edge of scrolling region
	     BYTE #cols (signed)
	B4h  shift window down
	     BYTE #lines (signed)
	B5h  shift window right
	     BYTE #columns (signed)
	B6h  expand physical window vertically
	     BYTE #lines (signed)
	B7h  expand physical window horizontally
	     BYTE #columns (signed)
	B8h  adjust viewport row
	     BYTE #rows (signed)
	B9h  adjust viewport column
	     BYTE #columns (signed)
	BAh  adjust virtual screen height
	     BYTE #rows to increase (signed)
	BBh  adjust virtual screen width
	     BYTE #cols to increase (signed)
	BCh-BFh  unused
	C0h  set logical cursor position
	     BYTE row number (0 is top border)
	     BYTE column number (0 is left border)
	C1h  set top left corner of scrolling region
	     BYTE row
	     BYTE column
	C2h  set window pos
	     BYTE upper left row (no top border if 0)
	     BYTE upper left column (no left border if 0)
	C3h  set current window size
	     BYTE #rows
	     BYTE #cols
	C4h  set upper left corner of viewport (portion of virtual screen
	     displayed in window)
	     BYTE row
	     BYTE column
	C5h  set size of virtual screen
	     BYTE #rows
	     BYTE #cols
	C6h  unused
	C7h  unused
	C8h  set logical cursor relative to current position
	     BYTE number of rows to move down (signed)
	     BYTE number of columns to move right (signed)
	C9h  shift top left corner of scrolling region
	     BYTE #rows (signed)
	     BYTE #cols (signed)
	CAh  set window pos relative to current position
	     BYTE number of rows to shift down (signed)
	     BYTE number of columns to shift right (signed)
	CBh  set window size relative to current size
	     BYTE number of rows to expand (signed)
	     BYTE number of cols to expand (signed)
	CCh  shift viewport relative to current position
	     BYTE rows to shift (signed)
	     BYTE cols to shift (signed)
	CDh  resize virtual screen
	     BYTE #rows to expand (signed)
	     BYTE #cols to expand (signed)
	CEh  scroll text when using E8h-EBh/F8h-FBh opcodes (default)
	CFh  scroll attributes when using  E8h-EBh/F8h-FBh opcodes
	D0h  allow window frame to extend beyond screen
	D1h  always display a complete frame, even if window extends beyond 
	     edge of screen
	D2h  allow DV to change colors on video mode switch (default)
	D3h  application changes colors
	D4h  window is visible
	D5h  window is hidden
	D6h  window has frame
	D7h  window unframed
	D8h  read characters from window (default)
	D9h  read attributes from window
	DAh  use logical attributes, which may be remapped
		attributes
		   1 normal text
		   2 highlighted normal text
		   3 help text
		   4 highlighted help text
		   5 error message
		   6 highlighted error message
		   7 emphasized text
		   8 marked text
		   9-16 are reverse video versions of 1-8
	DBh  use physical attributes for characters
	DCh  enable special actions for control characters (default)
	DDh  disable special control char handling, all chars displayable by
	     BIOS TTY call
	DEh  write both character and attribute (default)
	DFh  write character only, leave attribute untouched
	E0h  repeat following commands
	     BYTE number of times
	E1h  end of commands to repeat, start repeating them
	E2h  set color
	     BYTE color
	E3h  clear virtual screen
	E4h  redraw window
	E5h  select menu style
	     BYTE style
		bits 5,4 = 01 use two-letter menu entries for remainder of
		  this stream
	E5h  (panel file only)
	     BYTE modifier
		bits 7,6 = 11 panel goes in new window
			 = 01 panel uses existing window
		bit 5 = 1 create new keyboard in field mode
		bit 4 = 1 make newly-created keyboard active
		bit 3 reserved
		bit 2 = 1 stream defined exclusive input window (DV 2.2)
		bit 1 reserved
		bit 0 reserved
	E6h  create new window and perform rest of manipulations in new window
	     BYTE number of rows
	     BYTE number of columns
	     Return: DWORD object handle returned on stack at end
	E7h  unused
	E8h  scroll area up (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	E9h  scroll area down (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	EAh  scroll area left (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	EBh  scroll area right (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	ECh  set logical attributes for window contents
	     BYTE video modes command applies to
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	     BYTE which attributes to set
		bit 7  if set, copy single following byte to indicated attrs
		bits 4-6  # of first attribute to change - 1
		bits 0-3  # of consecutive attributes to change
	     N BYTEs new attributes
	EDh  set logical attributes for window frame
	     BYTE video modes command applies to (see opcode ECh)
	     BYTE which attributes to set
		bit 7  if set, copy single following byte to indicated attrs
		bits 4-6  # of first attribute to change - 1
		bits 0-3  # of consecutive attributes to change
	     N BYTEs new attributes
		  attributes
		       1 = top left corner
		       2 = top right corner
		       3 = bottom left corner
		       4 = bottom right corner
		       5 = top edge
		       6 = bottom edge
		       7 = left edge
		       8 = right edge
	EEh  set characters for window frame
	     BYTE video modes command applies to (see opcode ECh)
	     BYTE which characters to set
		bit 7  if set, copy single following byte to indicated chars
		bits 4-6  # of first char to change - 1
		bits 0-3  # of consecutive chars to change
	     N BYTEs new chars (same relative position as attributes above)
	EFh  set window name
	     BYTE length of name
	     N BYTEs name
	F0h  clear input field to blanks
	     BYTE field number
	F1h  fill input field with character
	     BYTE field number
	     BYTE char
	F2h  set color of input field
	     BYTE field number (1-N)
	     BYTE attribute
	F3h  set initial contents of input field
	     BYTE field number (1-N)
	     N BYTEs enough chars to exactly fill field as defined by op FFh
	F4h  position cursor to specific input field
	     BYTE field number (1-N)
	F5h  change field table entry
	     BYTE field number
	     7-8 BYTEs field table entry (see opcode FFh below)
	F6h  set field type
	     BYTE field number
	     BYTE type
	F7h  "broadcast write"  write data to fields with broadcast bit set
		in field table entry, in field number order
	     N BYTEs (total length of all program output fields)
	F8h  scroll field up a line
	     BYTE field number
	F9h  scroll field down a line
	     BYTE field number
	FAh  scroll field left
	     BYTE field number
	FBh  scroll field right
	     BYTE field number
	FCh  set field table header
	     BYTE number of fields
	     BYTE screen behavior bits
		bit 7  reserved
		bit 6  set if menu items may be selected via keyboard
		bit 5  set if left mouse button may terminate entry
		bit 4  set if right mouse button may terminate entry
		bit 3  if set, select fields return contents or blanks rather
			than 'Y' or 'N'
		bit 2  if set, modified bits reset on return to application
		bits 0,1 = 00 no data returned on read of keyboard
			   01 data returned as array of chars containing
				all fields packed together, with no field
				numbers
			   10 data returned as numbered variable-length
				records for all fields
			   11 data returned as numbered variable-length
				records for the fields which were modified
	     BYTE current input field (updated by DESQview)
	     BYTE current select field (updated by DESQview)
	     BYTE attribute for select fields when they are pointed at
	     BYTE attribute for select fields which have been selected
	FDh  reset modified bit for all fields
	FEh  reset selected and modified bits for all fields
	FFh  set up input fields
	     6 BYTEs table header (see opcode FCh above)
	     the field table entries, one for each field
		 BYTE start row    \
		 BYTE start column  \ if menu selection and start is to
		 BYTE end row	    / right or below end, select from kbd only
		 BYTE end column   /
		 BYTE field type
		    bits 7,6 = 00 inactive (non-entry) field
			       01 echos keystrokes input to make menu selection
			       10 fill-in field
			       11 select field
		    bit 5  field can be filled by broadcast write (F7h opcode)
		    bit 4  reserved
		    bit 3  reserved
		    bit 2  reserved
		    bit 1  set if field selected
		    bit 0  set if field modified
		 BYTE modifier
		      if type is fill-in, then bit flags to determine behavior
			  bit 7  if set, automatically enter CR when field full
			  bit 6  move to next field when current field is full
			  bit 5  if set, enter text from right end (for numbers)
			  bit 4  if set, force input to uppercase
			  bit 3  if set, clear old contents on first keystroke
			  bit 2  if set, input returned when cursor moves out
				 of modified field (API level 2.02+)
			  bit 1  reserved
			  bit 0  reserved
		      if select field, first key to press to activate
			  00h if have to point-&-click or is an extended-ASCII
			      keystroke (only if two-key menus enabled)
		 BYTE (select field only) normal color of field
		 BYTE second key for select field.  This byte is present iff
		      two-letter menu entries selected with opcode E5h, and
		      in that case is present regardless of field type
	     Note: DESQview uses and updates the actual copy of the information
	       which is contained in the stream.  Thus this info must remain
	       intact until after the data entry is complete.

MODE 01h "QUERY STREAM" (valid only for those opcodes listed here)
	A0h return logical cursor row in next byte
	A1h return logical cursor column in next byte
	A2h return top row of scrolling region in next byte
	A3h return left column of scrolling region in next byte
	A4h return row of physical window origin in next byte
	A5h return column of physical window origin in next byte
	A6h return height of physcial window in next byte
	A7h return width of physical window in next byte
	A8h return row of viewport origin in next byte
	A9h return column of viewport origin in next byte
	AAh return height of virtual screen in next byte
	ABh return width of virtual screen in next byte
	AFh return current video mode in next byte
	C0h return current logical cursor position in next two bytes
	C1h return top left corner of scrolling region in next two bytes
	C2h return current window position in next two bytes
	C3h return current window size in next two bytes
	C4h return current viewport origin in next two bytes
	C5h return current virtual screen size in next two bytes
	D0h \ overwritten with D0h if frames may fall off screen edge
	D1h /		       D1h if frames always displayed entirely
	D2h \ overwritten with D2h if DESQview controls color palette
	D3h /		       D3h if application changes color palette
	D4h \ overwritten with D4h if window visible
	D5h /		       D5h if window hidden
	D6h \ overwritten with D6h if window has frame
	D7h /		       D7h if window unframed
	D8h \ overwritten with D8h if reading characters from window
	D9h /		       D9h if reading attributes from window
	DAh \ overwritten with DAh if using logical attributes
	DBh /		       DBh if using physical attributes
	DCh \ overwritten with DCh if TTY control char interpretation on
	DDh /		       DDh if TTY control char interpretation off
	DEh \ overwritten with DEh if writing both characters and attributes
	DFh /		       DFh if leaving attributes untouched
	E2h return current color in next byte
	ECh get logical attributes for window contents
	    BYTE execute call if currently in specified video mode
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 # consecutive attributes
	    N BYTEs buffer to hold attributes
	EDh get logical attributes for window frame
	    BYTE execute call if currently in video mode (see opcode ECh)
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 # consecutive attributes
	    N BYTEs buffer to hold attributes
	EEh get characters for window frame
	    BYTE execute call if currently in video mode (see opcode ECh)
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first char to get - 1
		bits 0-3 # consecutive chars
	    N BYTEs buffer to hold chars
	EFh return current window name
	    BYTE    max length of returned name
	    N BYTEs buffer to hold window name
	F3h return contents of input field
	    BYTE field number
	    N BYTEs buffer to hold field contents (size exactly equal to field
		    size)
	F5h get field table entry
	    BYTE field number
	    7-8 BYTEs buffer to hold field table entry
	F6h get type of a field
	    BYTE field number
	    BYTE type
	FCh get field table header
	    6 BYTEs buffer to store header

MODE 10h "MANAGER STREAM" (valid only for opcodes listed here)
	00h allow window to be moved horizontally
	01h allow window to be moved vertically
	02h allow window to change width
	03h allow window to change height
	04h allow window to be scrolled horizontally
	05h allow window to be scrolled vertically
	06h allow "Close Window" menu selection
	07h allow window to be hidden
	08h allow "Mark" menu
	0Eh allow "Scissors" menu
	10h allow DESQview main menu to be popped up
	11h allow "Switch Windows" menu
	12h allow "Open Window" menu
	13h allow "Quit" menu selection
	20h-33h opposite of 00h-13h, disallow specified action
	40h notify if horizontal position of window changes
	41h notify if vertical position of window changes
	42h notify if width of window changes
	43h notify if height of window changes
	44h notify if window scrolled horizontally
	45h notify if window scrolled vertically
	46h notify if window is closed--program has to clean up and exit itself
	47h notify if window is hidden
	48h notify if "?" on main menu selected
	49h notify if pointer message sent to window
	4Ah notify if window is made active
	4Bh notify if window is switched away from
	4Ch notify if video mode changes
	4Dh notify if "Scissors" menu "Cut" option selected
	4Eh notify if "Scissors" menu "Copy" option selected
	4Fh notify if "Scissors" menu "Paste" option selected
	50h notify if DESQview main menu popped up
	51h notify if DESQview main menu popped down
	60h-71h  opposite of 40h-51h: don't notify on specified event
	84h attach window to parent task's window (both move together)
	85h detach window from parent task's window (may move independently)
	86h disable background operation
	87h enable running in background
	88h set minimum size of physical window
	    BYTE rows
	    BYTE columns
	89h set maximum size of physical window
	    BYTE rows
	    BYTE cols
	8Ah set primary asynchronous notification routine
	    DWORD address of routine, 0000h:0000h means none
		  on entry ES:DI = handle of window, DS:SI is 32-bit value set
		  by 8Bh opcode
			   mailbox contains message indicating event
			      Opcode
			       40h  horizontal movement
				   DWORD object handle of window
				   BYTE  new row
				   BYTE  new col
			       41h  vertical movement
				   DWORD object handle of window
				   BYTE  new row
				   BYTE  new col
			       42h  horizontal size change
				   DWORD object handle of window
				   BYTE  new rows
				   BYTE  new cols
			       43h  vertical size change
				   DWORD object handle of window
				   BYTE  new rows
				   BYTE  new cols
			       44h  scrolled horizontally
				   DWORD object handle of window
				   BYTE  mouse row within window
				   BYTE  mouse column within window
				   BYTE  field mouse is on, 0 if none
				   BYTE  amount moved: >0 right, <0 left, 0 done
			       45h  scrolled vertically
				   DWORD object hande of window
				   BYTE  mouse row within window
				   BYTE  mouse column within window
				   BYTE  field mouse is on, 0 if none
				   BYTE  amount moved: >0 down, <0 up, 0 done
			       46h  window closed
				   DWORD object handle of window
				   BYTE  mouse pointer row
				   BYTE  mouse pointer column
				   BYTE  field mouse is on, 0 if none
			       47h  window hidden
			       48h  Help for Program selected
				   DWORD object handle of window
				   BYTE  mouse pointer row
				   BYTE  mouse pointer column
				   BYTE  field mouse is on, 0 if none
			       49h  pointer message sent to window
			       4Ah  switched to window from another ("raise")
			       4Bh  switched away from the window ("lower")
			       4Ch  video mode changed
				   BYTE new video mode
			       4Dh  Scissors/cUt selected
				   DWORD object handle of window
				   BYTE  row of upper left corner
				   BYTE  column of upper left corner
				   BYTE  field number ul corner is in, 0=none
				   DWORD handle of orphaned window created to
					 hold data
				   BYTE  height of region
				   BYTE  width of region
			       4Eh  Scissors/Copy selected
				   DWORD object handle of window
				   BYTE  row of upper left corner
				   BYTE  column of upper left corner
				   BYTE  field number ul corner is in, 0=none
				   DWORD handle of orphaned window created to
					 hold data
				   BYTE  height of region
				   BYTE  width of region
			       4Fh  Scissors/Paste selected
				   DWORD object handle of window
				   BYTE  row of upper left corner
				   BYTE  column of upper left corner
				   BYTE  field number ul corner is in, 0=none
				   DWORD handle of orphaned window with data
				   BYTE  height of region
				   BYTE  width of region
			       50h  main menu popped up
			       51h  main menu popped down
		  routine should restore all registers before returning
	8Bh set async notification parameter
	    DWORD 32-bit value passed to async routine in DS:SI
	ACh (DV2.2) perform regular select field attribute processing
	ADh (DV2.2) protect attributes in selected field from being lost
	AEh make window default notify window for owning app (API level 2.00+)
	AFh set selected field marker character
	    BYTE character to display at left edge of selected fields
	BCh set standard field processing mode 
	BDh set alternate field processing mode (enables cursor pad for menus)
	BEh enables changing reverse logical attributes with ECh opcode
	BFh disables changing reverse logical attributes with ECh opcode
	C0h make current window topmost in system
	C1h force current process into foreground
	C2h make current window topmost in process
	C3h position mouse pointer relative to origin of current field
	    BYTE rows below upper left corner of field
	    BYTE columns to right of upper left corner of field
	C4h position mouse pointer relative to origin of given field
	    BYTE field number
	    BYTE rows below upper left corner of field
	    BYTE columns to right of upper left corner of field
	C5h hide current window
	C6h show windows for this process
	C7h hide all windows for this process
	C8h suspend process and hide all its windows
	C9h force current process into background
	CAh make current window bottom-most in process
	CBh cancel current window manager operation, remove DV menu, give 
	    control to topmost application
	CCh close window
	CEh reorder windows
	    DWORD pointer to null-terminated list of words
		  each word is segment of object handle for a window

MODES 14h to 1Fh "USER STREAMS"
	normally NOPs, but may be defined by SETESC message to invoke FAR
	routines, one for each mode number
	  on entry to handler,
		DS:SI = first byte of actual stream (not header)
		CX = #bytes in stream
		ES:DI = window's handle
---------------------------------------------
INT 15 - DESQview 2.2 - SEND MESSAGE - SET PRIORITY
	AH = 12h
	BH = 06h
	BL = object
	    00h object handle in DWORD on top of stack
	STACK: DWORD new priority of object in task's OBJECTQ 
---------------------------------------------
INT 15 - DESQview 2.2 - SEND MESSAGE - GET PRIORITY
	AH = 12h
	BH = 07h
	BL = object
	    00h object handle in DWORD on top of stack
Return: STACK: DWORD object priority
Note:	initially all objects have the same default value.  Should make 
	relative adjustments to this default value.
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE
	AH = 12h
	BH = 08h
	BL = object
	    00h handle in DWORD on top of stack
		timer: elapsed time since timer started
		pointer: number of messages queued to pointer object
		panel: number of panels in panel file
	    01h total chars in current task's default window
	    02h number of messages in task's mailbox (task's handle on stack)
	    03h number of messages in current task's mailbox
	    04h number of input buffers queued in task's kbd (handle on stack)
	    05h number of input buffers queued for current task's default kbd
	    06h number of objects queued in OBJECTQ (task's handle on stack)
	    07h number of objects queued in current task's OBJECTQ
Return: DWORD on stack is result
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH
	AH = 12h
	BH = 09h
	BL = object
	    00h handle in DWORD on top of stack
		window: chars/line
		timer: timer remaining before timer expires
	    01h number of chars/line in current task's default window
Return: DWORD on top of stack is length
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS
	AH = 12h
	BH = 0Ah
	BL = object
	    00h handle is DWORD on top of stack
		window: write characters and attributes
		timer: start timer for specified interval
		pointer: set control flags
	    01h write characters and attributes to task's default window
	    02h send message/status by value to mailbox (task's handle on stack)
	    03h send message/status by value to current task's default mailbox
	    04h set control flags on KEYBOARD object (handle on top of stack)
	    05h set control flags on task's default KEYBOARD object
	STACK: (if mailbox) DWORD status
			    DWORD length of message
			    DWORD address
	       (if timer)   DWORD duration in 1/100 seconds
	       (if window)  DWORD count of characters
			    DWORD address of characters
			    DWORD count of attributes
			    DWORD address of attributes
	       (otherwise)  DWORD bits to set
For keyboard objects, the bits have the following significance:
	bit 15 reserved, can't be set
	bit 14 unused
	bit 13 reserved, can't be set
	bit 12-5 unused
	bit 4  filter all keys (used with handler established by SETESC)
	bit 3  program continues executing while input in progress
	bit 2  insert mode active
	bit 1  keyboard is active
	bit 0  keyboard is in field mode
For pointer objects, the bits have the following significance:
	bit 15 reserved, can't be set
	bit 14-8 unused
	bit 7  mouse pointer is hidden while in window
	bit 6  get messages even if window not topmost
	bit 5  get messages even if window not foreground
	bit 4  mouse button must be held 1/2 second before it "clicks"
	bit 3  pointer position is relative to screen origin, not window origin
	bit 2  send message on button release as well as button press
	bit 1  unused???
	bit 0  send message only on button activity, not movement
	       DV-specific, and INT 15h/AX=DE0Fh must have been called first
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS
	AH = 12h
	BH = 0Bh
	BL = object
	    00h handle is DWORD on top of stack
		window:  write attributes only
		mailbox: send message by reference
		pointer: reset control flags
	    01h write attributes only to task's default window
	    02h send msg/status by reference to mailbox (task's handle on stack)
	    03h send msg/status by reference to current task's mailbox
	    04h clear control flags on KEYBOARD object (handle on top of stack)
	    05h clear control flags on task's default KEYBOARD object
	    06h remove specific object from OBJECTQ (task's handle on stack)
	    07h remove specific object from task's default OBJECTQ
	STACK: (if mailbox) DWORD status
			    DWORD length
			    DWORD address
	       (if window)  DWORD number of attributes to write
			    DWORD address of attributes
	       (if objectq) DWORD handle of object to remove
	       (otherwise)  DWORD indicates which bits to clear
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT
	AH = 12h
	BH = 0Ch
	BL = object
	    00h handle is DWORD on top of stack
		window:   fill with given character
		keyboard: attach to a window
		timer:	  open
		pointer:  start taking input for window
		panel:	  associate with a panel file
	    01h fill task's default window with given character
	    02h open given task's mailbox for input (task's handle on stack)
	    03h open current task's mailbox
	    04h attach a KEYBOARD to a window (handle on top of stack)
	    05h attach task's default KEYBOARD to a window
	    06h open a task's OBJECTQ (task's handle on top of stack)
	    07h open current task's OBJECTQ
	 STACK: (if window)   DWORD character to fill with
		(if keyboard) DWORD handle of window to attach to
		(if pointer)  DWORD handle of window to attach to
		(if panel)    DWORD length of filename
			      DWORD address of filename
		(otherwise)   nothing
Notes: special action taken if first byte of panel file name is 1Bh
       if first two bytes of panel file "name" are C0hC3h, then the "name" IS
         the panel file
       result code of open may be retrieved with STATUS message
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT
	AH = 12h
	BH = 0Dh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	  close
		keyboard: detach from window
		pointer:  stop taking input
		panel:	  close
	    02h close given task's mailbox (task's handle on top of stack)
	    03h close task's default mailbox
	    04h close KEYBOARD object (handle on top of stack)
	    05h close task's default KEYBOARD
	    06h close givent task's OBJECTQ (task's handle on top of stack)
	    07h close current task's OBJECTQ
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT
	AH = 12h
	BH = 0Eh
	BL = object
	    00h handle is DWORD on top of stack
		window:   clear
		keyboard: discard input
		timer:	  cancel current interval
		pointer:  discard all pending messages
	    01h clear task's default window
	    02h discard all queued messages in mailbox (handle on top of stack)
	    03h discard all queued messages in current task's default mailbox
	    04h discard all input queued to KEYBOARD (handle on top of stack)
	    05h discard all input queued to task's default KEYBOARD
	    06h remove all objects from OBJECTQ (task's handle on top of stack)
	    07h remove all objects from current task's OBJECTQ
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS
	AH = 12h
	BH = 0Fh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	 is it running?
		pointer: return status of last message
		panel:	 verify success of last OPEN or APPLY
	    02h return status of last msg READ from mailbox (handle on stack)
	    03h return status of last msg READ from task's default mailbox
	    04h get status of last msg from task's KEYBOARD (task handle on stk)
	    05h get status of last msg from task's default KEYBOARD
	    06h return whether OBJECTQ is open or not (handle on top of stack)
	    07h return whether task's default OBJECTQ is open or not
Return: DWORD on top of stack is status
Note:	if object is a panel object, the status indicates the error code:
	  14h panel name not in panel directory
	  15h not enough memory to apply panel
	  16h invalid panel format
	  17h panel file already open
	  81h-92h  DOS error codes+80h
	  95h not enough memory to open panel file
	  98h null panel file name
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS
	AH = 12h
	BH = 10h
	BL = object
	    00h handle is DWORD on top of stack
	    01h returns TRUE if logical cursor past end of task's def window
	    02h return ??? for task's mailbox (task's handle on top of stack)
	    03h return ??? for current task's mailbox
Return: DWORD on top of stack is status
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR
	AH = 12h
	BH = 11h
	BL = object
	    00h window's handle is DWORD on top of stack
	    01h position logical cursor on task's default window
	STACK: DWORD column
	       DWORD row
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETNAME" - ASSIGN NAME TO MAILBOX
	AH = 12h
	BH = 11h
	BL = mailbox to name
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD length of name
	       DWORD address of name
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR
	AH = 12h
	BX = 1100h
	STACK: DWORD object handle for pointer object
	       DWORD number of colums to scale pointer position to
	       DWORD number of rows to scale pointer position to
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES
	AH = 12h
	BH = 12h
	BL = object
	    00h handle is DWORD on top of stack
	    01h read next N chars/attributes on task's default window
	STACK: DWORD count
Return: STACK: DWORD width of screen line
	       DWORD address
	       DWORD count actually read
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR
	AH = 12h
	BX = 1200h
	STACK: DWORD object handle for pointer
Return: STACK: DWORD pointer pos scaled as if window were this many colums wide
	       DWORD pointer pos scaled as if window were this many rows high
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW
	AH = 12h
	BH = 13h
	BL = window object
	    00h DWORD on top of stack is handle for window to redraw
	    01h redraw task's default window
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON
	AH = 12h
	BX = 1300h
	STACK: DWORD object handle for pointer
	       DWORD character to use for pointer
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS
	AH = 12h
	BH = 14h
	BL = message modifier
	    00h handle is DWORD on top of stack
	    01h define user stream
	    04h intercept keystrokes from KEYBOARD to a window (handle on stack)
	    05h intercept keystrokes from task's default KEYBOARD to a window
	STACK: (if window)   DWORD user stream number (14h-1Fh)
			     DWORD address of FAR user stream handler
	       (if keyboard) DWORD address of FAR filter function

The keyboard filter function is called when the keyboard is in field mode.  On
entry,
	AL = character
	AH = 00h or extended ASCII code if AL = 00h
	BL = field number
	CH = cursor column
	CL = cursor row
	DL = field type modifier (sixth item in field table entry)
	DH = ??? (seventh item in field table entry)
	ES:SI = window's handle
(also, in DV 2.00, DS:DI points to the field table entry.  This may change in
 other versions)
The filter function should return
	AH = 00h use keystroke
	     01h ignore keystroke
	     >1 beep and ignore keystroke
---------------------------------------------
INT 15 - TopView - SEND MESSAGE - "LOCK" - REQUEST EXCLUSIVE ACCESS TO RESOURCE
	AH = 12h
	BH = 14h
	BL = object
	    00h mailbox handle is DWORD on top of stack
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
Note:	release exclusive access by sending CLOSE message to mailbox
	access may be requested multiple times, and requires multiple CLOSEs
---------------------------------------------
INT 15 - DESQview 2.2 - SEND MESSAGE - SET FLAGS
	AH = 12h
	BH = 15h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
	STACK: DWORD flags
		if mailbox:
			bit 0: all mail messages in common memory
			bit 1: allow write even if closed
			bit 2: don't erase messages when mailbox closed
		if keyboard:
			bit 5: exclusive input when keyboard in use for input
Return: nothing
Note:	this call is only available if the API level has been set to at least
	  2.2
---------------------------------------------
INT 15 - DESQview 2.2 - SEND MESSAGE - GET FLAGS
	AH = 12h 
	BH = 16h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
Return: STACK: DWORD current control flags
Note:	this call is only available if the API level has been set to at least
	  2.2
---------------------------------------------
INT 15 - VMiX - WAKE PROCESS
	AH = 13h
	STACK:	WORD	process ID
Return: AX = status
---------------------------------------------
INT 15 - VMiX - CLEAR WINDOW
	AH = 14h
	STACK:	WORD	top left corner of window
		WORD	bottom right corner of window
Return: AX = status
---------------------------------------------
INT 15 - VMiX - SET BANNER WINDOW MESSAGE
	AH = 15h
	STACK:	DWORD	pointer to ASCIZ banner	message
Return: AX = status
---------------------------------------------
INT 15 - VMiX - SET ROOT WINDOW SIZE AND HOME CURSOR
	AH = 16h
	STACK:	DWORD	pointer to I/O Request Packet
		WORD	top left corner of window
		WORD	bottom right corner of window
Return: AX = status
---------------------------------------------
INT 15 - VMiX - GET CONSOLE WINDOW COLORS
	AH = 17h
Return: AH = foreground color
	AL = background color
---------------------------------------------
INT 15 - VMiX - SET CONSOLE COLORS
	AH = 18h
	STACK:	WORD	new background/foreground colors
Return: AX = color
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 19h
	STACK: WORD ???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Ah
	STACK: 3 WORDs ???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Bh
	STACK: 5 WORDs ???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Ch
	STACK: 5 WORDs ???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Dh
	???
Return: ???
---------------------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Eh
	STACK: WORD ???
Return: ???
---------------------------------------------
INT 15 - DOS 3.10 PRINT.COM - DISABLE CRITICAL REGION FLAG (AT,XT286,PS50+)
	AX = 2000h
---------------------------------------------
INT 15 - DOS 3.10 PRINT.COM - SET CRITICAL REGION FLAG (AT,XT286,PS50+)
	AX = 2001h
	ES:BX -> byte which is to be incremented while in a DOS call
---------------------------------------------
INT 15 - OS HOOK - SETUP SYSREQ ROUTINE (AT,XT286,PS50+)
	AX = 2010h
	???
Return: ???
---------------------------------------------
INT 15 - OS HOOK - COMPLETION OF SYSREQ FUNCTION (AT,XT286,PS50+)
	AX = 2011h
	???
Return: ???
---------------------------------------------
INT 15 - SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)
	AH = 21h
	AL = subfunction
	    00h read POST log
	    01h write POST log
		BH = device ID
		BL = error code
Return: CF set on error
	AH = status (00h OK, 01h list full, 80h invalid cmd, 86h unsupported)
	if function 00h:
	   BX = number of error codes stored
	   ES:DI -> error log
Note:	the log is a series of words, the first byte of which identifies the
	  error code and the second the device.
---------------------------------------------
INT 15 - SYSTEM - READ/MODIFY PROFILES (CONVERTIBLE)
	AH = 40h
	AL = subfunction
	    00h get system profile in CX and BX
	    01h set system profile from CX and BX
	    02h get internal modem profile in BX
	    03h set internal modem profile from BX
---------------------------------------------
INT 15 - SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
	AH = 41h
	AL = condition type
	    bits 0-2: condition to wait for
		     0 any external event
		     1 compare and return if equal
		     2 compare and return if not equal
		     3 test and return if not zero
		     4 test and return if zero
	    bit 3:    reserved
	    bit 4:    1=port address, 0=user byte
	    bits 5-7: reserved
	BH = condition compare or mask value
	BL = timeout value times 55 milliseconds
	    00h means no timeout
	DX = I/O port address if AL bit 4 set
	ES:DI -> user byte if AL bit 4 clear
---------------------------------------------
INT 15 - SYSTEM - REQUEST POWER OFF (CONVERTIBLE)
	AH = 42h
	AL = 00h to use system profile
	     01h to force suspend regardless of system profile
---------------------------------------------
INT 15 - SYSTEM - READ SYSTEM STATUS (CONVERTIBLE)
	AH = 43h
Return: AL = status bits
	    bit 0: LCD detached
	    bit 1: reserved
	    bit 2: RS232/parallel adapter powered on
	    bit 3: internal modem powered on
	    bit 4: power activated by alarm
	    bit 5: standby power lost
	    bit 6: external power in use
	    bit 7: power low
---------------------------------------------
INT 15 - SYSTEM - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)
	AH = 44h
	AL = 00h to power off
	     01h to power on
---------------------------------------------
INT 15 - OS HOOK - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)
	AH = 4Fh
	AL = scan code
	CF set
Return: CF set
	   AL = scan code
	CF clear
	   scan code should be ignored
Note:	called by INT 9 handler to translate scan codes
---------------------------------------------
INT 15 - OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)
	AH = 80h
	BX = device ID
	CX = process type
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
SeeAlso: AH=81h,82h
---------------------------------------------
INT 15 - OS HOOK - DEVICE CLOSE (AT,XT2,XT286,PS)
	AH = 81h
	BX = device ID
	CX = process type
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
SeeAlso: AH=80h,82h
---------------------------------------------
INT 15 - OS HOOK - DEVICE PROGRAM TERMINATE (AT,XT2,XT286,PS)
	AH = 82h
	BX = device ID
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
Note:	closes all devices opened with function 80h
SeeAlso: AH=80h,81h
---------------------------------------------
INT 15 - SYSTEM - EVENT WAIT (AT,XT286,CONV,PS)
	AH = 83h
	AL = subservice
	    00h = set interval
	    01h = cancel
	ES:BX -> event flag (bit 7 set when interval expires)
	CX:DX = number of microseconds to wait (only accurate to 977 us)
Return: CF set if function already busy
SeeAlso: AH=86h
---------------------------------------------
INT 15 - SYSTEM - READ JOYSTICK (AT,XT2,XT286,PS)
	AH = 84h
	DX = subservice
	    0000h get switch settings
		Return: AL = switch settings (bits 7-4)
	    0001h read joystick inputs
		Return: AX = A(x) value
			BX = A(y) value
			CX = B(x) value
			DX = B(y) value
---------------------------------------------
INT 15 - OS HOOK - SYSTEM REQUEST KEY PRESSED (AT,XT2,XT286,CONV,PS)
	AH = 85h
	AL = 00h press
	   = 01h release
Return: CF set on error
	AH = status
Note:	called by keyboard decode routine
SeeAlso: INT 09
---------------------------------------------
INT 15 - SYSTEM - WAIT (AT,XT2,XT286,CONV,PS)
	AH = 86h
	CX,DX = number of microseconds to wait (only accurate to 977 us)
Return: CF clear: after wait elapses
	CF set: immediately due to error
SeeAlso: AH=83h
---------------------------------------------
INT 15 - EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
	AH = 87h
	CX = number of words to move
	ES:SI -> global descriptor table (see below)
Return: CF set on error
	AH = status
	    00h source copied into destination
	    01h parity error
	    02h interrupt error
	    03h address line 20 gating failed
SeeAlso: AH=88h

Format of global descriptor table:
Offset	Size	Description
 00h 16 BYTEs	zeros
 10h	WORD	source segment length in bytes (2*CX-1 or greater)
 12h  3 BYTEs	24-bit linear source address, low byte first
 15h	BYTE	source segment access rights (93h)
 16h	WORD	zero
 18h	WORD	destination segment length in bytes (2*CX-1 or greater)
 1Ah  3 BYTEs	24-bit linear destination address, low byte first
 1Dh	BYTE	destination segment access rights (93h)
 1Eh 18 BYTEs	zeros
---------------------------------------------
INT 15 - EXTENDED MEMORY - GET MEMORY SIZE (AT,XT286,PS)
	AH = 88h
Return: AX = memory size in K
SeeAlso: AH=87h
---------------------------------------------
INT 15 - SYSTEM - SWITCH TO VIRTUAL MODE (AT,XT286,PS50+)
	AH = 89h
	BL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)
	BH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)
	DS:SI -> GDT for protected mode
	       offset 0h  null descriptor
		      8h  GDT descriptor
		     10h  IDT descriptor
		     18h  DS
		     20h  ES
		     28h  SS
		     30h  CS
		     38h  uninitialized, used to build descriptor for BIOS CS
	CX = offset into protected-mode CS to jump to
Return: CF set on error
	   AH = 0FFh  error enabling address line 20
---------------------------------------------
INT 15 - OS HOOK - DEVICE BUSY LOOP (AT,XT2,XT286,CONV,PS)
	AH = 90h
	AL = type code
	    00h disk
	    01h diskette
	    02h keyboard
	    03h PS/2 pointing device
	    80h network
	    FCh disk reset
	    FDh diskette motor start
	    FEh printer
	ES:BX -> request block for type codes 80h through BFh
Return: CF set if wait time satisfied
	CF clear if driver must perform wait
Note:	type codes are allocated as follows:
	  00-7F non-reentrant devices; OS must arbitrate access
	  80-BF reentrant devices; ES:BX points to a unique control block
	  C0-FF wait-only calls, no complementary INT 15/AH=91h call
SeeAlso: AH=91h
---------------------------------------------
INT 15 - OS HOOK - SET FLAG AND COMPLETE INTERRUPT (AT,XT2,XT286,CONV,PS)
	AH = 91h
	AL = type code (see AH=90h)
	ES:BX -> request block for type codes 80h through BFh
Return: AH = 00h
SeeAlso: AH=90h
---------------------------------------------
INT 15 - SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
	AH = C0h
Return: CF set if BIOS doesn't support call
	CF clear on success
	    ES:BX -> ROM table (see below)
Note:	the 1/10/86 XT BIOS returns an incorrect value for the feature byte

Format of ROM configuration table:
Offset	Size	Description
 00h	WORD	number of bytes following
 02h	BYTE	model: PC=FFh, XT=FEh or FBh, PCjr = FDh, PS/2=F8h
 03h	BYTE	submodel: distingushes between AT and XT/286, etc.
 04h	BYTE	BIOS revision: 0 for first release, 1 for 2nd, etc.
 05h	BYTE	features:
		bit 7 = DMA channel 3 used by hard disk BIOS
		bit 6 = 2nd 8259 installed
		bit 5 = Real-Time Clock installed
		bit 4 = INT 15h/AH=4Fh called upon INT 9h
		bit 3 = wait for external event supported
		bit 2 = extended BIOS area allocated at 640K
		bit 1 = bus is Micro Channel instead of ISA
		bit 0 reserved
 06h	WORD	reserved (0)
 08h	WORD	reserved (0)
 0Ah		AWARD copyright notice here
---------------------------------------------
INT 15 - SYSTEM - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)
	AH = C1h
Return: CF set on error
	CF clear if successful
	    ES = segment of data area
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - ENABLE/DISABLE
	AX = C200h
	BH = 00h disable
	     01h enable
Return: CF set on error
	AH = status
	    00h successful
	    01h invalid function
	    02h invalid input
	    03h interface error
	    04h need to resend
	    05h no device handler installed
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - RESET
	AX = C201h
Return: CF set on error
 	    AH = status (see AX=C200h)
	CF clear if successful
	    BH = device ID
SeeAlso: INT 33/AX=0000h
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET SAMPLING RATE
	AX = C202h
	BH = sampling rate
	    00h 10/second
	    01h 20/second
	    02h 40/second
	    03h 60/second
	    04h 80/second
	    05h 100/second
	    06h 200/second
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: INT 33/AX=001Ch
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET RESOLUTION
	AX = C203h
	BH = resolution
	    00h one count per mm
	    01h two counts per mm
	    02h four counts per mm
	    03h eight counts per mm
Return: CF set on error
	    AH = status (see AX=C200h)
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET TYPE
	AX = C204h
Return: CF set on error
	    AH = status (see AX=C200h)
	CF clear if successful
	    BH = device ID
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - INITIALIZE
	AX = C205h
	BH = data package size (1 - 8 bytes)
Return: CF set on error
	    AH = status (see AX=C200h)
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET/SET SCALING FACTOR
	AX = C206h
	BH = subfunction
	    00h return device status
		Return: BL = status
			   bit 0: right button pressed
			   bit 1: reserved
			   bit 2: left button pressed
			   bit 3: reserved
			   bit 4: 0 if 1:1 scaling, 1 if 2:1 scaling
			   bit 5: device enabled
			   bit 6: 0 if stream mode, 1 if remote mode
			   bit 7: reserved
			CL = resolution (see AX=C203h)
  			DL = sample rate, reports per second
	    01h set scaling at 1:1
 	    02h set scaling at 2:1
Return: CF set on error
	    AH = status (see AX=C200h)
---------------------------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET DEVICE HANDLER ADDR
	AX = C207h
	ES:BX = user device handler
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: INT 33/AX=000Ch
--------------------------------------------
INT 15 - SYSTEM - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)
	AH = C3h
	AL = 00h disable
	     01h enable
		BX = timer counter
Return: CF set on error
Note:	the watchdog timer generates an NMI
---------------------------------------------
INT 15 - SYSTEM - PROGRAMMABLE OPTION SELECT (PS50+)
	AH = C4h
	AL = 00h return base POS register address
	     01h enable slot
		 BL = slot number
	     02h enable adapter
Return: CF set on error
	DX = base POS register address (if function 00h)
---------------------------------------------
INT 15 - DESQview - GET PROGRAM NAME
	AX = DE00h
Return: AX = offset into DESQVIEW.DVO of current program's record (see below)
SeeAlso: AX=DE07h

Format of program entry in DESQVIEW.DVO:
Offset	Size	Description
 00h	BYTE	length of name
 01h  N BYTEs	name
      2 BYTEs	keys to invoke program (second = 00h if only one key used)
	WORD	??? seems always to be 0000h
	BYTE	end flag: 00h for all but last entry, which is FFh
---------------------------------------------
INT 15 - DESQview - UPDATE "OPEN WINDOW" MENU
	AX = DE01h
Return: nothing
Note:	reads DESQVIEW.DVO, disables Open menu if file not in current directory
---------------------------------------------
INT 15 - DESQview 1.x only - SET ??? FLAG FOR CURRENT WINDOW
	AX = DE02h
Return: nothing
Note:	this call is a NOP in DV 2.x
---------------------------------------------
INT 15 - DESQview 1.x only - GET ??? FOR CURRENT WINDOW
	AX = DE03h
Return: AX = ??? for current window
	BX = ??? for current window
Note:	this call is a NOP in DV 2.x
---------------------------------------------
INT 15 - DESQview - GET AVAILABLE COMMON MEMORY
	AX = DE04h
Return: BX = bytes of common memory available
	CX = largest block available
	DX = total common memory in bytes
SeeAlso: AX=DE05h,DE06h
---------------------------------------------
INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY
	AX = DE05h
Return: BX = K of memory available
	CX = largest block available
	DX = total conventional memory in K
SeeAlso: AX=DE04h,DE06h
---------------------------------------------
INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY
	AX = DE06h
Return: BX = K of expanded memory available
	CX = largest block available
	DX = total expanded memory in K
SeeAlso: AX=DE04h,DE05h
---------------------------------------------
INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER
	AX = DE07h
Return: AX = number of program as it appears on the "Switch Windows" menu
SeeAlso: AX=DE00h
---------------------------------------------
INT 15 - DESQview - GET ???
	AX = DE08h
Return: AX = 0000h if ??? is not set to the current task
	     0001h if ??? is set to the current task
---------------------------------------------
INT 15 - DESQview - UNIMPLEMENTED
	AX = DE09h
Return: nothing (NOP in DV 1.x and 2.x)
---------------------------------------------
INT 15 - DESQview 2.x - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE
	AX = DE0Ah
	BL = character
Return: character displayed, next call will display in next position (which
	wraps back to the start of the line if off the right edge of screen)
Notes:	displays character on bottom line of *physical* screen, regardless
	  of current size of window (even entirely hidden)
	does not know about graphics display modes, just pokes the characters
	  into display memory
SeeAlso: AX=1003h
---------------------------------------------
INT 15 - DESQview 2.x - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED
	AX = DE0Bh
	BL = API level major version number
	BH = API level minor version number
Return: AX = maximum API level (AL = major, AH = minor)
Note:	if the requested API level is greater than the version of DESQview, a
	"You need a newer version" error window is popped up
---------------------------------------------
INT 15 - DESQview 2.x - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = DE0Ch
	BX = number of bytes
Return: ES:DI -> allocated block
SeeAlso: AX=1001h,DE0Dh
---------------------------------------------
INT 15 - DESQview 2.x - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = DE0Dh
	ES:DI -> previously allocated block
Return: nothing
SeeAlso: AX=1002h,DE0Ch
---------------------------------------------
INT 15 - DESQview 2.x - FIND MAILBOX BY NAME
	AX = DE0Eh
	ES:DI -> name to find
	CX = length of name
Return: BX = 0000h not found
	     0001h found
		DS:SI = object handle
---------------------------------------------
INT 15 - DESQview 2.x - ENABLE DESQview EXTENSIONS
	AX = DE0Fh
Return: AX and BX destroyed (seems to be bug, weren't saved&restored)
Notes:	sends a manager stream with opcodes AEh, BDh, and BFh to task's window
	enables an additional mouse mode
---------------------------------------------
INT 15 - DESQview 2.x - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM
	AX = DE10h
	BH = scan code
	BL = character
Return: nothing
Note:	a later read will get the keystroke as if it had been typed by the user
	early copies of DV 2.00 destroy AX, BX, ES, and DI
---------------------------------------------
INT 15 - DESQview 2.x - ENABLE/DISABLE AUTOMATIC JUSTIFICATION OF WINDOW
	AX = DE11h
	BL = 00h      viewport will not move automatically
	     nonzero  viewport will move to keep cursor visible
Return: nothing
---------------------------------------------
INT 15 - DESQview 2.01+ - SET ???
	AX = DE12h
	BX = 0000h    clear ??? flag
	     nonzero  set ??? flag
Return: nothing
---------------------------------------------
INT 15 - DESQview 2.2 - GET CRITICAL NESTING COUNT
	AX = DE13h
Return: BX = number of calls to BEGINC (see INT 15/AX=101Bh) without matching
	     ENDC (see INT 15/AX=101Ch)
---------------------------------------------
INT 15 - DESQview 2.2 - GET OBJECT TYPE
	AX = DE14h
	ES:DI -> object
Return: BL = 00h not an object
	     08h window or task
	     09h mailbox
	     0Ah keyboard
	     0Bh timer
	     0Ch objectq
	     0Fh pointer
	     10h panel
SeeAlso: AX=1016h
---------------------------------------------
INT 15 - DESQview 2.2 - SET MAILBOX ERROR HANDLING
	AX = DE15h
	BL = 00h post system error on conditions listed below
	     01h return carry flag set on calls to ADDTO, SUBFROM, and WRITE
		 messages sent to mailboxes which fail due to lack of system
		 or common memory
Return: nothing
---------------------------------------------
INT 15 - DESQview 2.2 - GET MAILBOX ERROR HANDLING
	AX = DE16h
Return: BL = 00h post system error
	     01h return carry flag set
---------------------------------------------
INT 15 - DESQview 2.2 - reserved
	AX = DE17h
Return: pops up "Programming error" window
Note:	AX = 1117h is NOT identical to this call
---------------------------------------------
INT 15 - DESQview 2.2 - ???
	AX = DE18h
Note:	calls video driver (NOP for Hercules driver)
---------------------------------------------
INT 16 - KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
	AH = 00h
Return: AH = scan code
	AL = character
Note:	on extended keyboards, this function discards any extended keystrokes,
	  returning only when a non-extended keystroke is available
SeeAlso: AH=10h
---------------------------------------------
INT 16 - KEYBOARD - CHECK BUFFER, DO NOT CLEAR
	AH = 01h
Return: ZF clear if character in buffer
	    AH = scan code
	    AL = character
	ZF set if no character in buffer
SeeAlso: AH=11h
---------------------------------------------
INT 16 - KEYBOARD - GET SHIFT STATUS
	AH = 02h
	AL = shift status bits
	    0 = right shift key depressed
	    1 = left shift key depressed
	    2 = CTRL depressed
	    3 = ALT depressed
	    4 = SCROLL LOCK active
	    5 = NUM LOCK active
	    6 = CAPS LOCK active
	    7 = INSERT state active
SeeAlso: AH=12h
---------------------------------------------
INT 16 - KEYBOARD - SET DELAYS (Jr,AT model 339,XT286,PS)
	AH = 03h
	AL = subfunction
	    00h reset typematic (PCjr)
	    01h increase initial delay (PCjr)
	    02h increase continuing delay (PCjr)
	    03h increase both delays (PCjr)
	    04h turn off typematic (PCjr)
	    05h Set typematic rate (AT or PS/2)
	BH = 00h - 03h for delays of 250ms, 500ms, 750ms, or 1s
	BL = 00h - 1Fh for typematic rates of 30cps down to 2cps
---------------------------------------------
INT 16 - KEYBOARD - KEYCLICK (Jr,CONV)
	AH = 04h
	AL = 00h click off
	     01h click on
---------------------------------------------
INT 16 - KEYBOARD - WRITE TO KEYBOARD BUFFER (AT model 339,XT2,XT286,PS)
	AH = 05h
	CH = scan code
	CL = character
Return: AL = 01h if buffer full
---------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
	AH = 10h
Return: AH = scan code
	AL = character
Note:	unlike AH=00h, this function does not discard extended keystrokes
SeeAlso: AH=00h
---------------------------------------------
INT 16 - KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
	AH = 11h
Return: ZF clear if keystroke available
	    AH = scan code \ meaningless if ZF = 1
	    AL = character /
	ZF set if kbd buffer empty
SeeAlso: AH=01h
---------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS)
	AH = 12h
Return: AL = shift flags (same as for AH=02h)
	   bit 7: Ins ON
	   bit 6: CapsLock ON
	   bit 5: NumLock ON
	   bit 4: ScrollLock ON
	   bit 3: Either ALT key down
	   bit 2: Either CTRL key down
	   bit 1: Left shift key down
	   bit 0: Right shift key down
	AH
	   bit 7: SysReq key down
	   bit 6: CapsLock key down
	   bit 5: NumLock key down
	   bit 4: ScrollLock key down
	   bit 3: Right Alt key down
	   bit 2: Right Ctrl key down
	   bit 1: Left Alt key down
	   bit 0: Left Ctrl key down
Notes:	AL bit 3 set only for left Alt key on many machines
	AH bits 7 through 4 always clear on a Compaq SLT/286
SeeAlso: AH=02h
---------------------------------------------
INT 16 - PC Tools v5.1 BACKTALK - UNHOOK
	AX = 6969h
	BX = 6968h
Return: resident code unhooked, but not removed from memory
---------------------------------------------
INT 16 - PC Tools v5.1 BACKTALK - INSTALLATION CHECK
	AX = 6969h
	BX = 6969h
	DX = 0000h
Return: DX nonzero if installed
	    BX = CS of resident code
	    DX = PSP segment of resident code
	    DS:SI -> ASCIZ identification string "CPoint Talk"
---------------------------------------------
INT 16 - MS Windows - ???
	AH = 6Fh
	???
Return: ???
---------------------------------------------
INT 16 - FAKEY.COM - INSTALLATION CHECK
	AH = 70h
Return: AX = 1954h if installed
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
---------------------------------------------
INT 16 - FAKEY.COM - PUSH KEYSTROKES
	AH = 71h
	CX = number of keystrokes
	DS:SI -> array of words containing keystrokes to be returned by AH=00h
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
---------------------------------------------
INT 16 - FAKEY.COM - CLEAR FAKED KEYSTROKES
	AH = 72h
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
---------------------------------------------
INT 16 - FAKEY.COM - PLAY TONES
	AH = 73h
	CX = number of tones to play
	DS:SI -> array of tones (see below)
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates

Format of tone array entries:
Offset	Size	Description
 00h	WORD	divisor for timer channel 2
 02h	WORD	duration in clock ticks
---------------------------------------------
INT 16 - pcANYWHERE - SET TICK COUNT FOR SCANNING
	AH = 75h
	AL = number of ticks between checks for new screen changes
---------------------------------------------
INT 16 - pcANYWHERE - SET ERROR CHECKING TYPE
	AH = 76h
	AL = error checking type
	    00h none
	    01h fast
	    02h slow
---------------------------------------------
INT 16 - pcANYWHERE - LOG OFF
	AH = 77h
	AL = mode
	    00h wait for another call
	    01h leave in Memory Resident Mode
	    02h leave in Automatic Mode
	    FFh leave in current operating mode
---------------------------------------------
INT 16 - WATCH.COM - INSTALLATION CHECK
	AX = 7761h ('wa')
Return: AX = 5741h ('WA') if installed
Note:	WATCH.COM is part of the "TSR" package by Kim Kokkonen
---------------------------------------------
INT 16 - PC Magazine PUSHDIR.COM - INSTALLATION CHECK
	AX = 7788h
	BX = 7789h
Return: AX = 7789h
	BX = 7788h
	DS:SI -> signature string
---------------------------------------------
INT 16 - pcANYWHERE - CHECK STATUS
	AH = 79h
Return: AX = status
	    FFFFh if resident and active
	    FFFEh if resident but not active
	    FFFDh if in Memory Resident mode
	    FFFCh if in Automatic mode
	    other value if not resident
---------------------------------------------
INT 16 - pcANYWHERE - CANCEL SESSION
	AH = 7Ah
---------------------------------------------
INT 16 - pcANYWHERE - SUSPEND
	AX = 7B00h
---------------------------------------------
INT 16 - pcANYWHERE - RESUME
	AX = 7B01h
---------------------------------------------
INT 16 - pcANYWHERE - GET PORT CONFIGURATION
	AH = 7Ch
Return: AH = port number
	AL = baud rate
	    00h = 50 baud
	    01h = 75 baud
	    02h = 110 baud
	    03h = 134.5 baud
	    04h = 150 baud
	    05h = 300 baud
	    06h = 600 baud
	    07h = 1200 baud
	    08h = 1800 baud
	    09h = 2000 baud
	    0Ah = 2400 baud
	    0Bh = 4800 baud
	    0Ch = 7200 baud
	    0Dh = 9600 baud
	    0Eh = 19200 baud
---------------------------------------------
INT 16 - pcANYWHERE - GET/SET TERMINAL PARAMETERS
	AH = 7Dh
	AL = subfunction
	    00h set terminal parameters
	    01h get terminal parameters
	    02h get configuration header and terminal parameters
	DS:CX -> terminal parameter block
---------------------------------------------
INT 16 - pcANYWHERE - COMMUNICATIONS I/O THROUGH PORT
	AH = 7Eh
	AL = subfunction
	    01h port input status
		Return AX = 0 if no characer ready,
		       AX = 1 if character ready
	    02h port input character
		Return AL = received character
	    03h port output character in CX
	    11h hang up phone
---------------------------------------------
INT 16 - pcANYWHERE - SET KEYBOARD/SCREEN MODE
	AH = 7Fh
	AL = subfunction
	    00h enable remote keyboard only
	    01h enable host keyboard only
	    02h enable both keyboards
	    08h display top 24 lines
	    09h display bottom 24 lines
	    10h Hayes modem
	    11h other modem
	    12h direct connect
---------------------------------------------
INT 16 - MAKEY.COM - INSTALLATION CHECK
	AH = 80h
Return: AX = 1954h if installed
Note:	MAKEY is a utility by System Enhancement Associates
---------------------------------------------
INT 16 - PTxxx.COM - (xxx=CGA,EGA,VGA,HER...) CALL GATE FOR GRAPHICS
	AH = AAh
	Various registers set up by high level language.
Return: Graphics performed
Note:	PT stands for Paint Tools which is a graphics library for Turbo Pascal,
	  Modula 2 and others from DataBiten in Sweden. The library is
	  installed as a memory resident driver.
---------------------------------------------
INT 16 - Compaq 386 - SET CPU SPEED
	AH = F0h
	AL = speed
	    00h equivalent to 6 MHz 80286 (COMMON)
	    01h equivalent to 8 MHz 80286 (FAST)
	    02h full 16 MHz (HIGH)
	    03h toggles between 8 MHz-equivalent and speed set by system board
		switch (AUTO or HIGH)
	    08h full 16 MHz except 8 MHz-equivalent during floppy disk access
	    09h specify speed directly
		CX = speed value, 1 (slowest) to 50 (full), 3 ~= 8088
---------------------------------------------
INT 16 - PE.EXE - INSTALLATION CHECK
	AX = F0F0h
Return: AX = 0F0Fh if installed
	    ES:DI -> data block
Note:	PE is a TSR screen grabber included with ASMED, an integrated
	  environment for TASM and MASM

Format of data block:
Offset	Size	Description
 00h	DWORD	pointer to program tag (counted ASCII string)
 04h	WORD	???
 06h	DWORD	pointer to ???
 0Ah  4 BYTEs	???
 0Eh	DWORD	???
	more???
---------------------------------------------
INT 16 - Compaq 386 - READ CURRENT CPU SPEED
	AH = F1h
Return:	AL = speed code (see AH=F0h)
	     if AL = 09h, CX = speed code
---------------------------------------------
INT 16 - Compaq 386 - DETERMINE ATTACHED KEYBOARD TYPE
	AH = F2h
Return: AL = type
	    00h if 11-bit AT keyboard is in use
	    01h if 9-bit PC keyboard is in use 
---------------------------------------------
INT 16 - PC Tools v5.5 DESKTOP API - ???
	AX = FFB2h
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.5 DESKTOP API - ???
	AX = FFB3h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.5 DESKTOP API - ???
	AX = FFB4h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.5 DESKTOP API - GET/SET ???
	AX = FFB5h
	BX = ??? (000Fh to 0019h)
	DX = 0000h get, nonzero = set
	ES:DI -> 16-byte buffer with new values or to receive old values
---------------------------------------------
INT 16 - PC Tools v5.5 DESKTOP API - ???
	AX = FFB6h
	???
Return: AH = ???
	AL = ???
---------------------------------------------
INT 16 - PC Tools v5.5 DESKTOP API - SET ???
	AX = FFB7h
	DS:SI -> 10-byte buffer with ???
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFB8h
	BH = subfunction
	    00h get
		Return: BL = old value of ???
	    nonzero set
		BL = new value for ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFB9h
	???
Return: AX = ???
	CX = ???
	DS:SI -> ???
	ES:DI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFBAh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFBBh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - RESTORE ORIGINAL SCREEN???
	AX = FFBCh
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - POP DOWN???
	AX = FFBDh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFBEh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFBFh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFC0h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFC1h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFC2h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFC3h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFC4h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFC5h
Return: BL = ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - SET ???
	AX = FFC6h
	BL = new value for ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFC7h
	???
Return: ???
Note:	screen swapping???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - GET ???
	AX = FFC8h
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFC9h
	SI = ???
	CX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFCAh
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFCBh
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - DISPLAY ASCIZ STRING
	AX = FFCCh
	DS:SI -> ASCIZ string
Return: AX = ???
	CX = ???
	ES:DI -> address past last character displayed
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFCDh
	DS:DX -> ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - SET ??? DELAYS
	AX = FFCEh
	CX = ???
Return: nothing???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFCFh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFD0h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFD1h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFD2h
	BX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFD3h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - CREATE/OPEN/DELETE FILE
	AX = FFD4h
	BH = 3Ch create file
		CX = file attributes
	     3Dh open file
	     41h delete file
	BL = access mode
	     00h read only
	     01h write only
	     02h read/write
	DS:SI -> ASCIZ filename
Return: BX = file handle
	    0000h on error
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFD5h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFD6h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFD7h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - SAFE CREATE FILE
	AX = FFD8h
	DS:BX -> ASCIZ filename
Return: BX = file handle
	    0000h on error
Note:	pops up confirmation menu if file already exists
	only available when popped up???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFD9h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFDAh
	DS:SI -> ???
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFDBh
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - UNHOOK
	AX = FFDCh
Return: interrupt vectors 09h, 16h, 1Ch, and 21h restored to original values
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - INSTALLATION CHECK
	AX = FFDDh
	BX = 0000h
Return: CX = 5555h 
	DX = 5555h if PCShell installed in resident mode
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - REQUEST POP-UP
	AX = FFDDh
	BX = 0001h
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - GET ???
	AX = FFDDh
	BX = 0002h
Return: AL = 
	    00h ???
	    01h ???
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - REQUEST POP-UP
	AX = FFDDh
	BX = 0003h
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - ???
	AX = FFDDh
	BX = 0004h
	???
Return: DS:SI -> ???
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - ???
	AX = FFDDh
	BX = 0005h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - ???
	AX = FFDDh
	BX = 0006h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - ???
	AX = FFDDh
	BX = 0007h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 PCShell API - ???
	AX = FFDDh
	BX = 0008h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFDEh
	DS:DX -> ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFDFh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFE0h
	CX = ???
	DX = ???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - BEEP
	AX = FFE1h
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFE2h
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFE3h
	BL = ???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFE4h
	DX = segment of ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFE5h
	DS:SI -> wildcard filename???
	DX = ???
Return: AX = ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFE6h
	DS:SI -> ???
Return: AX = ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFE7h
	BX = segment of ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - DISPLAY NUMBER
	AX = FFE8h
	CX = number
	DH = attribute
	DS:SI -> destination for ASCII number
Return: DS:SI buffer filled in with alternating characters and attributes
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFE9h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - DISPLAY COUNTED STRING
	AX = FFEAh
	DS:SI -> counted string (count byte followed by string)
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFEBh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFECh
	DS:SI -> FAR routine to ???
	BX = ???
Return: AX = ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFEDh
Return: AX = ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFEEh
	SI = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - INSTALLATION CHECK
	AX = FFEFh
	CX = 0000h
Return: CX = ABCDh if PC Tools DESKTOP.EXE installed
	    BX = segment of resident portion
	    AX = ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFF0h
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ALTERNATE INSTALLATION CHECK
	AX = FFF1h
	BX = 0000h  leave ??? flag as is
	    nonzero set ??? flag
Return: CX = 5555h if installed
	DX = 5555h
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFF2h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFF3h
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFF4h
	???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - GET SCREEN ATTRIBUTE ARRAY
	AX = FFF5h
Return: ES:BX -> array of screen attributes 
		00h	BYTE  normal characters on desktop menu
		01h	BYTE  highlighted characters on desktop menu
		02h	BYTE 
		03h	BYTE
		etc.
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFF6h
	DS = ???
	BX = ???
	DX = ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFF7h
	SI = ???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFF8h
	DS:SI -> ???
	BX = ???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFF9h
	ES:BX -> FAR routine to ???
Return: ???
Note:	available only when popped up
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFFAh
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFFBh
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - GET ???
	AX = FFFCh
Return: ES:BX = ???
	DS:DX = original INT 9 vector
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - ???
	AX = FFFDh
	???
Return: ???
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - SHOW MOUSE CURSOR
	AX = FFFEh
---------------------------------------------
INT 16 - PC Tools v5.1 DESKTOP API - HIDE MOUSE CURSOR
	AX = FFFFh
---------------------------------------------
INT 17 - PRINTER - OUTPUT CHARACTER
	AH = 00h
	AL = character
	DX = printer port (0-3)
Return: AH = status bits
	    0 = time out
	    1 = unused
	    2 = unused
	    3 = I/O error
	    4 = selected
	    5 = out of paper
	    6 = acknowledge
	    7 = not busy
---------------------------------------------
INT 17 - PRINTER - INITIALIZE
	AH = 01h
	DX = printer port (0-3)
Return: AH = status (see AH=00h)
---------------------------------------------
INT 17 - PRINTER - GET STATUS
	AH = 02h
	DX = printer port (0-3)
Return: AH = status (see AH=00h)
---------------------------------------------
INT 17 - INSET - INSTALLATION CHECK
	AH = 02h
	DX = 0000h
	CX = 07C3h (1987d)
Return: CX = 07C2h (1986d) if installed
Note:	INSET is a text/graphics integration program
---------------------------------------------
INT 17 - FLASHUP.COM - INSTALLATION CHECK
	AH = 60h
Return: AL = 60h
	DX = CS of resident code
Note:	FLASHUP.COM is part of Flash-Up Windows by The Software Bottling Co.
	FLASHUP also hooks INT 10 and received commands via INT 10/AH=09h,0Ah
	  consisting of an 80h followed by the actual command
---------------------------------------------
INT 17 - SPEEDSCR.COM - INSTALLATION CHECK
	AH = 61h
Return: AL = 61h
	DX = CS of resident code
Note:	SPEEDSCR.COM is by The Software Bottling Co.
---------------------------------------------
INT 17 - INSET - EXECUTE COMMAND STRING
	AX = CD00h
	DS:DX -> ASCIZ command string (max 80 bytes)
Return: CX = 07C2h (1986d)
Note:	user interface menus pop up after last command, unless that command
	exits INSET
---------------------------------------------
INT 17 - INSET - GET IMAGE SIZE
	AX = CD01h
	DS:DX -> ASCIZ name of image file
Return: AX = height in 1/720th inch
	BX = width in 1/720th inch
	CX = 07C2h (1986d)
---------------------------------------------
INT 17 - INSET - INITIALIZE
	AX = CD02h
Return: CX = 07C2h (1986d)
Note:	all open files are closed and the printer is reset
---------------------------------------------
INT 17 - INSET - EXECUTE INSET MENU WITHIN OVERRIDE MODE
	AX = CD03h
Return: CX = 07C2h (1986d)
---------------------------------------------
INT 17 - INSET - INITIALIZE LINKED MODE
	AX = CD04h
	ES:DI -> FAR routine for linked mode
Return: CX = 07C2h
Note:	calling sequence for linked-mode routine
	AL = 00h send character in BL to printer
	   = 01h send CX bytes from DS:DX to printer
	   = 02h move print head to horizontal starting position of image
	return code for linked-mode routine:
	AX = 0000h success
	   = 0001h failure
---------------------------------------------
INT 17 - INSET - START MERGING IMAGE INTO TEXT
	AX = CD05h
	DS:DX -> ASCIZ name of PIX file
	CX = left margin of text in 1/720th inch
Return: AH = printer type
	    00h page-oriented (multiple images may be placed side-by-side)
	    01h line-oriented (use AX=CD06h for vertical paper movement)
	CX = 07C2h (1986d)
---------------------------------------------
INT 17 - INSET - GRAPHICS LINE FEED
	AX = CD06h
Return: AH = completion status
	    00h image complete
	    01h image incomplete
	CX = 07C2h (1986d)
---------------------------------------------
INT 17 - INSET - FLUSH GRAPHICS FROM MERGE BUFFER
	AX = CD07h
Return: CX = 07C2h
---------------------------------------------
INT 17 - INSET - CANCEL LINK MODE
	AX = CD08h
Return: CX = 07C2h
SeeAlso: AX=CD04h
---------------------------------------------
INT 17 - INSET - ALTER GRAPHICS LINE SPACING
	AX = CD09h
	CX = line spacing in 1/720th inch
Return: CX = 07C2h
Note:	not yet implemented, line spacing is currently fixed at 1/6 inch
---------------------------------------------
INT 17 - INSET - GET SETUP
	AX = CD0Ah
	DS:DX -> buffer for IN.SET data
Return: CX = 07C2h
---------------------------------------------
INT 17 - INSET - START GETTING SCALED IMAGE
	AX = CD0Bh
	DS:SI -> ASCIZ pathname of .PIX file
	BX = number of bitplanes
	CX = number of rows in output bitmap
	DX = number of columns in output bitmap
Return: AX = status
	    0000h OK
	    FFFFh error	
Note:	image is returned in strips by repeated calls to AX=CD0Ch
---------------------------------------------
INT 17 - INSET - GET NEXT IMAGE STRIP
	AX = CD0Ch
Return:	AX = status
	    0000h OK but not complete
	    0001h OK and image complete
	    FFFFh error
	DS:SI -> buffer (max 4K) for bit map strip 
	CX = start row
	DX = number of rows
	BX = offset in bytes between bit planes
Note:	buffer may be overwritten by subsequent calls
---------------------------------------------
INT 18 - TRANSFER TO ROM BASIC
   causes transfer to ROM-based BASIC (IBM-PC)
   often reboots a compatible; often has no effect at all
---------------------------------------------
INT 19 - DISK BOOT
   causes reboot of disk system (no memory test performed)

   Usually, the BIOS will try to read sector 1, head 0, track 0 from drive A:.
   If this fails, and a harddisk is installed, the BIOS will read sector 1,
   head 0, track 0 of the first hard disk.  This sector should contain a master
   bootstrap loader and a partition table.  After loading the sector at
   0000h:7C00h, the master bootstrap loader is given control.  It will scan the
   partition table for an active partition, and will then load the operating
   system's bootstrap loader (contained in the first sector of the system's
   partition) and give it control.

Format of harddisk master boot sector:
Offset  Size    Description
 00h 446 BYTEs  Master bootstrap loader code
1BEh 16 BYTEs	partition record for partition 1 (see below)
1CEh 16 BYTEs	partition record for partition 2
1DEh 16 BYTEs	partition record for partition 3
1EEh 16 BYTEs	partition record for partition 4
1FEh	WORD	signature, AA55h indicates valid boot block

Format of partition record:
Offset	Size	Description
 00h	BYTE	boot indicator (80h = active partition)
 01h	BYTE	partition start head
 02h	BYTE	partition start sector (bits 0-5)
 03h	BYTE	partition start track (bits 8,9 in bits 6,7 of sector)
 04h	BYTE	operating system indicator
		00h empty
		01h DOS 12-bit FAT
		02h XENIX file system
		03h XENIX /usr file system (obsolete???)
		04h DOS 16-bit FAT
                05h DOS 3.3 extended partition
                06h DOS Large File System
                08h AIX bootable partition
                09h AIX data partition
                52h CP/M ???
		E1h SpeedStor 12-bit FAT extended partition
		E4h SpeedStor 16-bit FAT extended partition
 05h	BYTE	partition end head
 06h	BYTE	partition end sector (bits 0-5)
 07h	BYTE	partition end track (bits 8,9 in bits 6,7 of sector)
 08h	DWORD	sectors preceding partition
 0Ch	DWORD	length of partition in sectors
---------------------------------------------
INT 1A - CLOCK - GET TIME OF DAY
	AH = 00h
Return: CX:DX = clock count
	AL = 00h if clock was read or written (via AH=0,1) within the current
		 24-hour period
	     Otherwise, AL > 0
SeeAlso: INT 21/AH=2Ch
---------------------------------------------
INT 1A - CLOCK - SET TIME OF DAY
	AH = 01h
	CX:DX = clock count
Return: time of day set
SeeAlso: INT 21/AH=2Dh
---------------------------------------------
INT 1A - CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 02h
Return: CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
---------------------------------------------
INT 1A - CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 03h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
	DL = 01h if daylight savings, 00h if standard time
Return: CMOS clock set
---------------------------------------------
INT 1A - CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 04h
Return: DL = day in BCD
	DH = month in BCD
	CL = year in BCD
	CH = century (19h or 20h)
SeeAlso: INT 21/AH=2Ah
---------------------------------------------
INT 1A - CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 05h
	DL = day in BCD
	DH = month in BCD
	CL = year in BCD
	CH = century (19h or 20h)
Return: CMOS clock set
SeeAlso: INT 21/AH=2Bh
---------------------------------------------
INT 1A - CLOCK - SET ALARM (AT,XT286,CONV,PS)
	AH = 06h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
Return: CF set if alarm already set or clock inoperable
	INT 4Ah will be called when alarm goes off, every 24 hours until reset
---------------------------------------------
INT 1A - CLOCK - RESET ALARM (AT,XT286,CONV,PS)
	AH = 07h
Return: alarm disabled
---------------------------------------------
INT 1A - CLOCK - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE)
	AH = 08h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
---------------------------------------------
INT 1A - CLOCK - READ RTC ALARM TIME AND STATUS (CONV,PS30)
	AH = 09h
Return: CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
	DL = alarm status
	    00h alarm not enabled
	    01h alarm enabled but will not power up system
	    02h alarm will power up system
---------------------------------------------
INT 1A - CLOCK - READ SYSTEM-TIMER DAY COUNTER (XT2,PS)
	AH = 0Ah
Return: CF set on error
	CX = count of days since Jan 1,1980
---------------------------------------------
INT 1A - CLOCK - SET SYSTEM-TIMER DAY COUNTER (XT2,PS)
	AH = 0Bh
	CX = count of days since Jan 1,1980
Return: CF set on error
---------------------------------------------
INT 1A - WORD PERFECT 5.0 Third Party Interface - INSTALLATION CHECK
	AX = 3601h
Return: DS:SI = routine to monitor keyboard input, immediately preceded by the
		ASCIZ string "WPCORP\0"
Notes:	WordPerfect 5.0 will call this interrupt at start up to determine if a
	  third party product wants to interface with it.  The third party
	  product must intercept this interrupt and return the address of a
	  keyboard monitor routine.
	Before checking for keyboard input, and after every key entered by the
	  user, Word Perfect will call the routine whose address was provided
	  in DS:SI with the following parameters:
		Entry:	AX = key code or 0
			BX = WordPerfect state flag
		Exit:	AX = 0 or key code
			BX = 0 or segment address of buffer with key codes
	See the "WordPerfect 5.0 Developer's Toolkit" for further information.
---------------------------------------------
INT 1A - PCjr - SET UP SOUND MULTIPLEXOR
	AH = 80h
	AL = 00h source is 8253 channel 2
	     01h source is cassette input
	     02h source is I/O channel "Audio IN"
	     03h source is sound generator chip
---------------------------------------------
INT 1A - AT&T 6300 - READ TIME AND DATE
	AH = FEh
Return: BX = day count (0 = Jan 1, 1984)
	CH = hour
	CL = minute
	DH = second
	DL = hundredths
SeeAlso: INT 21/AH=2Ah,2Ch
---------------------------------------------
INT 1A - AT&T 6300 - SET TIME AND DATE
	AH = FFh
	BX = day count (0 = Jan 1, 1984)
	CH = hour
	CL = minute
	DH = second
	DL = hundredths
Return: ???
SeeAlso: INT 21/AH=2Bh,2Dh
---------------------------------------------
INT 1B - CTRL-BREAK KEY
   This interrupt is called when the keyboard scanner of the IBM
   machines detects CTRL and BREAK pressed at the same time. It
   normally points to a short routine in DOS which sets the
   Ctrl-C flag, thus invoking INT 23h the next time DOS checks
   for Ctrl-C.
SeeAlso: INT 23
---------------------------------------------
INT 1C - CLOCK TICK
   This interrupt is called (in the IBM) at the end of each time-update
   operation by the time-of-day routines.
Notes:	points to an IRET by default
	preferred interrupt to chain when a program needs to be invoked
	  regularly
SeeAlso: INT 08
---------------------------------------------
INT 1D - (NOT a vector!) 6845 VIDEO INIT TABLES

Format of video init tables:
Offset	Size	Description
 00h 16 BYTEs	table for modes 0 and 1		\
 10h 16 BYTEs	table for modes 2 and 3		 \  each table contains values
 20h 16 BYTEs	table for modes 4, 5, and 6	 /  for first sixteen 6485 regs
 30h 16 BYTEs	table for mode 7		/
 40h	WORD	size of video RAM for modes 0 and 1
 42h	WORD	size of video RAM for modes 2 and 3
 44h	WORD	size of video RAM for modes 4 and 5
 46h	WORD	size of video RAM for modes 6 and 7
 48h  8 BYTEs	number of colums in each of modes 0 through 7
 50h  8 BYTEs	video controller mode byte for each mode
---------------------------------------------
INT 1E - (NOT a vector!) DISKETTE PARAMS (BASE TABLE)
	default parameters at F000h:EFC7h in PC and most compatibles
SeeAlso: INT 41

Format of diskette parameters:
Offset	Size	Description
 00h	BYTE	4-bit step rate & 4-bit head unload times
 01h	BYTE	7-bit head load time & 1-bit DMA flag
 02h	BYTE	motor off time in clock ticks (36 to 38 typical)
 03h	BYTE	sector size in bytes (0->128, 1->256, 2->512, 3->1024)
 04h	BYTE	last sector number (8 or 9 typical)
 05h	BYTE	inter-sector gap size on read/write (42 typical)
 06h	BYTE	data transfer length (255 typical)
 07h	BYTE	inter-sector gap size on format (80 typical)
 08h	BYTE	sector fill on format (F6h typical)
 09h	BYTE	head-settle time ms (typical 25, 1.10->0, 2.10->15, 3.10->1)
 0Ah	BYTE	motor start-up time (1/8 secs) (typical 4, 2.10->2)
---------------------------------------------
INT 1F - (NOT a vector!) GRAPHICS SET 2
	pointer to bitmaps for high 128 chars
---------------------------------------------
INT 20 - Minix - SEND/RECEIVE MESSAGE
	AX = process ID of other process
	BX -> message
	CX = 1 send
	     2 receive
	     3 send&receive
Note:	the message contains the system call number (numbered as in V7 
	  Unix(tm)) and the call parameters
---------------------------------------------
INT 20 - DOS - PROGRAM TERMINATION
returns to DOS--identical to INT 21/AH=00h
Note:	IBM and Microsoft recommend using INT 21/AH=4Ch for DOS 2+
---------------------------------------------
INT 21 - DOS - PROGRAM TERMINATION
	AH = 00h
Return: never
---------------------------------------------
INT 21 - DOS - KEYBOARD INPUT
	AH = 01h
Return: AL = character read
Note:	^C/^Break are checked, and INT 23h executed if read
	character is echoed to standard output
---------------------------------------------
INT 21 - DOS - DISPLAY OUTPUT
	AH = 02h
	DL = character to send to standard output
Note:	^C/^Break are checked, and INT 23h executed if pressed
---------------------------------------------
INT 21 - DOS - AUX INPUT
	AH = 03h
Return: AL = character read
SeeAlso: INT 14/AH=02h
---------------------------------------------
INT 21 - DOS - AUX OUTPUT
	AH = 04h
	DL = character to send
SeeAlso: INT 14/AH=01h
---------------------------------------------
INT 21 - DOS - PRINTER OUTPUT
	AH = 05h
	DL = character to print
SeeAlso: INT 17/AH=00h
---------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
	AH = 06h
	DL = character <> FFh
---------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER INPUT
	AH = 06h
	DL = FFh
Return: ZF set	 = no character
	ZF clear = character recieved
		  AL = character
Notes:	character is echoed to STDOUT if received.
	^C/^Break are NOT checked
---------------------------------------------
INT 21 - DOS - DIRECT STDIN INPUT, NO ECHO
	AH = 07h
Note:	same as function 06h for input but char not echoed
---------------------------------------------
INT 21 - DOS - KEYBOARD INPUT, NO ECHO
	AH = 08h
Return: AL = character
Note:	same as function 07h, but ^C/^Break are checked
---------------------------------------------
INT 21 - DOS - PRINT STRING
	AH = 09h
	DS:DX -> string terminated by "$"
Note:	^C/^Break checked, and INT 23h called if pressed
---------------------------------------------
INT 21 - DOS - BUFFERED KEYBOARD INPUT
	AH = 0Ah
	DS:DX -> buffer
Note:	first byte of buffer must contain maximum length
	on entry, second byte contains actual length of previous line which may
	  be recalled with the DOS line-editing commands
	on return the second byte contains actual length, third and
	  subsequent bytes contain the input line
---------------------------------------------
INT 21 - DOS - CHECK STANDARD INPUT STATUS
	AH = 0Bh
Return: AL = FFh if character available
	     00h if no character
Note:	^C/^Break checked, and INT 23h called if pressed
---------------------------------------------
INT 21 - DOS - CLEAR KEYBOARD BUFFER
	AH = 0Ch
	AL must be 1, 6, 7, 8, or 0Ah.
Notes:	flushes all typeahead input, then executes function specified by AL
	  (effectively moving it to AH and repeating the INT 21 call).
	if AL contains a value not in the list above, the keyboard buffer is
	  flushed and no other action is taken.
---------------------------------------------
INT 21 - DOS - DISK RESET
	AH = 0Dh
Note:	flushes all disk buffers
---------------------------------------------
INT 21 - DOS - SELECT DISK
	AH = 0Eh
	DL = new default drive number (0 = A, 1 = B, etc.)
Return: AL = number of logical drives
SeeAlso: AH=19h
---------------------------------------------
INT 21 - DOS - OPEN DISK FILE
	AH = 0Fh
	DS:DX -> FCB (see below)
Return: AL = 00h file found
	     FFh file not found
Note:	(DOS 3+) file opened in compatibility mode
SeeAlso: AH=3Dh

Format of File Control Block:
Offset	Size	Description
 -7	BYTE	extended FCB if FFh
 -6   5 BYTEs	reserved
 -1	BYTE	file attribute if extended FCB
 00h	BYTE	drive number (0 = default, 1 = A, etc)
 01h  8 BYTEs	blank-padded file name 
 09h  3 BYTEs	blank-padded file extension
 0Ch	WORD	current block number
 0Eh	WORD	logical record size
 10h	DWORD	file size
 14h	WORD	date of last write (see AX=5700h)
 16h	WORD	time of last write (see AX=5700h)
 18h  8 BYTEs	reserved (see below)
 20h	BYTE	record within current block
 21h	DWORD	random access record number (if record size is > 64 bytes, high
		byte is omitted)

Format of reserved field for DOS 1.x:
Offset	Size	Description
 18h	BYTE	bit 7: set if logical device
		bit 6: set if open???
		bits 5-0: disk number or logical device ID
 19h	WORD	absolute current cluster number
 1Bh	WORD	starting cluster number
 1Dh	WORD	relative current cluster number
 1Fh	BYTE	unused???

Format of reserved field for DOS 2.x:
Offset	Size	Description
 18h	BYTE	bit 7: set if logical device
		bit 6: set if open???
		bits 5-0: ???
 19h	WORD	starting cluster number
 1Bh	WORD	???
 1Dh	BYTE	???
 1Eh	BYTE	???
 1Fh	BYTE	???

Format of reserved field for DOS 3.x:
Offset	Size	Description
 18h	BYTE	number of system file table entry for file
 19h	BYTE	attributes
		bits 7,6: 00 = SHARE.EXE not loaded, disk file
			  01 = SHARE.EXE not loaded, character device
			  10 = SHARE.EXE loaded, remote file
			  11 = SHARE.EXE loaded, local file
		bits 5-0: low six bits of device attribute word
---SHARE.EXE loaded, local file---
 1Ah	WORD	starting cluster of file
 1Ch	WORD	offset within SHARE of sharing record (see AH=52h)
 1Eh	BYTE	file attribute
 1Fh	BYTE	???
---SHARE.EXE loaded, remote file---
 1Ah	WORD	number of sector containing directory entry
 1Ch	WORD	relative cluster within file of last cluster read
 1Eh	BYTE	absolute cluster number of last cluster read
 1Fh	BYTE	???
---SHARE.EXE not loaded---
 1Ah	BYTE	(low byte of device attribute word AND 0Ch) OR open mode
 1Bh	WORD	starting cluster of file
 1Dh	WORD	number of sector containing directory entry
 1Fh	BYTE	number of directory entry within sector
Note:	if FCB opened on character device, DWORD at 1Ah is set to the address
	  of the device driver header, then the BYTE at 1Ah is overwritten.
---------------------------------------------
INT 21 - DOS - CLOSE DISK FILE
	AH = 10h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = 00h directory update successful
	     FFh file not found in directory
SeeAlso: AH=3Eh
---------------------------------------------
INT 21 - DOS - SEARCH FIRST USING FCB
	AH = 11h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h file found
		[DTA] = unopened FCB for file that was found
	    FFh file not found
SeeAlso: AH=4Eh
---------------------------------------------
INT 21 - DOS - SEARCH NEXT USING FCB
	AH = 12h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h file found
		[DTA] = unopened FCB for file that was found
	    FFh file not found
SeeAlso: AH=4Fh
---------------------------------------------
INT 21 - DOS - DELETE FILE via FCB
	AH = 13h
	DS:DX -> FCB (see AH=0Fh) with filename field filled with template for
		 deletion ('?' wildcard allowed, but not '*')
Return: AL = status
	    00h file found
	    FFh file not found
SeeAlso: AH=41h
---------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK FILE READ
	AH = 14h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful read
	    01h end of file
	    02h data transfer area too small
	    03h partial record, EOF
SeeAlso: AH=3Fh
---------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK RECORD WRITE
	AH = 15h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful write
	    01h disk full
	    02h data transfer area too small
SeeAlso: AH=40h
---------------------------------------------
INT 21 - DOS - CREATE A DISK FILE
	AH = 16h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful creation
	    FFh directory full
Note:	if file already exists, it is truncated to zero length
SeeAlso: AH=3Ch
---------------------------------------------
INT 21 - DOS - RENAME FILE via FCB
	AH = 17h
	DS:DX -> FCB (see AH=0Fh)
	FCB contains new name starting at byte 17h.
Return: AL = status
	    00h file found
	    FFh file not found
SeeAlso: AH=56h
---------------------------------------------
INT 21 - DOS internal - UNUSED
	AH = 18h
Return: AL = 00h
---------------------------------------------
INT 21 - DOS - GET DEFAULT DISK NUMBER
	AH = 19h
Return: AL = current drive number (letter - 'A')
SeeAlo: AH=0Eh
---------------------------------------------
INT 21 - DOS - SET DISK TRANSFER AREA ADDRESS
	AH = 1Ah
	DS:DX -> disk transfer buffer
SeeAlso: AH=2Fh
---------------------------------------------
INT 21 - DOS - GET ALLOCATION TABLE INFORMATION FOR DEFAULT DRIVE
	AH = 1Bh
Return: DS:BX -> FAT ID byte for default drive
	DX = number of allocation units on disk
	AL = number of sectors per allocation unit (cluster)
	CX = number of bytes per sector
SeeAlso: AH=36h
---------------------------------------------
INT 21 - DOS - GET ALLOCATION TABLE INFORMATION FOR SPECIFIC DEVICE
	AH = 1Ch
	DL = drive number to check
Return: DS:BX -> FAT ID byte
	DX = number of allocation units on disk
	AL = number of sectors per allocation unit (cluster)
	CX = number of bytes per sector
SeeAlso: AH=36h
---------------------------------------------
INT 21 - DOS internal - UNUSED
	AH = 1Dh
Return: AL = 00h
---------------------------------------------
INT 21 - DOS internal - UNUSED
	AH = 1Eh
Return: AL = 00h
---------------------------------------------
INT 21 - DOS internal - GET DEFAULT DRIVE PARAMETER BLOCK
	AH = 1Fh
Return: AL = 00h No Error
	     FFh Error
	DS:BX -> drive parameter block
Note:	for DOS 2+, this just invokes function 32h with DL = 0
SeeAlso: AH=32h
---------------------------------------------
INT 21 - DOS internal - UNUSED
	AH = 20h
Return: AL = 00h
---------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD READ
	AH = 21h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful read
	    01h end of file
	    02h data transfer area too small
	    03h partial record, EOF
SeeAlso: AH=3Fh
---------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD WRITE
	AH = 22h
	DS:DX -> FCB (see AH=0Fh)
Return: AL = status
	    00h successful write
	    01h disk full
	    02h data transfer area too small
SeeAlso: AH=40h
---------------------------------------------
INT 21 - DOS - GET FILE SIZE
	AH = 23h
	DS:DX -> unopened FCB (see AH=0Fh) with filename and record size
		 fields initialized
Return: AL = status
	    00h file found
	    FFh file not found
Note:	FCB's random-record field set to number of records (rounded up)
SeeAlso: AH=42h
---------------------------------------------
INT 21 - DOS - SET RANDOM RECORD FIELD
	AH = 24h
	DS:DX -> open FCB (see AH=0Fh)
Return: Random Record Field of FCB is set to be same as Current Block
	and Current Record.
SeeAlso: AH=42h
---------------------------------------------
INT 21 - DOS - SET INTERRUPT VECTOR
	AH = 25h
	AL = interrupt number
	DS:DX = new vector to be used for specified interrupt
SeeAlso: AH=35h
---------------------------------------------
INT 21 - DOS - CREATE PSP
	AH = 26h
	DX = segment number at which to set up PSP
Return: current PSP is copied to specified segment
Note:	new PSP is updated with memory size information; INTs 22h, 23h, 24h
	  taken from interrupt vector table
SeeAlso: AH=55h,67h

Format of PSP:
Offset	Size	Description
 00h  2 BYTEs	program exit point
 02h  	WORD	memory size in paragraphs
 04h	BYTE	unused
 05h  5 BYTEs	CP/M entry point
 0Ah	DWORD	terminate address (old INT 22h)
 0Eh	DWORD	break address (old INT 23h)
 12h	DWORD	critical error handler (old INT 24h)
 16h	WORD	parent PSP segment
 18h 20 BYTEs	DOS 2+ open file table, FFh = unused
 2Ch	WORD	DOS 2+ environment segment (see below)
 2Eh	DWORD	DOS 2+ process's SS:SP on entry to last INT 21 call
 32h	WORD	DOS 3+ max open files
 34h	DWORD	DOS 3+ open file table address
 38h	DWORD	DOS 3+ pointer to previous PSP??? (set to FFFFFFFFh in 3.1,3.3)
 3Ch 20 BYTEs	unused by DOS versions <= 3.3
 50h  3 BYTEs	DOS function dispatcher (FAR routine)--CDh 21h CBh
 53h  9 BYTEs	unused
 5Ch 16 BYTEs	FCB #1 (see AH=0Fh), filled in from first commandline argument
		(when opened, overwrites following FCB)
 6Ch 20 BYTEs	FCB #2 (see AH=0Fh), filled in from second commandline argument
		(when opened, overwrites part of command tail)
 80h 128 BYTEs	command tail / default DTA buffer
		command tail is BYTE for length of tail, N BYTEs for the tail,
		followed by a BYTE containing 0Dh

Format of environment block:
Offset	Size	Description
 00h  N BYTEs	first environment variable, ASCIZ string of form "var=value"
      N BYTEs	second environment variable, ASCIZ string
	...
      N BYTEs	last environment variable, ASCIZ string of form "var=value"
	BYTE	00h
---DOS 3+---
	WORD	number of strings following environment (normally 1)
      N BYTEs	ASCIZ full pathname of program owning this environment
		other strings may follow
---------------------------------------------
INT 21 - DOS - RANDOM BLOCK READ
	AH = 27h
	DS:DX -> FCB (see AH=0Fh)
	CX = number of records to be read
Return: AL = status
	    00h successful read
	    01h end of file
	    02h data transfer area too small
	    03h partial record, EOF
SeeAlso: AH=3Fh
---------------------------------------------
INT 21 - DOS - RANDOM BLOCK WRITE
	AH = 28h
	DS:DX -> FCB (see AH=0Fh)
	CX = number of records to be written
	     if zero, truncate file to current random file position
Return: AL = status
	    00h successful write
	    01h disk full
	    02h data transfer area too small
SeeAlso: AH=40h
---------------------------------------------
INT 21 - DOS - PARSE FILENAME
	AH = 29h
	DS:SI -> string to parse
	ES:DI -> buffer to fill with unopened FCB (see AH=0Fh)
	AL = bit mask to control parsing
	    0 = 0: parsing stops if file separator found
		1: leading separators ignored
	    1 = 0: drive number in FCB set to default drive if not present
		   in string
		1: drive number in FCB not changed
	    2 = 0: filename in FCB set to blanks if no filename in string
		1: filename in FCB not changed if string does not contain
		   a filename
	    3 = 0: extension in FCB set to blanks if no extension in string
		1: extension left unchanged
Return: AL = 00h no wildcards in name or extension
	     01h wildcards appeared
	     FFh drive specifier invalid
	DS:SI -> first byte after parsed string
	ES:DI buffer filled with unopened FCB
Notes:  asterisks expanded to question marks in the FCB
	all processing stops when a filename terminator is encountered
	cannot be used with filespecs which include a path (DOS 2+)
---------------------------------------------
INT 21 - DOS - GET CURRENT DATE
	AH = 2Ah
Return: DL = day
	DH = month
	CX = year
	AL = day of the week (0=Sunday, 1=Monday, etc.)
---------------------------------------------
INT 21 - DOS - SET CURRENT DATE
	AH = 2Bh
	DL = day
	DH = month
	CX = year
Return: AL = 00h if no error
	   = FFh if bad value sent to routine
Note:	DOS 3.3+ also sets CMOS clock
---------------------------------------------
INT 21 - DESQview - INSTALLATION CHECK
	AH = 2Bh
	AL = subfunction (DV v2.00+)
	    01h get version
		Return: BX = version (BH = major, BL = minor)
		Note: early copies of v2.00 return 0002h
	    02h get shadow buffer info, and start shadowing
		Return: BH = rows in shadow buffer
			BL = columns in shadow buffer
			DX = segment of shadow buffer
	    04h get shadow buffer info
		Return: BH = rows in shadow buffer
			BL = columns in shadow buffer
			DX = segment of shadow buffer
	    05h stop shadowing
	CX = 4445h ('DE')
	DX = 5351h ('SQ')
Return: AL = FFh if DESQview not installed
Note:	in DESQview v1.x, there were no subfunctions; this call only identified
	whether or not DESQview was loaded
---------------------------------------------
INT 21 - PC Tools v5.1 PC-CACHE - INSTALLATION CHECK
	AH = 2Bh
	CX = 4358h ('CX')
Return: AL = FFh if PC-CACHE not installed
	AL = 00h if installed
	    CX = 6378h ('cx')
	    BX = ???
	    DX = ???
---------------------------------------------
INT 21 - TAME v2.10 - INSTALLATION CHECK
	AX = 2B01h
	CX = 5441h ('TA')
	DX = 4D45h ('ME')
Return: AL = 02h if installed
	ES:DX -> data area in TAME-RES (see below)
Note:	TAME is a shareware program by David G. Thomas which gives up CPU time
	  to other partitions under a multitasker when the current partition's
	  program incessantly polls the keyboard or system time

Format of data area:
Offset	Size	Description
 00h  2 BYTEs	???
 02h	DWORD	number of task switches
 06h	DWORD	number of keyboard polls
 0Ah	DWORD	number of time polls
 0Eh  4 BYTEs	???
 12h	DWORD	original INT 10h
 16h	DWORD	original INT 14h
 1Ah	DWORD	original INT 15h
 1Eh	DWORD	original INT 16h
 22h	DWORD	original INT 17h
 26h	DWORD	original INT 21h
 2Ah	DWORD	original INT 28h
 2Eh 14 BYTEs	???
 3Ch	WORD	X in /max:X,Y
 3Eh	WORD	Y in /max:X,Y
 40h  4 BYTEs	flags ???
	more???
---------------------------------------------
INT 21 - DOS - GET CURRENT TIME
	AH = 2Ch
Return: CH = hours
	CL = minutes
	DH = seconds
	DL = hundredths of seconds
Note:	time is updated approximately every 5/100 second
SeeAlso: INT 1A/AH=00h,FEh
---------------------------------------------
INT 21 - DOS - SET CURRENT TIME
	AH = 2Dh
	CH = hours
	CL = minutes
	DH = seconds
	DL = hundredths of seconds
Return: AL = 00h if no error
	   = FFh if bad value sent to routine
Note:	DOS 3.3+ also sets CMOS clock
SeeAlso: INT 1A/AH=01h,FFh
---------------------------------------------
INT 21 - DOS - SET VERIFY FLAG
	AH = 2Eh
	DL = 00h
	AL = 01h VERIFY on
	     00h VERIFY off
SeeAlso: AH=54h
---------------------------------------------
INT 21 - DOS 2+ - GET DISK TRANSFER AREA ADDRESS
	AH = 2Fh
Return: ES:BX -> DTA
SeeAlso: AH=1Ah
---------------------------------------------
INT 21 - DOS 2+ - GET DOS VERSION
	AH = 30h
Return: AL = major version number (0 for DOS 1.x)
	AH = minor version number
	BH = OEM number
	    00h IBM
	    16h DEC
	BL:CX = 24-bit user number
Note:	the OS/2 Penalty Box returns 10 for the major version
---------------------------------------------
INT 21 - DOS 2+ - TERMINATE BUT STAY RESIDENT
	AH = 31h
	AL = exit code
	DX = program size, in paragraphs
Note:	most TSRs can save some memory by releasing their environment block
	  before terminating (see AH=26h)
SeeAlso: INT 27
---------------------------------------------
INT 21 - DOS 2+ internal - GET DRIVE PARAMETER BLOCK
	AH = 32h
	DL = drive number
	    0 = default, 1 = A, etc.
Return: AL = 0FFh if invalid drive number, else
	DS:BX -> drive parameter block

Format of DOS Drive Parameter Block:
Offset	Size	Description
 00h	BYTE	drive number (0 = A, etc.)
 01h	BYTE	unit number within device driver
 02h	WORD	number of bytes per sector
 04h	BYTE	largest sector number in cluster (one less than sect/clust)
 05h	BYTE	log base two of the cluster size
 06h	WORD	number of reserved (boot) sectors
 08h	BYTE	number of copies of the FAT
 09h	WORD	number of root directory entries
 0Bh	WORD	first data sector on medium
 0Dh	WORD	largest possible cluster number (one more than # data clust)
---DOS 2.x---
 0Fh	BYTE	number of sectors in one FAT copy
 10h	WORD	first sector of root directory
 12h	DWORD	address of device driver for this drive
 16h	BYTE	media descriptor byte for medium
 17h	BYTE	FFh indicates block must be rebuilt
 18h	DWORD	address of next device block, offset = FFFFh indicates last
 1Ch	WORD	starting cluster of current directory (0 = root directory)
 1Eh 64 BYTEs	ASCIZ current directory path string
---DOS 3.x---
 0Fh	BYTE	number of sectors in one FAT copy
 10h	WORD	first sector of root directory
 12h	DWORD	address of device driver for this drive
 16h	BYTE	media descriptor byte for medium
 17h	BYTE	FFh = block must be rebuilt, 00h indicates block accessed
 18h	DWORD	address of next device block, offset = FFFFh indicates last
 1Ch	WORD	cluster at which to start search for free space when writing
 1Eh	WORD	number of free clusters on drive, FFFFh = unknown
---DOS 4.0---
 0Fh	WORD	number of sectors in one FAT copy
 11h	WORD	first sector of root directory
 13h	DWORD	address of device driver for this drive
 17h	BYTE	media descriptor byte for medium
 18h	BYTE	FFh = block must be rebuilt, 00h indicates block accessed
 19h	DWORD	address of next device block, offset = FFFFh indicates last
 1Dh	WORD	cluster at which to start search for free space when writing
 1Fh	WORD	number of free clusters on drive, FFFFh = unknown

Note:	the OS/2 compatibility box supports the DOS 3.3 version of this call
	  except for the DWORD at 12h
---------------------------------------------
INT 21 - DOS 2+ - EXTENDED CONTROL-BREAK CHECKING
	AH = 33h
	AL = subfunction
	    00h get state
	    01h set state
	        DL = 00h for OFF or 01h for ON
	    02h (DOS 3.x internal) get and set state
		DL = 00h for OFF or 01h for ON
		Return: DL = old BREAK setting
Return: DL = current BREAK setting if AL = 00h
	    00h BREAK=OFF
	    01h BREAK=ON
	AL = FFh if error
Note:	under DOS 3+, this function does not use any of the DOS-internal stacks
	  and is thus fully reentrant
---------------------------------------------
INT 21 - DOS 4.0 - GET BOOT DRIVE
	AX = 3305h
Return: DL = boot drive (1=A:,...)
---------------------------------------------
INT 21 - DOS 2+ internal - RETURN CritSectFlag POINTER
	AH = 34h
Return: ES:BX -> 1-byte DOS "Critical Section Flag", also known as InDOS flag
Notes:	when the critical section flag is nonzero, code within DOS is being
	  executed.  It is safe to enter DOS when both the critical section
	  flag and the critical error flag are zero.
	The critical error flag is the byte after the critical section flag in
	  DOS 2.x, and the byte BEFORE the critical section flag in DOS 3.x 
	  (except COMPAQ DOS 3.0, where the critical error flag is located 1AAh
	  bytes BEFORE the critical section flag)
	For DOS 3.1+, an undocumented call exists to get the address of the
	  critical error flag (see AX=5D06h)
---------------------------------------------
INT 21 - DOS 2+ - GET INTERRUPT VECTOR
	AH = 35h
	AL = interrupt number
Return: ES:BX = value of interrupt vector
SeeAlso: AH=25h
---------------------------------------------
INT 21 - DOS 2+ - GET DISK SPACE
	AH = 36h
	DL = drive code (0 = default, 1 = A, 2 = B, etc.)
Return: AX = number of sectors per cluster
	     or 0FFFFh if invalid drive
	BX = number of available clusters
	CX = bytes per sector
	DX = total clusters
Notes:	multiply AX * CX * BX for free space on disk
	multiply AX * CX * DX for total disk space
	according to Dave Williams' MSDOS reference, the value in DX is
	  incorrect for non-default drives after ASSIGN is run
SeeAlso: AH=1Ch
---------------------------------------------
INT 21 - DOS 2+ internal - GET SWITCHAR
	AX = 3700h
Return: AL = FFh unsupported subfunction
	DL = current switch character
Note:	documented in some OEM versions of some releases of DOS
---------------------------------------------
INT 21 - DOS 2+ internal - SET SWITCHAR
	AX = 3701h
	DL = new switch character
Return: AL = FFh unsupported subfunction
Note:	documented in some OEM versions of some releases of DOS
---------------------------------------------
INT 21 - DOS 2.x only internal - AVAILDEV
	AH = 37h
	AL = subfunction
	   02h read device availability (as set by AL=03h)
		Return: DL = device availability
	   03h set device availability, where:
		DL = 00h means \DEV\ must preceed device names
		DL <> 00h means \DEV\ need not preceed device names
Return: AL = FFh if invalid subfunction
---------------------------------------------
INT 21 - DOS 2+ - GET COUNTRY-DEPENDENT INFORMATION
	AH = 38h
--DOS 2.x--
	AL = 00h get current-country info
	DS:DX -> buffer for returned info (see below)
Return: AX = country code (MSDOS 2.11 only)
	buffer at DS:DX filled
--DOS 3+--
	AL = 00h for current country
	AL = 01h thru 0FEh for specific country with code <255
	AL = 0FFh for specific country with code >= 255
	   BX = 16-bit country code
	DS:DX -> buffer for returned info (see below)
Return:	CF set on error
	    AX = error code (02h)
	CF clear if successful
	    BX = country code
	    DS:DX buffer filled
SeeAlso: AH=65h

Format of PCDOS 2.x country info:
Offset	Size	Description
 00h	WORD	date format  0 = USA	mm dd yy
			     1 = Europe dd mm yy
			     2 = Japan	yy mm dd
 02h	BYTE	currency symbol
 03h	BYTE	00h
 04h	BYTE	thousands separator char
 05h	BYTE	00h
 06h	BYTE	decimal separator char
 07h	BYTE	00h
 08h 24 BYTEs	reserved

Format of MSDOS 2.x, DOS 3+ country info:
Offset	Size	Description
 00h	WORD	date format (see above)
 02h  5 BYTEs	ASCIZ currency symbol string
 07h	BYTE	thousands separator char
 08h	BYTE	00h
 09h	BYTE	decimal separator char
 0Ah	BYTE	00h
 0Bh	BYTE	date separator char
 0Ch	BYTE	00h
 0Dh	BYTE	time separator char
 0Eh	BYTE	00h
 0Fh	BYTE	currency format
		bit 2 = set if currency symbol replaces decimal point
		bit 1 = number of spaces between value and currency symbol
		bit 0 = 0 if currency symbol precedes value
			1 if currency symbol follows value
 10h	BYTE	number of digits after decimal in currency
 11h	BYTE	time format
		bit 0 = 0 if 12-hour clock
			1 if 24-hour clock
 12h	DWORD	address of case map routine
		(FAR CALL, AL = char to map to upper case [>= 80h])
 16h	BYTE	data-list separator char
 17h	BYTE	00h
 18h 10 BYTEs	reserved
---------------------------------------------
INT 21 - DOS 3+ - SET COUNTRY CODE
	AH = 38h
	AL = 01h thru 0FEh for specific country with code <255
	AL = FFh for specific country with code >= 255
	   BX = 16-bit country code
	DX = FFFFh
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
---------------------------------------------
INT 21 - DOS 2+ - CREATE A SUBDIRECTORY (MKDIR)
	AH = 39h
	DS:DX -> ASCIZ pathname (may include drive)
Return: CF set on error
	    AX = error code (03h,05h) (see AH=59h)
SeeAlso: AH=3Ah,3Bh
---------------------------------------------
INT 21 - DOS 2+ - REMOVE A DIRECTORY ENTRY (RMDIR)
	AH = 3Ah
	DS:DX -> ASCIZ pathname (may include drive)
Return: CF set on error
	    AX = error code (03h,05h,06h,10h) (see AH=59h)
SeeAlso: AH=39h,3Bh
---------------------------------------------
INT 21 - DOS 2+ - CHANGE THE CURRENT DIRECTORY (CHDIR)
	AH = 3Bh
	DS:DX -> ASCIZ directory name (may include drive)
Return: CF set on error
	    AX = error code (03h) (see AH=59h)
Note:	if new directory name includes a drive letter, the default drive is
	  not changed, only the current directory on that drive
SeeAlso: AH=47h
---------------------------------------------
INT 21 - DOS 2+ - CREATE A FILE WITH HANDLE (CREAT)
	AH = 3Ch
	CX = attributes for file
	    bit 0: read-only
		1: hidden
		2: system
		3: volume label (ignored)
		4: reserved, must be zero (directory)
		5: archive bit
		7: if set, file is shareable under Novell NetWare
	DS:DX -> ASCIZ filename (may include drive and path)
Return: CF set on error
	    AX = error code (03h,04h,05h) (see AH=59h)
	CF clear if successful
	    AX = file handle
Note:	if a file with the given name exists, it is truncated to zero length
SeeAlso: AH=3Dh
---------------------------------------------
INT 21 - DOS 2+ - OPEN DISK FILE WITH HANDLE
	AH = 3Dh
	AL = access mode
	    00h read only
	    01h write only
	    02h read/write
	AL bits 7-3 = file-sharing modes (DOS 3+)
	    bit 7    = inheritance flag, set for no inheritance
	    bits 4-6 = sharing mode
		      000 compatibility mode
		      001 exclusive (deny all)
		      010 write access denied (deny write)
		      011 read access denied (deny read)
		      100 full access permitted (deny none)
	    bit 3    = reserved, should be zero
	DS:DX -> ASCIZ filename
Return: CF set on error
	    AX = error code (01h,02h,03h,04h,05h,0Ch) (see AH=59h)
	CF clear if successful
	    AX = file handle
Notes:	file pointer is set to start of file
	file handles which are inherited from a parent also inherit sharing
	  and access restrictions
SeeAlso: AH=0Fh,3Ch

File sharing behavior:
	  |	Second and subsequent Opens
 First	  |Compat  Deny	  Deny	 Deny	Deny
 Open	  |	   All    Write	 Read	None
	  |R W RW R W RW R W RW R W RW R W RW
 - - - - -| - - - - - - - - - - - - - - - - -
 Compat	R |Y Y Y  N N N  1 N N  N N N  1 N N
	W |Y Y Y  N N N  N N N  N N N  N N N
	RW|Y Y Y  N N N  N N N  N N N  N N N
 - - - - -|
 Deny	R |C C C  N N N  N N N  N N N  N N N
 All	W |C C C  N N N  N N N  N N N  N N N
	RW|C C C  N N N  N N N  N N N  N N N
 - - - - -|
 Deny	R |2 C C  N N N  Y N N  N N N  Y N N 
 Write	W |C C C  N N N  N N N  N N N  N N N 
	RW|C C C  N N N  N N N  N N N  N N N
 - - - - -|
 Deny	R |C C C  N N N  N Y N  N N N  N Y N
 Read	W |C C C  N N N  N N N  N N N  N Y N
	RW|C C C  N N N  N N N  N N N  N Y N
 - - - - -|
 Deny	R |2 C C  N N N  Y Y Y  N N N  Y Y Y
 None	W |C C C  N N N  N N N  Y Y Y  Y Y Y
	RW|C C C  N N N  N N N  N N N  Y Y Y
Legend: Y = open succeeds, N = open fails with error code 5
	C = open fails, INT 24 generated
	1 = open succeeds if file read-only, else fails with error code
	2 = open succeeds if file read-only, else fails with INT 24
---------------------------------------------
INT 21 - DOS 2+ - CLOSE A FILE WITH HANDLE
	AH = 3Eh
	BX = file handle
Return: CF set on error
	    AX = error code (06h) (see AH=59h)
Note:	if the file was written to, the time and date stamps are set to the
	  current time
SeeAlso: AH=10h,3Ch,3Dh
---------------------------------------------
INT 21 - DOS 2+ - READ FROM FILE WITH HANDLE
	AH = 3Fh
	BX = file handle
	CX = number of bytes to read
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (05h,06h) (see AH=59h)
	CF clear if successful
	    AX = number of bytes read (0 if at EOF before call)
Note:	the returned AX may be smaller than the request in CX if a partial
	  read occurred
	if reading from CON, read stops at first CR
SeeAlso: AH=27h,40h
---------------------------------------------
INT 21 - DOS 2+ - WRITE TO FILE WITH HANDLE
	AH = 40h
	BX = file handle
	CX = number of bytes to write
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (05h,06h) (see AH=59h)
	CF clear if successful
	    AX = number of bytes actually written
Note:	if CX is zero, no data is written, and the file is truncated or
	  extended to the current position
	the usual cause for AX < CX on return is a full disk
SeeAlso: AH=28h,3Fh
---------------------------------------------
INT 21 - DOS 2+ - DELETE A FILE (UNLINK)
	AH = 41h
	DS:DX -> ASCIZ pathname of file to delete (no wildcards allowed)
Return: CF set on error
	    AX = error code (02h,05h) (see AH=59h)
SeeAlso: AH=13h
---------------------------------------------
INT 21 - DOS 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
	AH = 42h
	AL = method
	    00h offset from beginning of file
	    01h offset from present location
	    02h offset from end of file
	BX = file handle
	CX:DX = offset in bytes
Return: CF set on error
	    AX = error code (01h,06h) (see AH=59h)
	CF clear if successful
	    DX:AX = new absolute offset from beginning of file
SeeAlso: AH=24h
---------------------------------------------
INT 21 - DOS 2+ - GET FILE ATTRIBUTES
	AX = 4300h
	DS:DX -> ASCIZ file name or directory name without trailing slash
Return: CF set on error
	    AX = error code (01h,02h,03h,05h) (see AH=59h)
	CF clear if successful
	    CX = file attributes (see AX=4301h)
---------------------------------------------
INT 21 - DOS 2+ - PUT FILE ATTRIBUTES (CHMOD)
	AX = 4301h
	CX = file attribute bits
	    bit 0 = read only
		1 = hidden file
		2 = system file
		3 = volume label
		4 = subdirectory
		5 = written since backup ("archive" bit)
		8 = shareable (Novell NetWare)
	DS:DX -> ASCIZ file name
Return: CF set on error
	    AX = error code (01h,02h,03h,05h) (see AH=59h)
Notes:	will not change volume label or directory attributes
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - GET DEVICE INFORMATION
	AX = 4400h
	BX = file or device handle
Return: CF set on error
	   AX = error code (see AH=59h)
	CF clear if successful
	   DX = device info
	   If bit 7 set: (character device)
	       bit 0: console input device
		   1: console output device
		   2: NUL device
		   3: CLOCK$ device
		   4: device is special
		   5: binary (raw) mode
		   6: Not EOF
		  12: network device (DOS 3+)
		  14: can process IOCTL control strings (see AL = 02h-05h)
	   If bit 7 clear: (file)
	       bits 0-5 are block device number
		   6: file has not been written
		  12: network device (DOS 3+)
		  14: ??? (DOS 3+)
		  15: file is remote (DOS 3+)
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - SET DEVICE INFORMATION
	AX = 4401h
	BX = device handle
	DH = 0
	DL = device information to set (bits 0-7 from function 0)
Return: CF set on error
	    AX = error code (see AH=59h)
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - READ CHARACTER DEVICE CONTROL STRING
	AX = 4402h
	BX = device handle
	CX = number of bytes to read
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX = number of bytes read
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - WRITE CHARACTER DEVICE CONTROL STRING
	AX = 4403h
	BX = device handle
	CX = number of bytes to write
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX = number of bytes written
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - READ BLOCK DEVICE CONTROL STRING
	AX = 4404h
	BL = drive number (0=default)
	CX = number of bytes to read
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX = number of bytes read
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - WRITE BLOCK DEVICE CONTROL STRING
	AX = 4405h
	BL = drive number (0=default)
	CX = number of bytes to write
	DS:DX -> buffer
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX = number of bytes written
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - GET INPUT STATUS
	AX = 4406h
	BX = file or device handle
Return: AL = FFh device ready
	     00h device not ready
---------------------------------------------
INT 21 - DOS 2+ - IOCTL - GET OUTPUT STATUS
	AX = 4407h
	BX = file or device handle
Return: AL = FFh device ready
	     00h device not ready
Note:	for DOS 2.x, files are always ready for output
---------------------------------------------
INT 21 - DOS 3+ - IOCTL - BLOCK DEVICE CHANGEABLE
	AX = 4408h
	BL = drive number (0=default)
Return: AX = 00h removable
	     01h fixed
	     0Fh invalid drive
---------------------------------------------
INT 21 - DOS 3+ - IOCTL - BLOCK DEVICE LOCAL
	AX = 4409h
	BL = drive number (0=default)
Return: DX = attribute word, bit 12 set if device is remote
---------------------------------------------
INT 21 - DOS 3+ - IOCTL - HANDLE LOCAL
	AX = 440Ah
	BX = file handle
Return: DX = attribute word, bit 15 set if file is remote
Note:	if file is remote, Novell Advanced NetWare 2.0 returns the number of
	the file server on which the handle is located in CX
---------------------------------------------
INT 21 - DOS 3+ - IOCTL - SET SHARING RETRY COUNT
	AX = 440Bh
	CX = delay (default 1)
	DX = retry count (default 3)
Return: CF set on error
	    AX = error code (see AH=59h)
---------------------------------------------
INT 21 - DOS 3.2+ - IOCTL - GENERIC
	AX = 440Ch
	BX = device handle
	CH = category code
	    00h unknown (DOS 3.3+)
	    01h COMn: (DOS 3.3+)
	    03h CON (DOS 3.3+)
	    05h LPTn:
	CL = function
	    45h set iteration count
	    4Ah select code page
	    4Ch start code-page preparation
	    4Dh end code-page preparation
	    5Fh set display information (DOS 4.0)
	    65h get iteration count
	    6Ah query selected code page
	    6Bh query prepare list
	    7Fh get display information (DOS 4.0)
	DS:DX -> parameter block (see below)
Return: CF set on error
	    AX = error code (see AH=59h)

Format of parameter block for function 45h:
Offset	Size	Description
 00h	WORD	number of times output is attempted before driver assumes
		device is busy

Format of parameter block for functions 4Ah and 6Ah:
Offset	Size	Description
 00h	WORD	length of data
 02h	WORD	code page ID
 04h 2N BYTEs	DCBS (double byte character set) lead byte range
		  start/end for each of N ranges (DOS 4.0)
	WORD	0000h  end of data (DOS 4.0)

Format of parameter block for function 4Dh:
Offset	Size	Description
 00h	WORD	length of data
 02h	WORD	code page ID

Format of parameter block for function 4Ch:
Offset	Size	Description
 00h	WORD	flags
 02h	WORD	length of remainder of parameter block
 04h	WORD	number of code pages following
 06h  N WORDs	code page 1,...,N

Format of parameter block for functions 5Fh and 7Fh:
Offset	Size	Description
 00h	BYTE	level (0 for DOS 4.0)
 01h	BYTE	reserved (0)
 02h	WORD	length of following data (14)
 04h	WORD	control flags
		  bit 0 set for blink, clear for intensity
		  bits 1 to 15 reserved
 06h	BYTE	mode type (1=text, 2=graphics)
 07h	BYTE	reserved (0)
 08h	WORD	colors
		   0 = monochrome
		   else N bits per pixel
 0Ah	WORD	pixel columns
 0Ch	WORD	pixel rows
 0Eh	WORD	character columns
 10h	WORD	character rows

Format of parameter block for function 6Bh:
Offset	Size	Description
 00h	WORD	length of following data
 02h	WORD	number of hardware code pages
 04h  N WORDs	hardware code pages 1,...,N
	WORD	number of prepared code pages
      N WORDs	prepared code pages 1,...,N
---------------------------------------------
INT 21 - DOS 3.2+ - IOCTL - BLOCK DEVICE REQUEST
	AX = 440Dh
	BL = drive number (0=default)
	CH = category code
	    08h disk drive
	CL = function
 	    40h set device parameters
	    41h write logical device track
	    42h format and verify logical device track
	    46h (DOS 4.0) set ???
	    47h (DOS 4.0) set access flag
	    60h get device parameters
	    61h read logical device track
	    62h verify logical device track
	    67h (DOS 4.0) get access flag
	DS:DX -> parameter block (see below)
Return: CF set on error
	   AX = error code (see AH=59h)
Note:	DOS 4.01 seems to ignore the high byte of the number of directory
	  entries in the BPB for diskettes.

Format of parameter block for functions 40h, 60h:
Offset	Size	Description
 00h	BYTE	special functions
		bit 0 set if function to use current BPB, clear if Device BIOS
			Parameter Block field contains new default BPB
		bit 1 set if function to use track layout fields only
			must be clear if CL=60h
		bit 2 set if all sectors in track same size (should be set)
		bits 3-7 reserved
 01h	BYTE	device type
		00h  320K/360K disk
		01h  1.2M disk
		02h  720K disk
		03h  single-density 8-inch disk
		04h  double-density 8-inch disk
		05h  fixed disk
		06h  tape drive
		07h  1.44M disk
		08h  other type of block device
 02h	WORD	device attributes
		bit 0 set if nonremovable medium
		bit 1 set if door lock supported
		bits 2-15 reserved
 04h	WORD	number of cylinders
 06h	BYTE	media type
		00h 1.2M disk (default)
		01h 320K/360K disk
 07h 31 BYTEs	device BPB (see AH=53h)
 26h	WORD	number of sectors per track (start of track layout field)
 28h  N word pairs: number,size of each sector in track

Format of parameter block for functions 41h, 61h:
Offset	Size	Description
 00h	BYTE	reserved, must be zero
 01h	WORD	number of disk head
 03h	WORD	number of disk cylinder
 05h	WORD	number of first sector to read/write
 07h	WORD	number of sectors
 09h	DWORD	transfer address

Format of parameter block for functions 42h, 62h:
Offset	Size	Description
 00h	BYTE	reserved, must be zero (DOS <3.2)
		  bit 0=0: format/verify track
			1: format status call (DOS 3.2+)
		  bits 1-7 reserved, must be zero
		on return (DOS 4.0):
		  bit 0: set if specified tracks, sectors/track supported
		  bit 1: set if function not supported by BIOS
		  bit 2: set if specified tracks, sectors/track not supported
		  bit 3: set if no disk in drive
 01h	WORD	number of disk head
 03h	WORD	number of disk cylinder

Format of parameter block for functions 47h, 67h:
Offset	Size	Description
 00h	BYTE	special-function field (must be zero)
 01h	BYTE	disk-access flag, nonzero if access allowed by driver
---------------------------------------------
INT 21 - DOS 3.2+ - IOCTL - GET LOGICAL DRIVE MAP
	AX = 440Eh
	BL = drive number (0=default)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AL = 00h block device has only one logical drive assigned
		 1..26 the last letter used to reference the drive (1=A:,etc)
---------------------------------------------
INT 21 - DOS 3.2+ - IOCTL - SET LOGICAL DRIVE MAP
	AX = 440Fh
	BL = physical drive number (0=default)
Return: CF set on error
	    AX = error code (see AH=59h)
Note:	maps logical drives to physical drives, similar to DOS's treatment of
	  a single physical floppy drive as both A: and B:
---------------------------------------------
INT 21 - DOS 2+ - CREATE DUPLICATE HANDLE (DUP)
	AH = 45h
	BX = file handle to duplicate
Return: CF set on error
	    AX = error code (04h,06h) (see AH=59h)
	CF clear if successful
	    AX = new file handle
Note:	moving file pointer for either handle will also move it for the other
SeeAlso: AH=46h
---------------------------------------------
INT 21 - DOS 2+ - FORCE DUPLICATE HANDLE (FORCDUP,DUP2)
	AH = 46h
	BX = existing file handle
	CX = new file handle
Return: CF set on error
	    AX = error code (04h,06h) (see AH=59h)
Notes:	closes file with handle BX if it is still open
	moving file pointer for either handle will also move it for the other
SeeAlso: AH=45h
---------------------------------------------
INT 21 - DOS 2+ - GET CURRENT DIRECTORY
	AH = 47h
	DL = drive (0=default, 1=A, etc.)
	DS:SI points to 64-byte buffer area
Return: CF set on error
	    AX = error code (0Fh) (see AH=59h)
Note:	the returned path does not include a drive or the initial backslash
SeeAlso: AH=3Bh
---------------------------------------------
INT 21 - DOS 2+ - ALLOCATE MEMORY
	AH = 48h
	BX = number of 16-byte paragraphs desired
Return: CF set on error
	    AX = error code (07h,08h) (see AH=59h)
	    BX = size of largest available block
	CF clear if successful
	    AX = segment of allocated memory block
SeeAlso: AH=49h,4Ah,58h
---------------------------------------------
INT 21 - DOS 2+ - FREE MEMORY
	AH = 49h
	ES = segment address of area to be freed
Return: CF set on error
	    AX = error code (07h,09h) (see AH=59h)
SeeAlso: AH=48h,4Ah
---------------------------------------------
INT 21 - DOS 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
	AH = 4Ah
	ES = segment address of block to change
	BX = new size in paragraphs
Return: CF set on error
	    AX = error code (07h,08h,09h) (see AH=59h)
	    BX = maximum size possible for the block (if AX=08h)
Notes:	under PCDOS 2.1 and 3.1 and MSDOS 3.2 and 3.3, if there is insufficient
	  memory to expand the block as much as requested, the block will be
	  made as large as possible
SeeAlso: AH=48h,49h
---------------------------------------------
INT 21 - DOS 2+ - LOAD OR EXECUTE (EXEC)
	AH = 4Bh
	AL = subfunction
	    00h load and execute program
	    01h load but do not execute (internal)
	    03h load overlay; do not create PSP
	    04h called by MSC spawn(P_NOWAIT,...) when running DOS 4.x.
		returns unsuccessfully under DOS 4.0 (but may be successful
		  in the original European OEM MSDOS 4.0, which has limited
		  multitasking built in)
	DS:DX -> ASCIZ filename
	ES:BX -> parameter block (see below)
Return: CF set on error
	    AX = error code (01h,02h,05h,08h,0Ah,0Bh) (see AH=59h)
	CF clear if successful
	    if function 1 and DOS 3+ or DESQview, process ID set to new
		program's PSP; get with INT 21/AH=62h
	    if function 1 and DOS 2.x, new program's initial stack and 
		entry point returned in registers
Notes:	DOS 2.x destroys all registers, including SS:SP
	for functions 00h and 01h, the calling process must ensure that there
	  is enough unallocated memory available, if necessary by releasing
	  memory with AH=49h or AH=4Ah
SeeAlso: AH=4Ch,4Dh,INT 2E

Format of EXEC parameter block for AL=00h:
Offset	Size	Description
 00h	WORD	segment of environment (0 = use current) (see AH=26h)
 02h	DWORD	pointer to command line
 06h	DWORD	pointer to first FCB (see AH=0Fh)
 0Ah	DWORD	pointer to second FCB (see AH=0Fh)

Format of EXEC parameter block for AL=01h:
Offset	Size	Description
 00h	WORD	segment of environment (0 = use current) (see AH=26h)
 02h	DWORD	pointer to command line
 06h	DWORD	pointer to first FCB (see AH=0Fh)
 0Ah	DWORD	pointer to second FCB (see AH=0Fh)
 0Eh	DWORD	(DOS 3+) will hold subprogram's initial SS:SP on return
 12h	DWORD	(DOS 3+) will hold entry point (CS:IP) on return

Format of EXEC parameter block for AL=03h:
Offset	Size	Description
 00h	WORD	segment load address
 02h	WORD	segment relocation factor

Format of .EXE file header:
Offset	Size  Description
 00h	WORD  4Dh, 5Ah signature (sometimes 5Ah, 4Dh)
 02h	WORD  image size remainder (program size mod 512, not including header)
 04h	WORD  number of 512-byte pages needed to hold .EXE file (incl header)
 06h	WORD  number of relocation items
 08h	WORD  header size in paragraphs
 0Ah	WORD  minimum extra paragraphs needed
 0Ch	WORD  maximum extra paragraphs needed
 0Eh	WORD  stack segment
 10h	WORD  stack offset
 12h	WORD  word checksum of entire file
 14h	DWORD initial CS:IP
 18h	WORD  offset of relocation table 
 1Ah	WORD  overlay number
Note:	if word at offset 02h is 4, it should be treated as 00h, since pre-1.10
	  versions of the MS linker set it that way
---------------------------------------------
INT 21 - DOS 2+ - QUIT WITH EXIT CODE (EXIT)
	AH = 4Ch
	AL = exit code
Return: never returns
Note:	unless the process is its own parent (see AH=26h, offset 16h in PSP),
	  all open files are closed
SeeAlso: AH=4Bh,4Dh
---------------------------------------------
INT 21 - DOS 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
	AH = 4Dh
Return: AL = exit code of subprogram (from AH=31h or AH=4Ch)
	AH = circumstance which caused termination
	    00h Terminate/abort
	    01h Control-C/Control-Break
	    02h Hard error
	    03h Terminate and stay resident
SeeAlso: AH=4Bh,4Ch
---------------------------------------------
INT 21 - WILDUNIX.COM internal - INSTALLATION CHECK
	AH = 4Eh
	DS:DX = 0000h:0000h
Return:	AH = 99h if installed
Note:	WILDUNIX.COM is a resident Unix-style wildcard expander by Steve
	  Hosgood and Terry Barnaby
---------------------------------------------
INT 21 - DOS 2+ - FIND FIRST ASCIZ (FIND FIRST)
	AH = 4Eh
	CX = search attributes
	DS:DX -> ASCIZ filespec (drive, path, and wildcards allowed)
Return: CF set on error
	    AX = error code (02h,12h) (see AH=59h)
	CF clear if successful
	    [DTA] = data block (see below)
SeeAlso: AH=11h,4Fh

Format of FindFirst data block:
Offset	Size	Description
---PCDOS 3.10, MSDOS 3.2/3.3---
 00h	BYTE	drive letter
 01h 11 BYTEs	search template
 0Ch	BYTE	search attributes
---DOS 2.x (and some DOS 3.x???)---
 00h	BYTE	search attributes
 01h	BYTE	drive letter
 02h 11 BYTEs	search template
---WILDUNIX.COM---
 00h 12 BYTEs	15-character wildcard search pattern and drive letter (packed)
 0Ch	BYTE	search attributes
---DOS 2.x and most 3.x---
 0Dh	WORD	entry count within directory
 0Fh	DWORD	pointer to DTA???
 13h	WORD	cluster number of start of parent directory
---MSDOS 3.2/3.3---
 0Dh	WORD	entry count within directory
 0Fh	WORD	cluster number of start of parent directory
 11h  4 BYTEs	reserved
---all versions, documented fields---
 15h	BYTE	attribute of file found
 16h	WORD	file time
		    bits 11-15: hour
		    bits 5-10:	minute
		    bits 0-4:	seconds/2
 18h	WORD	file date
		    bits 9-15:	year-1980
		    bits 5-8:	month
		    bits 0-4:	day
 1Ah	DWORD	file size
 1Eh 13 BYTEs	ASCIZ filename+extension
---------------------------------------------
INT 21 - DOS 2+ - FIND NEXT ASCIZ (FIND NEXT)
	AH = 4Fh
	[DTA] = data block from last AH = 4Eh/4Fh call
Return: CF set on error
	    AX = error code (12h) (see AH=59h)
	CF clear if successful
	    [DTA] = data block (see AH=4Eh)
SeeAlso: AH=12h,4Eh
---------------------------------------------
INT 21 - DOS 2+ internal - SET PSP SEGMENT
	AH = 50h
	BX = segment address of new PSP (see AH=26h)
Notes:	under DOS 2.x, this function cannot be invoked inside an INT 28h
	  handler without setting the Critical Error flag
	under DOS 3+, this function does not use any of the DOS-internal stacks
	  and is thus fully reentrant
SeeAlso: AH=51h,62h
---------------------------------------------
INT 21 - DOS 2+ internal - GET PSP SEGMENT
	AH = 51h
Return: BX = current PSP segment (see AH=26h)
Notes:	under DOS 2.x, this function cannot be invoked inside an INT 28h
	  handler without setting the Critical Error flag
	under DOS 3+, this function does not use any of the DOS-internal stacks
	  and is thus fully reentrant
SeeAlso: AH=26h,50h,62h
---------------------------------------------
INT 21 - DOS 2+ internal - GET LIST OF LISTS
	AH = 52h
Return: ES:BX points to DOS list of lists
Note:	not supported in OS/2 compatibility box

Format of List of Lists:
Offset	Size	Description
 -12	WORD	(DOS 3.1-3.3) sharing retry count (see AX=440Bh)
 -10	WORD	(DOS 3.1-3.3) sharing retry delay (see AX=440Bh)
 -8	DWORD	(DOS 3.x) pointer to current disk buffer
 -4	WORD	(DOS 3.x) ???  (default 0000h)
 -2	WORD	segment of first memory control block
 00h	DWORD	pointer to first DOS Device Control Block (see AH=32h)
 04h	DWORD	pointer to list of DOS file tables (see below)
 08h	DWORD	pointer to CLOCK$ device driver, resident or installable
 0Ch	DWORD	pointer to actual CON device driver, resident or installable
---DOS 2.x---
 10h	BYTE	number of logical drives in system
 11h	WORD	maximum bytes/block of any block device
 13h	DWORD	pointer to first disk buffer (see below)
 17h	Beginning (not a pointer--the real beginning!) of NUL device driver.
	This is the first device on DOS's linked list of device drivers.
	(see below for format)
---DOS 3.0---
 10h	BYTE	number of block devices
 11h	WORD	maximum bytes/block of any block device
 13h	DWORD	pointer to first disk buffer (see below)
 17h	DWORD	pointer to array of drive info (see below)
 1Bh	BYTE	value of LASTDRIVE command in CONFIG.SYS (default 5)
 1Ch	DWORD	pointer to STRING= workspace area
 20h	WORD	size of STRING area (the x in STRING=x from CONFIG.SYS)
 22h	DWORD	pointer to FCB table
 26h	WORD	the y in FCBS=x,y from CONFIG.SYS
 28h	Beginning (not a pointer--the real beginning!) of NUL device driver.
	This is the first device on DOS's linked list of device drivers.
	(see below for format)
---DOS 3.1-3.3---
 10h	WORD	maximum bytes/block of any block device
 12h	DWORD	pointer to first disk buffer (see below)
 16h	DWORD	pointer to array of drive info (see below)
 1Ah	DWORD	pointer to FCB table (if CONFIG.SYS contains FCBS=)
 1Eh	WORD	number of protected FCBs (the y in FCBS=x,y)
 20h	BYTE	number of block devices
 21h	BYTE	value of LASTDRIVE command in CONFIG.SYS (default 5)
 22h 18 BYTEs	actual NUL device driver header (not a pointer!)
		This is the first device on DOS's linked list of device 
		drivers. (see below for format)
 34h	BYTE	number of JOIN'ed drives
---DOS 4.x---
 10h	WORD	maximum bytes/block of any block device
 12h	DWORD	pointer to disk buffer info (see below)
 16h	DWORD	pointer to array of drive info (see below)
 1Ah	DWORD	pointer to FCB table (if CONFIG.SYS contains FCBS=)
 1Eh	WORD	number of protected FCBs (the y in FCBS=x,y)
 20h	BYTE	number of block devices
 21h	BYTE	value of LASTDRIVE command in CONFIG.SYS (default 5)
 22h 18 BYTEs	actual NUL device driver header (not a pointer!)
		This is the first device on DOS's linked list of device 
		drivers. (see below for format)
 34h	BYTE	number of JOIN'ed drives???
 35h	WORD	pointer within IBMDOS code segment to list of special program
		names
 37h	DWORD	pointer to ???
 3Bh    DWORD	pointer to chain of IFS (installable file system) drivers
 3Fh	WORD	the x in BUFFERS x,y (rounded up to multiple of 30 if in EMS)
 41h	WORD	the y in BUFFERS x,y
 43h	BYTE	boot drive??? (1=A:)
 44h	BYTE	??? seems always to be zero
 45h	BYTE	flags???
		   bit 7: MCA??? (clear on XT,AT,PS/2-30, set on PS/2-50,60)
 46h	BYTE	???

Format of memory control block:
Offset	Size	Description
 00h	BYTE	block type: 5Ah if last block in chain, otherwise 4Dh
 01h	WORD	PSP segment of owner, 0000h if free, 0008h if belongs to DOS
 03h	WORD	size of memory block in paragraphs
 05h  3 BYTEs	unused
---DOS 2.x,3.x---
 08h  8 BYTEs	unused
---DOS 4.x---
 08h  8 BYTEs	ASCII program name if PSP memory block, else garbage
		null-terminated if less than 8 characters
Notes:	under DOS 3.1+, the first memory block is the DOS data segment,
	  containing installable drivers, buffers, etc.
	under DOS 4.x it is divided into subsegments, each with its own memory
	  control block (see below), the first of which is at offset 0000h

Format of DOS 4.x data segment subsegment control blocks:
Offset	Size	Description
 00h	BYTE	subsegment type (blocks typically appear in this order)
		"D"  device driver
		"E"  device driver appendage
		"I"  IFS (Installable File System) driver
		"F"  FILES=  control block storage area (for FILES>5)
		"X"  FCBS=   control block storage area, if present
		"C"  BUFFERS EMS workspace area (if BUFFERS /X option used)
		"B"  BUFFERS=  storage area
		"L"  LASTDRIVE=  drive info table storage area
		"S"  STACKS=  code and data area, if present (see below)
 01h	WORD	paragraph of subsegment start (usually the next paragraph)
 03h	WORD	size of subsegment in paragraphs
 05h  3 BYTEs	unused
 08h  8 BYTEs	for types "D" and "I", base name of file from which the driver
		  was loaded (unused for other types)

Format of data at start of STACKS code segment (if present):
Offset  Size    Description
 00h    WORD    ???
 02h    WORD    number of stacks (the x in STACKS=x,y)
 04h    WORD    size of stack control block array (should be 8*x)
 06h    WORD    size of each stack (the y in STACKS=x,y)
 08h    DWORD   ptr to STACKS data segment
 0Ch    WORD    offset in STACKS data segment of stack control block array
 0Eh    WORD    offset in STACKS data segment of last element of that array
 10h    WORD    offset in STACKS data segment of the entry in that array for
                the next stack to be allocated (initially same as value in 0Eh
                and works its way down in steps of 8 to the value in 0Ch as
                hardware interrupts pre-empt each other)
Note:	the STACKS code segment data may, if present, be located as follows:
    DOS 3.2:    The code segment data is at a paragraph boundary fairly early
                in the IBMBIO segment (seen at 0070:0190h)
    DOS 3.3:    The code segment is at a paragraph boundary in the DOS data
                segment, which may be determined by inspecting the segment
                pointers of the vectors for those of interrupts 02h, 08h-0Eh,
                70h, 72-77h which have not been redirected by device drivers or
                TSRs.
    DOS 4.x:    Identified by sub-segment control block type "S" within the DOS
                data segment.

Format of array elements in STACKS data segment:
Offset  Size    Description
 00h    BYTE    status: 00h=free, 01h=in use, 03h=corrupted by overflow of
                higher stack.
 01h    BYTE    not used
 02h    WORD    previous SP
 04h    WORD    previous SS
 06h    WORD    ptr to word at top of stack (new value for SP). The word at the
                top of the stack is preset to point back to this control block.

SHARE.EXE hooks (DOS 3.1-4.01):
(offsets from first system file table--pointed at by ListOfLists+04h)
Offset	Size	Description
-3Ch	DWORD	pointer to FAR routine for ???
-38h	DWORD	pointer to FAR routine for ???
-34h	DWORD	pointer to FAR routine called on closing file???
-30h	DWORD	pointer to FAR routine for ??? (called by AX=5D03h)
-2Ch	DWORD	pointer to FAR routine for ??? (called by AX=5D04h)
-28h	DWORD	pointer to FAR routine for ??? (called by AX=5D02h)
-24h	DWORD	pointer to FAR routine to lock region of file
		call with BX = file handle
			  CX:DX = starting offset
			  SI:AX = size
		Return: CF set on error
			    AL = DOS error code (see AH=59h)
		Note: only called if file is marked as remote
-20h	DWORD	pointer to FAR routine to unlock region of file
		call with BX = file handle
			  CX:DX = starting offset
			  SI:AX = size
		Return: CF set on error
			    AL = DOS error code (see AH=59h)
		Note: only called if file is marked as remote
-1Ch	DWORD	pointer to FAR routine to check if file region is locked
		call with ES:DI -> system file table entry for file
			CX = length of region from current position in file
		Return: CF set if any portion of region locked
			    AX = 0021h
-18h	DWORD	pointer to ??? (called by AX=5D05h)
		Return: CF set on error or not loaded
			CF clear if successful
			    ES:DI -> ???
			    CX = ???
			    DX = ???
-14h	DWORD	pointer to FAR routine for opening FCB???
		call with ES:DI -> unopened FCB
			  DS:SI -> system file table entry
		Return: BL = C0h???
		Note: calls following fields from FCB to SFT:
	           starting cluster of file       1Ah	 0Bh
		   sharing record offset	  1Ch	 33h
		   file attribute		  1Eh	 04h
-10h	DWORD	pointer to FAR routine for ???
		call with ES:DI -> system file table entry
			  DS:SI -> FCB
		Return: CF set if SFT closed or sharing record offsets
				mismatched
			CF clear if successful
			    BX = starting cluster number from FCB
-0Ch	DWORD	pointer to FAR routine for ???
		Note: called during open/create of a file
-08h	DWORD	pointer to FAR routine for ???
-04h	DWORD	pointer to FAR routine to update directory info in related SFT
		  entries
		call with ES:DI -> system file table entry for file (see below)
			  AX = subfunction
				00h: update time stamp (offset 0Dh) and date
				     stamp (offset 0Fh)
				01h: update file size (offset 11h) and starting
				     cluster (offset 0Bh).  Under some
				     circumstances sets last read cluster
				     fields to start of file
				02h: as function 01h, but last-read fields
				     always changed
				03h: do both functions 00h and 02h
		Note: follows ptr at offset 2Bh in system file table entries

Format of DOS 2.x system file tables:
Offset	Size	Description
 00h	DWORD	pointer to next file table
 04h	WORD	number of files in this table
 06h  28h bytes per file
	Offset	Size	Description
	 00h	BYTE	number of file handles referring to this file
	 01h	BYTE	file open mode (see AH=3Dh)
	 02h	BYTE	file attribute
	 03h	BYTE	drive (0 = character device, 1 = A, 2 = B, etc)
	 04h 11 BYTEs	filename in FCB format (no path,no period,blank-padded)
	 0Fh	WORD	???
	 11h	WORD	???
	 13h	DWORD	file size???
	 17h	WORD	file date in packed format (see AX=5700h)
	 19h	WORD	file time in packed format (see AX=5700h)
	 1Bh	BYTE	device attribute (see AX=4400h)
	---character device---
	 1Ch	DWORD	pointer to device driver
	---block device---
	 1Ch	WORD	starting cluster of file
	 1Eh	WORD	relative cluster in file of last cluster read
	------
	 20h	WORD	absolute cluster number of current cluster
	 22h	WORD	???
	 24h	DWORD	current file position???

Format of DOS 3.x system file tables and FCB tables:
Offset	Size	Description
 00h	DWORD	pointer to next file table
 04h	WORD	number of files in this table
 06h  35h bytes per file
	Offset	Size	Description
	 00h	WORD	number of file handles referring to this file
	 02h	WORD	file open mode (see AH=3Dh)
			bit 15 set if this file opened via FCB
	 04h	BYTE	file attribute
	 05h	WORD	device info word (see AX=4400h)
	 07h	DWORD	pointer to device driver header if character device
			else pointer to DOS Device Control Block (see AH=32h)
	 0Bh	WORD	starting cluster of file
	 0Dh	WORD	file time in packed format (see AX=5700h)
	 0Fh	WORD	file date in packed format (see AX=5700h)
	 11h	DWORD	file size
	 15h	DWORD	current offset in file
	 19h	WORD	relative cluster within file of last cluster read
	 1Bh	WORD	absolute cluster number of last cluster read
	 1Dh	WORD	number of sector containing directory entry
	 1Fh	BYTE	number of dir entry within sector (byte offset/32)
	 20h 11 BYTEs	filename in FCB format (no path/period, blank-padded)
	 2Bh    DWORD	(SHARE.EXE) pointer to previous SFT sharing same file
	 2Fh	WORD	(SHARE.EXE) network machine number which opened file???
	 31h	WORD	PSP segment of file's owner (see AH=26h)
	 33h	WORD	offset within SHARE.EXE code segment of 
			sharing record (see below)  0000h = none

Format of DOS 4+ system file tables and FCB tables:
Offset	Size	Description
 00h	DWORD	pointer to next file table
 04h	WORD	number of files in this table
 06h  3Bh bytes per file
	Offset	Size	Description
	 00h	WORD	number of file handles referring to this file
	 02h	WORD	file open mode (see AH=3Dh)
			bit 15 set if this file opened via FCB
	 04h	BYTE	file attribute
	 05h	WORD	device info word (see AX=4400h)
	 07h	DWORD	pointer to device driver header if character device
			else pointer to DOS Device Control Block (see AH=32h)
	 0Bh	WORD	starting cluster of file
	 0Dh	WORD	file time in packed format (see AX=5700h)
	 0Fh	WORD	file date in packed format (see AX=5700h)
	 11h	DWORD	file size
	 15h	DWORD	current offset in file
	---local file---
	 19h	WORD	relative cluster within file of last cluster read
	 1Bh	DWORD	number of sector containing directory entry
	 1Fh	BYTE	number of dir entry within sector (byte offset/32)
	---network redirector---
	 19h	DWORD	pointer to REDIRIFS record
	 1Dh  3 BYTEs	???
	------
	 20h 11 BYTEs	filename in FCB format (no path/period, blank-padded)
	 2Bh    DWORD	(SHARE.EXE) pointer to previous SFT sharing same file
	 2Fh	WORD	(SHARE.EXE) network machine number which opened file???
	 31h	WORD	PSP segment of file's owner (see AH=26h)
	 33h	WORD	offset within SHARE.EXE code segment of 
			sharing record (see below)  0000h = none
	 35h	WORD	(local) absolute cluster number of last cluster read
			(redirector) ???
	 37h	DWORD	pointer to IFS driver for file, 0000000h if native DOS

Format of sharing record:
Offset	Size	Description
 00h	BYTE	flag
		00h free block
		01h allocated block
 01h	WORD	size of block
 03h	BYTE	???
 04h	WORD	offset in SHARE's DS of lock record (see below)
 06h	DWORD	pointer to start of system file table chain for file
 0Ah	WORD	???
 0Ch	var	ASCIZ full pathname

Format of SHARE.EXE lock record:
Offset	Size	Description
 00h	WORD	offset in SHARE's DS of next lock table in list
 02h	DWORD	offset in file of start of locked region
 06h	DWORD	offset in file of end of locked region
 0Ah	DWORD	pointer to System File Table entry for this file
 0Eh	WORD	??? 0 appears to mean 'in use'

Format of drive info table (array, 51h bytes [58h for DOS 4.x] per drive):
Offset	Size	Description
 00h 67 BYTEs	current path as ASCIZ, starting with 'x:\'
 43h	WORD	bit flags
		bit 15: network drive	\ installable file system if both set
		bit 14: physical drive	/ invalid drive if neither bit set
		bit 13: JOIN'ed, current path is actual path without JOIN
			drive letter in path may differ from logical drive name
		bit 12: SUBST'ed, current path is actual path without SUBST
			drive letter in path may differ from logical drive name
 45h	DWORD	pointer to DOS Disk Block for this drive
---local drives---
 49h	WORD	starting cluster of current dir
		0000h = root, FFFFh never accessed
 4Bh	WORD	??? seems always to be FFFFh
 4Dh	WORD	??? seems always to be FFFFh
---network drives---
 49h	DWORD	pointer to a REDIRIFS record, else FFFFFFFFh
 4Dh	WORD	????
------
 4Fh	WORD	Offset of '\' in current path field representing root directory 
		of logical drive (2 if not SUBST'ed or JOIN'ed, otherwise 
		number of bytes in SUBST/JOIN path)
---DOS 4.x---
 51h	BYTE	??? used by network
 52h	DWORD	pointer to IFS driver for this drive, 00000000h if native DOS
 56h	WORD	???

Format of device driver header:
Offset	Size	Description
 00h	DWORD	pointer to next driver, offset=FFFFh if last driver
 04h	WORD	device attributes
		Character device:
		   bit 15  set
		   bit 14  IOCTL supported (see AH=44h)
		   bit 13  output until busy supported
		   bit 12  reserved
		   bit 11  OPEN/CLOSE/RemMedia calls supported
		   bits 10-7 reserved
		   bit 6  Generic IOCTL call supported (command 13h)
				(see AX=440Ch,440Dh)
		   bit 5  reserved
		   bit 4  device is special (use INT 29 "fast console output")
		   bit 3  device is CLOCK$
		   bit 2  device is NUL
		   bit 1  device is standard output
		   bit 0  device is standard input
		Block device:
		   bit 15  clear
		   bit 14  IOCTL supported
		   bit 13  non-IBM format
		   bit 12  reserved
		   bit 11  OPEN/CLOSE/RemMedia calls supported
		   bit 10  reserved
		   bit 9   ??? set by DOS 3.3 DRIVER.SYS for "new" drives
		   bit 8   ??? set by DOS 3.3 DRIVER.SYS for "new" drives
		   bit 7   reserved
		   bit 6  Generic IOCTL call supported (command 13h)
				implies support for commands 17h and 18h
				(see AX=440Ch,440Dh,440Eh,440Fh)
		   bits 5-2 reserved
		   bit 1   driver supports 32-bit sector addressing
		   bit 0   reserved
 06h	WORD	device strategy entry point
		call with ES:BX -> request header (see INT 2F/AX=1510h)
 08h	WORD	device interrupt entry point
 0Ah  8 BYTEs	blank-padded character device name
 12h	WORD	(CD-ROM driver) reserved, must be 0000h
 14h	BYTE	(CD-ROM driver) drive letter (must initially be 00h)
 15h	BYTE	(CD-ROM driver) number of units
 16h  6 BYTEs	(CD-ROM driver) signature 'MSCDnn' where 'nn' is version 
			(currently '00')

Format of DOS 2.x disk buffer:
Offset	Size	Description
 00h	DWORD	pointer to next disk buffer, offset = FFFFh if last
 04h	BYTE	drive (0=A, 1=B, etc), FFh if not in use
 05h  3 BYTEs	unused??? (seems always to be 00h 00h 01h)
 08h	WORD	logical sector number
 0Ah	BYTE	number of copies to write (1 for non-FAT sectors)
 0Bh	BYTE	sector offset between copies if multiple copies to be written
 0Ch	DWORD	pointer to DOS Device Control Block (see AH=32h)
 10h		buffered data

Format of DOS 3.x disk buffer:
Offset	Size	Description
 00h	DWORD	pointer to next disk buffer, offset = FFFFh if last
 04h	BYTE	drive (0=A,1=B, etc), FFh if not in use
 05h	BYTE	flags
		bit 7: ???
		bit 6: buffer dirty
		bit 5: buffer in use
		bit 4: ???
		bit 3: sector in data area
		bit 2: sector in a directory, either root or subdirectory
		bit 1: sector in FAT
		bit 0: boot sector??? (guess)
 06h	WORD	logical sector number
 08h	BYTE	number of copies to write (1 for non-FAT sectors)
 09h	BYTE	sector offset between copies if multiple copies to be written
 0Ah	DWORD	pointer to DOS Device Control Block (see AH=32h)
 0Eh	WORD	unused??? (almost always 0)
 10h		buffered data

Format of DOS 4.00 disk buffer info:
Offset	Size	Description
 00h	DWORD	pointer to array of chain heads (see below)
 04h	WORD	number of disk buffer chains (referred to as NDBCH below)
 06h	DWORD	pointer to lookahead buffer, zero if not present
 0Ah	BYTE	number of lookahead sectors, else zero (the y in BUFFERS=x,y)
 0Bh	WORD	??? seems always to be zero
 0Dh	WORD	EMS handle for buffers, zero if not in EMS
 0Fh	WORD	EMS physical page number used for buffers (usually 255)
 11h	WORD	??? seems always to be 1
 13h	WORD	segment of EMS physical page frame
 15h	WORD	??? seems always to be zero
 17h  4 WORDs	EMS partial page mapping information???

Format of DOS 4.01 (from UR 25066 on) disk buffer info:
Offset	Size	Description
 00h	DWORD	pointer to array of chain heads (see below)
 04h	WORD	number of disk buffer chains (referred to as NDBCH below)
 06h	DWORD	pointer to lookahead buffer, zero if not present
 0Ah	BYTE	number of lookahead sectors, else zero (the y in BUFFERS=x,y)
 0Bh  9 BYTEs	???
 14h	DWORD	pointer to workspace buffer, purpose ???, allocated in main
		memory if BUFFERS/XS or /XD options in effect
 18h	WORD	EMS handle for buffers, zero if not in EMS
 1Ah	WORD	EMS physical page number used for buffers (usually 255)
 1Ch	WORD	??? seems always to be 1
 1Eh	WORD	segment of EMS physical page frame
 20h	WORD	??? seems always to be zero

Format of DOS 4.x disk buffer chain head (array, one entry per chain):
Offset	Size	Description
 00h	WORD	EMS logical page number in which chain is resident, garbage if
		not using EMS
 02h	DWORD	pointer to least recently used buffer header.  All buffers on
		this chain are in the same segment.
 06h	WORD	number of dirty buffers on this chain???
Note:	buffered disk sectors are assigned to chain N where N is the sector's
	  address modulo NDBCH,  0 <= N <= NDBCH-1
	each chain resides completely within one EMS page
	this structure is in main memory even if buffers are in EMS

Format of DOS 4.x disk buffer:
Offset	Size	Description
 00h	WORD	forward ptr, offset only, to next least recently used buffer
 02h	WORD	backward ptr, offset only
 04h	BYTE	drive (0=A,1=B, etc), FFh if not in use
 05h	BYTE	flags
		bit 7: ???
		bit 6: buffer dirty???
		bit 5: buffer in use???
		bit 4: ???
		bit 3: sector in data area
		bit 2: sector in a directory, either root or subdirectory
		bit 1: sector in FAT
		bit 0: ???
 06h	DWORD	logical sector number
 0Ah	BYTE	number of copies to write
		for FAT sectors, same as number of FATs
		for data and directory sectors, usually 1
 0Bh	WORD	offset in sectors between copies to write for FAT sectors
 0Dh	DWORD	pointer to DOS Device Control Block (see AH=32h)
 11h  3 BYTEs	??? zero or unset garbage
 14h		buffered data
Note:	all buffered sectors which have the same address modulo NDBCH are on
	  the same doubly-linked circular chain
	the links consist of offset addresses only, the segment being the same
	  for all buffers in the chain.
---------------------------------------------
INT 21 - DOS 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
	AH = 53h
	DS:SI -> BPB (Bios Parameter Block)
	ES:BP -> buffer for DOS Disk Block
Note:	translates BPB (see below) into a DOS Disk Block (see AH=32h)

Format of BIOS Parameter Block:
Offset	Size	Description
 00h	WORD	bytes/sector. Get from DDB bytes 2-3.
 02h	BYTE	sectors/cluster. Get from (DDB byte 4) + 1
 03h	WORD	reserved sectors. Get from DDB bytes 6-7
 05h	BYTE	number of FATs. Get from DDB byte 8
 06h	WORD	number of root dir entries. Get from DDB bytes 09h-0Ah
 08h	WORD	total number of sectors. Get from:
		  ((DDB bytes 0Dh-0Eh) - 1) * (sectors/cluster (BPB byte 2))
		    + (DDB Bytes 0Bh-0Ch)
		for DOS 4.0, set to zero if partition >32M, then set DWORD at
		  15h to actual number of sectors
 0Ah	BYTE	media descriptor byte. Get from DDB byte 16h
 0Bh	WORD	number of sectors/FAT. Get from DDB byte 0Fh
---DOS 3+---
 0Dh	WORD	number of sectors per track
 0Fh	WORD	number of heads
 11h	DWORD	number of hidden sectors
 15h 11 BYTEs	reserved	
---DOS 4.0---
 15h	DWORD	total number of sectors if word at 08h contains zero
---------------------------------------------
INT 21 - DOS 2+ - GET VERIFY FLAG
	AH = 54h
Return: AL = 00h if flag OFF
	AL = 01h if flag ON
SeeAlso: AH=2Eh
---------------------------------------------
INT 21 - DOS 2+ internal - CREATE PSP
	AH = 55h
	DX = segment number at which to set up PSP (see AH=26h)
	SI = value to place in memory size field at DX:[0002h]
Note:	like AH=26h but creates "child" PSP rather than copying existing one
SeeAlso: AH=26h
---------------------------------------------
INT 21 - DOS 2+ - RENAME A FILE
	AH = 56h
	DS:DX -> ASCIZ old name (drive and path allowed, no wildcards)
	ES:DI -> ASCIZ new name
Return: CF set on error
	    AX = error code (02h,03h,05h,11h) (see AH=59h)
Note:	allows move between directories on same logical volume
	(DOS 3+) allows renaming of directories
SeeAlso: AH=17h
---------------------------------------------
INT 21 - DOS 2+ - GET FILE'S DATE/TIME
	AX = 5700h
	BX = file handle
Return: CF set on error
	    AX = error code (01h,06h) (see AH=59h)
	CF clear if successful
	    CX = time of last write
		bits 11-15: hour
		     5-10:  minute
		     0-4:   seconds/2
	    DX = date of last write
		bits 9-15:   year-1980
		     5-8:    month
		     0-4:    day
---------------------------------------------
INT 21 - DOS 2+ - SET FILE'S DATE/TIME
	AX = 5701h
	BX = file handle
	CX = time to be set (see AX=5700h)
	DX = date to be set (see AX=5700h)
Return: CF set on error
	    AX = error code (01h,06h) (see AH=59h)
---------------------------------------------
INT 21 - DOS 4.0 - ???
	AX = 5702h
	???
Return: ???
---------------------------------------------
INT 21 - DOS 4.0 - ???
	AX = 5704h
	???
Return: ???
---------------------------------------------
INT 21 - DOS 3+ - GET/SET MEMORY ALLOCATION STRATEGY
	AH = 58h
	AL = function code
	    00h get allocation strategy
	    01h set allocation strategy
	       BL = strategy code
		   00h first fit (use first memory block large enough)
		   01h best fit (use smallest memory block large enough)
		   02h last fit (use high part of last usable memory block)
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
	CF clear if successful
	    AX = strategy code
Note: the Set subfunction accepts any value in BL; 2 or greater means last fit.
      the Get subfunction returns the last value set, so programs should check
      whether the value is >= 2, not just equal to 2.
SeeAlso: AH=48h,49h,4Ah
---------------------------------------------
INT 21 - DOS 3+ - GET EXTENDED ERROR CODE
	AH = 59h
	BX = version code (0000h for DOS 3.x)
Return: AX = extended error code (see below)
	BH = class of error (see below)
	BL = suggested action (see below)
	CH = locus (where error occurred) (see below)
	CL, DX, SI, DI, BP, DS, and ES destroyed
SeeAlso: AX=5D0Ah

Values for extended error code:
	01h function number invalid
	02h file not found
	03h path not found
	04h too many open files (no handles available)
	05h access denied
	06h invalid handle
	07h memory control block destroyed
	08h insufficient memory
	09h memory block address invalid
	0Ah environment invalid (usually >32K in length)
	0Bh format invalid
	0Ch access code invalid
	0Dh data invalid
	0Fh invalid drive
	10h attempted to remove current directory
	11h not same device
	12h no more files
	13h disk write-protected
	14h unknown unit
	15h drive not ready
	16h unknown command
	17h data error (CRC)
	18h bad request structure length
	19h seek error
	1Ah unknwon media type (non-DOS disk)
	1Bh sector not found
	1Ch printer out of paper
	1Dh write fault
	1Eh read fault
	1Fh general failure
	20h sharing violation
	21h lock violation
	22h disk change invalid
	    ES:DI -> ASCIZ volume label of required disk
	23h FCB unavailable
	24h sharing buffer overflow
	25h reserved
	26h (LANtastic) cannot complete file operation
	27h-31h reserved
	32h Network request not supported (DOS 3.1 + MS Networks)
	33h Remote computer not listening
	34h Duplicate name on network
	35h Network name not found
	36h Network busy
	37h Network device no longer exists
	38h Network BIOS command limit exceeded
	39h Network adapter hardware error
	3Ah Incorrect response from network
	3Bh Unexpected network error
	3Ch Incompatible remote adapter
	3Dh Print queue full
	3Eh Queue not full
	3Fh Not enough space to print file
	40h Network name was deleted
	41h Network: Access denied
	42h Network device type incorrect
	43h Network name not found
	44h Network name limit exceeded
	45h Network BIOS session limit exceeded
	46h Temporarily paused
	47h Network request not accepted
	48h (DOS 3.1 + MS Networks) Print/disk redirection paused
	49h (LANtastic) invalid network version
	4Ah (LANtastic) account expired
	4Bh (LANtastic) password expired
	4Ch (LANtastic) login attempt invalid at this time
	4Dh-4Fh reserved
	50h file exists
	51h reserved
	52h cannot make directory
	53h fail on INT 24h
	54h (DOS 3.3+) too many redirections
	55h (DOS 3.3+) duplicate redirection
	56h (DOS 3.3+) invalid password
	57h (DOS 3.3+) invalid parameter
	58h (DOS 3.3+) network write fault
	59h (LANtastic) function not supported on network
	5Ah (LANtastic) required system component not installed
Values for Error Class:
	01h out of resource (storage space or I/O channels)
	02h temporary situation (file or record lock)
	03h authorization (denied access)
	04h internal (system software bug)
	05h hardware failure
	06h system failure (configuration file missing or incorrect)
	07h application program error
	08h not found
	09h bad format
	0Ah locked
	0Bh media error
	0Ch already exists
	0Dh unknown
Values for Suggested Action:
	01h retry
	02h delayed retry
	03h prompt user to reenter input
	04h abort after cleanup
	05h immediate abort
	06h ignore
	07h retry after user intervention
Values for Error Locus:
	01h unknown or not appropriate
	02h block device (disk error)
	03h network related
	04h serial device (timeout)
	05h memory related
---------------------------------------------
INT 21 - DOS 3+ - CREATE UNIQUE FILE
	AH = 5Ah
	DS:DX -> ASCIZ directory path name ending with a '\' + 13 bytes to
		 receive generated filename
	CX = file attributes (only bits 0,1,2,5 may be set)
Return: CF set on error
	    AX = error code (03h,05h) (see AH=59h)
	CF clear if successful
	    AX = file handle
	DS:DX -> path name
Note: The file created is not truly temporary.	It MUST be removed by the user.
SeeAlso: AH=3Ch
---------------------------------------------
INT 21 - DOS 3+ - CREATE NEW FILE
	AH = 5Bh
	DS:DX -> ASCIZ directory path name
	CX = file attribute
Return: CF set on error
	    AX = error code (03h,04h,05h,50h) (see AH=59h)
	CF clear if successful
	DS:DX -> path name
Note:	unlike function 3Ch, function 5Bh will fail if the file already exists
SeeAlso: AH=3Ch
---------------------------------------------
INT 21 - DOS 3+ - LOCK/UNLOCK FILE ACCESS
	AH = 5Ch
	AL = 00h lock
	     01h unlock
	BX = file handle
	CX:DX = starting offset of region to lock
	SI:DI = size of region to lock
Return: CF set on error
	    AX = error code (01h,06h,21h) (see AH=59h)
Note:	error returned unless SHARE or network installed
---------------------------------------------
INT 21 - DOS 3.1 internal - INDIRECT FUNCTION CALL
	AX = 5D00h
	DS:DX -> buffer containing register values (see AX=5D0Ah)
		 for a call to INT 21h
Return: as appropriate for function being called
Notes:	does not check AH.  Out of range values will crash the system
---------------------------------------------
INT 21 - DOS 3.1 internal - SYNC???
	AX = 5D01h
	DS:DX -> buffer (see AX=5D0Ah), only fields at offset 12h, 14h used
	???
Return: ???
Note:	does something to each disk file in the System File Table which has
	  been written to; if remote file, calls INT 2F/AX=1107h
	seems to update the time stamp of all open files which have been
	  written
---------------------------------------------
INT 21 - DOS 3.1 internal - SHARE.EXE - ???
	AX = 5D02h
	DS:DX -> buffer (see AX=5D0Ah), only fields at offset 12h, 14h used
	???
Return: ???
Note:	error unless SHARE is loaded (calls [ListofLists+4Ah]) (see AH=52h)
---------------------------------------------
INT 21 - DOS 3.1 internal - SHARE.EXE - ???
	AX = 5D03h
	DS:DX -> buffer (see AX=5D0Ah), only fields at offset 12h, 14h used
	???
Return: ???
Note:	error unless SHARE is loaded (calls [ListofLists+42h]) (see AH=52h)
---------------------------------------------
INT 21 - DOS 3.1 internal - SHARE.EXE - ???
	AX = 5D04h
	DS:DX -> buffer (see AX=5D0Ah), only fields at offset 12h, 14h used
	???
Return: ???
Note:	error unless SHARE is loaded (calls [ListofLists+46h]) (see AH=52h)
---------------------------------------------
INT 21 - DOS 3.1 internal - SHARE.EXE - ???
	AX = 5D05h
	DS:DX -> buffer (see AX=5D0Ah), only fields at offset 12h, 14h used
	???
Return: ES:DI -> ???
	BX = ???
	CX = ???
Note:	error unless SHARE is loaded (calls [ListOfLists+5Ah]) (see AH=52h)
---------------------------------------------
INT 21 - DOS 3+ internal - GET ADDRESS OF CRITICAL ERROR FLAG
	AX = 5D06h
	DS:DX -> buffer (see AX=5D0Ah), only fields at offset 12h, 14h used
Return: DS:SI -> critical error flag
	BX = ???
	CX = ???
Notes:	this call does a lot of other work in addition to returning the	pointer
	the Critical Error flag is used in conjunction with the InDOS flag
	  (see AH=34h) to determine when it is safe to enter DOS from a TSR
	setting CritErr flag allows use of functions 50h/51h from INT 28h under
	  DOS 2.x by forcing use of correct stack
---------------------------------------------
INT 21 - DOS 3+ internal - ???
	AH = 5Dh
	AL = subfunction
	     07h: ???
	     08h: ??? (used by COMMAND.COM)
	     09h: ??? (used by COMMAND.COM)
Return: ???
Note:	in DOS 3.10 and 3.30, these are identical, and call INT 2F/AX=1125h
---------------------------------------------
INT 21 - DOS 3.1+ internal - SET EXTENDED ERROR INFORMATION
	AX = 5D0Ah
	DS:DX -> 11-word error information table
SeeAlso: AH=59h

Format of error information table:
Offset	Size	Description
 00h	WORD	value that next call to function 59h will return in AX 
 02h	WORD	value that next call to function 59h will return in BX
 04h	WORD	CX
 06h	WORD	DX
 08h	WORD	SI
 0Ah	WORD	DI
 0Ch	WORD	DS
 0Eh	WORD	ES
 10h	WORD	reserved (0)
 12h	WORD	??? (0 for DOS 3.1)
 14h	WORD	??? (0 for DOS 3.1)
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET MACHINE NAME
	AX = 5E00h
	DS:DX -> buffer for ASCIZ name (16 bytes)
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
	CH = 00h if name not defined
	  <> 00h defined
		CL = NETBIOS name number
		DS:DX -> ASCIZ machine name
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - SET MACHINE NAME
	AX = 5E01h
	CH = 00h undefine name
	   <> 0  define name
	CL = name number
	DS:DX -> ASCIZ name
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - SET PRINTER SETUP
	AX = 5E02h
	BX = redirection list index
	CX = length of setup string (<= 64)
	DS:SI -> string buffer
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET PRINTER SETUP
	AX = 5E03h
	BX = redirection list index
	ES:DI -> string buffer
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
	CX = length of setup string (<= 64)
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - something to do with PRINTER SETUP???
	AX = 5E04h
	???
Return: CF set on error
Note:	calls INT 2F/AX=111Fh with 5E04h on stack
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - something to do with PRINTER SETUP???
	AX = 5E05h
	???
Return: CF set on error
Note:	calls INT 2F/AX=111Fh with 5E05h on stack
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - something to do with PRINTER SETUP???
	AX = 5E06h
	???
Return: CF set on error
Note:	calls INT 2F/AX=111Fh with 5E06h on stack
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks, VINES - GET REDIRECTION LIST ENTRY
	AX = 5F02h
	BX = redirection list index
	DS:SI -> 16 char local device name buffer
	ES:DI -> 128 char network name buffer
Return: CF set on error
	    AX = error code (01h,12h) (see AH=59h)
	CF clear if successful
	    BH = device status flag (bit 0 = 0 if valid)
	    BL = device type (03h if printer, 04h if drive)
	    CX = stored parameter value (user data)
	    DS:SI and ES:DI buffers filled
Notes:	DX and BP are destroyed by this call!
	error code 12h is returned if BX is greater than the size of the list
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks, Banyan VINES - REDIRECT DEVICE
	AX = 5F03h
	BL = device type
		03h = printer device
		04h = file device
	CX = stored parameter value
	DS:SI -> ASCIZ source device name
	ES:DI -> destination ASCIZ network path + ASCIZ password
Return: CF set on error
	    AX = error code (01h,03h,05h,08h,54h,55h,57h) (see AH=59h)
---------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks, Banyan VINES - CANCEL REDIRECTION
	AX = 5F04h
	DS:SI -> ASCIZ device name or network path
Return: CF set on error
	    AX = error code (01h,0Fh,57h) (see AH=59h)
---------------------------------------------
INT 21 - DOS 3+ internal - RESOLVE PATH STRING TO FULLY QUALIFIED PATH STRING
	AH = 60h
	DS:SI -> ASCIZ relative path string or directory name
	ES:DI -> 80-byte buffer for ASCIZ fully qualified name
Return: CF set on error
	    AX = error code 
		02h invalid source name
		03h invalid drive or malformed path
		others???
	CF clear if successful
	    AH = 00h
	    AL = '\' if relative path refers to something in root directory
	       = uppercased last letter of relative path if relative path
		    refers to current directory or subdir of current directory
	       = 00h otherwise
	    buffer filled with qualified name of form D:\PATH\FILE.EXT
Notes:	the input path need not actually exist
	letters are uppercased, forward slashes converted to backslashes,
	   asterisks converted to appropriate number of question marks, and
	   file and directory names are truncated to 8.3 if necessary.
	'.' and '..' in the path are resolved
	if path string is on a JOINed drive, the returned name is the one that
	   would be needed if the drive were not JOINed; similarly for a
	   SUBSTed or ASSIGNed drive letter.  Because of this, it is possible
	   to get a qualified name that is not legal with the current
	   combination of SUBSTs, ASSIGNs, and JOINs
SeeAlso: INT 2F/AX=1221h
---------------------------------------------
INT 21 - DOS 3+ internal - UNUSED
	AH = 61h
Return: AL = 00h
---------------------------------------------
INT 21 - DOS 3+ - GET PSP ADDRESS
	AH = 62h
Return: BX = segment address of PSP
Note:	under DOS 3+, this function does not use any of the DOS-internal stacks
	  and is thus fully reentrant
SeeAlso: AH=51h
---------------------------------------------
INT 21 - DOS 2.25 only - GET LEAD BYTE TABLE (2-BYTE CHARACTER SUPPORT)
	AH = 63h
	AL = subfunction
	     00h get system lead byte table
		Return:	DS:SI -> lead byte table
	     01h set/clear interim console flag (determine whether interim
			bytes are returned on some console functions)
		DL = 01h/00h to set/clear interim console flag
	     02h get interim console flag
		Return:	DL = interim console flag
Return: CF set on error
	    AX = error code (01h) (see AH=59h)
Note:	does not preserve any registers other than SS:SP
---------------------------------------------
INT 21 - DOS 3.2 internal - ???
	AH = 64h
	AL = subfunction
	    00h get ???
		Return: DL = ???
	    01h set ???
		DL = ???
	    02h get and set ???
		DL = new ???
		Return: DL = old ???
---------------------------------------------
INT 21 - DOS 3.3 internal - ???
	AH = 64h
	AL = flag
		00h  ??? 
	    nonzero  ??? 
Return: nothing
Note:	seems to have something to do with the network
---------------------------------------------
INT 21 - DOS 3.3+ - GET EXTENDED COUNTRY INFORMATION
	AH = 65h
	AL = info ID
	    01h get general internationalization info
	    02h get pointer to uppercase table
	    04h get pointer to filename uppercase table
	    06h get pointer to collating sequence table
	    07h (DOS 4.x) get pointer to Double-Byte Character Set table
	BX = code page (-1=global code page)
	DX = country ID (-1=current country)
	ES:DI -> country information buffer
	CX = size of buffer (>= 5)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if succesful
	    CX = size of country information returned
	    ES:DI -> country information
SeeAlso: AH=38h

Format of country information:
Offset	Size	Description
 00h	BYTE	info ID
---if info ID = 01h---
 01h	WORD	size
 03h	WORD	country ID
 05h	WORD	code page
 07h 34 BYTEs	country-dependent info (see AH=38h)
---if info ID = 02h---
 01h	DWORD	pointer to uppercase table (see below)
---if info ID = 04h---
 01h	DWORD	pointer to collating table (see below)
---if info ID = 06h---
 01h	DWORD	pointer to filename uppercase table (see below)
---if info ID = 07h (DOS 4.x)---
 01h	DWORD	pointer to DBCS lead byte table (see below)

Format of uppercase table:
Offset	Size	Description
 00h	WORD	table size
 02h 128 BYTEs	uppercase equivalents (if any) of chars 80h to FFh

Format of collating table:
Offset	Size	Description
 00h	WORD	table size
 02h 256 BYTEs	values used to sort characters 00h to FFh

Format of filename uppercase table:
Offset	Size	Description
 00h	WORD	table size
 02h 128 BYTEs	uppercase equivalents (if any) of chars 80h to FFh

Format of DBCS lead byte table:
Offset	Size	Description
 00h	WORD	length
 02h 2N BYTEs	start/end for N lead byte ranges
	WORD	0000h	(end of table)
---------------------------------------------
INT 21 - DOS 3.3+ - GET GLOBAL CODE PAGE TABLE
	AX = 6601h
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    BX = active code page
	    DX = system code page
---------------------------------------------
INT 21 - DOS 3.3+ - SET GLOBAL CODE PAGE TABLE
	AX = 6602h
	BX = active code page
	    437  US
	    850  Multilingual
	    860  Portugal
	    863  Canada (French)
	    865  Norway/Denmark
	DX = system code page (active page at boot time)
Return: CF set on error
	    AX = error code (see AH=59h)
---------------------------------------------
INT 21 - DOS 3.3+ - SET HANDLE COUNT
	AH = 67h
	BX = desired number of handles (max 255)
Return: CF set if error (and error code in AX)
SeeAlso: AH=26h
---------------------------------------------
INT 21 - DOS 3.3+ - COMMIT FILE, WRITE ALL BUFFERED DATA TO DISK
	AH = 68h
	BX = file handle
Return: CF set on error 
	    AX = error code (see AH=59h)
Note:	if BX <= 20, no action is taken
---------------------------------------------
INT 21 - DOS 4.0 internal - GET/SET DISK SERIAL NUMBER
	AH = 69h
	AL = subfunction
	    00h	get serial number
	    01h set serial number
	BL = drive (0=default, 1=A, 2=B, etc)
	DS:DX -> disk info (see below)
Return: CF set on error
	    AX = error code (see AH=59h)
	CF clear if successful
	    AX destroyed
	    (AL = 00h) buffer filled with appropriate values from extended BPB
	    (AL = 01h) extended BPB on disk set to values from buffer
Notes:	does not generate a critical error; all errors are returned in AX
	error 0005h given if no extended BPB on disk
	does not work on network drives (error 0001h)
	buffer after first two bytes is exact copy of bytes 27h thru 3Dh of
	   extended BPB on disk

Format of disk info:
Offset	Size	Description
 00h	WORD	??? (zero)
 02h	DWORD	disk serial number (binary)
 06h 11 BYTEs	volume label or "NO NAME    " if none present
 11h  8 BYTEs	FAT type--string "FAT12   " or "FAT16	"
---------------------------------------------
INT 21 - DOS 4.0 internal - ???
	AH = 6Ah
	???
Return: ???
---------------------------------------------
INT 21 - DOS 4.0 internal - ???
	AH = 6Bh
	???
Return: ???
---------------------------------------------
INT 21 - DOS 4.0 - EXTENDED OPEN/CREATE
	AX = 6C00h
	BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
		bits 0-2: access mode
		bit 3 reserved
		bits 4-6: sharing mode
		bit 7: inheritance
	BH = 0WF00000
	    W = auto commit on write
	    F = return error rather than doing INT 24h
	CX = create attribute
		bit 0: readonly
		bit 1: hidden
		bit 2: system
		bit 3: volume label
		bit 4: reserved
		bit 5: archive
		bits 6-15 reserved
	DL = action if file exists/does not exists
	    bits 7-4 action if file does not exist
		    0000 fail
		    0001 create
	    bits 3-0 action if file exists
		    0000 fail
		    0001 open
		    0010 replace/open
	DH = 00h (reserved)
	DS:SI -> ASCIZ file name
Return: CF set on error
	   AX = error code (see AH=59h)
	CF clear if successful
	   AX = file handle
	   CX = 1 file opened
		2 file created
		3 file replaced
SeeAlso: AH=3Ch,3Dh
---------------------------------------------
INT 21 - ???
	AH = 89h
	???
Note:	called by Microsoft C 4.0 startup code
---------------------------------------------
INT 21 - Novell NetWare SFT Level II - EXTENDED FILE ATTRIBUTES
	AH = B6h
	AL = subfunction
	    00h get extended file attributes
	    01h set extended file attributes
	CL = attributes
	    bit 4: transaction tracking file
		5: indexing file (to be implemented)
		6: read audit (to be implemented)
		7: write audit (to be implemented)
	DS:DX -> ASCIZ pathname
Return: CF set on error
	    AL = error code
		FFh file not found
		8Ch caller lacks privileges
	CL = current extended file attributes
---------------------------------------------
INT 21 - Novell Advanced NetWare 2.0+ - PRINT JOBS
	AH = B8h
	AL = subfunction
	    00h get default print job flags
	    01h set default capture flags
	    02h get specific capture flags
	    03h set specific print job flags
	    04h get default local printer
	    05h set default local printer
	    06h set capture print queue
	    07h set capture print job
	    08h get banner user name
	    09h set banner user name
	CX = buffer size
	ES:BX -> buffer
Return: none
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SET END OF JOB STATUS
	AH = BBh
	AL = new EOJ flag
	    00h disable EOJs
	    otherwise enable EOJs
Return: AL = old EOJ flag
---------------------------------------------
INT 21 - Novell NetWare 4.6 - LOG PHYSICAL RECORD
	AH = BCh
	AL = flags
	    bit 0: lock as well as log record
		1: non-exclusive lock
	BX = file handle
	CX:DX = offset
	BP = timeout in timer ticks (1/18 sec)
	SI:DI = length
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RELEASE PHYSICAL RECORD
	AH = BDh
	BX = file handle
	CX:DX = offset
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - CLEAR PHYSICAL RECORD
	AH = BEh
	BX = file handle
	CX:DX = offset
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - LOG RECORD (FCB)
	AH = BFh
	AL = flags
	    bit 0: lock as well as log record
		1: non-exclusive lock
	DS:DX -> FCB
	BX:CX = offset
	BP = timeout in timer ticks (1/18 sec)
	SI:DI = length
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RELEASE RECORD (FCB)
	AH = C0h
	DS:DX -> FCB
	BX:CX = offset
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - CLEAR RECORD (FCB)
	AH = C1h
	DS:DX -> FCB
	BX:CX = offset
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - LOCK PHYSICAL RECORD SET
	AH = C2h
	AL = flags
	    bit 1: non-exclusive lock
	BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RELEASE PHYSICAL RECORD SET
	AH = C3h
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - CLEAR PHYSICAL RECORD SET
	AH = C4h
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - SEMAPHORES
	AH = C5h
	AL = subfunction
	    00h open semaphore
		DS:DX -> semaphore name
		CL = initial value
	    01h examine semaphore
		Return: CX = semaphore value (sign extended)
			DL = open count
	    02h wait on semaphore
		BP = timeout in timer ticks (1/18 sec)
	    03h signal semaphore
	    04h close semaphore
	CX:DX = semaphore handle (except function 00h)
Return: AL = error code
	if function 00h
	   CX:DX = semaphore handle
	   BL = open count
---------------------------------------------
INT 21 - Novell NetWare 4.6 - GET OR SET LOCK MODE
	AH = C6h
	AL = subfunction
	    00h set old "compatibility" mode
	    01h set new extended locks mode 
	    02h get lock mode
Return: AL = current lock mode
---------------------------------------------
INT 21 - Novell NetWare 4.0 - TTS
	AH = C7h
	AL = subfunction
	    00h begin transaction (NetWare SFT level II)
		Return: AL = error code
	    01h end transaction (NetWare SFT level II)
		Return: AL = error code
			CX:DX = transaction reference number
	    02h TTS available (NetWare SFT level II)
		Return: AL = completion code
			    00h TTS not available
			    01h TTS available
			    FDh TTS available but disabled
	    03h abort transaction (NetWare SFT level II)
		Return: AL = error code
	    04h transaction status
	    05h get application thresholds
	    06h set application thresholds
	    07h get workstation thresholds
	    08h set workstation thresholds
Return: ???
---------------------------------------------
INT 21 - Novell NetWare 4.0 - BEGIN LOGICAL FILE LOCKING
	AH = C8h
	if function C6h lock mode 00h:
	    DL = mode
		00h no wait
		01h wait
	if function C6h lock mode 01h:
	    BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - END LOGICAL FILE LOCKING
	AH = C9h
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - LOG PERSONAL FILE (FCB)
	AH = CAh
	DS:DX -> FCB
	if function C6h lock mode 01h:
	    AL = log and lock flag
		00h log file only
		01h lock as well as log file
	    BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - LOCK FILE SET
	AH = CBh
	if function C6h lock mode 00h:
	    DL = mode
		00h no wait
		01h wait
	if function C6h lock mode 01h:
	    BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - RELEASE FILE (FCB)
	AH = CCh
	DS:DX -> FCB
Return: none
---------------------------------------------
INT 21 - Novell NetWare 4.0 - RELEASE FILE SET
	AH = CDh
Return: none
---------------------------------------------
INT 21 - Novell NetWare 4.0 - CLEAR FILE (FCB)
	AH = CEh
	DS:DX -> FCB
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - CLEAR FILE SET
	AH = CFh
Return: AL = 00h
---------------------------------------------
INT 21 - Novell NetWare 4.6, Banyan VINES - LOG LOGICAL RECORD
	AH = D0h
	DS:DX -> record string
	if function C6h lock mode 01h: (Novell only)
	    AL = flags
		bit 0: lock as well as log the record
		bit 1: non-exclusive lock
	    BP = timeout in timer ticks (1/18 sec)
Return: AL = error code
	    00h successful
	    FFh unsuccessful
---------------------------------------------
INT 21 - Novell NetWare 4.6, Banyan VINES - LOCK LOGICAL RECORD SET
	AH = D1h
	if function C6h lock mode 00h:
	    DL = mode
		00h no wait
		01h wait
	if function C6h lock mode 01h: (Novell only)
	   BP = timeout in timer ticks (1/18 sec)
Return: AL = error code (see AH=D0h)
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - UNLOCK LOGICAL RECORD
	AH = D2h
	DS:DX -> semaphore identifier (counted string up to 100 chars long)
Return: AL = error code (see AH=D0h)
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - UNLOCK LOGICAL RECORD SET
	AH = D3h
Return: AL = error code (see AH=D0h)
Note:	unlocks all semaphores logged in the semaphore set of the requesting PC
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - CLEAR LOGICAL RECORD
	AH = D4h
	DS:DX -> semaphore identifier (counted string up to 100 chars long)
Return: AL = error code
	    00h successful
	    FFh not successful
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - CLEAR LOGICAL RECORD SET
	AH = D5h
Return: AL = error code (see AH=D4h)
Note:	unlocks and clears all semaphores associated with the semaphore set
	  of teh requesting PC
---------------------------------------------
INT 21 - Novell NetWare 4.0 - END OF JOB
	AH = D6h
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SYSTEM LOGOUT
	AH = D7h
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare, Banyan VINES - ALLOCATE RESOURCE
	AH = D8h
	DL = resource number
Return: AL = status
	    00h successful
	    FFh unsucessful
---------------------------------------------
INT 21 - Novell NetWare, Banyan VINES - DEALLOCATE RESOURCE
	AH = D9h
	DL = resource number
Return:	AL = status (see AH=D8h)
---------------------------------------------
INT 21 - Novell NetWare 4.0 - GET VOLUME STATISTICS
	AH = DAh
	DL = volume number
	ES:DI -> reply buffer (see below)
Return: AL = 00h

Format of reply buffer:
Offset	Size	Description
 00h	WORD	sectors/block
 02h	WORD	total blocks
 04h	WORD	unused blocks
 06h	WORD	total directory entries
 08h	WORD	unused directory entries
 0Ah 16 BYTEs	volume name, null padded
 1Ah	WORD	removable flag, 0000h = not removable
---------------------------------------------
INT 21 - Novell NetWare 4.0 - GET NUMBER OF LOCAL DRIVES
	AH = DBh
Return: AL = number of local disks
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - GET STATION NUMBER
	AH = DCh
Return: AL = station number
	    00h if NetWare not loaded or this machine is a non-dedicated server
	CX = station number in ASCII
Note:	station number only unique for those PCs connected to same semaphore
	  service
---------------------------------------------
INT 21 - PCMag PCMANAGE/DCOMPRES - TURN ON/OFF
	AH = DCh
	DX = state
	    0000h turn on
	    0001h turn off
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SET ERROR MODE
	AH = DDh
	DL = error mode
	    00h display critical I/O errors
	    01h extended errors for all I/O in AL
	    02h extended errors for critical I/O in AL
Return: AL = previous error mode
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SET BROADCAST MODE
	AH = DEh
	AL = broadcast mode
	    00h receive console and workstation broadcasts
	    01h receive console broadcasts only
	    02h receive no broadcasts
	    03h store all broadcasts for retrieval
	    04h get broadcast mode
	    05h disable shell tiemr interrupt checks
	    06h enable shell timer interrupt checks
Return: AL = old broadcast mode
---------------------------------------------
INT 21 - Novell NetWare 4.0 - CAPTURE
	AH = DFh
	AL = subfunction
	    00h start LPT capture
	    01h end LPT capture
	    02h cancel LPT capture
	    03h flush LPT capture
	    04h start specific capture
	    05h end specific capture
	    06h cancel specific capture
	    07h flush specific capture
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - PRINT SPOOLING
	AH = E0h
	DS:SI -> request buffer
	ES:DI -> reply buffer
	subfunction in third byte of request buffer
	    00h spool data to a capture file
	    01h close and queue capture file
	    02h set spool flags
	    03h spool existing file
	    04h get spool queue entry
	    05h remove entry from spool queue
	    06h get printer status
	    09h create a disk capture file
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - BROADCAST MESSAGES
	AH = E1h
	DS:SI -> request buffer
	ES:DI -> reply buffer
	subfunction in third byte of request buffer
	    00h send broadcast message
	    01h get broadcase message
	    02h disable station broadcasts
	    03h enable station broadcasts
	    04h send personal message
	    05h get personal message
	    06h open message pipe
	    07h close message pipe
	    08h check pipe status
	    09h broadcast to console
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - DIRECTORY FUNCTIONS
	AH = E2h
	DS:SI -> request buffer
	ES:DI -> reply buffer
	subfunction in third byte of request buffer
	    00h set directory handle
	    01h get directory path
	    02h scan directory information
	    03h get effective directory rights
	    04h modify maximum rights mask
	    05h get volume number
	    06h get volume name
	    0Ah create directory
	    0Bh delete directory
	    0Ch scan directory for trustees
	    0Dh add trustee to directory
	    0Eh delete trustee from directory
	    0Fh rename directory
	    10h purge erased files
	    11h restore erased file
	    12h allocate permanent directory handle
	    13h allocate temporary directory handle
	    14h deallocate directory handle
	    15h get volume info with handle
	    16h allocate special temporary directory handle
	    17h retrieve a short base handle (Advanced NetWare 2.0)
	    18h restore a short base handle (Advanced NetWare 2.0)
	    19h set directory information
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - CONNECTION CONTROL
	AH = E3h
	DS:SI -> requst buffer
	ES:DI -> reply buffer
	subfunction in third byte of request buffer
	    00h login
	    01h change password
	    02h map user to station set
	    03h map object to number
	    04h map number to object
	    05h get station's logged information
	    06h get station's root mask (obsolete)
	    07h map group name to number
	    08h map number to group name
	    09h get memberset M of group G
	    0Ah enter login area
	    0Bh ???
	    0Ch ???
	    0Dh log network message
	    0Eh get disk utilization (Advanced NetWare 1.0)
	    0Fh scan file information (Advanced NetWare 1.0)
	    10h set file information (Advanced NetWare 1.0)
	    11h get file server information (Advanced NetWare 1.0)
	    12h ???
	    13h get internet address (Advanced NetWare 1.02)
	    14h login to file server (Advanced NetWare 2.0)
	    15h get object connection numbers (Advanced NetWare 2.0)
	    16h get connection information (Advanced NetWare 1.0)
	    32h create object (Advanced NetWare 1.0)
	    33h delete object (Advanced NetWare 1.0)
	    34h rename object (Advanced NetWare 1.0)
	    35h get object ID (Advanced NetWare 1.0)
	    36h get object name (Advanced NetWare 1.0)
	    37h scan object (Advanced NetWare 1.0)
	    38h change object security (Advanced NetWare 1.0)
	    39h create propery (Advanced NetWare 1.0)
	    3Ah delete property (Advanced NetWare 1.0)
	    3Bh change property security (Advanced NetWare 1.0)
	    3Ch scan property (Advanced NetWare 1.0)
	    3Dh read property value (Advanced NetWare 1.0)
	    3Eh write property value (Advanced NetWare 1.0)
	    3Fh verify object password (Advanced NetWare 1.0)
	    40h change object password (Advanced NetWare 1.0)
	    41h add object to set (Advanced NetWare 1.0)
	    42h delete object from set (Advanced NetWare 1.0)
	    43h is object in set? (Advanced NetWare 1.0)
	    44h close bindery (Advanced NetWare 1.0)
	    45h open bindery (Advanced NetWare 1.0)
	    46h get bindery access level (Advanced NetWare 1.0)
	    47h scan object trustee paths (Advanced NetWare 1.0)
	    C8h check console priviledges
	    C9h get file server description strings
	    CAh set file server date and time
	    CBh disable file server login
	    CCh enable file server login
	    CDh get file server login status
	    CEh purge all erased files
	    CFh disable transaction tracking
	    D0h enable transaction tracking
	    D1h send console broadcast
	    D2h clear connection number
	    D3h down file server
	    D4h get file system statistics
	    D5h get transaction tracking statistics
	    D6h read disk cache statistics
	    D7h get drive mapping table
	    D8h read physical disk statistics
	    D9h get disk channel statistics
	    DAh get connection's task information
	    DBh get list of connection's open files
	    DCh get list of connections using a file
	    DDh get physical record locks by connection and file
	    DEh get physical record locks by file
	    DFh get logical records by connection
	    E0h get logical record information
	    E1h get connection's semaphores
	    E2h get semaphore information
	    E3h get LAN driver's configuration information
	    E5h get connection's usage statistics
	    E6h get object's remaining disk space
	    E7h get server LAN I/O statistics
	    E8h get server miscellaneous information
	    E9h get volume information
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - SET FILE ATTRIBUTES (FCB)
	AH = E4h
	CL = file attributes
	    bit 0: read only
		1: hidden
		2: system
		7: shareable
	DX:DX -> FCB
Return: AL = error code
---------------------------------------------
INT 21 - DoubleDos - INSTALLATION CHECK
	AX = E400h
Return: AL <> 00h if DoubleDos is active
	AL = 02h if caller is running in the invisible partition
---------------------------------------------
INT 21 - Novell NetWare 4.0 - UPDATE FILE SIZE (FCB)
	AH = E5h
	DS:DX -> FCB
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0 - COPY FILE TO FILE (FCB)
	AH = E6h
	CX:DX = number of bytes to copy
	DS:SI -> source FCB
	ES:DI -> destination FCB
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.0, Banyan VINES - GET FILE SERVER DATE AND TIME
	AH = E7h
	DS:DX -> reply buffer
		BYTE  year - 1900
		BYTE  month
		BYTE  day
		BYTE  hours
		BYTE  minutes
		BYTE  seconds
		BYTE  day of week (0 = Sunday) (Novell only)
Return: AL = error code
	    00h successful
	    FFh unsuccessful
---------------------------------------------
INT 21 - Novell NetWare 4.6 - SET FCB RE-OPEN MODE
	AH = E8h
	DL = mode
	    00h no automatic re-open
	    01h auto re-open
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - SHELL'S "GET BASE STATUS"
	AH = E9h
	AL = subfunction
	    00h get directory handle
	DX = drive number to check (0 = A:)
Return: AL = network pathbase
	AH = base flags
	    00h drive not currently mapped to a base
	    01h drive is mapped to a permanent base
	    02h drive is mapped to a temporary base
	    03h drive exists locally
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RETURN SHELL VERSION
	AH = EAh
	AL = subfunction
	    00h return code in AL
		Return: AL = hardware type
			    00h IBM PC
			    01h Victor 9000
	    01h get workstation environment string
		ES:DI -> 40-byte buffer
		Return: buffer filled with three null-terminated entries:
			major operating system
			version
			hardware type
Return: AH = 00h if DOS
---------------------------------------------
INT 21 - DoubleDos - TURN OFF TASK SWITCHING
	AH = EAh
Return: task switching turned off
---------------------------------------------
INT 21 - Novell NetWare 4.6 - LOG FILE
	AH = EBh
	DS:DX -> ASCIZ filename
	if function C6h lock mode 01h:
	    AL = flags
		00h log file only
		01h lock as well as log file
	    BP = timeout in timer ticks (1/18 second)
Return: AL = error code
---------------------------------------------
INT 21 - DoubleDos - TURN ON TASK SWITCHING
	AH = EBh
Return: task switching turned on
---------------------------------------------
INT 21 - Novell NetWare 4.6 - RELEASE FILE
	AH = ECh
	DS:DX -> ASCIZ filename
Return: none
---------------------------------------------
INT 21 - DoubleDos - GET VIRTUAL SCREEN ADDRESS
	AH = ECh
Return: ES = segment of virtual screen
Note:	screen address can change if task-switching is on!!
---------------------------------------------
INT 21 - Novell NetWare - CLEAR FILE
	AH = EDh
	DS:DX -> ASCIZ filename
Return: AL = error code
---------------------------------------------
INT 21 - Novell NetWare 4.6 - GET PHYSICAL STATION NUMBER
	AH = EEh
Return: CX:BX:AX = six-byte address
---------------------------------------------
INT 21 - DoubleDos - GIVE AWAY TIME TO OTHER TASKS
	AH = EEh
	AL = number of 55ms time slices to give away
Return: returns after giving away time slices
---------------------------------------------
INT 21 - Novell Advanced NetWare 1.0+ - GET DRIVE INFO
	AH = EFh
	AL = subfunction
	    00h get drive handle table
	    01h get drive flag table
	    02h get drive connection ID table
	    03h get connection ID table
	    04h get file server name table
Return: ES:DI -> shell status table
---------------------------------------------
INT 21 - Novell Advanced NetWare 1.0+ - CONNECTION ID
	AH = F0h
	AL = subfunction
	    00h set preferred connection ID
	    01h get preferred connection ID
	    02h get default connection ID
	    03h LPT capture active
	    04h set primary connection ID
	    05h get primary connection ID
	DL = preferred file server
Return: AL = selected file server
---------------------------------------------
INT 21 - Novell Advanced NetWare 1.0+ - FILE SERVER CONNECTION
	AH = F1h
	AL = subfunction
	    00h attach to file server
		DL = preferred file server
	    01h detach from file server
	    02h logout from file server
Return: AL = completion code
---------------------------------------------
INT 21 - Novell NetWare - ???
	AH = F2h
	???
Return: ???
---------------------------------------------
INT 21 - Novell Advanced NetWare 2.0+ - FILE SERVER FILE COPY
	AH = F3h
	ES:DI -> request string (see below)
Return: AL = status/error code
	CX:DX = number of bytes copied

Format of request string:
Offset	Size	Description
 00h	WORD	source file handle
 02h	WORD	destination file handle
 04h	DWORD	starting offset in source
 08h	DWORD	starting offset in destination
 0Ch	DWORD	number of bytes to copy
---------------------------------------------
INT 21 - DOS v??? - SET OEM INT 21 HANDLER
	AH = F8h
	DS:DX -> OEM INT 21 handler for functions F9h to FFh
		 FFFFh:FFFFh resets to original handlers

Notes:	calls to AH=F9h through AH=FFH will return CF set and AX=1 (invalid
	  function) if no handler set
	handler is called with all registers exactly as set by caller, and
	  should exit with IRET
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = F9h
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FAh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FBh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FCh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FDh
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FEh
---------------------------------------------
INT 21 - PCMag PCMANAGE/DCOMPRES - INSTALLATION CHECK
	AX = FEDCh
Return: AX = CDEFh if installed
---------------------------------------------
INT 21 - DOS v??? - OEM FUNCTION
	AH = FFh
---------------------------------------------
INT 21 - CED - INSTALLABLE COMMANDS
	AH = FFh
	AL = 00h add installable command
	       BL = mode - bit 0 = 1 callable from DOS prompt
			   bit 1 = 1 callable from application
	       DS:SI -> CR-terminated command name
	       ES:DI -> FAR routine entry point
	AL = 01h remove installable command
	       DS:SI -> CR-terminated command name
	AL = 02h reserved, may be used to test for CED installation
Return: CF set on error
	    AX = 01h invalid function
		 02h command not found (subfunction 01h only)
		 08h insufficient memory (subfunction 00h only)
		 0Eh bad data (subfunction 00h only)
	AH = 0FFh if CED not installed
---------------------------------------------
INT 22 - DOS - TERMINATE ADDRESS
   FAR (DWORD) address of routine to be executed when program "returns to DOS".
   Should NEVER be called directly.
---------------------------------------------
INT 23 - DOS - CONTROL "C" EXIT ADDRESS
   Automatically called from keyboard scanner when CTRL-C or CTRL-BREAK is
   detected. Normally aborts program and returns to DOS, but may be changed.
SeeAlso: INT 1B
---------------------------------------------
INT 24 - DOS - FATAL ERROR HANDLER ADDRESS
   Automatically called upon detection of unrecoverable I/O error.
   Normally points to routine in resident part of COMMAND.COM that prints
   "Abort, Retry, Ignore?" message and takes the reply, but may be overridden
   if desired.

Provides the following values in registers on entry to interrupt handler:
	AH: bit 7 = 0 disk I/O error
		  = 1 other error -- if block device, bad FAT
				  -- if char device, code in DI
	    bit 6  unused
	    bit 5 = 1 if Ignore allowed, 0 if not (DOS 3+)
	    bit 4 = 1 if Retry allowed, 0 if not (DOS 3+)
	    bit 3 = 1 if Fail allowed, 0 if not (DOS 3+)
	    bit 2 \ disk area of error	00 = DOS area  01 = FAT
	    bit 1 /			10 = root dir  11 = data area
	    bit 0 = 1 if write, 0 if read
	AL = drive number if AH bit 7 = 1, otherwise undefined
	BP:SI -> header of device driver for which error occurred
	    block device if high bit of BP:[SI+4] set
	low byte of DI:
	   00h write-protect error
	   01h unknown unit
	   02h drive not ready
	   03h unknown command
	   04h data error (bad CRC)
	   05h bad request structure length
	   06h seek error
	   07h unknown media type
	   08h sector not found
	   09h printer out of paper
	   0Ah write fault
	   0Bh read fault
	   0Ch general failure
	   0Dh (DOS 3+) sharing violation
	   0Eh (DOS 3+) lock violation
	   0Fh (DOS 3+) invalid disk change
	   10h (DOS 3+) FCB unavailable
	   11h (DOS 3+) sharing buffer overflow
Handler must return
	AL = 00h ignore error
	   = 01h retry operation
	   = 02h terminate program through INT 22h
	   = 03h fail system call in progress (DOS 3+)
Note:	for DOS 3.1+, IGNORE (AL=00h) is turned into FAIL (AL=03h) on network
	  critical errors
	if IGNORE specified but not allowed, it is turned into FAIL
	if RETRY specified but not allowed, it is turned into FAIL
	if FAIL specified but not allowed, it is turned into ABORT
---------------------------------------------
INT 25 - DOS - ABSOLUTE DISK READ (except DOS 4.0/COMPAQ DOS 3.31 >32M partitn)
	AL = drive number (0=A, 1=B, etc)
	DS:BX = Disk Transfer Address (buffer)
	CX = number of sectors to read
	DX = first relative sector to read
Return: CF set on error
	    AL = error code issued to INT 24h in low half of DI
	    AH = 80h if attachment failed to respond
		 40h if seek operation failed
		 20h if controller failed
		 10h if data error (bad CRC)
		 08h if DMA failure
		 04h if requested sector not found
		 03h if write-protected disk (INT 26 only)
		 02h if bad address mark
		 01h if bad command
Note:	ORIGINAL FLAGS ON STACK!  May destroy all registers except segment regs
BUG:	DOS 3.1 through 3.3 set the word at ES:[BP+1Eh] to FFFFh if AL is an
	invalid drive number
---------------------------------------------
INT 25 - DOS 4.0/COMPAQ DOS 3.31 - ABSOLUTE DISK READ (>32M hard-disk partitn)
	AL = drive number (0=A, 1=B, etc)
	CX = FFFFh
	DS:BX -> disk read packet (see below)
Return: same as above???
Note:	partition is potentially >32M (and requires this form of the call) if
	  bit 1 of device attribute word in device driver is set

Format of disk read packet:
Offset	Size	Description
 00h	DWORD	sector number
 04h	WORD	number of sectors to read
 06h	DWORD	transfer address
---------------------------------------------
INT 26 - DOS - ABSOLUTE DISK WRITE (except DOS 4.0/COMPAQ DOS 3.31 >32M partn)
	AL = drive number (0=A, 1=B, etc)
	DS:BX = Disk Transfer Address (buffer)
	CX = number of sectors to write
	DX = first relative sector to write
Return: CF set on error
	    AL = error code issued to INT 24h in low half of DI
	    AH = same error codes as for INT 25h
Note:	ORIGINAL FLAGS ON STACK!
BUG:	DOS 3.1 through 3.3 set the word at ES:[BP+1Eh] to FFFFh if AL is an
	invalid drive number
---------------------------------------------
INT 26 - DOS 4.0/COMPAQ DOS 3.31 - ABSOLUTE DISK WRITE (>32M hard-disk partitn)
	AL = drive number (0=A, 1=B, etc)
	CX = FFFFh
	DS:BX -> disk write packet (see below)
Return: same as above???
Note:	partition is potentially >32M (and requires this form of the call) if
	  bit 1 of device attribute word in device driver is set

Format of disk write packet:
Offset	Size	Description
 00h	DWORD	sector number
 04h	WORD	number of sectors to read
 06h	DWORD	transfer address
---------------------------------------------
INT 27 - DOS - TERMINATE BUT STAY RESIDENT
	CS = current program segment
	DX = last program byte + 1
Return: never
Note:	this is an obsolete call
SeeAlso: INT 21/AH=31h
---------------------------------------------
