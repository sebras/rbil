Interrupt List, part 14 of 16
Copyright (c) 1989,1990,1991,1992,1993,1994,1995,1996,1997 Ralf Brown
--------*-63---------------------------------
INT 63 - reserved for user interrupt
--------d-63---------------------------------
INT 63 - Adaptec and OMTI controllers - DRIVE 0 DATA
Desc:	this vector stores the last four bytes of the parameter table for
	  hard disk 0
SeeAlso: INT 60"Adaptec",INT 61"Adaptec",INT 62"Adaptec",INT 64"Adaptec"
--------b-63---------------------------------
INT 63 - TI Professional PC - OPTION ROM DATA AREA POINTER (NOT A VECTOR!)
Desc:	the low word of this vector contains the segment of the RAM data area
	  to be used by the expansion ROM at F400h:4000h, and the high word
	  contains the length of the data area; this segment and size are
	  both set to 0000h if no ROM is installed at F400h:4000h
SeeAlso: INT 60"TI Professional PC",INT 62"TI Professional"
SeeAlso: INT 64"TI Professional PC"
----------63---------------------------------
INT 63 - Oracle SQL Protected Mode Executive - ???
--------d-63---------------------------------
INT 63 - 4+Power FLOPPY CONTROLLER - ORIGINAL INT 13/40
Desc:	the "4+Power" quad floppy controller BIOS hooks INT 13 (or INT 40 if
	  INT 13 has been moved there) and places the old value here
----------63---------------------------------
INT 63 - Kofax KF9X00 image manipulation card interface
--------Q-63---------------------------------
INT 63 - DESQview/X - SOCKET API
Notes:	parameters are passed by patching (!) data field immediately following
	  the entry point, as detailed below (see #2764); the preferred
	  method for calling the socket API is via INT 15/AX=DE2Eh
	the installation check consists of testing for the string "dvxunix"
	  (yes, lowercase) at offset 9 from the interrupt handler start
	  (see #2764)
SeeAlso: INT 15/AX=DE2Eh,INT BE"DESQview"
Index:	installation check;DESQview/X socket interface

Format of DESQview/X socket interrupt handler entry:
Offset	Size	Description	(Table 2764)
 00h  3 BYTEs	near jump or short jump + NOP to actual interrupt handler
 03h	WORD	offset from following pointer for initial top of local stack
 05h	DWORD	pointer to argument/stack block (see INT 15/AX=DE2Eh)
 09h  7 BYTEs	signature "dvxunix"
--------b-6300-------------------------------
INT 63 - HP 100LX - MAP HIGH MEMORY
	AH = 00h
	AL = physical page (00h seg C000, 01h seg C400h, ...)
	BX = zero-based logical page
	CX = page number
	DX = device ID (00h system ROM, 05h plugin, etc.)
Return: ???
SeeAlso: AH=01h
--------N-6300-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - SET IP ADDRESS???
	AH = 00h
	DS:BX -> DWORD containing IP address (big-endian)
Return: CF clear if successful
	CF set on error
	AX destroyed
Range:	INT 4D to INT FC, selected by configuration
Note:	the Beame&Whiteside TCP/IP protocol stack uses two consecutive
	  interrupts (62h and 63h by default); the BW-NFS client uses a third
	  consecutive interrupt (64h by default) if it is loaded
SeeAlso: AH=01h"BW-TCP",AH=02h"BW-TCP"
--------b-6301-------------------------------
INT 63 - HP 100LX - SAVE/RESTORE MEMORY MAP
	AH = 01h
	AL = function (00h save, 01h restore)
	???
Return: ???
--------N-6301-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 01h
	ES:BX -> ???
	???
Return: ???
Range:	INT 4D to INT FC, selected by configuration
Note:	the Beame&Whiteside TCP/IP protocol stack uses two consecutive
	  interrupts (62h and 63h by default); the BW-NFS client uses a third
	  consecutive interrupt (64h by default) if it is loaded
SeeAlso: AH=00h"BW-TCP",AH=02h"BW-TCP"
--------N-6302-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 02h
	???
Return: ???
SeeAlso: AH=00h"BW-TCP",AH=01h"BW-TCP"
--------N-6303-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - GET IP ADDRESS
	AH = 03h
	DS:SI -> buffer for DWORD IP address (big-endian)
Return: AX destroyed
	CF clear if successful
	CF set on error
Note:	this call may use ARP or RARP to determine the address
--------N-6304-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 04h
	???
Return: ???
--------N-6305-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 05h
	DS:BX -> ???
	ES:SI -> ???
Return: ???
Range:	INT 4D to INT FC, selected by configuration
--------N-6306-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 06h
	???
Return: ???
--------N-6307-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 07h
	???
Return: ???
--------N-6308-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - SET DEFAULT ??? HANDLER
	AH = 08h
	DS:BX -> DWORD containing IP address
Return: CF clear if successful
	CF set on error
	???
--------N-6309-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - INSTALL ??? HANDLERS
	AH = 09h
	BL = handler type
	ES:SI -> FAR handler of specified type
Return: ???
SeeAlso: AH=0Ah,AH=0Dh
--------N-630A-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - DELETE ??? HANDLERS
	AH = 0Ah
	BL = handler type
Return: CF clear if successful
	CF set on error (no handler of specified type installed)
SeeAlso: AH=09h
--------N-630B-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 0Bh
	AL = ???
	DL = ???
	DS:BX -> ???
	ES:SI -> ???
Return: ???
--------N-630C-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 0Ch
	???
Return: ???
Range:	INT 4D to INT FC, selected by configuration
--------N-630D-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - INSTALL DEFAULT ??? HANDLER
	AH = 0Dh
	???
Return: ???
Note:	if not already installed, installs a type 06h handler with AH=09h
SeeAlso: AH=09h
--------N-630E-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - CLOSE NETWORK DESCRIPTOR
	AH = 0Eh
	???
Return: ???
SeeAlso: INT 61/AH=08h"PC/TCP",INT 61/AH=09h"PC/TCP",INT 61/AH=18h
--------N-630F-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 0Fh
	AL = ???
	SI = ???
	DS:DI -> ???
	???
Return: ???
Range:	INT 4D to INT FC, selected by configuration
--------N-6310-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 10h
	DS:DI -> ???
	???
Return: ???
--------N-6311-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 11h
	???
Return: ???
--------N-6312-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - LISTEN FOR INCOMING CONNECTIONS
	AH = 12h
	DS:SI -> ???
	ES:BP -> ???
Return: ???
SeeAlso: AH=14h,INT 61/AH=23h
--------N-6313-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - NOP
	AH = 13h
Return: nothing
Range:	INT 4D to INT FC, selected by configuration
--------N-6314-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - OPEN NETWORK CONNECTION
	AH = 14h
	BX = network descriptor???
	DS:SI -> ???
	ES:BP -> ???
Return: ???
SeeAlso: AH=12h,AH=16h,AH=19h,INT 61/AH=13h"PC/TCP",INT 62/AH=13h"ETHDEV"
--------N-6315-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 15h
	DS:DI -> ???
	???
Return: ???
Range:	INT 4D to INT FC, selected by configuration
--------N-6316-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - RESET NETWORK CONNECTION
	AH = 16h
	DS:DI -> ???
Return: ???
Note:	calls AH=17h after preprocessing
SeeAlso: AH=17h,INT 61/AH=19h"PC/TCP"
--------N-6317-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 17h
	DS:DI -> ???
	???
Return: ???
Range:	INT 4D to INT FC, selected by configuration
SeeAlso: AH=18h
--------N-6318-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 18h
	DS:DI -> ???
	???
Return: ???
Note:	same as AH=17h, except performed with interrupts disabled
SeeAlso: AH=17h
--------N-6319-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - WRITE TO THE NETWORK
	AH = 19h
	DS:DI -> ???
	???
Return: BX = number of bytes NOT written
	???
Range:	INT 4D to INT FC, selected by configuration
Note:	calls AH=17h with interrupts disabled and ??? set to 01h
SeeAlso: AH=14h,AH=1Ah,AH=1Bh,INT 61/AH=1Ah"PC/TCP"
--------N-631A-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - READ FROM THE NETWORK
	AH = 1Ah
	CX = maximum number of bytes to read
	ES:BP -> ???
	???
Return: CX = number of bytes actually read
	???
SeeAlso: AH=12h,AH=14h,AH=19h,INT 61/AH=1Bh"PC/TCP"
--------N-631B-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 1Bh
	CX = ???
	ES:BP -> ???
Return: DX = ???
	???
Range:	INT 4D to INT FC, selected by configuration
--------N-631C-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 1Ch
	DS:DI -> ???
	???
Return: ???
Note:	calls AH=17h with ???
SeeAlso: AH=17h
--------N-631D-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 1Dh
	???
Return: ???
Range:	INT 4D to INT FC, selected by configuration
--------N-631E-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 1Eh
	DS:BX -> DWORD containing IP address (big-endian)
	???
Return: CF clear if successful
	CF set on error
	???
--------N-631F-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - SET SOCKET ??? HANDLER
	AH = 1Fh
	BX = socket number
	ES:SI -> FAR function for ???
Return: CF clear if successful
	CF set on error (out of slots)
SeeAlso: AH=20h
--------N-6320-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - REMOVE SOCKET ??? HANDLER
	AH = 20h
	BX = socket number
Return: CF clear if successful
	CF set on error (not set)
Range:	INT 4D to INT FC, selected by configuration
SeeAlso: AH=1Fh
--------N-6321-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 21h
	ES:SI -> ???
Return: ???
SeeAlso: INT 61/AH=1Ch"PC/TCP"
--------N-6322-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - REMOVE ??? HANDLER
	AH = 22h
Return: CF clear
Range:	INT 4D to INT FC, selected by configuration
Note:	decrements a counter if not already zero, and calls AH=0Ah with BL=11h
	  if the counter reaches zero
--------N-6323-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 23h
	DS:BX -> ???
	ES:SI -> 6-byte buffer for ???
Return: CF clear if successful
	CF set on error
--------N-6324-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - GET SOCKET
	AH = 24h
Return: AX = socket number (0400h-FFFFh)
Range:	INT 4D to INT FC, selected by configuration
Note:	the Beame&Whiteside TCP/IP protocol stack uses two consecutive
	  interrupts (62h and 63h by default); the BW-NFS client uses a third
	  consecutive interrupt (64h by default) if it is loaded
SeeAlso: AH=12h,AH=14h,INT 62/AH=12h"ETHDEV",INT 64/AH=01h"BW-NFS"
--------N-6325-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - GET INTERNET ADDRESS
	AH = 25h
Return: CL:CH:DL:DH = caller's Internet address
SeeAlso: AH=03h,AH=26h,INT 61/AH=05h"PC/TCP"
--------N-6326-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - SET INTERNET ADDRESS???
	AH = 26h
	CL:CH:DL:DH = Internet address
Return: nothing
Range:	INT 4D to INT FC, selected by configuration
Note:	this function sets a different variable than AH=25h returns
SeeAlso: AH=03h,AH=25h
--------N-6327-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - SET ???
	AH = 27h
	BX = ???
	ES:SI -> ???
Return: ???
--------N-6328-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 28h
	???
Return: ???
--------N-6329-------------------------------
INT 63 - BW-TCP - TCPIP.SYS - ???
	AH = 29h
	???
Return: ???
Range:	INT 4D to INT FC, selected by configuration
Note:	the Beame&Whiteside TCP/IP protocol stack uses two consecutive
	  interrupts (62h and 63h by default); the BW-NFS client uses a third
	  consecutive interrupt (64h by default) if it is loaded
--------*-64---------------------------------
INT 64 - reserved for user interrupt
--------d-64---------------------------------
INT 64 - Adaptec controllers - DRIVE 1 DATA
Desc:	this vector stores the first four bytes of the parameter table for
	  hard disk 1
Notes:	these vectors are used by the following Adaptec controllers:
	    ACB 2370 A/B/C, ACB 2372 A/B/C, ACB 2333 A/B, 2322B-8, 2322B-16
	these vectors are NOT used by the following Adaptec controllers:
	    ACB 2310, ACB 2312, ACB 2320D, ACB 2322D
SeeAlso: INT 60"Adaptec",INT 65"Adaptec",INT 66"Adaptec",INT 67"Adaptec"
--------b-64---------------------------------
INT 64 - TI Professional PC - OPTION ROM DATA AREA POINTER (NOT A VECTOR!)
Desc:	the low word of this vector contains the segment of the RAM data area
	  to be used by the expansion ROM at F400h:6000h, and the high word
	  contains the length of the data area; this segment and size are
	  both set to 0000h if no ROM is installed at F400h:6000h
SeeAlso: INT 60"TI Professional PC",INT 63"TI Professional"
SeeAlso: INT 65"TI Professional PC"
----------64---------------------------------
INT 64 - Oracle SQL Protected Mode Executive - ???
--------N-64---------------------------------
INT 64 - Novell NetWare to v2.0a - LOW-LEVEL API
Note:	equivalent to INT 7A for NetWare versions through 2.0a only; later
	  versions do not use this interrupt for IPX/SPX access, instead
	  getting an entry point from INT 2F/AX=7A00h
SeeAlso: INT 2F/AX=7A00h,INT 7A"LOW-LEVEL API"
--------h-64---------------------------------
INT 64 - Data General DG10 - MicroECLIPSE COPROCESSOR INTERFACE
SeeAlso: INT 65"DG10",INT 66"DG10"
--------r-64---------------------------------
INT 64 - Extended Batch Language v3.14+
	AH = function
	    00h to 5Fh chained to previous handler
	    60h to 6Ch reserved, return immediately
	    80h to FFh chained to previous handler
	    6Dh (v4.01+) insert tone in queue
		AL = ???
		CX = frequency in Hertz
		DL = duration in clock ticks
		Return: AL = 00h if note stored
			   = 01h if no room to store
	    6Eh clear ??? counter/flag
	    6Fh return counter/flag that AH=6Eh clears
	    70h ???
		AL = ???
	    71h ???
		AL = ???
	    72h ???
	    73h insert byte at end of keyboard buffer
		AL = byte to insert
		Return: AL = 00h if byte inserted
			   = 01h if no room to store
	    74h insert byte at front of keyboard buffer
		AL = byte to insert
		Return: AL = 00h if byte inserted
			   = 01h if no room to store
	    75h ???
	    76h get keyboard "stack" status
		AL = 'K' if kbd read will read physical keyboard
		     'S' if it will read EBL internal keyboard buffer
		AH = ???
	    77h clear internal keyboard buffer
	    78h ???
		AL = ???
	    79h ???
	    7Ah ???
		AL = ???
	    7Bh ???
		AL = ???
	    7Ch ???
		AL = ???
	    7Dh ???
		AL = ???
	    7Eh clear buffer for ???
	    7Fh installation check
		Return: CX = version in BCD
			DI = segment of ???
			BX = segment of next program's PSP???
Program: Extended Batch Language is a batch-file enhancer by Seaware
Notes:	the chaining does not check whether the interrupt had been hooked
	  before, so if you try to chain when the previous vector was
	  0000h:0000h, you'll be in trouble
	functions 72h and 7Ah-7Dh appear to be interfaces to the optional
	  floating-point and extended function packages
Index:	installation check;EBL|installation check;Extended Batch Language
--------d-64---------------------------------
INT 64 - Pdisk by Scott Garfinkle - Overwritten for Hard Drive information
Note:	This vector is overwritten by Pdisk to install custom harddrive types.
	  It can either destroy 4 vectors and take no memory or TSR and take
	  up some memory.
SeeAlso: INT 65"Pdisk"
----------64---------------------------------
INT 64 - PC-DRAFT - ASYNCHRONOUS DRIVER
	???
Return: ???
Program: PC-DRAFT is a powerful CAD environment by rhv.
SeeAlso: INT 62"PC-DRAFT",INT 65"PC-DRAFT",INT 66"PC-DRAFT",INT 67"PC-DRAFT"
--------N-6401-------------------------------
INT 64 U - BW-NFS - BWRPC - ???
	AH = 01h
	ES:BX -> ??? (at least 8 bytes)
	ES:BP -> DWORD ???
	???
Return: CF clear if successful
	    ???
	CF set on error
	    CX = 0000h
Range:	INT 4E to INT FD, selected by configuration
Notes:	the Beame&Whiteside TCP/IP protocol stack uses two consecutive
	  interrupts (62h and 63h by default); the BW-NFS client uses a third
	  consecutive interrupt (64h by default) if it is loaded
	the BWRPC installation check consists of determining the interrupt
	  vector assigned to it (two more than the value returned by reading
	  the ETHDEV27 device), and testing whether the word immediately
	  preceding the interrupt handler is 4257h ('BW')
SeeAlso: INT 62/AH=00h"ETHDEV",INT 63/AH=03h"BW-TCP",INT 63/AH=24h
Index:	installation checks;BWRPC
--------N-6402-------------------------------
INT 64 U - BW-NFS - BWRPC - ???
	AH = 02h
	DS:DI -> ???
Return: ???
Note:	this call is passed directly through to INT 62/AH=07h
SeeAlso: INT 62/AH=07h"ETHDEV"
--------N-6403-------------------------------
INT 64 U - BW-NFS - BWRPC - ADD ???
	AH = 03h
	AL = ???
	BP = ???
	ES:SI -> ???
Return: ???
Note:	this call is passed directly through to INT 62/AH=0Bh
SeeAlso: AH=04h,INT 62/AH=0Bh"ETHDEV"
--------N-6404-------------------------------
INT 64 U - BW-NFS - BWRPC - REMOVE ???
	AH = 04h
	BP = ???
Return: ???
Range:	INT 4E to INT FD, selected by configuration
Note:	this call is passed directly through to INT 62/AH=0Ch
SeeAlso: AH=03h,INT 62/AH=0Ch"ETHDEV"
--------N-6405-------------------------------
INT 64 U - BW-NFS - BWRPC - ???
	AH = 05h
	CX = ???
Return: ???
Note:	this call is passed directly through to INT 62/AH=13h
SeeAlso: INT 62/AH=13h"ETHDEV"
--------N-6406-------------------------------
INT 64 U - BW-NFS - BWRPC - ???
	AH = 06h
	ES:SI -> ???
Return: AL = 00h if CF clear
Range:	INT 4E to INT FD, selected by configuration
Note:	this call is passed directly through to INT 62/AH=14h
SeeAlso: INT 62/AH=14h"ETHDEV"
--------N-6407-------------------------------
INT 64 U - BW-NFS - BWRPC - GET IP ADDRESS
	AH = 07h
Return: CX:DX = IP address
--------N-6410-------------------------------
INT 64 U - BW-NFS - BWRPC - CALL ETHDEV.SYS
	AH = 10h
	AL = ETHDEV function number
	other registers as appropriate for ETHDEV call
Return: as returned by ETHDEV
Note:	this call is passed directly through to INT 62
SeeAlso: INT 62/AH=00h"ETHDEV"
--------N-6411-------------------------------
INT 64 U - BW-NFS - BWRPC - NOP???
	AH = 11h
Return: CF clear
Range:	INT 4E to INT FD, selected by configuration
--------N-64FE-------------------------------
INT 64 - BW-NFS - BWRPC - MAP EMS PAGE FRAME
	AH = FEh
	AL = direction
	    00h map in driver's memory block
	    01h map out driver's memory block
Return: CF clear if successful
	CF set on error
	    AL = error code
Range:	INT 4E to INT FD, selected by configuration
Note:	this call is passed through directly to ETHDEV.SYS (see INT 62/AH=FEh)
SeeAlso: INT 21/AH=3Fh"BW-TCP",INT 62/AH=FEh,INT 63/AH=03h"BW-TCP"
SeeAlso: INT 63/AH=24h
--------*-65---------------------------------
INT 65 - reserved for user interrupt
--------d-65---------------------------------
INT 65 - Adaptec controllers - DRIVE 1 DATA
Desc:	this vector stores the second four bytes of the parameter table for
	  hard disk 1
SeeAlso: INT 64"Adaptec",INT 66"Adaptec",INT 67"Adaptec",#0629
--------b-65---------------------------------
INT 65 - TI Professional PC - OPTION ROM DATA AREA POINTER (NOT A VECTOR!)
Desc:	the low word of this vector contains the segment of the RAM data area
	  to be used by the expansion ROM at F400h:8000h, and the high word
	  contains the length of the data area; this segment and size are
	  both set to 0000h if no ROM is installed at F400h:8000h
SeeAlso: INT 60"TI Professional PC",INT 64"TI Professional"
SeeAlso: INT 66"TI Professional PC"
--------h-65---------------------------------
INT 65 - Data General DG10 - MicroECLIPSE COPROCESSOR INTERFACE
SeeAlso: INT 64"DG10",INT 66"DG10"
--------N-65---------------------------------
INT 65 - FTP Software NDIS-Packet Driver adapter - POST PROCESSING INTERRUPT
--------U-65---------------------------------
INT 65 - SD.COM v6.2
Desc:	The unregistered version of SD62.COM uses the low byte of this vector
	  to count the number of invocations, displaying a registration
	  reminder each time after the 20th use.
--------d-65---------------------------------
INT 65 - Pdisk by Scott Garfinkle - Overwritten for Hard Drive information
SeeAlso: INT 64"Pdisk",INT 66"Pdisk"
----------65---------------------------------
INT 65 - PC-DRAFT - SECONDARY DISPLAY DRIVER
	???
Return: ???
Program: PC-DRAFT is a powerful CAD environment by rhv.
SeeAlso: INT 62"PC-DRAFT",INT 64"PC-DRAFT",INT 66"PC-DRAFT",INT 67"PC-DRAFT"
--------s-65---------------------------------
INT 65 - Ad Lib SOUND.COM - INTERFACE
	SI = function number (also see separate entries below)
	    0000h Init
	    0002h RelTimeStart
	    0003h SetState
	    0004h GetState
	    0005h Flush
	    0006h SetMode
	    0007h GetMode
	    0008h SetRelVolume
	    0009h SetTempo
	    000Ah SetTranspose
	    000Bh GetTranspose
	    000Ch SetActVoice
	    000Dh GetActVoice
	    000Eh PlayNoteDel
	    000Fh PlayNote
	    0010h SetTimbre
	    0011h SetPitch
	    0012h SetTickBeat
	    0013h NoteOn
	    0014h NoteOff
	    0015h Timbre
	    0016h SetPitchBend
	    0017h WaveForm
	ES:BX -> arguments
Note:	the installation check consists of checking for the signature block
	  immediately preceding the interrupt handler (see #2765)
SeeAlso: SI=8000h
Index:	installation check;Ad Lib SOUND.COM

Format of AdLib signature block:
Offset	Size	Description	(Table 2765)
 00h	WORD	version number
 02h 19 BYTEs	"SOUND-DRIVER-AD-LIB"
 15h	BYTE	01h
 16h	BYTE	01h
 17h	BYTE	00h
--------N-65----DX4147-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - ??? API
	DX = 4147h
	BH = 01h
	BL = function number (00h-2Ah)
	???
Return: CF clear if successful
	    AX = ???
	CF set on error
	    AX = error code (0001h=invalid function/subfunction)
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number and function number may be retrieved via INT 2A/AX=4147h
Note:	this API is supported by CLIENT.COM, SERVER.COM, DOSNET.COM, and
	  ROUTER.COM
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4147-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - ??? API
	DX = 4147h
	BH = 02h
	BL = function number (00h-05h)
	???
Return: CF clear if successful
	    AX = ???
	CF set on error
	    AX = error code (0001h=invalid function/subfunction)
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number and function number may be retrieved via INT 2A/AX=4147h
Note:	this API is supported by CLIENT.COM, SERVER.COM, DOSNET.COM, and
	  ROUTER.COM
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4147-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - ??? API
	DX = 4147h
	BH = 03h
	BL = function number (00h-03h) (00h-04h for ROUTER.COM)
	???
Return: CF clear if successful
	    AX = ???
	CF set on error
	    AX = error code
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number and function number may be retrieved via INT 2A/AX=4147h
Note:	this API is supported by CLIENT.COM, SERVER.COM, DOSNET.COM, and
	  ROUTER.COM
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4147-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - ??? API
	DX = 4147h
	BH = 04h
	BL = function number (00h-07h)
	???
Return: CF clear if successful
	    AX = ???
	CF set on error
	    AX = error code
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number and function number may be retrieved via INT 2A/AX=4147h
Note:	this API is supported by CLIENT.COM, SERVER.COM, and DOSNET.COM
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4147-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - ??? API
	DX = 4147h
	BH = 07h
	BL = function number (00h-08h)
	???
Return: CF clear if successful
	    AX = ???
	CF set on error
	    AX = error code (0001h=invalid function/subfunction)
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number and function number may be retrieved via INT 2A/AX=4147h
Note:	this API is supported by CLIENT.COM, SERVER.COM, and DOSNET.COM
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4147-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - INSTALLATION CHECK???
	DX = 4147h
	BH = 80h
Return: CF set
	AX = 0001h
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number and function number may be retrieved via INT 2A/AX=4147h
Note:	this call is supported by CLIENT.COM, SERVER.COM, and ROUTER.COM
SeeAlso: DX=4147h,INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - SPOOLER - ???
	DX = 4741h
	BH = 01h
	AL = 02h
	BL = function number (0Eh,0Fh)
	AH = subfunction number
	???
Return: ???
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - PRNREDIR - ???
	DX = 4741h
	BH = 01h
	AL = 03h
	BL = function number (0Eh,0Fh)
	AH = subfunction number
	???
Return: ???
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - PRNREDIR - ???
	DX = 4741h
	BH = 01h
	AL = 04h
	BL = function number (0Eh,0Fh)
	AH = subfunction number
	???
Return: ???
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - NETBIOS - ???
	DX = 4741h
	BH = 01h
	AL = 07h
	BL = function number (0Eh,0Fh)
	AH = subfunction number
	???
Return: ???
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - MACTEST - ???
	DX = 4741h
	BH = 01h
	AL = 08h
	BL = function number (0Eh,0Fh)
	AH = subfunction number
	???
Return: ???
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - Physical Layer - ???
	DX = 4741h
	BH = 02h
	BL = function number (01h-04h)
	???
Return: ???
	---function 02h---
	DS:SI -> ??? data area
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
Note:	this API is supported by PARALLEL.COM, SERIAL.COM, ARCNET.COM,
	  ETHERNET.COM, NDIS.COM, ODI.COM, SMC.COM, and FTP.COM
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - SPOOLER.COM - ???
	DX = 4741h
	BH = 05h
	BL = function number (00h,01h)
Return: CF clear
	AL = status code (00h=successful)
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - PRNREDIR.COM - ???
	DX = 4741h
	BH = 06h
	BL = function number (00h-04h)
	???
Return: ???
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - COMREDIR.COM - ???
	DX = 4741h
	BH = 08h
	BL = function number (00h-01h)
	???
Return: ???
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------N-65----DX4741-----------------------
INT 65 U - NetSoft DOS-NET v1.20+ - FTP.COM - ???
	DX = 4741h
	BX = 8010h
	AL = instance number???
Return: AX = 0008h if AL matches internal variable (call chained otherwise)
Range:	INT ?? to INT ??, selected by configuration option; actual interrupt
	  number may be retrieved via INT 2A/AX=4147h
SeeAlso: DX=4147h"INSTALLATION",INT 2A/AX=4147h
--------s-65----SI0000-----------------------
INT 65 - Ad Lib SOUND.COM - INITIALIZE (RESET)
	SI = 0000h
--------s-65----SI0003-----------------------
INT 65 - Ad Lib SOUND.COM - SET STATE
	SI = 0003h
	ES:BX -> WORD new state (0000h disabled, 0001h enabled)
SeeAlso: SI=0004h
--------s-65----SI0004-----------------------
INT 65 - Ad Lib SOUND.COM - GET STATE
	SI = 0004h
Return: AX = status
	    0000h all done playing sounds
	    else  still playing sounds
SeeAlso: SI=0003h
--------s-65----SI0006-----------------------
INT 65 - Ad Lib SOUND.COM - SET MODE
	SI = 0006h
	ES:BX -> WORD new mode (0000h melodic, 0001h percussive)
SeeAlso: SI=0007h
--------s-65----SI0007-----------------------
INT 65 - Ad Lib SOUND.COM - GET MODE
	SI = 0007h
Return: AX = mode
	    0000h melodic
	    0001h percussive
SeeAlso: SI=0006h
--------s-65----SI000C-----------------------
INT 65 - Ad Lib SOUND.COM - SET ACTIVE VOICE
	SI = 000Ch
	ES:BX -> WORD voice = 0000h to 0008h
SeeAlso: SI=000Dh
--------s-65----SI000D-----------------------
INT 65 - Ad Lib SOUND.COM - GET ACTIVE VOICE
	SI = 000Dh
Return: AX = voice (0000h to 0008h)
SeeAlso: SI=000Ch
--------s-65----SI8000-----------------------
INT 65 u - Media Vision FM.COM v4.1a+ - GET INTERNAL DATA STRUCTURES
	SI = 8000h
Return: DX:AX -> internal data structures
Program: FM.COM is an Ad Lib SOUND.COM-compatible driver for Media Vision's
	  Pro Audio Spectrum sound boards
SeeAlso: SI=8001h
--------s-65----SI8001-----------------------
INT 65 u - Media Vision FM.COM v4.1a+ - GET VOICE COUNT
	SI = 8001h
Return: AX = ???
	DX = number of voices??? (09h or 0Bh)
SeeAlso: SI=8000h
--------s-65----SI8002-----------------------
INT 65 - Media Vision FM.COM v4.1a+ - START BACKGROUND FM SOUNDS
	SI = 8002h
SeeAlso: SI=8003h
--------s-65----SI8003-----------------------
INT 65 - Media Vision FM.COM v4.1a+ - STOP BACKGROUND FM SOUNDS
	SI = 8003h
SeeAlso: SI=8002h
--------s-65----SI8004-----------------------
INT 65 U - Media Vision FM.COM v4.1a+ - GET ???
	SI = 8004h
Return: AX = ??? (0280h)
	DX = ??? (01A0h)
--------s-65----SI8005-----------------------
INT 65 U - Media Vision FM.COM v4.1a+ - ???
	SI = 8005h
	???
Return: ???
SeeAlso: SI=8000h
--------S-65---------------------------------
INT 65 U - EZRECV v1.0 - API
	AX = function
	    0000h ???
		Return: AX = ??? or FFFFh
	    0001h ???
		Return: AX = status (0000h or 0001h)
	    0002h ???
		Return: AX = status (0000h or 0001h)
	    0003h set ??? to 0001h
		Return: AX = 0000h
	    0004h ???
		Return: AX = ???
Return: BH = COM port being used
	BL = speed???
	CH = ???
	CL = ???
	DX = ???
	DS = ???
	ES = EZRECV data segment
Program: EZRECV is a background Zmodem file receiver by Express Consulting
--------*-66---------------------------------
INT 66 - reserved for user interrupt
--------d-66---------------------------------
INT 66 - Adaptec controllers - DRIVE 1 DATA
Desc:	this vector stores the third four bytes of the parameter table for
	  hard disk 1
SeeAlso: INT 64"Adaptec",INT 65"Adaptec",INT 67"Adaptec"
--------b-66---------------------------------
INT 66 - TI Professional PC - SYSTEM INFORMATION (NOT A VECTOR!)
Desc:	the low word of this vector contains the system memory size in
	  paragraphs; the third byte contains the number of outstanding
	  interrupt requests, and the fourth byte contains a description
	  of the installed drive types (see #2766)
SeeAlso: INT 60"TI Professional PC",INT 67"TI Professional"

Bitfields for TI Professional drive type information:
Bit(s)	Description	(Table 2766)
 7	floppy drive D: has 80 tracks
 6	floppy drive D: is double-sided
 5	floppy drive C: has 80 tracks
 4	floppy drive C: is double-sided
 3	floppy drive B: has 80 tracks
 2	floppy drive B: is double-sided
 1	floppy drive A: has 80 tracks
 0	floppy drive A: is double-sided
--------h-66---------------------------------
INT 66 - Data General DG10 - MicroECLIPSE COPROCESSOR INTERFACE
SeeAlso: INT 64"DG10"
--------N-66---------------------------------
INT 66 C - Nanosoft, Inc. TurboNET - NETWORK PROCESSING ???
Program: TurboNET is a NetBIOS-based file redirector and server
Note:	hooked but not used (IRET) by both redirector and server; called from
	  server's INT 28 handler
SeeAlso: INT 2F/AX=8100h
--------d-66---------------------------------
INT 66 - Pdisk by Scott Garfinkle - Overwritten for Hard Drive information
SeeAlso: INT 64"Pdisk",INT 67"Pdisk"
--------W-66---------------------------------
INT 66 - Microsoft Windows VITD.386 Virtual Interval Timer
Note:	This Windows 3.x Virtual Device Driver implements a virtual timer
	  which will expire and call INT 66.  This timer can be used to
	  calculate elapsed execution time etc.
--------K-66---------------------------------
INT 66 - Newkey v5.4 - INSTALLATION VECTOR
Return: immediately (IRET)
Program: Newkey is a shareware keyboard macro program by Frank A. Bell
Range:	INT 60h to INT 67h, selected by scanning for highest unused vector
Note:	the installation check consists of testing for the signature bytes
	  FDh FCh FFh FEh at offset 03h in the interrupt handlers segment
BUG:	the code obviously intends to use INT F0-FE, INT 70-77, and INT 68-6F
	  before falling back to INT 60-67, but only uses the last of these
	  ranges in v5.4
SeeAlso: INT 2F/AX=E300h
Index: installation checks;Newkey|Newkey;installation check
----------66---------------------------------
INT 66 - PC-DRAFT - TABLET/DIGITIZER DRIVER
	???
Return: ???
Program: PC-DRAFT is a powerful CAD environment by rhv.
SeeAlso: INT 62"PC-DRAFT",INT 64"PC-DRAFT",INT 65"PC-DRAFT",INT 67"PC-DRAFT"
--------U-66---------------------------------
INT 66 - PC-Magazin - INCA
	details not yet availble
Program: INCA is a utility from PC-Magazin (the German edition of PC Magazine)
	  issue 51-52/85.
SeeAlso: INT 61"SWAPx"
--------F-6601-------------------------------
INT 66 - BitFax Scheduler - SET MODE???
	AH = 01h
SeeAlso: AH=02h
--------F-6602-------------------------------
INT 66 - BitFax Scheduler - SET MODE???
	AH = 02h
SeeAlso: AH=01h
--------F-6603-------------------------------
INT 66 - BitFax Scheduler - SCHEDULE FAX TRANSMISSIONS
	AH = 03h
	???
Return: ???
SeeAlso: AH=05h
--------F-6604-------------------------------
INT 66 - BitFax Scheduler - GET STATUS???
	AH = 04h
Return: AX = ??? (0000h or 0001h)
	DX = BitSched version???  (for versions >= 3.00)
	    9796h (ver. 3.00)
	    97E6h (ver. 3.02)
	    92D0h (ver. 3.04.06)
	    9510h (ver. 3.06.02)
SeeAlso: AH=06h,AX=3345h,INT 2F/AX=8000h"FaxBIOS"
--------F-6605-------------------------------
INT 66 - BitFax Scheduler - CONVERT FILE AND SEND FAX
	AH = 05h
	BX:CX -> command block (see #2767)
	???
Return: ???
SeeAlso: AH=03h

Format of BitFax command block:
Offset	Size	Description	(Table 2767)
 00h 18 BYTEs	configuration bytes???
 12h	BYTEs	ASCIZ temporary file name to place converted fax
 52h	BYTEs	ASCIZ directory containing BitFax executables
 92h	BYTEs	ASCIZ telephone number
 C2h	BYTE	cover page control (00h don't send, 01h do send cover page)
 C3h 15 BYTEs	configuration bytes???
 E2h	BYTEs	ASCIZ path of BITFAX.TRA file (containing additional
		  configuration information???)
122h	BYTEs	configuration bytes???
12Ch	BYTE	00h don't send cover page
		01h send cover page
12Dh  7 BYTEs	configuration bytes???
134h	BYTEs	ASCIZ path of file to send
174h	BYTEs	more configuration bytes???
	???
--------F-6606-------------------------------
INT 66 - BitFax Scheduler - SET MODE???
	AH = 06h
Return: DX = BitSched version??? (same as AH=04h)
SeeAlso: AH=04h
--------s-660688-----------------------------
INT 66 - IBMSND driver, DIGPAK - PLAY 8-BIT DIGITIZED SOUND
	AX = 0688h
	DS:SI -> SNDSTRUC (see #2768)
Return: ???
Program: The IBMSND driver is part of John W. Ratcliff's
	   The IBM Digitized Sound Package
	DIGPAK is a set of digitized sound drivers written by
	  John W. Ratcliff, The Audio Solution, Inc.
Note:	the installation check consists of looking for a valid signature
	  string six bytes prior to the interrupt handler; this string may
	  be either "KERN" or "MIDI" (in the latter case, call AX=0701h to
	  determine whether IBMSND is installed)
SeeAlso: AX=068Bh,AX=068Fh,AX=0701h

Format of IBMSND driver SNDSTRUC:
Offset	Size	Description	(Table 2768)
 00h	DWORD	-> audio data
 04h	WORD	length of audio data in bytes
 06h	DWORD	-> playback status flag
 0Ah	WORD	playback frequency
--------s-660689-----------------------------
INT 66 - IBMSND driver, DIGPAK - REPORT SOUND DRIVER STATUS
	AX = 0689h
Return: AX = status
	    0000h no sound playing
	    0001h sound effect is currently playing
	---DIGPAK---
	BX = version number (v3.1+)
	DX = looping status
	    0000h no sound looping
	    0001h sound effect is currently looping
SeeAlso: AX=0688h,AX=068Bh,AX=068Ch
Index:	version check;DIGPAK
--------s-66068A-----------------------------
INT 66 - IBMSND driver, DIGPAK - PREFORMAT SOUND
	AX = 068Ah
	DS:SI -> SNDSTRUC (see #2768)
Desc:	convert audio data into output hardware format
SeeAlso: AX=068Bh
--------s-66068B-----------------------------
INT 66 - IBMSND driver, DIGPAK - PLAY PREFORMATTED SOUND
	AX = 068Bh
	DS:SI -> SNDSTRUC (see #2768)
Return: AX = ???
SeeAlso: AX=0688h,AX=068Ah,AX=068Fh
--------s-66068C-----------------------------
INT 66 - IBMSND driver, DIGPAK - REPORT AUDIO DRIVER CAPABILITIES
	AX = 068Ch
Return: AX = capabilities (see #2769)
	DX = playback rate if fixed-frequency playback
	---DIGPAK---
	BX:CX -> ASCIZ ID string
SeeAlso: AX=0689h,AX=068Dh

Bitfields for IBMSND driver capabilities:
Bit(s)	Description	(Table 2769)
 0	can play audio in background
 1	data is massaged for output device
 2	driver plays at fixed frequency, resampling input data to fit
 3	driver uses timer interrupt
---DIGPAK---
 4	device supports timer sharing
 5	supports looped sounds and pending
 6	supports stereo panning
 7	supports 8-bit PCM stereo playback
 8	supports audio recording
 9	supports DMA bakcfilling
--------s-66068D-----------------------------
INT 66 - IBMSND driver, DIGPAK - REPORT CURRENT SAMPLE ADDRESS
	AX = 068Dh
Return: AX = current playback address
Desc:	determine what point in the audio data the playback has reached, for
	  synchronization with video or animation effects
Notes:	this function applies to background playback only
	the reported address may be an approximation rather than the exact
	  address
SeeAlso: AX=068Ch,AX=0691h
--------s-66068E-----------------------------
INT 66 - IBMSND driver, DIGPAK - SET CALLBACK ADDRESS
	AX = 068Eh
	BX:DX -> callback function
	    0000h:0000h to disable callback
	DS = value to load into DS when calling the callback function
Desc:	specify the function to be called when playback of a sound effect is
	  completed
Note:	the callback function will typically be called during a hardware
	  interrupt, so all the usual precautions should be taken except for
	  preserving registers
SeeAlso: AX=0691h
--------s-66068F-----------------------------
INT 66 - IBMSND driver, DIGPAK - STOP CURRENT SOUND
	AX = 068Fh
Desc:	cause any currently-playing sound effect to be terminated
SeeAlso: AX=0688h,AX=068Bh
--------s-660690-----------------------------
INT 66 - IBMSND driver, DIGPAK - "SetAudioHardware" - SET UP HARDWARE INFO
	AX = 0690h
	BX = IRQ
	CX = base address
	DX = other setup value (device-dependent???)
--------s-660691-----------------------------
INT 66 - IBMSND driver, DIGPAK - REPORT CALLBACK ADDRESS
	AX = 0691h
Return: AX:DX -> current callback function
	BX = original caller's DS register
Program: The IBMSND driver is part of John W. Ratcliff's
	   The IBM Digitized Sound Package
	DIGPAK is a set of digitized sound drivers written by
	  John W. Ratcliff, The Audio Solution, Inc.
SeeAlso: AX=068Eh
--------s-660693-----------------------------
INT 66 - DIGPAK - SET TIMER DIVISOR RATE
	AX = 0693h
	DX = rate
Program: DIGPAK is a set of digitized sound drivers written by
	  John W. Ratcliff, The Audio Solution, Inc.
--------s-660694-----------------------------
INT 66 - DIGPAK - PLAY PREFORMATTED DATA
	AX = 0694h
	DS:SI -> Sound Data structure (see #2768)
Return: AX = status???
--------s-660695-----------------------------
INT 66 - DIGPAK - POST AUDIO PENDING
	AX = 0695h
	DS:SI -> Sound Data structure (***)
Return: AX = status
	    0000h sound started playing
	    0001h sound was posted as pending to play
	    0002h sound effect already pending, this one not posted
SeeAlso: AX=0696h
--------s-660696-----------------------------
INT 66 - DIGPAK - GET AUDIO PENDING STATUS
	AX = 0696h
Return: AX = status
	    0000h no sound is playing
	    0001h sound playing, and a sound is pending
	    0002h sound playing, no sound pending
SeeAlso: AX=0695h
--------s-660697-----------------------------
INT 66 - DIGPAK - SET STEREO PANNING
	AX = 0697h
	DX = panning position (0 = right, 127 = left)
Return: AX = status
	    0000h command ignored (not supported)
	    0001h panning set
--------s-660698-----------------------------
INT 66 - DIGPAK - SET PLAY MODE
	AX = 0698h
	DX = playback mode
	    0000h 8-bit PCM
	    0001h 8-bit stereo PCM
	    0002h 16-bit PCM
	    0003h 16-bit stereo PCM
Return: AX = status
	    0000h command ignored
	    0001h mode set
--------s-660699-----------------------------
INT 66 - DIGPAK - GET ADDRESSES
	AX = 0699h
Return: AX = pending address
	BX = semaphore address
--------s-66069A-----------------------------
INT 66 - DIGPAK - SET RECORD MODE
	AX = 069Ah
	DX = recording mode
	    0000h turn audio recording on
	    0001h turn audio recording off
Return: AX = status
	    0000h command ignored
	    0001h audio recording mode set
--------s-66069B-----------------------------
INT 66 - DIGPAK - STOP NEXT LOOP
	AX = 069Bh
--------s-66069C-----------------------------
INT 66 - DIGPAK - SET DMA BACKFILL MODE
	AX = 069Ch
	DX = mode
	    0000h turn backfill mode on
	    0001h turn backfill mode off
Return: AX = status
	    0000h command ignored
	    0001h backfill mode set
SeeAlso: AX=069Dh,AX=069Eh
--------s-66069D-----------------------------
INT 66 - DIGPAK - REPORT DMA COUNTER
	AX = 069Dh
Return: AX = DMA counter
SeeAlso: AX=069Eh
--------s-66069E-----------------------------
INT 66 - DIGPAK - VERIFY DMA BLOCK
	AX = 069Eh
	CX = length of buffer
	ES:BX -> buffer containing sound data
Return: AX = status
	    0000h block crosses 64K bounadary
	    0001h block is OK
SeeAlso: AX=069Dh
--------s-66069F-----------------------------
INT 66 - DIGPAK - SET PCM VOLUME
	AX = 069Fh
	BX = left channel volume (0-100)
	CX = right channel volume (0-100)
Return: AX =  status
	    0000h command ignored
	    0001h volume set
--------s-6606A0-----------------------------
INT 66 - DIGPAK - SET DPMI MODE
	AX = 06A0h
	DX = mode
	    0000h 32-bit register addressing on
	    0001h 32-bit register addressing off
SeeAlso: INT 31/AX=0400h
--------s-660700-----------------------------
INT 66 - MIDPAK - UNINSTALL
	AX = 0700h
Note:	this function should NOT be called by applications
Program: MIDPAK is a set of MIDI sound drivers developed by Miles Design
	  Incorporated.
--------s-660701-----------------------------
INT 66 - IBM Digitized Sound Package MIDI driver - GET DIGITIZED SOUND CAPABIL
	AX = 0701h
Return: AX = digitized sound capabilities
	    0000h if digitized sound driver (functions 06xxh) not available
Notes:	the installation check for the MIDI driver is to test for the signature
	  "MIDI" six bytes before the interrupt handler
	also supported by MIDPAK, the successor to the Digitized Sound
	  Package's MIDI driver
SeeAlso: AX=0688h
--------s-660702-----------------------------
INT 66 - MIDPAK - PLAY SEQUENCE
	AX = 0702h
	BX = Sequence number
Return: AX = status
	    0000h Sequence is being played
	    0001h Sequence not available
SeeAlso: AX=0703h,AX=0705h
--------s-660703-----------------------------
INT 66 - MIDPAK - SEGUE SEQUENCE
	AX = 0703h
	BX = sequence number
	CX = activation code (FFFFh is next trigger)
Return: ???
--------s-660704-----------------------------
INT 66 - MIDPAK - REGISTER XMIDI
	AX = 0704h
	CX:BX -> XMIDI sequence data
	DI:SI = length of XMIDI data
Return: AX = status
	    0000h unable to register XMIDI data
	    0001h XMIDI file registered resident
	    0002h XMIDI file was registered to the application
--------s-660705-----------------------------
INT 66 - MIDPAK - STOP MIDI
	AX = 0705h
SeeAlso: AX=0702h,AX=0709h
--------s-660706-----------------------------
INT 66 O - MIDPAK - REMAP CHANNEL
	AX = 0706h
	BX = sequence
	CX = physical
--------s-660707-----------------------------
INT 66 - MIDPAK - REPORT TRIGGER EVENT COUNTER
	AX = 0707h
Return: AX = count of number of callbacks since last reset
	DX = ID
SeeAlso: AX=0708h,AX=0713h
--------s-660708-----------------------------
INT 66 - MIDPAK - RESET EVENT TRIGGER COUNTER
	AX = 0708h
SeeAlso: AX=0707h,AX=0713h
--------s-660709-----------------------------
INT 66 O - MIDPAK - MIDI SLEEP
	AX = 0709h
SeeAlso: AX=070Ah
--------s-66070A-----------------------------
INT 66 O - MIDPAK - MIDI AWAKE
	AX = 070Ah
SeeAlso: AX=0709h
--------s-66070B-----------------------------
INT 66 - MIDPAK - RESUME PLAYING
	AX = 070Bh
SeeAlso: AX=070Ch
--------s-66070C-----------------------------
INT 66 - MIDPAK - GET SEQUENCE STATUS
	AX = 070Ch
Return: AX = status
	    0000h sequence stopped
	    0001h sequence playing
	    0002h sequence done
SeeAlso: AX=070Bh
--------s-66070D-----------------------------
INT 66 - MIDPAK - REGISTER XMIDI FILE
	AX = 070Dh
	CX:BX -> ASCII filename
SeeAlso: AX=0704h,AX=0710h
--------s-66070E-----------------------------
INT 66 - MIDPAK - GET RELATIVE VOLUME
	AX = 070Eh
Return: AX = current volume
SeeAlso: AX=070Fh
--------s-66070F-----------------------------
INT 66 - MIDPAK - SET RELATIVE VOLUME
	AX = 070Fh
	BX = new volume
	CX = time
SeeAlso: AX=070Eh
--------s-660710-----------------------------
INT 66 - MIDPAK - LOAD MIDPAK DRIVER
	AX = 0710h
	BX = segment of .ADV driver
	CX = 0000h (offset must be zero)
	DX:SI -> .AD driver
SeeAlso: AX=070Dh
--------s-660711-----------------------------
INT 66 - MIDPAK - POLL MIDPAK
	AX = 0711h
Return: AX = ???
	???
SeeAlso: AX=0712h
--------s-660712-----------------------------
INT 66 - MIDPAK - GET MIDI CLOCK
	AX = 0712h
Return: AX:DX = clock counter
	CX:BX = clock address
SeeAlso: AX=0711h,AX=0713h
--------s-660713-----------------------------
INT 66 - MIDPAK - GET TRIGGER COUNT ADDRESS
	AX = 0713h
Return: AX:DX -> trigger counter address
SeeAlso: AX=0707h,AX=0712h,AX=0714h
--------s-660714-----------------------------
INT 66 - MIDPAK - GET EVENT ID ADDRESS
	AX = 0714h
Return: AX:DX -> event ID
SeeAlso: AX=0713h,AX=0716h
--------s-660716-----------------------------
INT 66 - MIDPAK - REPORT SEQUENCE NUMBER
	AX = 0716h
Return: AX = current sequence number
SeeAlso: AX=0702h
Program: MIDPAK is a set of MIDI sound drivers developed by Miles Design
	  Incorporated.
--------n-6610-------------------------------
INT 66 - PenDOS - TDMOUSE.EXE - GET ???
	AH = 10h
Return: CF clear
	AX = 0000h
	BX = ??? (0012h)
	DX:CX -> TDMOUSE INT 33 handler (IRET to hide mouse from other apps)
Program: TDMOUSE is a PenDOS hardware driver which allows a mouse to emulate
	  a touchpad; PenDOS is a set of programs by Communication Intelligence
	  Corporation which makes applications pen-aware
--------n-6611-------------------------------
INT 66 - PenDOS - TDMOUSE.EXE - SET ??? HANDLER
	AH = 11h
	DX:BX -> new handler for ???
Return: CF clear
	AX = 0000h
	DX:BX -> old handler for ??? (points at RETF by default)
--------n-6612-------------------------------
INT 66 - PenDOS - TDMOUSE.EXE - INITIALIZE
	AH = 12h
Return: CF clear
	AX = 0000h
Note:	this function calls the old mouse handler with functions 0000h, 0002h,
	  0007h, 0008h, 000Fh, 0004h, and 000Ch (in that order)
SeeAlso: AH=13h
--------n-6613-------------------------------
INT 66 - PenDOS - TDMOUSE.EXE - SHUTDOWN???
	AH = 13h
Return: CF clear
	other register as returned by INT 33/AX=0000h
SeeAlso: AH=12h
--------n-6614-------------------------------
INT 66 - PenDOS - TDMOUSE.EXE - ???
	AH = 14h
	BX = ???
	CX = ???
Return: CF clear
	AX = 0000h
--------n-6615-------------------------------
INT 66 - PenDOS - TDMOUSE.EXE - SET ??? HANDLER
	AH = 15h
	DX:BX -> new handler for ???
Return: CF clear
	AX = 0000h
	DX:BX -> old handler (points at RETF by default)
--------n-6616-------------------------------
INT 66 - PenDOS - TDMOUSE.EXE - UNUSED FUNCTIONS
	AH = 16h to 1Fh
Return: CF set
Program: TDMOUSE is a PenDOS hardware driver which allows a mouse to emulate
	  a touchpad; PenDOS is a set of programs by Communication Intelligence
	  Corporation which makes applications pen-aware
--------n-6621-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 21h
Return: CF clear if successful
	CF set on error
Note:	this function sets ??? flag or counter (also set by AH=2Fh) to FFFFh
--------n-6622-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 22h
	DX:BX -> ???
	CL = ???
Return: CF clear if successful
	CF set on error
	???
SeeAlso: AH=24h
--------n-6623-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 23h
	???
Return: CF clear if successful
	CF set on error
	???
--------n-6624-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 24h
	DX:BX -> ???
	CL = ???
Return: CF clear if successful
	CF set on error
	???
SeeAlso: AH=22h
--------n-6625-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 25h
	CL = ??? (NOP if 00h)
	???
Return: CF clear if successful
	CF set on error
	???
--------n-6627-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 27h
	BL = ???
	BH = ???
	CL = ??? (0-3)
	DL = ??? (> BL)
	DH = ??? (> BH)
Return: ???
--------n-6628-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 28h
	???
Return: CF clear if successful
	CF set on error
	???
Note:	this function sets ??? flag or counter (also set by AH=2Fh) to FFFFh
--------n-6629-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 29h
	???
Return: ???
Note:	this function sets ??? flag or counter (also set by AH=2Fh) to FFFFh
--------n-662A-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 2Ah
	DL = ??? (nonzero)
	DH = ??? (nonzero)
Return: CF clear if successful
	CF set on error
	???
--------n-662B-------------------------------
INT 66 - PenDOS - PINK - ???
	AH = 2Bh
	???
Return: CF clear if successful
	CF set on error
	???
--------n-662F-------------------------------
INT 66 - PenDOS - PINK - INITIALIZE
	AH = 2Fh
	???
Return: AX = status
	    0000h failed
	    FFFFh successful
	???
Note:	this function sets ??? flag or counter to FFFFh and hooks INT 1Ch
--------F-663345-----------------------------
INT 66 - BitFax Scheduler - REMOVE TSR FROM MEMORY
	AX = 3345h
Return: AX = FFFFh error removing TSR
Note:	the installation check consists of checking for the signature
	  "BitFax Scheduler" beginning two bytes past the interrupt handler
SeeAlso: AH=04h,INT 2F/AH=2Ah,INT 2F/AX=CB00h
Index:	installation check;BitFax Scheduler
--------n-6640-------------------------------
INT 66 - PenDOS - PKEYUS - GET VERSION
	AH = 40h
Return: CF clear
	AX = 0000h
	BH = major version (02h for version bundled with IBM DOS 6.1)
	BL = minor version (00h for version bundled with IBM DOS 6.1)
	DL = ??? (4Eh)
	DH = ??? (0Eh)
--------n-6641-------------------------------
INT 66 - PenDOS - PKEYUS - SET ???
	AH = 41h
	BX = ???
	CL = ??? (08h-20h)
	DL = screen column??? (<= 50h)
	DH = screen row???  (<= 3Ch)
Return: AX = status (0000h successful, 0001h error)
Note:	this function also sets an internal flag
SeeAlso: AH=42h,AH=43h
--------n-6642-------------------------------
INT 66 - PenDOS - PKEYUS - ???
	AH = 42h
Return: CF clear
	AX = 0000h
Note:	this function also clears the flag set by AH=41h
SeeAlso: AH=41h
--------n-6643-------------------------------
INT 66 - PenDOS - PKEYUS - ???
	AH = 43h
	BX = ???
	DX = ???
Return: AX = status
	    0000h if AH=41h flag set
	    else
		AH = ???
		AL = ???
		BX = ???
		DX = ???
SeeAlso: AH=41h
--------n-6644-------------------------------
INT 66 - PenDOS - PKEYUS - UNUSED FUNCTIONS
	AH = 44h to 4Fh
Return: CF set
--------n-6650-------------------------------
INT 66 - PenDOS - PMOUSE - SET ???
	AH = 50h
	BX = ???
	CH = ???
	DX = ???
Return: CF clear
	AX = 0000h
--------n-6651-------------------------------
INT 66 - PenDOS - PMOUSE - NOP
	AH = 51h
Return: CF set
--------n-6652-------------------------------
INT 66 - PenDOS - PMOUSE - ???
	AH = 52h
	BX = ???
	CL = ???
	DX = ???
Return: ???
--------n-6653-------------------------------
INT 66 - PenDOS - PMOUSE - UNUSED FUNCTIONS
	AH = 53h to 57h
Return: CF set
--------n-66---------------------------------
INT 66 - PenDOS - PMOUSE - ALTERNATE API
	AH = function (58h-5Fh)
Note:	these functions exactly duplicate AH=50h-57h
--------U-66AA02-----------------------------
INT 66 - HelpTSR v2.10 - INSTALLATION CHECK
	AX = AA02h
Return: ES:DI -> 7 byte signature "HelpTSR" if resident
Program: HelpTSR is a resident viewer by David Jurgens for HelpPC
--------n-66C5-------------------------------
INT 66 - PenDOS - VLOAD - API
	AH = C5h
	???
Return: ???
--------t-66FFFBBXFFFB-----------------------
INT 66 - MicroHelp Stay-Res Plus - ???
	AX = FFFBh
	BX = FFFBh
	???
Return: ???
SeeAlso: AX=FFFEh,INT 2D"AMIS"
--------t-66FFFEBXFFFE-----------------------
INT 66 - MicroHelp Stay-Res/Stay-Res Plus - UNINSTALL
	AX = FFFEh
	BX = FFFEh
Return: only if unsuccessful
Notes:	installation check is for the interrupt handler to begin with the bytes
	  FBh 9Ch or 9Ch FAh, and the program name (not case-sensitive) to
	  appear at offset 0005h (older versions) or the offset returned by
	  AX=FFFFh/BX=FFF0h in the interrupt handler segment.
	Programs which use Stay-Res include ThesPlus (program name "THESPLUS")
	  and Personal Calendar (program name "CAL") by Paul Mun~oz-Colman.
SeeAlso: AX=FFFBh,AX=FFFFh,INT 2D"AMIS"
Index:	installation check;MicroHelp Stay-Res|installation check;ThesPlus
Index:	installation check;Personal Calendar|installation check;CAL
--------t-66FFFFBXFFF0-----------------------
INT 66 - MicroHelp Stay-Res Plus - FIND PROGRAM NAME
	AX = FFFFh
	BX = FFF0h
Return: DI = offset of program name in interrupt handler segment
SeeAlso: AX=FFFBh,AX=FFFEh,INT 2D"AMIS"
--------d-67---------------------------------
INT 67 - Adaptec controllers - DRIVE 1 DATA
Desc:	this vector stores the last four bytes of the parameter table for
	  hard disk 1
SeeAlso: INT 64"Adaptec",INT 65"Adaptec",INT 66"Adaptec"
--------b-67---------------------------------
INT 67 - TI Professional PC - SYSTEM DATA (NOT A VECTOR!)
Desc:	this vector contains the TI Pro's system configuration words
	  (see #2770)
SeeAlso: INT 66"TI Professional PC"

Bitfields for TI Professional PC System Configuration doubleword:
Bit(s)	Description	(Table 2770)
 0	8087 present
 31-1	reserved (0)
--------d-67---------------------------------
INT 67 - Pdisk by Scott Garfinkle - Overwritten for Hard Drive information
SeeAlso: INT 64"Pdisk",INT 66"Pdisk"
--------I-67---------------------------------
INT 67 - Sangoma CCPOP 3270 resident module
SeeAlso: INT 61"Sangoma",INT 68"Sangoma"
--------U-67---------------------------------
INT 67 - CUCKOO.COM - INSTALLATION CHECK
Program: CUCKOO is a resident on-screen clock with optional hourly chime or
	  cuckoo by an unknown author with revisions by Thomas A. Lundin
Note:	this is not a vector; when loaded for the first time, CUCKOO.COM uses
	  the last unused (0000h:0000h) vector in the range 60h-67h to store
	  the signature value 434Ch:4F4Bh ('CLOK')
----------67---------------------------------
INT 67 - PC-DRAFT - KEYBOARD DRIVER
	???
Return: ???
Program: PC-DRAFT is a powerful CAD environment by rhv.
SeeAlso: INT 62"PC-DRAFT",INT 64"PC-DRAFT",INT 65"PC-DRAFT",INT 66"PC-DRAFT"
--------N-6700-------------------------------
INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE AND WAIT
	AH = 00h
	DS:DX -> ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #2771)
	AH = semaphore owner if status=02h
SeeAlso: AH=01h,AH=02h"PC-NET",INT 7F/AH=00h

(Table 2771)
Values for PC-NET semaphore function status:
 00h	successful
 01h	invalid function
 02h	semaphore already locked
 03h	unable to lock semaphore
 04h	semaphore space exhausted
--------N-6701-------------------------------
INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE
	AH = 01h
	DS:DX -> ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #2771)
	AH = semaphore owner if status=02h
SeeAlso: AH=00h,AH=02h"PC-NET",INT 7F/AH=01h"Alloy"
--------N-6702-------------------------------
INT 67 - PC-NET, Alloy NTNX - UNLOCK SEMAPHORE
	AH = 02h
	DS:DX -> ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #2771)
	AH = semaphore owner if status=02h
SeeAlso: AH=00h,AH=01h"PC-NET",INT 7F/AH=02h
--------m-671E-------------------------------
INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - INSTALLATION CHECK
	AH = 1Eh
Return: AH = 00h if installed
	    AL destroyed
	    ES:DI -> ASCII signature "MemLimit"
SeeAlso: AH=1Fh,INT 21/AX=4402h"386MAX"
--------m-671F-------------------------------
INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - API
	AH = 1Fh
	DS:SI -> request packet (see #2772)
Return: AH = status (00h successful, 84h invalid function code, etc.)
SeeAlso: AH=1Eh

Format of 386MAX MEMLIMIT request packet:
Offset	Size	Description	(Table 2772)
 00h	WORD	function code (00h-0Fh)
 02h	WORD	return code (see #2773)
 04h  4 BYTEs	???
 08h	WORD	???
	???

(Table 2773)
Values for 386MAX MEMLIMIT return code:
 00h	unknown request
 01h	invalid parameter for VCPI limit
 02h	VCPI limit set
 03h	invalid parameter for EMS limit
 04h	EMS limit set
 05h	DPMI disabled
 06h	XMS disabled
 07h	XMS limit set
 08h	unable to uninstall
 09h	unloaded
--------m-672763CL01-------------------------
INT 67 - VIDEMS.SYS v1.31+ - INSTALLATION CHECK
	AX = 2763h
	CL = 01h
	BX = signature AAFFh
Return: AH = 00h if VIDEMS is installed
	    CH = 00h if optimization for 80286 is used, 01h otherwise
	    CL = internal revision number (typically 00h to 03h)
	    DX = driver version (DH=major, DL=minor; not a BCD!)
	AH = 84h if not installed but EMS manager is present
Program: VIDEMS is an expanded memory manager from Conea Software Corp. It
	 converts video adapter RAM to LIM 3.2 EMS.
SeeAlso: AX=2763h/CL=02h,AX=2763h/CL=03h
--------m-672763CL02-------------------------
INT 67 - VIDEMS.SYS v1.31+ - FLUSH EMS TO VIDEO RAM
	AX = 2763h
	CL = 02h
	BX = signature AAFFh
Return: AH = 00h if successful
Notes:	This call is normally used by Conea products only.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=03h
--------m-672763CL02-------------------------
INT 67 - VIDEMS.SYS v1.31+ - RELOAD EMS FROM VIDEO RAM
	AX = 2763h
	CL = 02h
	[Yes, I know the registers are duplicated.  Clarification to follow.]
	BX = signature AAFFh
Return: AH = 00h if successful
Notes:	This call is normally used by Conea products only.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=03h
--------m-672763CL03-------------------------
INT 67 - VIDEMS.SYS v1.31+ - RETURN HIDDEN BLOCK SIZE
	AX = 2763h
	CL = 03h
	BX = signature AAFFh
Return: AH = 00h if successful
	    DX = block size in kilobytes
Desc:	Returns the amount of EMS which can be safely used at any time, and
	  can't be destroyed by writing anything to the B800:0000 buffer.
Note:	this function normally returns 184K, while the driver provides up to
	  240K of EMS.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=02h
--------m-672763CL03-------------------------
INT 67 - VIDEMS.SYS v1.31+ - RETURN PHYSICAL PAGE SIZE
	AX = 2763h
	CL = 03h
	[Yes, I know the registers are duplicated.  Clarification to follow.]
	BX = signature AAFFh
Return: AH = 00h
	DX = size in bytes
Desc:	Used by Conea products to determine if addressing mode has changed.
	  Normally, all VIDEMS versions beginning from 1.10 (or 1.15 - ?) use
	  4K "physical" pages.
Notes:	this function will probably become raw page size in future releases of
	  VIDEMS, which	will support the LIM 4.0 standard.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=02h
--------u-672833-----------------------------
INT 67 - Q87 v4+ - PREPARE TO UNLOAD AND GET XMS HANDLE FOR Q87 MEMORY
	AX = 2833h
	EAX = 29482833h (entire EAX value required)
Return: EAX = XMS handle for memory allocated when Q87 was installed
	EBX = status
	    00000000h Q87 is in demo mode (countdown running);
			  Q87 remains active
	    00000001h Q87 is in registered mode; memory manager's IDT, GDT,
			  and optionally CR0 (if BL <> 5Fh on entry) have
			  been restored
	    00000002h Q87 is in demo mode (demo time has expired);
			  Q87 remains active
Note:	this call is used by UNLOAD87 to release the memory used by Q87
BUG:	v4.00-v4.03 will hang on most machines when run under bare DOS with
	  no memory manager, because neither Q87 nor UNLOAD87 checks whether
	  there is a valid INT 67 handler before performing an installation
	  check via INT 67
SeeAlso: AX=4321h,INT 21/AX=4321h/BX=0000h
--------m-673F--CX5145-----------------------
INT 67 U - QEMM-386 v4.23+ - INSTALLATION CHECK
	AH = 3Fh
	CX = 5145h ("QE")
	DX = 4D4Dh ("MM")
Return: AH = 00h if installed
	    ES:DI -> QEMM API entry point (see #2774,#2777,#2889)
Notes:	if no other program has hooked INT 67, an alternate installation
	  check is to test for the string
	  "QUARTERDECK EXPANDED MEMORY MANAGER 386" at offset 14h in the INT 67
	  handler's segment; the word at offset 12h contains the offset in
	  the handler's segment of the API entry point
	although this function is still undocumented, Quarterdeck has recently
	  documented two alternate methods for determining the QEMM API entry
	  point, as well as several of the API functions
	MICEMM (Micronics Expanded Memory Manager) versions 2.0C and 4D support
	  the alternate QEMM installation check and entry point functions 00h,
	  02h, and 03h; version 4D only provides the signature string if the
	  commandline argument "DV" is provided
	386MAX v6.01 responds to this call, but DESQview 2.42 does not
	  recognize the returned entry point as providing QEMM's capabilities
	  because a) only functions 0Ch (different from QEMM 0Ch) and
			1000h-1009h are supported,
		  b) status is returned as for EMS functions, not QEMM funcs
		  c) the protected-mode entry point returned by function 1000h
			only supports functions 0Ch, 1004h, 1005h, and 100Ah
	the string check mentioned above is not supported by 386MAX
SeeAlso: AX=5BF0h,AH=DDh,AX=FFA5h,INT 15/AX=11DEh,INT 21/AX=4402h/SF=01h
SeeAlso: INT 21/AX=4402h"QEMM",INT 21/AX=4402h"386MAX",INT 2F/AX=D201h/BX=5145h

(Table 2774)
Values for calling QEMM "QPI_GetStatus" function:
	AH = 00h get QEMM state
Return: CF clear
	AL = QEMM state
	    bit 0 set if QEMM turned OFF
	    bit 1 set if in "Auto" mode
Note:	this function is officially documented
SeeAlso: #2775,#2776,#2777,#2889

(Table 2775)
Values for calling QEMM "QPI_SetStatus" function:
	AH = 01h set QEMM state
	AL = new state
	    bit 0 set: place QEMM in OFF state
Return: CF clear if successful
	CF set on error
Note:	this function is officially documented
SeeAlso: #2774

(Table 2776)
Values for calling QEMM QPI function 02h:
	AH = 02h get ???
Return: CF clear
	AX = segment of ??? data structure
	Data Structure
	Offset	Size	Description
	 00h	DWORD	page table entry for ???
		???
SeeAlso: #2777

(Table 2777)
Values for calling QEMM "QPI_GetVersion" function:
	AH = 03h get QEMM version
Return: CF clear
	AX = BX = version in BCD
Notes:	this function is officially documented.	 The most recent official docs
	  state that the version is returned in both AX and BX; older
	  documentation only mentions BX
	MICEMM returns AX=0001h, BX unchanged
SeeAlso: #2774,#2778

(Table 2778)
Values for calling QEMM QPI function 04h:
	AH = 04h allocate 4K page and set AUTO/ON mode
Return: CF clear if successful
	    DX = page number of a 4K page
	CF set if unable to allocate page
Note:	QEMM mode unchanged if not AUTO/OFF
SeeAlso: #2779

(Table 2779)
Values for calling QEMM QPI function 05h:
	AH = 05h free 4K page and turn QEMM off
	DX = page number returned by function 04h
Return: CF clear
Note:	QEMM mode unchanged if not AUTO/ON
SeeAlso: #2778,#2780

(Table 2780)
Values for calling QEMM QPI function 06h:
	AH = 06h make new mapping context???
	DX = page number of 4K page to hold page table
Return: CF clear
Note:	copies page table into given page and then sets ??? page table entry
	  to point at copy
SeeAlso: #2781,#2782

(Table 2781)
Values for calling QEMM QPI function 07h:
	AH = 07h get mapping context
Return: CF clear
	DX = page number of page table for current mapping context
SeeAlso: #2777,#2780,#2782

(Table 2782)
Values for calling QEMM QPI function 08h:
	AH = 08h set mapping context???
	DX = linear page number of page table
Return: CF clear
SeeAlso: #2777,#2780,#2781,#2783,#2785

(Table 2783)
Values for calling QEMM QPI function 09h:
	AH = 09h get linear page number for page table entry
	CX = page table index
Return: CF clear
	DX = linear page number
SeeAlso: #2784

(Table 2784)
Values for calling QEMM QPI function 0Ah:
	AH = 0Ah set linear page number for page table entry
	CX = page table index
	DX = linear page number
Return: CF clear
SeeAlso: #2783

(Table 2785)
Values for calling QEMM QPI function 0Bh:
	AH = 0Bh map 4K pages
	BX = number of pages
	CX = first page number (must be 0100h to allocate HMA)
	DX = EMS handle (memory belonging to EMS handle will be mapped
	      into the address space beginning with the first page
	      allocated to the handle)
Return: AH = 00h
SeeAlso: #2782,#2786

(Table 2786)
Values for calling QEMM QPI function 0Ch:
	AH = 0Ch get available memory
Return: CF clear
	BX = 0001h
	CX = total 4K pages???
	DX = number of 4K pages free
SeeAlso: #2785,#2787

(Table 2787)
Values for calling QEMM QPI function 0Dh:
	AH = 0Dh CRT controller I/O port trapping
	AL = mode
	    00h only trap on I/O ports 03C0h-03C5h, 03C7h, 03CAh-03CFh
	    01h trap on ports 03B4h, 03B5h, 03B8h, 03C6h, 03C8h, 03C9h,
		  03D4h, and 03D5h
	    02h only trap on I/O ports 03C6h, 03C8h, and 03C9h
Return: CF clear

(Table 2788)
Values for calling QEMM QPI function 0Eh:
	AH = 0Eh set cursor virtualization callbacks
	DS:BX -> FAR routine for getting hardware cursor address
	ES:DX -> FAR routine for setting hardware cursor address
Return: CF clear
Note:	both callbacks are invoked with CL indicating which
	  CRT controller register to access (0Eh for high
	  byte of cursor address, 0Fh for low byte)
	the DS:BX callback should return BX=cursor address;
	  ES:DX is called with BL or BH (depending on CL)
	  set to the appropriate half of the cursor's address

(Table 2789)
Values for calling QEMM QPI function 0Fh:
	AH = 0Fh unmap 4K pages
	CX = first page number
	DX = number of pages
Return: CF clear
	AL = 00h/01h if ???
Note:	if CX=0100h and DX=0010h, the HMA is remapped to
	  simulate a disabled A20

(Table 2790)
Values for calling QEMM QPI function 1000h:
	AX = 1000h get protected-mode interface
	DS:SI -> 16-byte buffer for two GDT entries
	ES:DI -> buffer for 4K page table
Return: CF clear
	EAX = offset of protected-mode API entry point
	DS:SI buffer filled with two GDT descriptors
		first is QEMM code segment, second is data???
	ES:DI buffer filled with 4K page table
	DI points to first unused page table entry
SeeAlso: INT 67/AX=DE01h

(Table 2791)
Values for calling QEMM QPI function 1001h:
	AX = 1001h get CPU debug registers
	ES:DI -> buffer for debug registers (8 DWORDs)
Return: CF clear
	BL = INT01 handling (see #2792)
	ES:DI buffer filled

(Table 2792)
Values for calling QEMM QPI function 1002h:
	AX = 1002h set CPU debug registers
	BL = INT01 handling
	    00h	 reflect all debugging exceptions as V86-mode INT 01's
	    else convert debugging exceptions other than single-step
		  into V86-mode INT 03's, single-step to INT 01's
	ES:DI -> buffer containing debug registers (8 DWORDs)
Return: CF clear
Notes:	identical to INT 67/AX=DE09h if BL=01h
	the INT01 handling flag is set to 01h by the general-protection
	  violation handler for certain privileged instructions
SeeAlso: #2791

(Table 2793)
Values for calling QEMM QPI function 1003h:
	AX = 1003h get machine status word CR0
Return: CF clear
	EAX = contents of CR0
SeeAlso: INT 67/AX=DE07h

(Table 2794)
Values for calling QEMM QPI function 1004h:
	AX = 1004h allocate a 4K page
Return: CF clear if successful
	    EDX = linear address of allocated page
	CF set on error
SeeAlso: INT 67/AX=DE04h

(Table 2795)
Values for calling QEMM QPI function 1005h:
	AX = 1005h free 4K page
	EDX = linear address of page to free
Return: CF clear
SeeAlso: INT 67/AX=DE05h

(Table 2796)
Values for calling QEMM QPI function 1006h:
	AX = 1006h NOP
Return: CF set

(Table 2797)
Values for calling QEMM QPI function 1007h:
	AX = 1007h get maximum physical memory address
Return: CF clear
	EDX = physical address of highest 4K memory page
SeeAlso: INT 67/AX=DE02h

(Table 2798)
Values for calling QEMM QPI function 1008h:
	AX = 1008h get physical address of page in first megabyte
	CX = page number (linear address shifted right 12 bits)
Return: CF clear
	EDX = linear address of page
SeeAlso: #2797,#2873,#2874

(Table 2799)
Values for calling QEMM QPI function 1009h:
	AX = 1009h switch to protected mode
	ESI = linear address in first megabyte of system reg values
	      (see INT 67/AX=DE0Ch)
	interrupts disabled
Return: interrupts disabled
	GDTR, IDTR, LDTR, TR loaded
	SS:ESP must have at least 16 bytes space, and the
	      entry point is required to set up a new stack
	      before enabling interrupts
	EAX, ESI, DS, ES, FS, GS destroyed

(Table 2800)
Values for calling QEMM QPI function 100Ah:
	AX = 100Ah switch back to virtual-86 mode
	DS = selector for data segment from function 1000h
	SS:ESP in first megabyte of linear memory
	interrupts disabled
	STACK:	QWORD  return address from FAR call to 32-bit segment
		DWORD  EIP
		DWORD  CS
		DWORD  reserved for EFLAGS
		DWORD  ESP
		DWORD  SS
		DWORD  ES
		DWORD  DS
		DWORD  FS
		DWORD  GS
	will switch to virtual86 mode with interrupts disabled, all
	  segment registers loaded, and EAX destroyed.

(Table 2801)
Values for calling QEMM QPI function 11h:
	AH = 11h get memory type map
	AL = zero/nonzero ??? (set by QEMM.COM but apparently ignored
	      by QEMM 6.00)
	ES:DI -> 256-byte buffer for memory types
Return: CF clear
	BL = ???
	ES:DI buffer filled
Note:	each byte of the buffer corresponds to a 4K page, and
	  contains the type of that page: 00h = mappable,
	  02h = mapped ROM, 03h = high RAM, 04h = excluded,
	  05h = video, 06h = ROM, 07h = adapter ROM,
	  08h = split ROM, 09h = page frame, 0Ah = RAMmable,
	  0Bh = conventional, 83h = high RAM under MS Windows

(Table 2802)
Values for calling QEMM QPI function 12h:
	AH = 12h get HIRAM chain
Return: CF clear
	BX = segment of first MCB in high memory
	    0000h if no high memory

(Table 2803)
Values for calling QEMM QPI function 1300h:
	AX = 1300h VIDRAMEGA???
	BL = 00h copy ???
	     nonzero copy ??? (reverse)
Return: CF clear
	AL = status
	    00h if all pages clean
	    01h if any page dirty

(Table 2804)
Values for calling QEMM QPI function 1301h:
	AX = 1301h check if pages modified
	DX:DI = start address of range to check
	CX = length of range in paragraphs
Return: CF clear
	CX = status
	    0000h none of the indicated pages is dirty
		DI destroyed
	    1000h one or more pages is dirty
		DI = low word of first dirty page's linear addr

(Table 2805)
Values for calling QEMM QPI function 1302h:
	AX = 1302h ???
	BL = ???
	BH = ???
	CX = ???
	SI = offset of ???
	DI = offset of ???
	???
Return: CF clear
	???
Note:	disables certain interrupts at the two 8259 PICs during
	  execution; also modifies CRT controller during
	  execution under certain circumstances

(Table 2806)
Values for calling QEMM QPI function 1303h:
	AX = 1303h initialize EGA graphics virtualization
	BX = number of pages (less 1) of EMS to allocate
Return: CF clear if successful
	    DX = EMS handle
	CF set on error

(Table 2807)
Values for calling QEMM QPI function 1304h:
	AX = 1304h shutdown EGA graphics virtualization
	DX = EMS handle being used for virtualization
Return: CF clear

(Table 2808)
Values for calling QEMM QPI function 1305h:
	AX = 1305h select portion of EGA graphics to virtualize???
	(related to graphics virtualization, changes memory mappings)
	CX = start offset within A000h segment of virtualized mem???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during
	  execution (see #2815) and runs inside a QEMM
	  critical section

(Table 2809)
Values for calling QEMM QPI function 1306h:
	AX = 1306h set DESQview critical section counter address
	ES:BX -> WORD DESQview critical section counter or 0000h:0000h
Return: CF clear
Note:	also sets a pointer in the low-memory part of QEMM to
	  the current value of INT 15 if ES:BX not 0000h:0000h

(Table 2810)
Values for calling QEMM QPI function 1307h:
	AX = 1307h ??? (changes memory mappings for entire A000h segment)
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during
	  execution (see #2815) and runs inside a QEMM
	  critical section

(Table 2811)
Values for calling QEMM QPI function 1308h:
	AX = 1308h start/reset CRT controller I/O trapping
	BL = subfunction
	    00h restore CRTC I/O port trapping to previous state
	    else start trapping all accesses to I/O ports 03B0-03DF
Return: CF clear
Note:	if called more than once in a row with BL nonzero, the
	  original state of the I/O port trapping will be lost

(Table 2812)
Values for calling QEMM QPI function 1309h:
	AX = 1309h Hercules mode-change support
	ES:BX -> new address for Hercules mode-change callback
Return: CF clear
Note:	the callback function is called whenever the CRTC mode
	  register is written, with AL set to the value written

(Table 2813)
Values for calling QEMM QPI function 130Ah:
	AX = 130Ah virtualize EGA/VGA DAC registers (I/O ports 03C8h/03C9h)
	CX:DX -> DAC register virtualization buffer (see #2896)
		or 0000h:0000h to disable
Return: CF clear

(Table 2814)
Values for calling QEMM QPI function 130Bh:
	AX = 130Bh ???
	BL = ??? (??? or 00h)
Return: CF clear
	???
Note:	calls AX=130Eh in some cases

(Table 2815)
Values for calling QEMM QPI function 130Ch:
	AX = 130Ch set interrupts to mask
	BX = interrupts to mask out during AX=1302h,AX=1307h,AX=1308h,
	      AX=130Dh,AX=1310h (BL = master PIC, BH = slave PIC)
Return: CF clear

(Table 2816)
Values for calling QEMM QPI function 130Dh:
	AX = 130Dh map EGA memory at A0000h
	???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during execution
	  (see #2815) and runs inside a QEMM critical section
	calls AX=1307h (see #2810)

(Table 2817)
Values for calling QEMM QPI function 130Eh:
	AX = 130Eh ??? (modifies CRT controller setup)
	???
Return: CF clear

(Table 2818)
Values for calling QEMM QPI function 130Fh:
	AX = 130Fh reset ???
Return: CF clear

(Table 2819)
Values for calling QEMM QPI function 1310h:
	AX = 1310h copy modified pages to physical video RAM???
	???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during execution
	  (see #2815) and runs inside a QEMM critical section
	also calls AX=130Dh (see #2816)

(Table 2820)
Values for calling QEMM QPI function 1311h:
	AX = 1311h set ???
	BL = zero/nonzero???
Return: CF clear
Note:	certain operations will be performed with interrupts
	  (as set by AX=130Ch) enabled rather than disabled if
	  called with BL nonzero

(Table 2821)
Values for calling QEMM QPI function 1312h:
	AX = 1312h (v6.02) NOP???
Note:	called by DV 2.42, but appears to be a NOP in QEMM 6.02

(Table 2822)
Values for calling QEMM QPI function 1400h:
	AX = 1400h initialize DESQview "protection level" support
	ES:DI -> protection level configuration (at least 24 bytes)
		(see #2890)
	BL = highest ??? to return (one less than number of words)
Return: CF clear
	AX = ??? (4204h for v6.00)
Note:	QEMM also sets the protected mode INT 02 and INT 06
	  vectors to alternate handlers in certain cases

(Table 2823)
Values for calling QEMM QPI function 1401h:
	AX = 1401h turn off DESQview protection level support
		Return: CF clear
			???
		Notes:	clears the DV critical-section flag address set with
			  function 1306h
			QEMM also sets the protected mode INT 02 and INT 06
			  vectors to the default handlers if they had been
			  revectored by function 1400h

(Table 2824)
Values for calling QEMM QPI function 1402h:
	AX = 1402h set protection level???
		BL = protection level???
		    00h NOP
		    01h ???
		    02h ???
		    other (03h) ???
		ES:DI -> ???
		Return: CF clear
			???
		Format of Data structure:
		Offset	Size	Description
		 00h	WORD	segment of ??? (X, word at X:0136h set to X)
		 02h	WORD	segment of ??? (word at X:0124h set to this)
		 04h	WORD	number of paragraphs of ???
		 06h  3 WORDs	??? (copied to X:0000h)
		 0Ch	WORD	???

(Table 2825)
Values for calling QEMM QPI function 1403h:
	AX = 1403h add ??? to end of list and ??? (execute func 1406h)
		ES:DI -> ??? structure added to end of ??? list
			(at least 31 bytes, DWORD at offset 06h used for
			 storing pointer to next struc, WORD at offset 00h
			 seems to be a key or index)
		Return: CF clear

(Table 2826)
Values for calling QEMM QPI function 1404h:
	AX = 1404h NOP
		Return: CF clear

(Table 2827)
Values for calling QEMM QPI function 1405h:
	AX = 1405h remove ??? from ??? list
		BX = key???
		Return: CF clear

(Table 2828)
Values for calling QEMM QPI function 1406h:
	AX = 1406h ???
		???
		Return: CF clear
			???
		Notes:	this function is a NOP unless protection level 2 or 3
			  is active
			when not a NOP, one of the actions is to write-protect
			  certain memory pages

(Table 2829)
Values for calling QEMM QPI function 1407h:
	AX = 1407h ???
		???
		Return: CF clear
			???
		Note:	same as function 1406h, but only does anything if
			  protection level 2 is active

(Table 2830)
Values for calling QEMM QPI function 1408h:
	AX = 1408h unprotect???
		???
		Return: CF clear
			???

(Table 2831)
Values for calling QEMM QPI function 1409h:
	AX = 1409h abort program causing protection violation???
		???
		Return: CF clear
			???

(Table 2832)
Values for calling QEMM QPI function 140Ah:
	AX = 140Ah set ???
		BX = index of ???
		Return: CF clear
			???
		Notes:	no range checking is performed on BX
			this function is a NOP unless protection level 3 active

(Table 2833)
Values for calling QEMM QPI function 140Bh:
	AX = 140Bh get ???
		BX = index of ???
		SI = 0000h
		Return: CF clear
			SI = segment of 256-byte buffer??? or 0000h
		Notes:	no range checking is performed on BX
			this function is a NOP unless protection level 3 active

(Table 2834)
Values for calling QEMM QPI function 15h:
	AH = 15h set timer channel 0 virtualization buffer
		ES:BX -> WORD buffer for timer channel 0 divisor
			0000h:0000h to disable virtualization
		Return: CF clear

(Table 2835)
Values for calling QEMM v5.00+ QPI function 1600h:
	AX = 1600h get memory access status
		ES:DI -> 256-byte buffer
		Return: ES:DI buffer filled
		Note:	each byte of the buffer indicates the status of a 4K
			  page (bit 0 set if read, bit 1 set if written)

(Table 2836)
Values for calling QEMM v5.00+ QPI function 1601h:
	AX = 1601h set memory access status
		ES:DI -> 256-byte buffer containing access statuses (see #2835)

(Table 2837)
Values for calling QEMM v5.00+ QPI function 17h:
	AH = 17h get memory usage statistics
		ES:DI -> 81-byte buffer for memory statistics (see #2894)
		Return: CF clear

(Table 2838)
Values for calling QEMM v5.11+ QPI function 18h:
	AH = 18h check whether conventional memory mapped into address range
		ES:BX = starting address
		CX = number of 4K pages
		Return: CF clear
			AL = 00h one or more pages is remapped
			     01h all pages in range are conventional memory
				(physical address == virtual address)

(Table 2839)
Values for calling QEMM v5.11+ QPI function 19h:
	AH = 19h NOP
		Return: CF set

(Table 2840)
Values for calling QEMM v5.11+ "QPI_UntrappedIORead" function:
	AX = 1A00h get byte from I/O port
	DX = port number
Return: CF clear
	BL = port value
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2841)
Values for calling QEMM v5.11+ "QPI_UntrappedIOWrite" function:
	AX = 1A01h send byte to I/O port
	BL = value to send
	DX = port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2842)
Values for calling QEMM v5.11+ "QPI_UntrappedIOReadIndexed" function:
	AX = 1A02h
	BH = index value to send
	DX = base port number
Return: CF clear
	BL = value read from I/O port (DX+1)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2843)
Values for calling QEMM v5.11+ "QPI_UntrappedIOWriteIndexed" function:
	AX = 1A03h send bytes to two consecutive I/O ports
	BH = value for first I/O port (DX)
	BL = value for second I/O port (DX+1)
	DX = base port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2844)
Values for calling QEMM v7.03+ "QPI_UntrappedIO" function:
	AX = 1A04h
	BX = value to write to port
	CX = direction and size
	    bit 2: output instead of input
	    bit 3: word instead of byte
	DX = I/O port to be accessed
Return: CF clear
	BX = value read (if CX indicates read)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2845)
Values for calling QEMM v7.03+ function 1A05h
	AX = 1A05h
	???
Return: ???

(Table 2846)
Values for calling QEMM v7.03+ "QPI_GetIOCallback" function:
	AX = 1A06h
Return: CF clear
	ES:DI -> current I/O callback function (see #2848)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2847)
Values for calling QEMM v7.03+ "QPI_SetIOCallback" function:
	AX = 1A07h
	ES:DI -> new I/O callback function (see #2848)
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2848)
Values QEMM v7.03+ I/O callback function is called with:
	AL/AX = data to/from trapped port
	CL = I/O direction (00h = IN instruction, else OUT instruction)
	DX = I/O port address
Return: CF clear if port handled by callback function
	CF set if not handled
	all other registers returned to application executing the IN or OUT
	  instruction (allowing arbitrary changes to port address, data value,
	  etc.)
SeeAlso: #2846,#2847

(Table 2849)
Values for calling QEMM v7.03+ "QPI_GetPortTrap" function:
	AX = 1A08h
	DX = I/O port number
Return: CF clear
	BL = trapping state (00h not being trapped, 01h trap installed)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2850)
Values for calling QEMM v7.03+ "QPI_SetPortTrap" function:
	AX = 1A09h
	DX = I/O port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2851)
Values for calling QEMM v7.03+ "QPI_ClearPortTrap" function:
	AX = 1A0Ah
	DX = I/O port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2852)
Values for calling QEMM v5.11+ QPI function 1B00h:
	AX = 1B00h get EMM Import Structure address
	ES:DI -> buffer for EMM import data structure (see #2892)
Return: CF set on error
	CF clear if successful
SeeAlso: INT 21/AX=4402h/SF=01h

(Table 2853)
Values for calling QEMM v5.11+ QPI function 1B01h:
	AX = 1B01h disable V86 mode
Return: CF set on error
	    (i.e. no Global EMM Import rec. allocated)
	CF clear if successful
Note:	shuts down EMS and initializes Global EMM Import record; this function
	  is invoked from the callback supplied by INT 2F/AX=1605h

(Table 2854)
Values for calling QEMM v5.11+ QPI function 1B02h:
	AX = 1B02h enable V86 mode
Return: CF set on error
	CF clear if successful
Note:	restarts EMS and frees Global EMM Import record; this function is
	  invoked from the callback supplied by INT 2F/AX=1605h

(Table 2855)
Values for calling QEMM v5.11+ QPI function 1B03h:
	AX = 1B03h MS Windows initializing
	CX = segment from which Windows init broadcast made???
	DX = Windows startup flags
	DI = Windows version number (major in upper byte)
Return: CF clear if successful
	    DS:SI -> V86 mode enable/disable callback
		  (see #1962 at INT 2F/AX=1605h)
	    ES:BX -> startup info structure (see #1959 at INT 2F/AX=1605h)
	CF set on error (unable to start Windows)
SeeAlso: INT 2F/AX=1605h

(Table 2856)
Values for calling QEMM v5.11+ QPI function 1B04h:
	AX = 1B04h MS Windows terminating
Return: CF clear

(Table 2857)
Values for calling QEMM v5.11+ QPI function 1B05h:
	AX = 1B05h determine whether program is driver
	DS:DX -> ASCIZ filename
Return: CF clear
	AL = status
	    01h if string ends in ".DRV"
	    FFh if string ends in "GDI.EXE"
	    00h otherwise
Note:	when MS Windows 3.0 standard mode starts, QEMM patches all drivers
	  until GDI.EXE is loaded

(Table 2858)
Values for calling QEMM v5.11+ QPI function 1B06h:
	AX = 1B06h patch protected-mode check in Windows driver
	CX = length of data pointed at by DS:DX
	DS:DX -> buffer containing Windows driver code
Return: CF clear
Note:	patches all SMSW x/TEST x,1 instruction sequences into MOV x,CS/VERW x
	  sequences, which has the effect that the protected-mode check will
	  only indicate protected mode in native protected mode and not in V86
	  mode

(Table 2859)
Values for calling QEMM v5.11+ QPI function 1B07h:
	AX = 1B07h
BUG: QEMM 6.00-7.01 accept this and branch randomly

(Table 2860)
Values for calling QEMM v5.11+ QPI function 1Bxxh:
	AX = 1B08h to 1BFFh
Return: CF set

(Table 2861)
Values for calling QEMM v5.11+ QPI function 1C00h:
	AX = 1C00h disable IRQ0-7 calldowns
Return: CF clear

(Table 2862)
Values for calling QEMM v5.11+ QPI function 1C01h:
	AX = 1C01h set V86-mode IRQ0-7 handlers
	ES:DI -> 8 DWORDs containing V86-mode handler addresses
Return: CF clear

(Table 2863)
Values for calling QEMM v5.11+ QPI function 1C02h:
	AX = 1C02h disable IRQ8-15 handlers
Return: CF clear

(Table 2864)
Values for calling QEMM v5.11+ QPI function 1C03h:
	AX = 1C03h set V86-mode IRQ8-15 handlers
	ES:DI -> 8 DWORDs containing V86-mode handler addresses
BUG:	although the jump table only contains four entries, QEMM 6.00 will
	  attempt to use it for any value of AL between 00h and 2Ah, thus
	  branching unpredictably for AL=04h-2Ah; QEMM v7.01 behaves
	  similarly for AL=04h-1Bh
Note:	when enabled, the appropriate IRQs are reflected back to the specified
	  handlers in virtual-86 mode after the CPU automatically invokes the
	  protected-mode handler inside QEMM

(Table 2865)
Values for calling QEMM v7.03+ "QPI_SimulateHWInt" function:
	AX = 1C04h
	BX = number of interrupt to simulate
Return: ???
Notes:	this function will allow proper simulation of a hardware interrupt
	  under DESQview and DESQview/X, where the correct interrupt handler
	  may be in a different process with a completely different address
	  space
	this function was officially documented with the release of QEMM v7.50

(Table 2866)
Values for calling QEMM v6.0x only QPI function 1D00h:
	AX = 1D00h switch to pre-Stealth interrupt vector table
Return: CF clear if supported (QEMM v6.x)
	CF set if not supported (QEMM v7+)
Notes:	also switches VGA Save table pointer (0040h:00A8h) and overwrites the
	  vectors currently assigned for use by the two interrupt controllers
	  (see INT 67/AX=DE0Ah) with the vectors for INT 08-0F and 70-77 (to
	  avoid crashing the system).
	functions 1Dxxh are not supported by QEMM v7.01, and always return CF
	  set

(Table 2867)
Values for calling QEMM v6.0x only QPI function 1D01h:
	AX = 1D01h restore user interrupt vector table
Return: CF clear if supported (QEMM v6.x)
	CF set if not supported (QEMM v7+)
Notes:	interrupts should be disabled around the AX=1D00h and AX=1D01h calls
	  because QEMM does not modify the memory maps to map in ROM, so
	  an interrupt could be disastrous
	clears any pending IRQ7 at end of function
	functions 1Dxxh are not supported by QEMM v7.01, and always return CF
	  set

(Table 2868)
Values for calling QEMM v6.00+ QPI function 1Dxxh:
	AX = 1D02h to 1DFFh
Return: CF set

(Table 2869)
Values for calling QEMM v6.00+ "QEMM_GET_INFO"/"QPI_GetInfo" function:
	AX = 1E00h get Stealth configuration
Return: CF clear
	BL = memory configuration flags (documented as "reserved") (see #2893)
	BH = (v7.00+) disk buffer flags
	    bit 0: DISKBUFFRAME buffer instead of DISKBUF buffer
	    bit 1: buffer has already been used
	CL = stealth type (00h none, 46h Frame, 4Dh Map, 50h Protect)
	CH = suspend/resume interrupt (00h none)
	DL = (v7.00+) size of QEMM disk buffer in KB (00h none)
	DH = reserved (always 00h for v6.00)
	SI = reserved (always 0000h for v6.00)
	DI = reserved (always 0000h for v6.00)
Note:	this function is officially documented

(Table 2870)
Values for calling QEMM v6.00+ "QPI_GetStealthCount" function:
	AX = 1E01h get number of Stealth'ed ROMs
Return: CF clear
	BX = number of Stealth'ed ROMs
Note:	this function is officially documented

(Table 2871)
Values for calling QEMM v6.00+ "QPI_GetStealthList" function:
	AX = 1E02h
	ES:DI -> buffer for Stealth ROM info (see #2895)
Return: CF clear
	BX = number of Stealth'ed ROMs
	ES:DI buffer filled
Note:	this function is officially documented

(Table 2872)
Values for unimplemented Stealth information functions:
	AX = 1E03h to 1EFFh
Return: CF set


(Table 2873)
Values for calling QEMM v6.00+ "QEMM_GET_PTE"/"QPI_GetPTE" function:
	AX = 1F00h get page table entry
	CX = page number (0000h-010Fh)
Return: CF clear
	EDX = page table entry
Note:	this function is officially documented

(Table 2874)
Values for calling QEMM v6.00+ "QEMM_SET_PTE"/"QPI_SetPTE" function:
	AX = 1F01h set page table entry
	CX = page number (0000h-010Fh)
	EDX = new page table entry
Return: CF clear
Note:	this function is officially documented
SeeAlso: #2798

(Table 2875)
Values for calling QEMM v6.00+ QPI function 1Fxxh:
	AX = 1F02h to 1FFFh
Return: CF set

(Table 2876)
Values for calling QEMM v6.00+ "QEMM_GET_VHI_INFO"/"QPI_GetVHIInfo" function:
	AX = 2000h "QEMM_GET_VHI_INFO" get VirtualHDIRQ information
Return: CF clear
	BL = flags
	    bit 7: VirtualHDIRQ setting respected
		  (set if Stealth active)
	    bits 6-1 reserved
	    bit 0: VirtualHDIRQ currently enabled
		(INT 15/AH=90h suppressed when enabled)
Note:	this function is officially documented
SeeAlso: #2877

(Table 2877)
Values for calling QEMM v6.00+ "QEMM_SET_VHI_INFO"/"QPI_SetVHIInfo" function:
	AX = 2001h set VirtualHDIRQ state
	BL bit 0 = new VirtualHDIRQ state
Return: CF clear
	BL = old VHI setting (bits 0 and 7, see #2876)
Note:	this function is officially documented
SeeAlso: #2876

(Table 2878)
Values for calling QEMM v6.00+ QPI function 20xxh:
	AX = 2002h to 20FFh
Return: CF set

(Table 2879)
Values for calling QEMM v6.00+ "QEMM_COPY_STEALTH_ROMS"/"QPI_CopyStealthRoms":
	AX = 2100h copy data from Stealthed address space
	DS:SI -> start address of hidden memory to copy
	ES:DI -> buffer for copied data
	ECX = number of bytes to copy
Return: CF clear if successful
	CF set on error (no Stealth or DS:SI < C000h:0000h or DS:SI + ECX > 1M)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 2880)
Values for calling QEMM v6.00+ QPI function 21xxh:
	AX = 2101h to 21FFh
Return: CF set

(Table 2881)
Values for calling QEMM v6.03+ QPI function 2200h:
	AX = 2200h DESQview/X support -- get ???
Return: CF clear
	ES:DI -> ???

(Table 2882)
Values for calling QEMM v6.03+ QPI function 2201h:
	AX = 2201h DESQview/X support -- set ???
	ES:DI -> ??? or 0000h:0000h
Return: CF clear if successful
	CF set on error

(Table 2883)
Values for calling QEMM v6.04+ QPI function 2300h:
	AX = 2300h get ???
	BX = which ??? to get (must be 0000h for v6.04)
Return: CF clear if successful
	    ES:DI -> ???
	CF set on error

(Table 2884)
Values for calling QEMM v6.04+ QPI function 2301h:
	AX = 2301h set ???
	BX = which ??? to set (must be 0000h for v6.04)
	ES:DI -> ???
Return: CF clear if successful
	CF set on error

(Table 2885)
Values for calling QEMM v6.04+ QPI function 2302h:
	AX = 2302h clear specified ???
	BX = which ??? to clear (must be 0000h for v6.04)
Return: CF clear if successful
	CF set on error

(Table 2886)
Values for calling QEMM v6.04+ QPI function 23FFh:
	AX = 23FFh clear all ???
Return: CF clear if successful
	CF set on error

(Table 2887)
Values for calling QEMM v6.04+ QPI function 23xxh:
	AX = 2303h to 23FEh
Return: CF set

(Table 2888)
Values for calling QEMM v7.01+ QPI function 24h:
	AH = 24h ST-DBL support
	AL = subfunction
	    00h set ???
		EDX -> information table (EDX = segment SHL 16 + offset)
	    01h ???
Return: CF clear if successful
	CF set on error

(Table 2889)
Values for calling QEMM unimplemented QPI functions:
	AH = 25h to FFh
Return: CF set

Format of QEMM protection level configuration:
Offset	Size	Description	(Table 2890)
 00h	WORD	segment of 128 breakpoint (INT 3) instructions for use in
		  DESQview protection level 3 interrupt vector checking, or
		  0000h to disable; in pl3, INTs 00-7F are pointed at these
		  breakpoints
 02h	DWORD	-> array of actual interrupt handler addresses for INT 00-7F
		  when interrupt vectors are pointed at protection level 3
		  breakpoints
 06h	DWORD	far pointer to ??? region list (see #2891)
 0Ah	DWORD	far pointer to buffer for returned ???
 0Eh	DWORD	seg:ofs of function to call on protection violation???
 12h	WORD	segment of ???
 14h	DWORD	far pointer to DWORD containing number of paragraphs of
		  ??? for segment at offset 12h
	???

Format of protection level Region List:
Offset	Size	Description	(Table 2891)
 00h	WORD	number of PAIRS of pointers to follow
 02h 2N DWORDs	start/end seg:ofs addresses of ??? regions
Note:	QEMM converts the segmented addresses into linear addresses in place

Format of EMM Import structure:
Offset	Size	Description	(Table 2892)
 00h	DWORD	physical address of EMM import struct
 04h	BYTE	major version (v6.00 sets to 01h)
 05h	BYTE	minor version (v6.00 sets to 00h/0Bh)
SeeAlso: INT 21/AX=4402h/SF=01h

Bitfields for memory configuration flags:
Bit(s)	Description	(Table 2893)
 0	conventional memory sorted
 1	conventional memory filled
 2	???
 3	???
 4	expanded memory is in use
 5	???

Format of QEMM 6.0 memory statistics:
Offset	Size	Description	(Table 2894)
 00h	BYTE	01h if Shadow RAM found, 00h otherwise
 01h	DWORD	initial conventional memory in bytes
 05h	DWORD	initial extended memory in bytes
 09h	DWORD	initial expanded memory in bytes
 0Dh	DWORD	initial "top" or "shadow" memory in bytes
 11h	DWORD	Unavailable conventional memory in bytes
 15h	DWORD	Unavailable extended memory in bytes
 19h	DWORD	Unavailable expanded memory in bytes
 1Dh	DWORD	Unavailable "top" or "shadow" memory in bytes
		Add to offset 49h for Total unavailable top/shadow.
 21h	DWORD	QEMM code size in bytes
 25h	DWORD	QEMM data size in bytes
 29h	DWORD	bytes used for TASKS=
 2Dh	DWORD	DMA buffer size
 31h	DWORD	bytes used for MAPS=
 35h	DWORD	bytes of high RAM
 39h	DWORD	bytes used by mapped ROMs
 3Dh	DWORD	bytes of conventional memory provided by QEMM
 41h	DWORD	bytes of extended memory NOT converted by QEMM (EXT=xxx)
 45h	DWORD	bytes of EMS/XMS pool memory provided by QEMM
 49h	DWORD	Unavailable "top" or "shadow" memory in bytes
		Add to offset 1Dh for Total unavailable top/shadow.
 4Dh	DWORD	conventional memory overhead in bytes
		(set to 0 by QEMM.COM prior to call)

Format of Stealth ROM info [array]:
Offset	Size	Description	(Table 2895)
 00h	WORD	starting segment of ROM
 02h	WORD	length of ROM in paragraphs

Format of QEMM EGA/VGA DAC register virtualization buffer:
Offset	Size	Description	(Table 2896)
 00h	BYTE	(temp) current color register number
 01h	BYTE	(temp) number of bytes written so far for current color reg
 02h 768 BYTEs	three bytes per color register
--------m-6740-------------------------------
INT 67 - LIM EMS - GET MANAGER STATUS
	AH = 40h
Return: AH = status (00h,80h,81h,84h) (see #2897)
Note:	this call can be used only after establishing that the EMS driver is in
	  fact present
SeeAlso: AH=3Fh,AX=FFA5h

(Table 2897)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 83h	invalid handle
 84h	undefined function requested by application
 85h	no more handles available
 86h	error in save or restore of mapping context
 87h	insufficient memory pages in system
 88h	insufficient memory pages available
 89h	zero pages requested
 8Ah	invalid logical page number encountered
 8Bh	invalid physical page number encountered
 8Ch	page-mapping hardware state save area is full
 8Dh	save of mapping context failed
 8Eh	restore of mapping context failed
 8Fh	undefined subfunction
 90h	undefined attribute type
 91h	feature not supported
 92h	successful, but a portion of the source region has been overwritten
 93h	length of source or destination region exceeds length of region
	  allocated to either source or destination handle
 94h	conventional and expanded memory regions overlap
 95h	offset within logical page exceeds size of logical page
 96h	region length exceeds 1M
 97h	source and destination EMS regions have same handle and overlap
 98h	memory source or destination type undefined
 9Ah	specified alternate map register or DMA register set not supported
 9Bh	all alternate map register or DMA register sets currently allocated
 9Ch	alternate map register or DMA register sets not supported
 9Dh	undefined or unallocated alternate map register or DMA register set
 9Eh	dedicated DMA channels not supported
 9Fh	specified dedicated DMA channel not supported
 A0h	no such handle name
 A1h	a handle found had no name, or duplicate handle name
 A2h	attempted to wrap around 1M conventional address space
 A3h	source array corrupted
 A4h	operating system denied access
--------m-6741-------------------------------
INT 67 - LIM EMS - GET PAGE FRAME SEGMENT
	AH = 41h
Return: AH = status (see also AH=40h)
	    00h function successful
		BX = segment of page frame
SeeAlso: AH=58h,AH=68h
--------m-6742-------------------------------
INT 67 - LIM EMS - GET NUMBER OF PAGES
	AH = 42h
Return: AH = status (see also AH=40h)
	    00h function successful
		BX = number of unallocated pages
		DX = total number of pages
BUG:	DOS 6.0 EMM386.EXE causes a system lock-up or reboot if in AUTO mode
	  when this call is made; use AH=46h to ensure that EMM386 is ON
	  before making this call
SeeAlso: INT 2F/AX=2702h
--------m-6743-------------------------------
INT 67 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY
	AH = 43h
	BX = number of logical pages to allocate
Return: AH = status (00h,80h,81h,84h,85h,87h,88h,89h) (see #2897)
	DX = handle if AH=00h
SeeAlso: AH=45h
--------u-674321-----------------------------
INT 67 - Q87 v4+ - INSTALLATION CHECK
	AX = 4321h
	EAX = 87654321h (entire EAX value required)
Return: EAX = 12345678h if Q87 is installed
Note:	this call requires that VCPI services be available; if they are not,
	  this call will not be recognized
BUG:	v4.00-v4.03 will hang on most machines when run under bare DOS with
	  no memory manager, because neither Q87 nor UNLOAD87 checks whether
	  there is a valid INT 67 handler before performing an installation
	  check via INT 67
SeeAlso: AX=2833h,INT 21/AX=4321h
--------m-6744-------------------------------
INT 67 - LIM EMS - MAP MEMORY
	AH = 44h
	AL = physical page number (0-3)
	BX = logical page number
	    or FFFFh to unmap (QEMM)
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Ah,8Bh) (see #2897)
SeeAlso: AH=69h
--------m-6745-------------------------------
INT 67 - LIM EMS - RELEASE HANDLE AND MEMORY
	AH = 45h
	DX = EMM handle
Return: AH = status (00h,80h,81h,83h,84h,86h) (see #2897)
SeeAlso: AH=43h
--------m-6746-------------------------------
INT 67 - LIM EMS - GET EMM VERSION
	AH = 46h
Return: AH = status (00h,80h,81h,84h) (see #2897)
	AL = EMM version number if AH=00h
--------m-6747-------------------------------
INT 67 - LIM EMS - SAVE MAPPING CONTEXT
	AH = 47h
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Ch-8Eh) (see #2897)
SeeAlso: AH=48h
--------m-6748-------------------------------
INT 67 - LIM EMS - RESTORE MAPPING CONTEXT
	AH = 48h
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Eh) (see #2897)
SeeAlso: AH=47h
--------m-6749-------------------------------
INT 67 - LIM EMS - reserved - GET I/O PORT ADDRESSES
	AH = 49h
Note:	defined in EMS 3.0, but undocumented in EMS 3.2
--------m-674A-------------------------------
INT 67 - LIM EMS - reserved - GET TRANSLATION ARRAY
	AH = 4Ah
Note:	defined in EMS 3.0, but undocumented in EMS 3.2
--------m-674B-------------------------------
INT 67 - LIM EMS - GET NUMBER OF EMM HANDLES
	AH = 4Bh
Return: AH = status (00h,80h,81h,83h,84h) (see #2897)
	BX = number of EMM handles if AH=00h
--------m-674C-------------------------------
INT 67 - LIM EMS - GET PAGES OWNED BY HANDLE
	AH = 4Ch
	DX = EMM handle
Return: AH = status (see #2065)
	BX = number of logical pages if AH=00h
SeeAlso: AH=4Dh
--------m-674D-------------------------------
INT 67 - LIM EMS - GET PAGES FOR ALL HANDLES
	AH = 4Dh
	ES:DI -> array to receive information
Return: AH = status (00h,80h,81h,84h) (see #2897)
	---if AH=00h---
	BX = number of active EMM handles
	array filled with 2-word entries, consisting of a handle and the
	  number of pages allocated to that handle
SeeAlso: AH=4Ch
--------m-674E-------------------------------
INT 67 - LIM EMS - GET OR SET PAGE MAP
	AH = 4Eh
	AL = subfunction
	    00h get mapping registers
	    01h set mapping registers
	    02h get and set mapping registers at once
	    03h get size of page-mapping array
	DS:SI -> array holding information (AL=01h/02h)
	ES:DI -> array to receive information (AL=00h/02h)
Return: AH = status (00h,80h,81h,84h,8Fh,A3h) (see also AH=40h)
	    00h successful
		AL = bytes in page-mapping array (AL=03h only)
		array pointed to by ES:DI receives mapping info (AL=00h/02h)
Notes:	this function was designed to be used by multitasking operating systems
	  and should not ordinarily be used by appplication software.
	MD386 returns the size of the page-mapping array in AX instead of AL
SeeAlso: AH=4Fh
--------m-674F-------------------------------
INT 67 - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP
	AH = 4Fh
	AL = subfunction
	    00h get partial page map
	       DS:SI -> structure containing list of segments whose mapping
			contexts are to be saved
	       ES:DI -> array to receive page map
	    01h set partial page map
	       DS:SI -> structure containing saved partial page map
	    02h get size of partial page map
	       BX = number of mappable segments in the partial map to be saved
Return: AH = status (00h,80h,81h,84h,8Bh,8Fh,A3h) (see also AH=40h)
	    8Bh one of the specified segments is not mappable
	    A3h contents of partial page map corrupted or count of mappable
		segments exceeds total number of mappable segments in system
	AL = size of partial page map for subfunction 02h
SeeAlso: AH=4Eh
--------m-6750-------------------------------
INT 67 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
	AH = 50h
	AL = subfunction
	    00h use physical page numbers
	    01h use segment addresses
	DX = handle
	CX = number of entries in array
	DS:SI -> mapping array (see #2898)
Return: AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #2897)
SeeAlso: AH=40h

Format of EMS mapping array entry:
Offset	Size	Description	(Table 2898)
 00h	WORD	logical page number or FFFFh to unmap physical page
 02h	WORD	physical page number or segment address
--------m-6751-------------------------------
INT 67 - LIM EMS 4.0 - REALLOCATE PAGES
	AH = 51h
	DX = handle
	BX = number of pages to be allocated to handle
Return: AH = status (00h,80h,81h,83h,84h,87h,88h) (see #2899)
	BX = actual number of pages allocated to handle

(Table 2899)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 83h	invalid handle
 84h	undefined function requested
 87h	more pages requested than present in system
 88h	more pages requested than currently available
 8Ah	invalid logical page number encountered
 8Bh	invalid physical page number encountered
 8Fh	undefined subfunction
 90h	undefined attribute type
 91h	feature not supported
 A0h	no such handle name
 A1h	duplicate handle name
--------m-6752-------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES
	AH = 52h
	AL = subfunction
	    00h get handle attributes
		Return: AL = attribute
			    00h handle is volatile
			    01h handle is nonvolatile
	    01h set handle attributes
		BL = new attribute
		   00h handle is volatile
		   01h handle is nonvolatile
	    02h get attribute capability
		Return: AL = attribute capability
			    00h only volatile handles supported
			    01h both volatile and non-volatile supported
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Fh-91h) (see #2897)
SeeAlso: AH=53h
--------m-6753-------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE NAME
	AH = 53h
	AL = subfunction
	    00h get handle name
	       ES:DI -> 8-byte buffer for handle name
	    01h set handle name
	       DS:SI -> 8-byte handle name
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Fh,A1h) (see #2897)
SeeAlso: AH=52h
--------m-6754-------------------------------
INT 67 - LIM EMS 4.0 - GET HANDLE DIRECTORY
	AH = 54h
	AL = subfunction
	    00h get handle directory
	       ES:DI -> buffer for handle directory (see #2900)
	    01h search for named handle
	       DS:SI -> 8-byte name
	    02h get total number of handles
Return: AL = number of entries in handle directory (subfunction 00h)
	DX = value of named handle (subfunction 01h)
	BX = total number of handles (subfunction 02h)
	AH = status (00h,80h,81h,84h,8Fh,A0h,A1h) (see also #2899)
	    A1h a handle found had no name

Format of EMS handle directory entry:
Offset	Size	Description	(Table 2900)
 00h	WORD	handle
 02h  8 BYTEs	handle's name
--------m-6755-------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP
	AH = 55h
	AL = subfunction
	    00h physical page numbers provided by caller
	    01h segment addresses provided by caller
	DX = handle
	DS:SI -> structure containing map and jump address
Return: (at target address unless error)
	AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #2897)
SeeAlso: AH=56h
--------m-6756-------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL
	AH = 56h
	AL = subfunction
	    00h physical page numbers provided by caller
		DX = handle
		DS:SI -> structure containing page map and call address
	    01h segment addresses provided by caller
		DX = handle
		DS:SI -> structure containing page map and call address
	    02h get page map stack space required
		Return: BX = stack space required
Return: (if successful, the target address is called.  Use a RETF to return
	 and restore mapping context)
	AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #2897)
SeeAlso: AH=55h
--------m-6756FF-----------------------------
INT 67 - RM386 v6.00 - ???
	AX = 56FFh
	DS:SI -> ???
	???
Return: ???
--------m-6757-------------------------------
INT 67 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION
	AH = 57h
	AL = subfunction
	    00h move memory region
	    01h exchange memory region
	DS:SI -> structure describing source and destination (see #2902)
Return: AH = status (see #2901)
Note:	source and destination may overlap for a move, in which case the copy
	  direction is chosen such that the destination receives an intact copy
	  of the source region

(Table 2901)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware failure
 83h	invalid handle
 84h	undefined function requested
 8Ah	invalid logical page number encountered
 8Fh	undefined subfunction
 92h	successful, but a portion of the source region has been overwritten
 93h	length of source or destination region exceeds length of region
	  allocated to either source or destination handle
 94h	conventional and expanded memory regions overlap
 95h	offset within logical page exceeds size of logical page
 96h	region length exceeds 1M
 97h	source and destination EMS regions have same handle and overlap
 98h	memory source or destination type undefined
 A2h	attempted to wrap around 1M conventional address space

Format of EMS copy data:
Offset	Size	Description	(Table 2902)
 00h	DWORD	region length in bytes
 04h	BYTE	source memory type
		00h conventional
		01h expanded
 05h	WORD	source handle (0000h if conventional memory)
 07h	WORD	source initial offset (within page if EMS, segment if convent)
 09h	WORD	source initial segment (conv mem) or logical page (EMS)
 0Bh	BYTE	destination memory type
		00h conventional
		01h expanded
 0Ch	WORD	destination handle
 0Eh	WORD	destination initial offset
 10h	WORD	destination initial segment or page
--------m-6758-------------------------------
INT 67 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY
	AH = 58h
	AL = subfunction
	    00h get mappable physical address array
		ES:DI -> buffer to be filled with array (see #2903)
	    01h get number of entries in m.p.a. array
Return: CX = number of entries in array
	AH = status (00h,80h,81h,84h,8Fh) (see #2901)
Note:	the returned array for subfunction 00h is filled in physical segment
	  address order

Format of EMS mappable physical address entry:
Offset	Size	Description	(Table 2903)
 00h	WORD	physical page segment
 02h	WORD	physical page number
--------m-675857-----------------------------
INT 67 U - NETROOM??? - ???
	AX = 5857h
	BX = function??? (0057h,0059h,0159h seen)
	???
Return: ???
Note:	BX=0059h appears to be analogous to AX=5800h and BX=0159h appears to
	  be analogous to AX=5801h; BX=0057h appears to indicate whether
	  AX=580xh or AX=5857h/BX=0x59h should be used
SeeAlso: AX=5BF0h
--------m-6759-------------------------------
INT 67 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION
	AH = 59h
	AL = subfunction
	    00h get hardware configuration array
		ES:DI -> buffer to be filled with array (see #2904)
	    01h get unallocated raw page count
		Return: BX = unallocated raw pages
			DX = total raw pages
Return: AH = status (see also AH=58h"EMS 4.0")
	    A4h access denied by operating system
Note:	subfunction 00h is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system

Format of EMS hardware configuration array:
Offset	Size	Description	(Table 2904)
 00h	WORD	size of raw EMM pages in paragraphs
 02h	WORD	number of alternate register sets
 04h	WORD	size of mapping-context save area in bytes
 06h	WORD	number of register sets assignable to DMA
 08h	WORD	DMA operation type
		0000h DMA with alternate register sets
		0001h only one DMA register set
--------m-675A-------------------------------
INT 67 - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES
	AH = 5Ah
	AL = subfunction
	    00h allocate standard pages
	    01h allocate raw pages
	BX = number of pages to allocate
Return: DX = handle
	AH = status (00h,80h,81h,84h,85h,87h,88h,8Fh) (see #2897)
--------m-675B-------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET
	AH = 5Bh
	AL = subfunction
	    00h get alternate map register set
		Return: BL = current active alternate map register set number
			ES:DI -> map register context save area if BL=00h
	    01h set alternate map register set
		BL = new alternate map register set number
		ES:DI -> map register context save area if BL=0
	    02h get alternate map save array size
		Return: DX = array size in bytes
	    03h allocate alternate map register set
		Return: BL = number of map register set; 00h = not supported
	    04h deallocate alternate map register set
		BL = number of alternate map register set
Return: AH = status (00h,80h,81h,84h,8Fh,9Ah-9Dh,A3h,A4h) (see #2905)
Note:	this function is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system

(Table 2905)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 84h	undefined function requested
 8Fh	undefined subfunction
 9Ah	specified alternate map register or DMA register set not supported
 9Bh	all alternate map register or DMA register sets currently allocated
 9Ch	alternate map register or DMA register sets not supported
 9Dh	undefined or unallocated alternate map register/DMA register set
 9Eh	dedicated DMA channels not supported
 9Fh	specified dedicated DMA channel not supported
 A3h	source array corrupted
 A4h	operating system denied access
--------m-675B-------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS
	AH = 5Bh
	AL = subfunction
	    05h allocate DMA register set
		Return: BL = DMA register set number, 00h if not supported
	    06h enable DMA on alternate map register set
	       BL = DMA register set number
	       DL = DMA channel number
	    07h disable DMA on alternate map register set
	       BL = DMA register set number
	    08h deallocate DMA register set
	       BL = DMA register set number
Return: AH = status (00h,80h,81h,84h,8Fh,9Ah-9Fh,A3h,A4h) (see #2905)
Note:	this function is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system
--------m-675BE0-----------------------------
INT 67 - MICEMM v4D, RM386 - GET LINEAR ADDRESS OF MEMORY
	AX = 5BE0h
	ES:BX -> memory for which to get linear address
Return: AH = 00h
	CX:DX = linear address of physical memory corresponding to ES:BX
Program: RAM-MAN/386 is the memory manager included with Helix's Netroom;
	  MICEMM is a memory manager for some Micronics motherboards
Note:	this has been superceded by AX=DE06h, which should be used instead
SeeAlso: AX=5BF0h,AX=5BF1h,AX=DE06h
--------m-675BE1-----------------------------
INT 67 - RM386 v6.00+ - GET MEMORY MANAGER SIZE
	AX = 5BE1h
Return: AH = 00h
	CX = code and data size in bytes
	DX:BX = physical address of RM386 code
	DI:SI = total size of RM386 area including handle tables
	BP = number of additional pages (high DOS, etc.)
SeeAlso: AX=5BE0h,AX=5BE2h
--------m-675BE2-----------------------------
INT 67 - RM386 v6.00+ - GET INTERRUPT VECTORS
	AX = 5BE2h
Return: DS:SI -> V86-mode table (see #2906)
	ES:BX -> ??? (undoc, middle of device driver interrupt routine!)
SeeAlso: AX=5BE0h,AX=5BE1h

Format of RM386 V86-mode table:
Offset	Size	Description	(Table 2906)
 00h	DWORD	original INT 13 vector
 04h	DWORD	original INT 15 vector
 08h	DWORD	original INT 19 vector
 0Ch	DWORD	original INT 21 vector
 10h	DWORD	original INT 4B vector
 14h	DWORD	original INT 67 vector
--------m-675BF0-----------------------------
INT 67 - MICEMM v4D, RM386 - INSTALLATION CHECK
	AX = 5BF0h
Return: AH = 00h if MICEMM or RM386 present
	    BX = code segment of driver
Program: MICEMM is the Micronics Expanded Memory Manager; RM386 is the memory
	  manager included in Helix Software's Netroom
SeeAlso: AH=3Fh,AX=5BE0h,AX=5BF1h
--------m-675BF1-----------------------------
INT 67 - MICEMM v4D, RM386 - GET ADDRESS MAP
	AX = 5BF1h
	ES:BX -> 256-byte (MICEMM) or 512-byte (RM386) buffer for memory types
Return: AH = 00h
	ES:BX buffer filled (see #2907)
Note:	each byte in the buffer specifies the type of a 4K page of memory
SeeAlso: AX=5BE0h,AX=5BF0h

(Table 2907)
Values for MICEMM/RM386 memory type:
 00h	unused (MICEMM), RAM/available (RM386)
 02h	DOS extension (XMS UMB)
 04h	shadowed ROM
 08h	mappable EMS
 10h	page frame
 20h	ROM
 40h	reserved (video memory, etc)
 80h	RAM (MICEMM), Windows UMB (RM386)
--------m-675BF2-----------------------------
INT 67 - RM386 - GET RM386 INTERNAL DATA
	AX = 5BF2h
	CX = size of buffer
	DS:SI -> buffer for internal data
	(documentation says ES:BX -> buffer, SI = offset within RM386)
Return: buffer filled
Note:	the data returned by this function is release-specific
SeeAlso: AX=5BF0h
--------m-675BF3-----------------------------
INT 67 - RM386 - RETURN TO REAL MODE
	AX = 5BF3h
Return: nothing
Note:	use AX=5DE0h instead of this functin
SeeAlso: AX=5BF0h,AX=5DE0h
--------m-675BF4-----------------------------
INT 67 - RM386 v6.00 - GET RM386 GLOBAL FLAGS
	AX = 5BF4h
Return: AH = 00h
	BX = global flags 1 (see #2908)
	CX = global flags 2 (see #2909)
	DX = global flags 3 (see #2910)
	SI = global flags 4 (see #2911)
SeeAlso: AX=5BF0h

Bitfields for RM386 global flags 1:
Bit(s)	Description	(Table 2908)
 0-3	reserved
 4	V86 mode
 5	reserved
 6	80386 or higher CPU
 7,8	reserved
 9	A20 enabled at startup
 10	"HIGH_IO"
 11	ROM
 12	large frame
 13,14	reserved
 15	PS/2-style A20 control

Bitfields for RM386 global flags 2:
Bit(s)	Description	(Table 2909)
 0	HMA in use
 1	XMS present
 2	using XMS driver memory
 3	HIGH (NEAT only)
 4-7	reserved
 8	NOBKTRAP
 9	NORESET
 10	ALTMAP
 11	NOFRAME
 12-15	reserved

Bitfields for RM386 global flags 3:
Bit(s)	Description	(Table 2910)
 0	NOTEST
 1	NOEBDA
 2	Windows3 support
 3	system board mouse
 4	DISKBUF
 5	EBDALOW
 6	A20 global enable flag
 7	A20 flag
 8	EBDA moved to stub
 9	VXD file was found
 10	reserved
 11	NOBOOTMAP
 12	AUTO
 13	PS/2 machine
 14	Compaq ROM merge active
 15	NOHMA set

Bitfields for RM386 global flags 4:
Bit(s)	Description	(Table 2911)
 0	"NOV8259" don't virtualize interrupt controller
 1	NOSCSI
 2	NOSCAN
 3	NOTR
 4	ALTBOOT
 5	NOCOMPQ
 6	KB2TRAP
 7	DESHADOW
 8	Video 7 VGA detected
 9	reserved
 10	NOVGA
 11	NOPS2
 12	DEBUG
 13	NOVKB
 14,15	reserved
--------m-675BF5-----------------------------
INT 67 - RM386 v6.00 - GET RM386 EMS HANDLE COUNT
	AX = 5BF5h
Return: AH = status
	    00h successful
		BX = current number of allocated EMS handles
	    84h function not available
SeeAlso: AX=5BF0h
--------m-675C-------------------------------
INT 67 - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT
	AH = 5Ch
Return: AH = status (see #2912)
Note:	when MS-DOS v6.xx EMM386 is loaded and the keyboard driver supports
	  INT 15/AH=4Fh (keyboard intercept) calls, the system may hang
	  instead of booting if this function is called just prior to a jump
	  to F000h:FFF0h

(Table 2912)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 84h	undefined function requested
--------m-675D-------------------------------
INT 67 - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS
	AH = 5Dh
	AL = subfunction
	    00h enable OS Function Set
	    01h disable OS Function Set
	    02h return access key (resets memory manager, returns access key at
		next invocation)
	BX,CX = access key returned by first invocation
Return: BX,CX = access key, returned only on first invocation of function
	AH = status (see also AH=5Ch)
	    8Fh undefined subfunction
	    A4h operating system denied access
--------m-675D03-----------------------------
INT 67 u - Nanosoft MD386 - INTERNAL INITIALIZATION
	AX = 5D03h
	???
Return: ???
Program: MD386 is a subset EMS memory manager by Nanosoft specifically
	  designed for use with the MultiDOS Plus multitasker
SeeAlso: AX=5D04h,AX=5E00h
--------m-675D04-----------------------------
INT 67 - Nanosoft MD386 - GET ALTERNATE MAP STRUCTURE
	AX = 5D04h
	BX = alternate register set number
	ES:DI -> 1024-byte buffer for map structure
Return: AH = status (see #2897)
	buffer filled if AH=00h
Note:	used for debugging purposes
SeeAlso: AX=5D05h
--------m-675D05-----------------------------
INT 67 - Nanosoft MD386 - GET INTERNAL HANDLE TABLE
	AX = 5D05h
	BX = handle number
	ES:DI -> 1024-byte buffer for handle table
Return: AH = status (see #2897)
	buffer filled if AH=00h
Note:	used for debugging purposes
SeeAlso: AX=5D04h
--------m-675DE0-----------------------------
INT 67 - RM386 - DISABLE RM386
	AX = 5DE0h
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE1h
--------m-675DE1-----------------------------
INT 67 - RM386 - ENABLE RM386
	AX = 5DE1h
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE0h
--------m-675DE2-----------------------------
INT 67 - RM386 - GET PAGE TABLE
	AX = 5DE2h
	ES:DI -> 1088-byte buffer for page table
Return: ES:DI buffer filled
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE3h
--------m-675DE3-----------------------------
INT 67 - RM386 - SET PAGE TABLE
	AX = 5DE3h
	ES:DI -> 1088-byte buffer containing page table
Notes:	only the access bits of the page table are used, the remainder is
	  ignored
	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE2h
--------m-675DE4-----------------------------
INT 67 - RM386 - SET WRITE-PROTECTION FOR PAGE IN FIRST MEGABYTE
	AX = 5DE4h
	BL = page number
	BH = access (00h read-only, 01h read-write)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
--------m-675DE5-----------------------------
INT 67 - RM386 - MAP PHYSICAL PAGE TO PHYSICAL SEGMENT
	AX = 5DE5h
	EBX = physical page number
	DX = page number in first megabyte to be remapped (linear-addr SHR 12)
Return: AH = status
	    00h successful
	    8Bh invalid destination page (not in first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE6h
--------m-675DE6-----------------------------
INT 67 - RM386 - MAP LOGICAL 4K PAGE TO PHYSICAL SEGMENT
	AX = 5DE6h
	BX = logical page number in 4K pages from beginning of memory for EMS
	      handle
	CX = segment in first megabyte to be remapped
	DX = previously-allocated EMS handle
Return: AH = status
	    00h successful
	    83h invalid handle
	    8Ah invalid logical page (out of handle's range)
	    8Bh invalid destination page (not in first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE5h
--------m-675DE7-----------------------------
INT 67 - RM386 - SET PAGE TABLE BITS FOR RANGE OF PAGES
	AX = 5DE7h
	BL = page table bits to be set (bits 2-0 = U/S, R/W, P)
	CX = number of pages to set
	DX = first page number to set (in first megabyte)
Return: AH = status
	    00h successful
	    8Bh invalid destination page (not in first megabyte)
	    A5h invalid page bits
	    A6h invalid page count (overflows first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
--------m-675DE8-----------------------------
INT 67 - RM386 - GET PARTIAL PAGE TABLE
	AX = 5DE8h
	BX = starting page number in first megabyte+HMA (0000h-010Fh)
	CX = number of page table entries to get
	ES:DI -> buffer for DWORD page table entries
Return: AH = status (00h successful, 8Bh invalid page)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE9h
--------m-675DE9-----------------------------
INT 67 - RM386 - SET PARTIAL PAGE TABLE
	AX = 5DE9h
	BX = starting page number in first megabyte+HMA (0000h-010Fh)
	CX = number of page table entries to get
	DS:SI -> buffer of DWORD page table entries
Return: AH = status (00h successful, 8Bh invalid destination page)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE8h
--------m-675DEA-----------------------------
INT 67 - RM386 - V86-MODE I/O PORT TRAPPING CONTROL
	AX = 5DEAh
	BX = function
	    00h globally disable V86-mode trapping
	    01h globally enable V86-mode trapping
		CL = interrupt to use for trapping
	    02h get I/O trapping state
Return: AH = status
	    00h successful
		BX = current trapping state (function 02h)
		    0000h disabled, 0001h enabled
		CX = interrupt used as trap interrupt (functions 00h and 02h)
Notes:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
	when I/O trapping is enabled and I/O port access occurs, RM386
	  simulates an INT instruction for the specified interrupt; the
	  interrupt handler is responsible for decoding the trapped instruction
	  and performing the appropriate action.  INT 2C/AX=002Dh provides a
	  similar but more-easily used interface.
SeeAlso: AX=5DEBh,AH=EFh"RM386",INT 2C/AX=002Dh
--------m-675DEB-----------------------------
INT 67 - RM386 - V86-MODE I/O TRAPPING PORT CONTROL
	AX = 5DEBh
	BX = function
	    00h disable V86-mode trapping for specified port
	    01h enable V86-mode trapping for specified port
	    02h get V86-mode trapping state for specified port
	DX = port for which to enable/disable/query trapping
Return: AH = status
	    00h successful
		BX = current trapping state (00h off, 01h on) (function 02)
	    A7h invalid port ID
	    A8h reserved port--cannot trap/untrap (DMA/INT/KBD controllers)
Notes:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DEAh
--------m-675DFD-----------------------------
INT 67 U - RM386 v6.00 - ???
	AX = 5DFDh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFEh
--------m-675DFE-----------------------------
INT 67 U - RM386 v6.00 - ???
	AX = 5DFEh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFDh
--------m-675DFF-----------------------------
INT 67 U - RM386 v6.00 - ???
	AX = 5DFFh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFDh,AX=5DFEh
--------m-675E00-----------------------------
INT 67 - Nanosoft MD386 - SET HARDWARE BREAKPOINT
	AX = 5E00h
	DH = breakpoint number (0-3)
	DL = breakpoint attributes (used to set DR7)
	CX:BX = linear address of breakpoint
SeeAlso: AX=5D03h,AX=5E01h
--------m-675E01-----------------------------
INT 67 - Nanosoft MD386 - GET HARDWARE DEBUG REGISTER
	AX = 5E01h
	BL = register number (0-3,7)
Return: CX:BX = value of specified DRx register
SeeAlso: AX=5E00h
--------m-675E02-----------------------------
INT 67 - Nanosoft MD386 - SET DEBUG EXCEPTION HANDLER
	AX = 5E02h
	CX:BX -> exception handler
Note:	the specified exception handler is called with a simulated interrupt
	  whenever a debug exception occurs which was caused by a hardware
	  breakpoint set with the debug registers
SeeAlso: AX=5E04h,AX=5E05h
--------m-675E03-----------------------------
INT 67 - Nanosoft MD386 - ENABLE/DISABLE MEMORY WRITE PROTECTION
	AX = 5E03h
	BL = register map set number
	BH = new state (00h read-only, else read-write)
	CX = linear page number (linear address SHR 12)
Note:	setting write protection in map set 0 will cause the setting to become
	  the default for newly-allocated map sets
--------m-675E04-----------------------------
INT 67 - Nanosoft MD386 - GET DEBUG EXCEPTION
	AX = 5E04h
Return: BL = debug exception (low byte of DR6 register)
SeeAlso: AX=5E02h,AX=5E05h
--------m-675E05-----------------------------
INT 67 - Nanosoft MD386 - IGNORE NEXT DEBUG EXCEPTION
	AX = 5E05h
Note:	may be required when using AX=5E02h for handling instruction
	  breakpoints
SeeAlso: AX=5E02h,AX=5E04h
--------m-6760-------------------------------
INT 67 - EEMS - GET PHYSICAL WINDOW ARRAY
	AH = 60h
	ES:DI -> buffer
Return: AH = status (see also AH=40h)
	AL = number of entries
	buffer at ES:DI filled
--------m-6761-------------------------------
INT 67 - EEMS - GENERIC ACCELERATOR CARD SUPPORT
	AH = 61h
	???
Return: ???
Note:	can be used by accelerator card manufacturer to flush RAM cache,
	  ensuring that the cache accurately reflects what the processor would
	  see without the cache.
--------m-676100-----------------------------
INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - INSTALLATION CHECK???
	AX = 6100h
Return: AH = status (00h if installed???)
Note:	STB's RAPIDMAP.SYS EMS driver calls this function and AX=6101h if
	  the signature "GACXXX" is found at offset 0Ah in the INT 67 handler's
	  segment (i.e. a device driver named GACXXX?? has hooked INT 67)
SeeAlso: AX=6101h,INT 02/SI=0714h
--------m-676101-----------------------------
INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - GET ??? ENTRY POINT
	AX = 6101h
Return: AH = status
	---if AH=00h---
	ES:BX -> ??? entry point
SeeAlso: AX=6100h
--------m-6768-------------------------------
INT 67 - EEMS - GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM
	AH = 68h
	ES:DI -> buffer
Return: AH = status (see also AH=40h)
	AL = number of entries
	buffer at ES:DI filled
Note:	equivalent to LIM 4.0 function 58h
--------m-6769-------------------------------
INT 67 - EEMS - MAP PAGE INTO FRAME
	AH = 69h
	AL = frame number
	BX = page number
	DX = handle
Return: AH = status (see also AH=40h)
Note:	similar to EMS function 44h
SeeAlso: AH=44h,AH=50h,AH=6Ah
--------m-676A-------------------------------
INT 67 - EEMS - PAGE MAPPING
	AH = 6Ah
	AL = subfunction
	    00h save partial page map
		CH = first page frame
		CL = number of frames
		ES:DI -> buffer which is to be filled
	    01h restore partial page map
		CH = first page frame
		CL = number of frames
		DI:SI -> previously saved page map
	    02h save and restore partial page map
		CH = first page frame
		CL = number of frames
		ES:DI = buffer for current page map
		DI:SI = new page map
	    03h get size of save array
		CH = first page frame
		CL = number of frames
		Return: AL = size of array in bytes
	    04h switch to standard map register setting
	    05h switch to alternate map register setting
	    06h deallocate pages mapped to frames in conventional memory
		CH = first page frame
		CL = number of frames
Return: AH = status (see #2897)
Note:	similar to EMS function 4Eh, except that a subrange of pages can be
	  specified
SeeAlso: AH=69h
--------m-676B-------------------------------
INT 67 - DESQview 2.42-2.53 - BUG
	AH = 6Bh
Note:	the EMM.DVR portion of DESQview branches to a random location on this
	  function due to a fencepost error
--------m-67DD-------------------------------
INT 67 - Quadtel QMAPS - API
	AH = DDh
	AL = function
	???
Return: ???
Notes:	details are not yet available
	Hewlett-Packard's HPMM.SYS is a licensed version of QMAPS, and thus
	  supports this API
SeeAlso: AH=3Fh,AX=FFA5h
--------E-67DE00-----------------------------
INT 67 - Virtual Control Program Interface - INSTALLATION CHECK
	AX = DE00h
Return: AH = status
	    00h VCPI is present
		BH = major version number
		BL = minor version number
	    nonzero  VCPI not present
BUG:	MS Windows 3.00 is reported to "object violently" to this call.
SeeAlso: INT 2F/AX=1687h
--------E-67DE01-----------------------------
INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE
	AX = DE01h
	ES:DI -> 4K page table buffer
	DS:SI -> three descriptor table entries in GDT
		first becomes code segment descriptor, other two for use by
		  main control program
Return: AH = 00h successful
	    DI -> first unused page table entry in buffer
	    EBX -> protected mode entry point in code segment (see #2913)
	AH = nonzero  failed
Note:	protected mode entry point may be called with AX=DE00h-DE05h and
	  AX=DE0Ch (in each case, all other registers as appropriate for
	  the function)
SeeAlso: INT 2F/AX=1687h,INT 67/AH=3Fh

(Table 2913)
Call QEMM v6.03 protected mode entry point additionally with:
	AX = DF00h ???
		???
		Return: ???
	AX = DF01h ???
		???
		Return: ???
--------E-67DE02-----------------------------
INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS
	AX = DE02h
Return: AH = 00h  successful
	    EDX = physical address of highest 4K memory page
	AH nonzero: failed
SeeAlso: AH=3Fh
--------E-67DE03-----------------------------
INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES
	AX = DE03h
Return: AH = 00h  successful
	    EDX = number of free 4K pages
	AH nonzero: failed
Notes:	returns total number of pages available to ALL tasks in system
	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#2913)
SeeAlso: AX=DE04h
--------E-67DE04-----------------------------
INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE
	AX = DE04h
Return: AH = 00h successful
	    EDX = physical address of allocated page
	AH nonzero: failed
Notes:	the client program is responsible for freeing all memory allocated
	  with this call before terminating
	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#2913)
SeeAlso: AH=3Fh,AX=DE03h,AX=DE05h
--------E-67DE05-----------------------------
INT 67 - Virtual Control Program Interface - FREE 4K PAGE
	AX = DE05h
	EDX = physical address of 4K page
Return: AH = status
	    00h successful
	    nonzero failed
Note:	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#2913)
SeeAlso: AH=3Fh,AX=DE04h
--------E-67DE06-----------------------------
INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB
	AX = DE06h
	CX = page number (linear address shifted right 12 bits)
Return: AH = status
	    00h successful
		EDX = physical address of page
	    nonzero invalid page number (AH = 8Bh recommended)
SeeAlso: AX=5BE0h
--------E-67DE07-----------------------------
INT 67 - Virtual Control Program Interface - READ CR0
	AX = DE07h
Return: AH = 00h
	EBX = value of Control Register 0
SeeAlso: AH=3Fh,AX=DE07h
--------E-67DE08-----------------------------
INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS
	AX = DE08h
	ES:DI -> array of 8 DWORDs
Return: AH = 00h
	buffer filled with DR0 first, DR7 last, DR4 and DR5 unused
SeeAlso: AH=3Fh,AX=DE09h
--------E-67DE09-----------------------------
INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS
	AX = DE09h
	ES:DI -> array of 8 DWORDs holding new values of debug registers
Return: AH = 00h
Note:	values for DR4 and DR5 ignored
SeeAlso: AH=3Fh,AX=DE08h
--------E-67DE0A-----------------------------
INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Ah
Return: AH = 00h successful
	    BX = first vector used by master 8259 (IRQ0)
	    CX = first vector used by slave 8259 (IRQ8)
	AH nonzero: failed
Note:	CX is undefined in systems without a slave 8259
SeeAlso: AX=DE0Bh,INT 21/AX=250Ch,INT 31/AX=0400h
--------E-67DE0B-----------------------------
INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Bh
	BX = first vector used by master 8259
	CX = first vector used by slave 8259
	interrupts disabled
Return: AH = 00h successful
	AH nonzero: failed
Notes:	This call merely informs the server that the client has changed the
	  interrupt mappings.  The client may not change the mappings if they
	  have already been changed by the server or another client, and is
	  responsible for restoring the original mappings before terminating.
SeeAlso: AX=DE0Ah,INT 2C/AX=002Ah
--------E-67DE0C-----------------------------
INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE
	AX = DE0Ch
	ESI = linear address in first megabyte of values for system
	      registers (see #2914)
	interrupts disabled
Return: interrupts disabled
	GDTR, IDTR, LDTR, TR loaded
	SS:ESP must have at least 16 bytes space, and the entry point is
	      required to set up a new stack before enabling interrupts
	EAX, ESI, DS, ES, FS, GS destroyed
Note:	in protected mode, calling the protected-mode VCPI entry point with
	  AX = DE0Ch
	  DS = segment selector mapping entire linear address space obtained
		  via AX=DE01h
	  SS:ESP in first megabyte of linear memory
	  STACK:QWORD  return address from FAR call to 32-bit segment
		DWORD  EIP
		DWORD  CS
		DWORD  reserved for EFLAGS
		DWORD  ESP
		DWORD  SS
		DWORD  ES
		DWORD  DS
		DWORD  FS
		DWORD  GS
	  and interrupts disabled, will switch to virtual86 mode with
	    interrupts disabled, all segment registers loaded, and EAX
	    destroyed.
SeeAlso: AH=3Fh,INT 15/AH=89h,INT D4/AH=10h

Format of system register values for switch to protected mode:
Offset	Size	Description	(Table 2914)
 00h	DWORD	value for CR3
 04h	DWORD	linear address in first megabyte of value for GDTR
 08h	DWORD	linear address in first megabyte of value for IDTR
 0Ch	WORD	value for LDTR
 0Eh	WORD	value for TR
 10h	PWORD	CS:EIP of protected mode entry-point
--------m-67DE0F-----------------------------
INT 67 - Netroom3 - ???
	AX = DE0Fh
	???
Return: ???
Note:	called by Netroom's DPMI.EXE
--------m-67EF-------------------------------
INT 67 - RM386 v6.00+ - EXECUTE XMS FUNCTION
	AH = EFh
	AL = function (00h-12h,80h-8Fh)
	other register as appropriate for XMS function
Return: varies by function (see INT 2F/AX=4310h"XMS")
Note:	these functions appear to be equivalent to the XMS functions with the
	  same numbers
SeeAlso: AX=5DFFh"RM386",INT 2F/AX=4310h"XMS"
--------m-67FFA5-----------------------------
INT 67 - Microsoft EMM386.EXE v4.20+ - INSTALLATION CHECK
	AX = FFA5h
Return: AX = 845Ah/84A5h if loaded
	    BX:CX -> API entry point (see #2915)
Notes:	this call is available even if EMM386 is not providing EMS
	the returned AX is 845Ah inside of MSWindows, 84A5h under bare DOS
	if no other program has hooked INT 67, an alternate installation
	  check is to test for the string
	  "MICROSOFT EXPANDED MEMORY MANAGER 386" at offset 14h in the INT 67
	  handler's segment; the word immediately preceding this string
	  contains the offset of the API entry point
SeeAlso: AH=3Fh,AX=FFA5h/BX=4345h,INT 21/AX=4402h"EMM386.EXE"

(Table 2915)
Call EMM386.EXE API entry point with:
	AH = 00h get memory manager's status
	    Return: AH = status
			bit 0: not active (OFF)
			bit 1: in "Auto" mode
	AH = 01h set memory manager's state
	    AL = new state (00h ON, 01h OFF, 02h AUTO)
	AH = 02h Weitek coprocessor support
	    AL = subfunction
		00h get Weitek support state
		    Return: AL = status
				bit 0: Weitek coprocessor is present
				bit 1: Weitek support is enabled
		01h turn on Weitek support
		02h turn off Weitek support
     --- v4.20-4.41 only ---
	AH = 03h Windows support???
	    AL = subfunction (00h, 01h)
	AH = 04h print copyright notice to standard output
		 (using INT 21/AH=09h)
	AH = 05h print available report
		 (the one shown when running EMM386 from the DOS prompt)
SeeAlso: #0855 at INT 21/AX=4402h/SF=02h,#1951 at INT 2F/AX=12FFh/BX=0106h
--------m-67FFA5BX4345-----------------------
INT 67 U - Compaq CEMM v5.10+ - PRIVATE API
	AX = FFA5h
	BX = 4345h ("CE")
	DX = subfunction
	    0000h unshadow video ROM???
	    0001h shadow video ROM???
	    0002h map pages
		CX = number of pages (00h=one)
		ESI = linear address of first page to map into address space
		EDI = linear starting address at which pages are to be visible
	    0003h get ???
		Return: DX = ??? (0-2)
	    0004h BUG: crashes system due to fencepost error
Return: AH = 84h
	AL = status (84h = error, FFh = success)
Note:	if BX <> 4345h or DX > 0004h on entry, CEMM behaves identically to
	  Microsoft's EMM386 (see AX=FFA5h"EMM386")
SeeAlso: AX=FFA5h"EMM386",#0855 at INT 21/AX=4402h/SF=02h,#2915
--------I-68---------------------------------
INT 68 - Sangoma CCPOP 3270 resident module
SeeAlso: INT 67"Sangoma",INT 92"Sangoma"
--------N-68---------------------------------
INT 68 - Novell NetWare LU6.2
Note:	the installation check consists of testing for the signature string
	  "APPC/PC" nine bytes before the interrupt handler
SeeAlso: AH=01h/SF=1B00h,AH=FAh
--------h-68---------------------------------
INT 68 C - HP Vectra AT - IRQ16 - 8041 SERVICE REQUEST
SeeAlso: INT 08"IRQ0",INT 69"HP Vectra",INT 6F/AH=00h"HP"
--------N-6801--SF1B00-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - DISPLAY
	AH = 01h subfn 1B00h
	DS:DX -> control block (see #2916)
Return: control block updated
SeeAlso: AH=01h/SF=2000h,AH=01h/SF=2B00h,INT 68"Novell"

Format of APPC/PC "DISPLAY" control block:
Offset	Size	Description	(Table 2916)
 00h 12 BYTEs	reserved
 0Ch	WORD	1B00h (verb "DISPLAY")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h  8 BYTEs	(big-endian) partner logical unit name
 2Ah  8 BYTEs	(big-endian) mode name
 32h	BYTE	logical unit session limit
 33h	BYTE	partner logical unit session limit
 34h	BYTE	node maximum negotiable session limit
 35h	BYTE	current session limit
 36h	BYTE	minimum negotiated winner limit
 37h	BYTE	maximum negotiated loser limit
 38h	BYTE	active session count
 39h	BYTE	active CONWINNER session count
 3Ah	BYTE	active CONLOSER session count
 3Bh	BYTE	session termination count
 3Ch	BYTE	bit 7: SESSION_TERMINATION_TARGET_DRAIN
		bit 6: SESSION_TERMINATION_SOURCE_DRAIN

(Table 2917)
Values for APPC/PC return code:
 0000h	successful
 0001h	BAD_TP_ID
 0002h	BAD_CONV_ID
 0003h	bad logical unit ID
 0008h	no physical unit attached
 0110h	bad state
 01B1h	BAD_PART_LUNAME
 01B2h	bad mode name
 0201h	physical unit already active
 0211h	logical unit already active
 0212h	BAD_PART_SESS
 0213h	BAD_RU_SIZES
 0214h	BAD_MODE_SESS
 0216h	BAD_PACING_CNT
 0219h	EXTREME_RUS
 021Ah	SNASVCMG_1
 0223h	SSCP_CONNECTED_LU
 0230h	invalid change
 0243h	too many TPs
 0272h	adapter close failure
 0281h	GET_ALLOC_BAD_TYPE
 0282h	unsuccessful
 0283h	DLC failure
 0284h	unrecognized DLC
 0286h	duplicate DLC
 0301h	SSCP_PU_SESSION_NOT_ACTIVE
 0302h	data exceeds RU size
 0401h	invalid direction
 0402h	invalid type
 0403h	segment overlap
 0404h	invalid first character
 0405h	table error
 0406h	conversion error
 F0010000h	APPC disabled
 F0020000h	APPC busy
 F0030000h	APPC abended
 F0040000h	incomplete
--------N-6801--SF2000-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - ATTACH PHYSICAL UNIT
	AH = 01h subfn 2000h
	DS:DX -> control block (see #2918)
Return: control block updated
SeeAlso: AH=01h/SF=2100h,AH=01h/SF=2B00h

Format of APPC/PC "Attach Physical Unit" control block:
Offset	Size	Description	(Table 2918)
 00h 12 BYTEs	reserved
 0Ch	WORD	2000h (verb "Attach Physical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h	WORD	00h
 1Ah	BYTE	version
 1Bh	BYTE	release
 1Ch  8 BYTEs	(big-endian) net name
 24h  8 BYTEs	(big-endian) physical unit name
 2Ch  8 BYTEs	00h
 34h	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh=don't log errors
		(see also AH=01h/SF=2100h)
 38h	DWORD	00h
 3Ch	BYTE	00h RETURN_CONTROL: COMPLETE
		01h RETURN_CONTROL: INCOMPLETE
--------N-6801--SF2100-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - ATTACH LOGICAL UNIT
	AH = 01h subfn 2100h
	DS:DX -> control block (see #2919)
Return: control block updated
SeeAlso: #2922,#2923,#2925,AH=01h/SF=2000h,AH=01h/SF=2200h,AH=01h/SF=2B00h

Format of APPC/PC "Attach Logical Unit" control block:
Offset	Size	Description	(Table 2919)
 00h 12 BYTEs	reserved
 0Ch	WORD	2100h (verb "Attach Logical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h	WORD	70  offset to partner logical unit record
 1Ah  8 BYTEs	(big-endian) logical unit name
 22h  8 BYTEs	(big-endian) logical unit ID
 2Ah	BYTE	logical unit local address
 2Bh	BYTE	logical unit session limit
 2Ch	DWORD	pointer to CREATE_TP_EXIT routine,
		FFFFFFFFh = reject incoming ALLOCATEs
		00000000h = queue ALLOCATEs
 30h	DWORD	00h
 34h	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh=don't log errors
 38h	DWORD	00h
 3Ch	BYTE	maximum TPs
 3Dh	BYTE	queue depth
 3Eh	DWORD	pointer to LU_LU_PASSWORD_EXIT routine, FFFFFFFFh=no pswd exit
 42h	DWORD	00h
 46h	WORD	total length of partner records
 48h	var	array of partner logical unit records (see #2920)
SeeAlso: #2922,#2923,#2925

Format of APPC/PC partner logical unit record:
Offset	Size	Description	(Table 2920)
 00h	WORD	length of this partner logical unit record
 02h	WORD	42  offset to mode records
 04h  8 BYTEs	(big-endian) partner logical unit name
 0Ch	BYTE	partner logical unit security capabilities
		bit 7: already verified
		bit 6: conversation level security
		bit 5: session level security
 0Dh	BYTE	partner logical unit session limit
 0Eh	WORD	partner logical unit maximum MC_SEND_LL
 10h  8 BYTEs	(big-endian) partner logical unit DLC name
 18h	BYTE	partner logical unit adapter number
 19h 17 BYTEs	(counted string) partner logical unit adapter address
 2Ah	WORD	total length of mode records
 2Ch 16N BYTEs	array of mode records (see #2921)

Format of mode record:
Offset	Size	Description	(Table 2921)
 00h	WORD	16  length of this mode record
 02h  8 BYTEs	(big-endian) mode name
 0Ah	WORD	RU_SIZE high bound
 0Ch	WORD	RU_SIZE low bound
 0Eh	BYTE	mode maximum negotiable session limit
 0Fh	BYTE	pacing size for receive

Routines defined by LU_LU_PASSWORD_EXIT, CREATE_TP_EXIT, and SYSTEM_LOG_EXIT
pointers are called by pushing the DWORD pointer to the verb on the stack and
then performing a FAR call.

Format of ACCESS_LU_LU_PW verb:
Offset	Size	Description	(Table 2922)
 00h 12 BYTEs	reserved
 0Ch	WORD	1900h (verb "ACCESS_LU_LU_PW")
 0Eh  8 BYTEs	(big-endian) logical unit ID
 16h  8 BYTEs	(big-endian) logical unit name
 1Eh  8 BYTEs	(big-endian) partner logical unit name
 26h 17 BYTEs	(counted string) partner fully qualified logical unit name
 37h	BYTE	password available (0=no, 1=yes)
 38h  8 BYTEs	password
SeeAlso: #2919,#2923,#2925

Format of CREATE_TP verb:
Offset	Size	Description	(Table 2923)
 00h 12 BYTEs	reserved
 0Ch	WORD	2300h (verb "CREATE_TP")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) sense code (see #2924)
 18h  8 BYTEs	(big-endian) TP ID
 20h  8 BYTEs	(big-endian) logical unit ID
 28h	DWORD	(big-endian) conversation ID
 2Ch	BYTE	0 basic conversation, 1 mapped conversation
 2Dh	BYTE	0 no sync level, 1 confirm
 2Eh	BYTE	reserved
 2Fh 65 BYTEs	(counted string) transaction program name
 70h  6 BYTEs	00h
 76h	WORD	length of ERROR_LOG_DATA to return
 78h	DWORD	pointer to ERROR_LOG_DATA buffer
 7Ch  8 BYTEs	(big-endian) partner logical unit name
 84h 18 BYTEs	(counted string) partner fully qualified logical unit name
 96h  8 BYTEs	(big-endian) mode name
 9Eh 12 BYTEs	00h
 AAh 11 BYTEs	(counted string) password
 B5h 11 BYTEs	(counted string) user ID
 C0h	BYTE	0 verification should be performed
		1 already verified
SeeAlso: #2922,#2925

(Table 2924)
Values for APPC/PC sense code:
 00000000h	Ok
 080F6051h	SECURITY_NOT_VALID
 084B6031h	TP_NOT_AVAIL_RETRY
 084C0000h	TP_NOT_AVAIL_NO_RETRY
 10086021h	TP_NAME_NOT_RECOGNIZED
 10086034h	CONVERSATION_TYPE_MISMATCH
 10086041h	SYNC_LEVEL_NOT_SUPPORTED

Format of SYSLOG verb:
Offset	Size	Description	(Table 2925)
 00h 12 BYTEs	reserved
 0Ch	WORD	2600h (verb "SYSLOG")
 0Eh 10 BYTEs	00h
 18h	WORD	(big-endian) type
 1Ah	DWORD	(big-endian) subtype
 1Eh	DWORD	pointer to ADDITIONAL_INFO
 22h	DWORD	(big-endian) conversation ID
 26h  8 BYTEs	(big-endian) TP ID
 2Eh  8 BYTEs	(big-endian) physical unit or logical unit name
 36h	WORD	length of data
 38h	DWORD	pointer to data
 3Ch	BYTE	00h
SeeAlso: #2922,#2923
--------N-6801--SF2200-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - DETACH LOGICAL UNIT
	AH = 01h subfn 2200h
	DS:DX -> control block (see #2926)
Return: control block updated
SeeAlso: AH=01h/SF=2000h,AH=01h/SF=2100h,AH=01h/SF=2700h

Format of APPC/PC "Detach Logical Unit" control block:
Offset	Size	Description	(Table 2926)
 00h 12 BYTEs	reserved
 0Ch	WORD	2200h (verb "Detach Logical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h  8 BYTEs	(big-endian) logical unit ID
 20h	BYTE	00h
--------N-6801--SF2700-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - DETACH PHYSICAL UNIT
	AH = 01h subfn 2700h
	DS:DX -> control block (see #2927)
Return: control block updated
SeeAlso: AH=01h/SF=2000h,AH=01h/SF=2100h,AH=01h/SF=2200h

Format of APPC/PC "Detach Physical Unit" control block:
Offset	Size	Description	(Table 2927)
 00h 12 BYTEs	reserved
 0Ch	WORD	2700h (verb "Detach Physical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h	BYTE	00h  type: hard
		01h  type: soft
--------N-6801--SF2B00-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - ACTIVATE DLC
	AH = 01h subfn 2B00h
	DS:DX -> control block (see #2928)
Return: control block updated
SeeAlso: AH=01h/SF=1B00h,AH=01h/SF=2000h

Format of APPC/PC "Activate DLC" control block:
Offset	Size	Description	(Table 2928)
 00h 12 BYTEs	reserved
 0Ch	WORD	2B00h (verb "Activate DLC")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h  8 BYTEs	(big-endian) DLC name
 20h	BYTE	adapter number
--------N-6802--SF0100-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - ALLOCATE
	AH = 02h subfn 0100h
	DS:DX -> control block (see #2929)
Return: control block updated
SeeAlso: AH=02h/SF=0500h

Format of APPC/PC "Allocate" control block:
Offset	Size	Description	(Table 2929)
 00h 12 BYTEs	reserved
 0Ch	WORD	0100h (verb "Allocate" or "MC_Allocate")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	(MC_Allocate only) conversation type
		0 basic conversation
		1 mapped conversation
 27h	BYTE	SYNC_LEVEL (00h none, 01h confirm)
 28h	WORD	0000h
 2Ah	BYTE	RETURN_CONTROL
		00h when session allocated
		01h immediate
		02h when session free
 2Bh  8 BYTEs	00h
 33h  8 BYTEs	(big-endian) partner logical unit name
 3Bh  8 BYTEs	(big-endian) mode name
 43h 65 BYTEs	(counted string) TP name
 84h	BYTE	security (00h none, 01h same, 02h pgm)
 85h 11 BYTEs	00h
 90h 11 BYTEs	(counted string) password
 9Bh 11 BYTEs	(counted string) user ID
 A6h	WORD	PIP_DATA length
 A8h	DWORD	pointer to PIP_DATA

(Table 2930)
Values for APPC/PC primary return code:
 0000h	successful
 0001h	parameter check
 0002h	state check
 0003h	allocation error
 0005h	deallocate abended
 0006h	deallocate abended program
 0007h	deallocate abended SVC
 0008h	deallocate abended timer
 0009h	deallocate normal return
 000Ah	data posting blocked
 000Bh	posting not active
 000Ch	PROG_ERROR_NO_TRUNC
 000Dh	PROG_ERROR_TRUNC
 000Eh	PROG_ERROR_PURGING
 000Fh	CONV_FAILURE_RETRY
 0010h	CONV_FAILURE_NO_RETRY
 0011h	SVC_ERROR_NO_TRUNC
 0012h	SVC_ERROR_TRUNC
 0013h	SVC_ERROR_PURGING
 0014h	unsuccessful
 0018h	CNOS partner logical unit reject
 0019h	conversation type mixed
 F001h	APPC disabled
 F002h	APPC busy
 F003h	APPC abended
 F004h	incomplete

(Table 2931)
Values for APPC/PC error code:
 0001h	bad TP ID
 0002h	bad conversation ID
 0004h	allocation error, no retry
 0005h	allocation error, retry
 0006h	data area crosses segment boundary
 0010h	bad TPN length
 0011h	bad CONV length
 0012h	bad SYNC level
 0013h	bad security selection
 0014h	bad return control
 0015h	SEC_TOKENS too big
 0016h	PIP_LEN incorrect
 0017h	no use of SNASVCMG
 0018h	unknown partner mode
 0031h	confirm: SYNC_NONE
 0032h	confirm: bad state
 0033h	confirm: NOT_LL_BDY
 0041h	confirmed: bad state
 0051h	deallocate: bad type
 0052h	deallocate: flush bad state
 0053h	deallocate: confirm bad state
 0055h	deallocate: NOT_LL_BDY
 0057h	deallocate: log LL_WRONG
 0061h	flush: not send state
 0091h	post on receipt: invalid length
 0092h	post on receipt: not in receive state
 0093h	post on receipt: bad fill
 00A1h	prepare to receive:invalid type
 00A2h	prepare to receive: unfinished LL
 00A3h	prepare to receive: not in send state
 00B1h	receive and wait: bad state
 00B2h	receive and wait: NOT_LL_BDY
 00B5h	receive and wait: bad fill
 00C1h	receive immediate: not in receive state
 00C4h	receive immediate: bad fill
 00E1h	request to send: not in receive state
 00F1h	send data: bad LL
 00F2h	send data: not in send state
 0102h	send error: log LL wrong
 0103h	send error: bad type
 0121h	test: invalid type
 0122h	test: not in receive state
--------N-6802--SF0300-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - CONFIRM
	AH = 02h subfn 0300h
	DS:DX -> control block (see #2932)
Return: control block updated
SeeAlso: AH=02h/SF=0400h

Format of APPC/PC "Confirm" control block:
Offset	Size	Description	(Table 2932)
 00h 12 BYTEs	reserved
 0Ch	WORD	0300h (verb "Confirm" or "MC_Confirm")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	request to send received (0=no, 1=yes)
--------N-6802--SF0400-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - CONFIRMED
	AH = 02h subfn 0400h
	DS:DX -> control block (see #2933)
Return: control block updated
SeeAlso: AH=02h/SF=0300h

Format of APPC/PC "Confirmed" control block:
Offset	Size	Description	(Table 2933)
 00h 12 BYTEs	reserved
 0Ch	WORD	0400h (verb "Confirmed" or "MC_Confirmed")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
--------N-6802--SF0500-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - DEALLOCATE
	AH = 02h subfn 0500h
	DS:DX -> control block (see #2934)
Return: control block updated
SeeAlso: AH=02h/SF=0100h,AH=02h/SF=0300h

Format of APPC/PC "Deallocate" control block:
Offset	Size	Description	(Table 2934)
 00h 12 BYTEs	reserved
 0Ch	WORD	0500h (verb "Deallocate" or "MC_Deallocate")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	00h
 27h	BYTE	type
		00h SYNC_LEVEL
		01h FLUSH
		02h ABEND_PROC
		03h ABEND_SVC
		04h ABEND_TIMER
		05h ABEND
 28h	WORD	(MC_Deallocate only) length of error log data
 2Ah	DWORD	(MC_Deallocate only) pointer to error log data
--------N-6802--SF0600-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - FLUSH
	AH = 02h subfn 0600h
	DS:DX -> control block (see #2935)
Return: control block updated
SeeAlso: AH=02h/SF=0300h

Format of APPC/PC "Flush" control block:
Offset	Size	Description	(Table 2935)
 00h 12 BYTEs	reserved
 0Ch	WORD	0600h (verb "Flush" or "MC_Flush")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
--------N-6802--SF0700-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - GET ATTRIBUTES
	AH = 02h subfn 0700h
	DS:DX -> control block (see #2936)
Return: control block updated
SeeAlso: AH=02h/SF=0300h

Format of APPC/PC "Get_Attributes" control block:
Offset	Size	Description	(Table 2936)
 00h 12 BYTEs	reserved
 0Ch	WORD	0700h (verb "Get_Attributes" or "MC_Get_Attributes")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h  8 BYTEs	(big-endian) logical unit ID
 2Eh	BYTE	00h
 2Fh	BYTE	SYNC_LEVEL (0=none, 1=confirm)
 30h  8 BYTEs	(big-endian) mode name
 38h  8 BYTEs	(big-endian) own net name
 40h  8 BYTEs	(big-endian) own logical unit name
 48h  8 BYTEs	(big-endian) partner logical unit name
 50h 18 BYTEs	(counted string) partner's fully qualified logical unit name
 62h	BYTE	00h
 63h 11 BYTEs	(counted string) user ID
--------N-6802--SF0800-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - GET CONVERSATION TYPE
	AH = 02h subfn 0800h
	DS:DX -> control block (see #2937)
Return: control block updated
SeeAlso: AH=02h/SF=0300h

Format of APPC/PC "Get_Type" control block:
Offset	Size	Description	(Table 2937)
 00h 12 BYTEs	reserved
 0Ch	WORD	0800h (verb "Get_Type")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	(ret) type (0=basic conversation, 1=mapped conversation)
--------N-6802--SF0900-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - POST ON RECEIPT
	AH = 02h subfn 0900h
	DS:DX -> control block (see #2938)
Return: control block updated
SeeAlso: AH=02h/SF=0A00h

Format of APPC/PC "Post_on_Receipt" control block:
Offset	Size	Description	(Table 2938)
 00h 12 BYTEs	reserved
 0Ch	WORD	0900h (verb "Post_on_Receipt")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	WORD	maximum length
 28h	BYTE	fill (0=buffer, 1=LL)
--------N-6802--SF0A00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - PREPARE TO RECEIVE
	AH = 02h subfn 0A00h
	DS:DX -> control block (see #2939)
Return: control block updated
SeeAlso: AH=02h/SF=0900h,AH=02h/SF=0B00h

Format of APPC/PC "Prepare_to_Receive" control block:
Offset	Size	Description	(Table 2939)
 00h 12 BYTEs	reserved
 0Ch	WORD	0A00h (verb "Prepare_to_Receive" or "MC_Prepare_to_Receive")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	type (0=SYNC_LEVEL, 1=FLUSH)
 27h	BYTE	locks (0=short, 1=long)
--------N-6802--SF0B00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - RECEIVE AND WAIT
	AH = 02h subfn 0B00h
	DS:DX -> control block (see #2940)
Return: control block updated
SeeAlso: AH=02h/SF=0C00h,AH=02h/SF=0F00h

Format of APPC/PC "Receive_and_Wait" control block:
Offset	Size	Description	(Table 2940)
 00h 12 BYTEs	reserved
 0Ch	WORD	0B00h (verb "Receive_and_Wait" or "MC_Receive_and_Wait")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	type of information received (see #2941)
 27h	BYTE	(MC_Receive_and_Wait only) fill (0=buffer, 1=LL)
 28h	BYTE	Request_to_Send_Received (0=no, 1=yes)
 29h	WORD	maximum length
 2Bh	WORD	data length
 2Dh	DWORD	pointer to data

(Table 2941)
Values for type of information received:
 00h	data
 01h	data complete
 02h	data incomplete
 03h	confirm
 04h	confirm send
 05h	confirm deallocate
 06h	send
--------N-6802--SF0C00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - RECEIVE IMMEDIATE
	AH = 02h subfn 0C00h
	DS:DX -> control block (see #2942)
Return: control block updated
SeeAlso: AH=02h/SF=0B00h,AH=02h/SF=0F00h

Format of APPC/PC "Receive_Immediate" control block:
Offset	Size	Description	(Table 2942)
 00h 12 BYTEs	reserved
 0Ch	WORD	0C00h (verb "Receive_Immediate" or "MC_Receive_Immediate")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	type of information received (see #2941)
 27h	BYTE	(MC_Receive_Immediate only) fill (0=buffer, 1=LL)
 28h	BYTE	Request_to_Send_Received (0=no, 1=yes)
 29h	WORD	maximum length
 2Bh	WORD	data length
 2Dh	DWORD	pointer to data
--------N-6802--SF0E00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - REQUEST TO SEND
	AH = 02h subfn 0E00h
	DS:DX -> control block (see #2943)
Return: control block updated
SeeAlso: AH=02h/SF=0F00h,AH=02h/SF=1000h

Format of APPC/PC "Request_to_Send" control block:
Offset	Size	Description	(Table 2943)
 00h 12 BYTEs	reserved
 0Ch	WORD	0E00h (verb "Request_to_Send" or "MC_Request_to_Send")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
--------N-6802--SF0F00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - SEND DATA
	AH = 02h subfn 0F00h
	DS:DX -> control block (see #2944)
Return: control block updated
SeeAlso: AH=02h/SF=0E00h,AH=02h/SF=1000h

Format of APPC/PC "Send_Data" control block:
Offset	Size	Description	(Table 2944)
 00h 12 BYTEs	reserved
 0Ch	WORD	0F00h (verb "Send_Data" or "MC_Send_Data")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	request to send received (0=no, 1=yes)
 27h	BYTE	00h
 28h	WORD	data length
 2Ah	DWORD	pointer to data
--------N-6802--SF1000-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - SEND ERROR
	AH = 02h subfn 1000h
	DS:DX -> control block (see #2945)
Return: control block updated
SeeAlso: AH=02h/SF=0F00h

Format of APPC/PC "Send_Error" control block:
Offset	Size	Description	(Table 2945)
 00h 12 BYTEs	reserved
 0Ch	WORD	1000h (verb "Send_Error" or "MC_Send_Error")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	request to send received (0=no, 1=yes)
 27h	BYTE	type (0=program, 1=SVC)
 28h	DWORD	00h
 2Ch	WORD	(MC_Send_Error only) LOG_DATA length
 2Eh	DWORD	(MC_Send_Error only) pointer to LOG_DATA
--------N-6802--SF1200-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - TEST
	AH = 02h subfn 1200h
	DS:DX -> control block (see #2946)
Return: control block updated
SeeAlso: AH=02h/SF=1300h

Format of APPC/PC "Test" control block:
Offset	Size	Description	(Table 2946)
 00h 12 BYTEs	reserved
 0Ch	WORD	1200h (verb "Test" or "MC_Test")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	(MC_Test only) test (0=posted, 1=request_to_send received)
Note:	error code has different interpretations for:
	0 posted data
	1 posted not data (primary return code = 0)
	1 bad TP_ID (primary return code = 1)
--------N-6802--SF1300-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - WAIT
	AH = 02h subfn 1300h
	DS:DX -> control block (see #2947)
Return: control block updated
SeeAlso: AH=02h/SF=1200h

Format of APPC/PC "Wait" control block:
Offset	Size	Description	(Table 2947)
 00h 12 BYTEs	reserved
 0Ch	WORD	1300h (verb "Wait")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) error code (see #2931,#2946)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	number of conversations to wait on
		Note: error codes have interpretations as for AH=02h/SF=1200h
--------N-6803--SF2400-----------------------
INT 68 - APPC/PC - TP STARTED
	AH = 03h subfn 2400h
	DS:DX -> control block (see #2948)
Return: control block updated

Format of APPC/PC "TP Started" control block:
Offset	Size	Description	(Table 2948)
 00h 12 BYTEs	reserved
 0Ch	WORD	2400h (verb "TP Started")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h  8 BYTEs	(big-endian) TP ID
--------N-6803--SF2800-----------------------
INT 68 - APPC/PC - GET ALLOCATE
	AH = 03h subfn 2800h
	DS:DX -> control block (see #2949)
Return: control block updated

Format of APPC/PC "Get ALLOCATE" control block:
Offset	Size	Description	(Table 2949)
 00h 12 BYTEs	reserved
 0Ch	WORD	2800h (verb "Get ALLOCATE")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h	BYTE	type (00h dequeue, 01h test)
 23h	DWORD	pointer to CREATE_TP record
--------N-6803--SF2A00-----------------------
INT 68 - APPC/PC - CHANGE LOGICAL UNIT
	AH = 03h subfn 2A00h
	DS:DX -> control block (see #2950)
Return: control block updated

Format of APPC/PC "Change Logical Unit" control block:
Offset	Size	Description	(Table 2950)
 00h 12 BYTEs	reserved
 0Ch	WORD	2A00h (verb "Change Logical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h	DWORD	pointer to CREATE_TP_EXIT routine
		00000000h queue ALLOCATEs
		FFFFFFFFh reject incoming ALLOCATEs
 26h	DWORD	00000000h
 2Ah	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh= don't log errors
 2Eh	DWORD	00000000h
 32h	BYTE	maximum TPs
 33h	BYTE	00h stop QUEUE_ALLOCATEs
		01h resume QUEUE_ALLOCATEs
 34h	DWORD	pointer to LU_LU_PASSWORD_EXIT routine, FFFFFFFFh = no exit
 38h	DWORD	00000000h
--------N-6804-------------------------------
INT 68 - APPC/PC - TRANSACTION PROCESSING
	AH = 04h
	DS:DX -> control block (see #2951)
Return: control block updated

Format of APPC/PC control block:
Offset	Size	Description	(Table 2951)
 00h 12 BYTEs	reserved
 0Ch	WORD	verb (action)
		2500h TP_ENDED
		2900h TP_VALID
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	-> CREATE_TP record (only if verb = 2900h)
--------N-6805-------------------------------
INT 68 - APPC/PC - TRANSFER MESSAGE DATA
	AH = 05h
	DS:DX -> control block (see #2952)
Return: control block updated

Format of APPC/PC "Transfer Message Data" control block:
Offset	Size	Description	(Table 2952)
 00h 12 BYTEs	reserved
 0Ch	WORD	1C00h (verb "Transfer Message Data")
 0Eh	BYTE	data type
		00h user defined
		01h NMVT
		02h alert subvectors
		03h PDSTATS subvectors
 0Fh  5 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #2917)
 18h 12 BYTEs	00h
 24h	BYTE	flags (see #2953)
 25h	BYTE	00h
 26h	WORD	length of data
 28h  N BYTEs	data

Bitfields for APPC/PC message transfer flags:
Bit(s)	Description	(Table 2953)
 0	don't add correlation subvector
 1	don't add product set ID subvector
 2	don't do SYSLOG
 3	don't send SSCP_PU_SESSION
SeeAlso: #2952
--------N-6806-------------------------------
INT 68 - APPC/PC - CHANGE NUMBER OF SESSIONS
	AH = 06h
	DS:DX -> control block (see #2954)
Return: control block updated

Format of APPC/PC "Change Number of Sessions" control block:
Offset	Size	Description	(Table 2954)
 00h 12 BYTEs	reserved
 0Ch	WORD	1500h (verb "Change Number of Sessions")
 0Eh  6 BYTEs	00h
 14h	WORD	(big-endian) primary return code (see #2930)
 16h	DWORD	(big-endian) secondary return code (see #2917,#2955)
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h  8 BYTEs	blanks
 2Ah  8 BYTEs	(big-endian) partner logical unit name
 32h  8 BYTEs	(big-endian) mode name
 3Ah	BYTE	bit 7: use MODE_NAME_SELECT_ALL rather than MODE_NAME
		bit 6: set negotiable values
 3Bh	BYTE	partner logical unit mode session limit
 3Ch	BYTE	minimum CONWINNERS_SOURCE
 3Dh	BYTE	maximum CONWINNERS_TARGET
 3Eh	BYTE	automatic activation
 3Fh	BYTE	00h
 40h	BYTE	flags
		bit 7: drain target
		bit 6: drain source
		bit 5: target responsible, not source

(Table 2955)
Values for secondary return code (see also AH=01h/SF=1B00h):
 0000h	accepted
 0001h	negotiated
 0003h	bad logical unit ID
 0004h	allocation failure, no retry
 0005h	allocation failure, retry
 0151h	can't raise limits
 0153h	all modes must reset
 0154h	bad SNASVCMG limits
 0155h	minimum greater than total
 0156h	mode closed (primary return code = 1)
	CNOS mode closed (primary return code = 18h)
 0157h	bad mode name (primary return code = 1)
	CNOS bad mode name (primary return code = 18h)
 0159h	reset SNA drains
 015Ah	single not SRC response
 015Bh	bad partner logical unit
 015Ch	exceeds maximum allowed
 015Dh	change SRC drains
 015Eh	logical unit detached
 015Fh	CNOS command race reject
--------N-6807-------------------------------
INT 68 - APPC/PC - PASSTHROUGH
	AH = 07h
	DS:DX -> control block (format depends on application subsystem)
Return: control block updated
SeeAlso: AH=FFh
----------684300-----------------------------
INT 68 U - ??? - INSTALLATION CHECK???
	AX = 4300h
Return: AX = F386h if ???
	???
Note:	called by Novell DOS 7.0 EMM386.EXE
SeeAlso: AX=4400h,INT 41/AX=004Fh
----------684400-----------------------------
INT 68 U - ???
	AX = 4400h
	BX = ???
	CX = ???
	DX = ???
	DS:SI = real-mode address of protected-mode GDT
	ES:DI = real-mode address of protected-mode IDT
Return: ???
Note:	called by Novell DOS 7.0 EMM386.EXE if AX=4300h returns AX=F386h
SeeAlso: AX=4300h
--------W-6847-------------------------------
INT 68 - MS Windows debugging kernel - OUTPUT STRING
	AH = 47h
	ES:SI -> string
Notes:	output a string (to inform a debugger of some events)
	KERNEL outputs "Windows Kernel Entry\r\n" on startup
SeeAlso: INT 41/AX=0012h
--------N-68FA-------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE APPC
	AH = FAh
	AL bit 0 = new state (0 enable, 1 disable)
SeeAlso: AH=FDh,INT 68"Novell"
--------N-68FB-------------------------------
INT 68 - APPC/PC - CONVERT
	AH = FBh
	DS:DX -> control block (see #2956)
Return: control block updated

Format of APPC/PC "CONVERT" control block:
Offset	Size	Description	(Table 2956)
 00h 12 BYTEs	reserved
 0Ch	WORD	1A00h (verb "CONVERT")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code
 18h	BYTE	conversion
		00h ASCII to EBCDIC
		01h EBCDIC to ASCII
 19h	BYTE	character set
		00h AE
		01h A
		02h G
 1Ah	WORD	length of string to convert
 1Ch	DWORD	pointer to source
 20h	DWORD	pointer to target
--------N-68FC-------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE MESSAGE TRACING
	AH = FCh
	AL = new state
	    00h disable tracing
	    01h enable tracing
		DX = number of bytes to keep (0=all)
SeeAlso: AH=FDh,AH=FEh
--------N-68FD-------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE API VERB TRACING
	AH = FDh
	AL = new tracing state (00h disabled, 01h enabled)
SeeAlso: AH=FAh,AH=FCh,AH=FEh
--------N-68FE-------------------------------
INT 68 - APPC/PC - SET TRACE DESTINATION
	AH = FEh
	AL = trace destinations (see #2957)
	DS:DX -> trace stats record if AL bit 0 set (see #2958)
SeeAlso: AH=FCh,AH=FDh

Bitfields for trace destinations:
Bit(s)	Description	(Table 2957)
 0	storage (DS:DX -> trace stats record)
 1	display
 2	file (trace written to file OUTPUT.PC)
 3	printer

Format of APPC/PC Trace Statistics Record:
Offset	Size	Description	(Table 2958)
 00h	DWORD	pointer to storage trace buffer
 04h	WORD	max number of 80-byte records in trace
 06h	WORD	(high-order byte first!) current record number (must init to 0)
 08h	DWORD	(high-order byte first!) number of records written (init to 0)
 0Ch	DWORD	reserved
Note:	do not move record while trace is active
--------N-68FF-------------------------------
INT 68 - APPC/PC - SET PASSTHROUGH
	AH = FFh
	DS:DX -> passthrough exit routine
SeeAlso: AH=07h,INT 68"Novell"
--------b-69---------------------------------
INT 69 - Zenith AT BIOS - ???
Note:	called by INT 09 handler
--------h-69---------------------------------
INT 69 C - HP Vectra AT - IRQ17 - KEYBOARD OUTPUT-BUFFER-FULL SERVICE ROUTINE
SeeAlso: INT 09"IRQ1",INT 68"HP Vectra",INT 6A"HP Vectra"
--------N-690100-----------------------------
INT 69 - DECnet DOS CTERM - INSTALLATION CHECK
	AX = 0100h
Return: AL = FFh if present
SeeAlso: AX=010Fh
--------N-690101-----------------------------
INT 69 - DECnet DOS CTERM - SEND BYTE
	AX = 0101h
	BL = character
	DX = session handle
Return: AH >= 80h on error
SeeAlso: AX=0102h
--------N-690102-----------------------------
INT 69 - DECnet DOS CTERM - READ BYTE
	AX = 0102h
	DX = session handle
Return: AH >= 80h on error
	AH < 80h if successful
	    AL = character
SeeAlso: AX=0101h
--------N-690103-----------------------------
INT 69 - DECnet DOS CTERM - STATUS
	AX = 0103h
	DX = session handle
Return: AH status flags (see #2959)
	AL = reason code if DECnet error (see #2960)
SeeAlso: AX=0104h

Bitfields for DECnet DOS CTERM status flags:
Bit(s)	Description	(Table 2959)
 7	session has been aborted
 6	DECnet error
 1	trace data available
 0	receive data available

(Table 2960)
Values for reason code:
 00h	normal disconnect
 01h	unknown message from host
 02h	protocol violation from host
 03h	could not process the initiate message
 04h	error receiving message from host
 05h	error sending message to host
 06h	error checking for message from host
 07h	remote system does not support CTERM
 08h	remote system does not support correct protocol version
 09h	did not receive BIND message from host
 0Ah	could not send BIND message to host
 0Bh	no more sessions available
 0Ch	session does not exist
 0Dh	not enough memory to complete operation
 0Eh	connection has broken
Index:	error codes;DECnet DOS CTERM|DECnet DOS CTERM;error codes
--------N-690104-----------------------------
INT 69 - DECnet DOS CTERM - DECnet STATUS
	AX = 0104h
	DX = session handle
Return: AX = reason code (see #2960)
Note:	use this call when AX=0103h returns a DECnet error
SeeAlso: AX=0103h
--------N-690105-----------------------------
INT 69 - DECnet DOS CTERM - OPEN SESSION
	AX = 0105h
	DS:BX -> ASCIZ node name
	ES:DX -> buffer for session control block (see #2976 at INT 6A/AH=D0h)
Return: AX <= 0 on error
	AX > 0 session handle
SeeAlso: AX=0103h,AX=0106h,AX=010Ah
--------N-690106-----------------------------
INT 69 - DECnet DOS CTERM - CLOSE SESSION
	AX = 0106h
	DX = session handle
Return: AH = status
	    00h good close
	    other error code (see #2960)
SeeAlso: AX=0103h,AX=0105h
--------N-69010A-----------------------------
INT 69 - DECnet DOS CTERM - GET SESSION CONTROL BLOCK SIZE
	AX = 010Ah
Return: AX = length of session control block in bytes
SeeAlso: AX=0105h
--------N-69010B-----------------------------
INT 69 - DECnet DOS CTERM - GET DECnet SOCKET
	AX = 010Bh
	DX = session handle
Return: AX > 0	DECnet socket for the session
	AX = 0	no match for handle
--------N-69010F-----------------------------
INT 69 - DECnet DOS CTERM - DEINSTALL CTERM
	AX = 010Fh
Return: AH = status
	    00h successful uninstall
	    other error code (see #2960)
Note:	CTERM must have been the last TSR loaded in order to deinstall it
SeeAlso: AX=0100h
Index:	uninstall;DECnet DOS CTERM
--------N-690A-------------------------------
INT 69 - DECnet DOS 2.1+ - DATA LINK LAYER
	AH = 0Ah
	AL = function number (see #2961)
	ES:BX -> Datalink Communication Block (see #2963)
Return: AX = status (see #2962)
SeeAlso: INT 6D"DECnet"

(Table 2961)
Values for DECnet DOS Data Link Layer function:
 00h	initialize
 01h	open portal
 02h	close portal
 03h	enable multicast address
 04h	disable multicast address
 05h	transmit
 06h	request transmit buffer
 07h	deallocate transmit buffer
 08h	read channel status
 09h	read datalink portal list
 0Ah	read information about a datalink portal
 0Bh	read and/or clear counters
 0Ch	request to boot from a network server
 0Dh	enable Ethernet channel
 0Eh	disable Ethernet channel
 0Fh	start MOP/send a System ID message
 10h	stop MOP
 11h	get DECPARM
 12h	set DECPARM
 13h	external loopback

(Table 2962)
Values for DECnet DOS Data Link Layer status:
 00h	successful
 01h	hardware failed to initialize
 02h	channel state was not off (must be off to execute that command)
 03h	channel state is off (must be on to execute that command)
 04h	address not set
 05h	hardware missing
 06h	buffer too small
 07h	no more buffers available
 08h	no more resources available
 09h	promiscuous receiver active
 0Ah	non exclusive
 0Bh	unrecognized portal
 0Ch	protocol type in use
 0Dh	not a valid Multicast address
 0Eh	outstanding calls
 0Fh	hardware doesn't support receiving bad frames
 10h	none outstanding
 11h	no events
 12h	broken
 13h	buffer quota exceeded
 14h	already initialized
 15h	loopback failure
Index:	error codes;DECnet DOS|DECnet DOS;error codes

Format of Datalink Communication Block:
Offset	Size	Description	(Table 2963)
 00h	WORD	portal ID
 02h  6 BYTEs	source address
 08h  6 BYTEs	destination address
 0Eh	DWORD	buffer pointer
 12h	WORD	buffer length
 14h	WORD	operation
 16h	BYTE	pad flag (used on open)
		00h no pad
		01h pad
 17h	BYTE	mode flag (used on open)
		00h 802.3
		01h Ethernet
		02h promiscuous
 18h	DWORD	line status change function
 1Ch	DWORD	received data function
 20h	DWORD	transmitted data function
 24h	BYTE	maximum outstanding transmits/receives
 25h  2 BYTEs	protocol type
 27h	WORD	buffers lost
--------N-694001-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4001h
Return: CF clear
	AX = 0000h
	ES:SI -> ???
Range:	INT 60 to INT 7F, selected by configuration
Note:	the signature "SYSV" immediately before the interrupt handler serves
	  as the installation check
SeeAlso: AX=4002h
Index:	installation check;10NET SYSSVC
--------N-694002-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4002h
	???
Return: ???
Range:	INT 60 to INT 7F, selected by configuration
Note:	the signature "SYSV" immediately before the interrupt handler serves
	  as the installation check
--------N-694101-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4101h
Return: CF clear
	ES:SI -> ???
Range:	INT 60 to INT 7F, selected by configuration
SeeAlso: AX=4102h,AX=4103h,AX=4104h
--------N-694102-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4102h
	???
Return: ???
--------N-694103-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4103h
	???
Return: ???
--------N-694104-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4104h
	???
Return: ???
--------N-6942-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AH = 42h
	AL = function (01h-14h)
	???
Return: ???
Range:	INT 60 to INT 7F, selected by configuration
--------N-6943-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AH = 43h
	AL = function (01h-05h)
	???
Return: ???
--------N-6944-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AH = 44h
	AL = function (01h-03h)
	???
Return: ???
Range:	INT 60 to INT 7F, selected by configuration
--------N-6949-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - BUG
	AH = 49h
Note:	due to a fencepost error, this function branches to hyperspace
SeeAlso: AX=4001h,AH=FFh
--------G-696996-----------------------------
INT 69 - ISR.COM v1.00 - SPECIFY INTERRUPT HANDLER
	AX = 6996h
	DS:DX -> interrupt handler or 0000h:0000h to disable
Return: AX = 9669h
Program: ISR (Interrupt Service Reflector) is a TSR by Rich Bono which permits
	  a program to provide hardware interrupt handlers even while being
	  debugged with a debugger that swaps interrupt vectors during
	  debugging.
Note:	the interrupt vector which is to be reflected is set at installation
	  time and cannot be changed
--------N-69FF-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - SIGNAL SYSTEM ERROR
	AH = FFh
Return: never???
Desc:	displays "System Error" message and register dump, then halts system
Range:	INT 60 to INT 7F, selected by configuration
Notes:	the signature "SYSV" immediately before the interrupt handler serves
	  as the installation check
SeeAlso: AX=4001h,AH=49h
--------U-6A---------------------------------
INT 6A - OPTHELP.COM
Program: OPTHELP is an optionally-resident help system for SLR Systems's OPTASM
	  assembler
Range:	INT 60h to INT 7Fh, selected by configuration
--------N-6A---------------------------------
INT 6A - DECnet DOS - LOCAL AREA TRANSPORT PROGRAM - INSTALLATION CHECK
Note:	the installation check consists of testing for a signature area
	  immediately preceding the interrupt handler (see #2964)
SeeAlso: AH=01h/DH=FFh,INT 6B"DECnet",INT 6D"DECnet"
Index:	installation check;DECnet DOS Local Area Transport

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 2964)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "LAT")
--------h-6A---------------------------------
INT 6A C - HP Vectra AT - IRQ18 - RESERVED HARDWARE INTERRUPT
SeeAlso: INT 0A"IRQ2",INT 69"HP Vectra",INT 6B"HP Vectra"
--------N-6A0000-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - INSTALLATION CHECK
	AX = 0000h
Return: AX = 4357h ('CW')
Program: Super-TCP is a TCP/IP protocol stack by Frontier Technologies Corp.
Note:	an alternate installation check is to test for the ASCIZ signature
	  "FTC Super-TCP" three bytes past the interrupt handler
SeeAlso: AX=0001h,AX=0002h,AX=000Fh,AX=0010h,INT 21/AH=3Fh"BW-TCP"
SeeAlso: INT 61"FTP Software",INT 62/AH=00h"ETHDEV"
--------N-6A0001-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - ???
	AX = 0001h
	BH = function number
	    01h ???
		DS:SI -> ??? 24-byte record1 (see #2966)
		ES:DI -> buffer containing ???
	    02h ???
		DS:SI -> ??? 18-byte record2 (see #2967)
		ES:DI -> buffer containing ???
	    04h ???
		BL = subfunction
		    01h
			DS:SI -> ??? 28-byte record3 (see #2968)
			ES:DI -> buffer containing ???
		    02h
			DS:SI -> ??? 28-byte record3 (see #2968)
			ES:DI -> buffer containing ???
		    03h
			DS:SI -> ??? 28-byte record3 (see #2968)
		    else Return: AX = 0005h
	    05h ???
		DS:SI -> ??? 20-byte record4 (see #2969)
		ES:DI -> buffer containing ???
	    06h ???
		BL = subfunction
		    01h
			DS:SI -> ??? 40-byte record5 (see #2970)
		    02h
			DS:SI -> ??? 20-byte record6 (see #2971)
			ES:DI -> ???
		    03h
			DS:SI -> ??? 20-byte record6 (see #2971)
		    04h
			DS:SI -> ??? 46-byte record7 (see #2972)
		    else Return: AX = 0005h
	    11h ???
		DS:SI -> ??? 28-byte record8 (see #2973)
		ES:DI -> ???
Return: AX = function status (see #2965)
SeeAlso: AX=0000h

(Table 2965)
Values for Super-TCP function status:
 0000h	successful
 0005h	unsupported function
 000Ah	out of memory

Format of record1:
Offset	Size	Description	(Table 2966)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h 18 BYTEs	???

Format of record2:
Offset	Size	Description	(Table 2967)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h 12 BYTEs	???

Format of record3:
Offset	Size	Description	(Table 2968)
 00h  2 BYTEs	???
 02h	WORD	???
 04h	WORD	size of ES:DI buffer
 06h	WORD	???
 08h	WORD	operation number (for function 0401h)
 0Ah	DWORD	-> ???
 0Eh	WORD	(ret) ???
 10h 12 BYTEs	???

Format of record4:
Offset	Size	Description	(Table 2969)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h 14 BYTEs	???

Format of record5:
Offset	Size	Description	(Table 2970)
 00h	BYTE	operation??? (00h-07h)
 01h	BYTE	???
 02h	WORD	(ret) ???
 04h	DWORD	-> ???
 08h  4 BYTEs	???
 0Ch	DWORD	-> ??? or 0000h:0000h
 10h 16 BYTEs	???
 20h	DWORD	???
 24h  4 BYTEs	???

Format of record6:
Offset	Size	Description	(Table 2971)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h 14 BYTEs	???

Format of record7:
Offset	Size	Description	(Table 2972)
 00h	WORD	???
 02h	WORD	???
 04h	WORD	???
 06h 40 BYTEs	???

Format of record8:
Offset	Size	Description	(Table 2973)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h  6 BYTEs	???
 0Ch	WORD	(ret) ???
 0Eh	WORD	operation??? (01h-03h)
 10h 12 BYTEs	???
--------N-6A0002-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - ???
	AX = 0002h
	BX = ??? (zero/nonzero)
	CX = ??? identifier (see AX=0004h)
	DS:SI -> 40-byte buffer for ??? or 0000h:0000h
	ES:DI -> buffer for ??? or 0000h:0000h
Return: AX = 0000h (successful) ???
	BL = ???
	BH = ???
	CX = ???
	DX = ???
--------N-6A0003-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - GET ??? DATA AREA
	AX = 0003h
Return: CX:DX -> data area (see #2974)

Format of Super-TCP data area:
Offset	Size	Description	(Table 2974)
 00h  2 BYTEs	???
 02h	DWORD	original INT 6A vector
 06h  2 BYTEs	???
 08h 96 BYTEs	array of 16 6-byte ???
 68h	WORD	number of elements of above array in use
 6Ah	WORD	???
	???
--------N-6A0004-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - ALLOCATE ???
	AX = 0004h
	CX = size in ???
Return: AX = 0000h (successful)
	CX = DX = ???
SeeAlso: AX=0005h,AX=000Fh
--------N-6A0005-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - FREE/CLOSE ???
	AX = 0005h
	CX = ??? identifier (from AX=0004h)
Return: AX = status (0000h successful, FFFFh failed)
SeeAlso: AX=0004h,AX=000Fh
--------N-6A000F-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - FREE/CLOSE ALL ???
	AX = 000Fh
Return: AX = 0000h (successful)
SeeAlso: AX=0000h,AX=0004h,AX=0005h
--------N-6A0010-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - UNINSTALL
	AX = 0010h
Return: AX = status
	    0000h successful
	    0002h can't uninstall, interrupt vector hooked by another program
Program: Super-TCP is a TCP/IP protocol stack by Frontier Technologies Corp.
Note:	if AX is not one of the values listed here on entry, Super-TCP
	  returns AX=FFFEh
SeeAlso: AX=0000h
--------N-6A01--DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - SEND BYTE
	AH = 01h
	DH = FFh
	AL = character
	DL = handle
Return: AH >= 80h on error
SeeAlso: AH=02h
--------N-6A02--DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - READ BYTE
	AH = 02h
	DH = FFh
	DL = handle
Return: AH < 80h if successful
	    AL = character
	AH >= 80h on error
SeeAlso: AH=01h
--------N-6A03--DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - STATUS
	AH = 03h
	DH = FFh
	DL = handle
Return: AH = status flags (see #2975)

Bitfields for DECnet DOS LAT status flags:
Bit(s)	Description	(Table 2975)
 5	transmit buffer empty
 3	session in start state
 2	session not active
 1	unable to queue transmit data
 0	receive data available
--------N-6AD0--DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - OPEN SESSION
	AH = D0h
	DH = FFh
	AL = password flag
	    FFh no password
	    0Fh password at ES:DI
	ES:BX -> LAT session control block (see #2976)
	ES:DI -> 16-byte blank-padded password (optional)
Return: AH = 00h success
	    DL = handle
SeeAlso: AX=D000h

Format of LAT Session Control Block:
Offset	Size	Description	(Table 2976)
 00h 18 BYTEs	service name
 12h 18 BYTEs	node name (future use)
 24h 18 BYTEs	port name (future use)
 36h	DWORD	-> session stopped post routine
 3Ah	DWORD	-> service table overflow post routine
 3Eh	DWORD	-> transmit post routine
 42h	DWORD	-> receive post routine
 46h	WORD	session status
		04h circuit failure
		08h stop slot received
---LAT v???---
 48h	WORD	slot state (LAT driver use)
 4Ah	WORD	local credits (LAT driver use)
 4Ch	DWORD	-> VCB (LAT driver use)
 50h	WORD	backward slot (LAT driver use)
 52h	WORD	forward slot (LAT driver use)
 54h	WORD	remote slot ID (LAT driver use)
 56h	WORD	local slot ID (LAT driver use)
 58h	WORD	slot byte count (LAT driver use)
 5Ah	BYTE	remote credits (LAT driver use)
 5Bh 255 BYTEs	transmitted data slot
15Ah	BYTE	number of receive data slots (4 recommended)
15Bh	BYTE	number of occupied slots
15Ch	BYTE	index of next receive slot to use
15Dh	BYTE	index of current receive slot
15Eh	WORD	pointer to first received character
160h  N WORDs	pointers to receive slots (buffers); each is 259 bytes
     259N BYTEs	buffers
Note:	set post routines to 0000h:0000h if polled operation will be used
---LAT v4.1.17---
 48h	WORD	session state (LAT driver use)
 4Ah	BYTE	local credits (LAT driver use)
 4Bh	DWORD	-> VCB (LAT driver use)
 4Fh	WORD	backward slot (LAT driver use)
 51h	WORD	forward slot (LAT driver use)
 53h	BYTE	remote slot ID (LAT driver use)
 54h	BYTE	local slot ID (LAT driver use)
 55h	BYTE	slot byte count (LAT driver use)
 56h	BYTE	remote credits (LAT driver use)
 57h 255 BYTEs	transmitted data slot
156h	BYTE	number of receive data slots (4 recommended)
157h	BYTE	number of occupied slots
158h	BYTE	index of next receive slot to use
159h	BYTE	index of current receive slot
15Ah	WORD	pointer to first received character
15Ch  N WORDs	pointers to receive slots (buffers); each is 259 bytes
     259N BYTEs	buffers
Note:	set post routines to 0000h:0000h if polled operation will be used
--------N-6AD000DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - CLOSE SESSION
	AX = D000h
	DH = FFh
	DL = handle
Return: AX = status (see #2977)
SeeAlso: AH=D0h

(Table 2977)
Values for DECnet DOS LAT function status:
 0000h	successful
 0001h	no such session
 0002h	session not running, try again later
--------N-6AD100DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - SEND BREAK
	AX = D100h
	DH = FFh
	DL = handle
Return: AX = 0000h if successful
	AH bit 7 set if unable to send break
--------N-6AD300DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - RESET LAT COUNTERS
	AX = D300h
	DH = FFh
SeeAlso: AX=D400h
--------N-6AD400DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - COPY LAT COUNTERS
	AX = D400h
	DH = FFh
	CX = buffer size
	ES:BX -> buffer for LAT counters
Return: AX = status
	    0000h counters copied into buffer
	    FFFFh buffer too small
SeeAlso: AX=D300h
--------N-6AD500DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - GET NEXT LAT SERVICE NAME
	AX = D500h
	DH = FFh
	ES:BX -> 17-byte buffer for name
Return: AH = 00h if successful
	   ES:BX buffer filled
	AX = FFFFh if end of table or no name available
Notes:	use this function to get the names of the hosts on the network
	successive calls are necessary to get all names
SeeAlso: AX=D600h/DH=FFh
--------N-6AD600DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - LAT SERVICE TABLE RESET
	AX = D600h
	DH = FFh
Return: AX = number of service table entries
	BX = status
	    0000h service table has not overflowed
	    FFFFh service table has overflowed
SeeAlso: AX=D500h
--------N-6B---------------------------------
INT 6B - DECnet DOS - PORT DRIVER
Note:	the installation check consists of testing for a signature area
	  (see #2978) immediately preceding the interrupt handler
SeeAlso: INT 6A"DECnet",INT 6C"DECnet"
Index:	installation check;DECnet DOS Port Driver

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 2978)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "PDV")
--------v-6B---------------------------------
INT 6B - VIRUS - "Saddam" - ORIGINAL INT 21h VECTOR
SeeAlso: INT 21/AX=FFFFh,INT 61"VIRUS",INT 70"VIRUS"
--------h-6B---------------------------------
INT 6B C - HP Vectra AT - IRQ19 - RESERVED HARDWARE INTERRUPT
SeeAlso: INT 0B"IRQ3",INT 6A"HP Vectra",INT 6C"HP Vectra"
--------S-6B0000-----------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - BUFFERED WRITE
	AX = 0000h
	CX = length
	ES:BX -> buffer
Return: CX = number of bytes written
Program: NASI is Novell's NetWare Asynchronous Services Interface (purchased
	  from Network Products Corp, who call it NCSI) which runs on
	  workstations; NACS is the NetWare Asynchronous Communications
	  Services module which runs on servers
Notes:	the installation check consists of testing for the signature string
	  "NCSI" three bytes past the interrupt handler; see also AH=02h.
	  As of version 3.0, Novell's NASI can be distinguished from NPC's
	  NCSI by the presence of an 'A' immediately following the signature
	this function is also supported by TelAPI, NPC NCSI, and Connection
	  Manager CLIENT.EXE; for TelAPI, nonzero values in AL specify a
	  connection ID
	Connection Manager returns CF set/AL=FFh if called while an INT 6B
	  call is already in progress
SeeAlso: AX=0100h,AH=18h,INT 14/AH=19h,INT 14/AH=E3h
--------S-6B0100-----------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - BUFFERED READ
	AX = 0100h
	CX = length of buffer
	ES:BX -> buffer
Return: CX = number of bytes read
Note:	also supported by TelAPI and NPC NCSI; for TelAPI, nonzero values in
	  AL specify a connection ID
SeeAlso: AX=0000h,AH=19h,INT 14/AH=18h,INT 14/AH=E2h,INT 14/AX=FF02h
--------S-6B02-------------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - INSTALL CHECK
	AH = 02h
	AL nonzero
Return: AL = 00h if present and OK
Note:	this function is also supported by TelAPI and NPC NCSI
SeeAlso: AX=0700h
--------S-6B0600-----------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - CONTROL
	AX = 0600h
	CX = command
	    02h send break
	    04h disconnect
	    06h hold
Return: CF clear if successful
	    AL = 00h
	CF set on error
	    AX < 0
Note:	this function is also supported by TelAPI and NPC NCSI
--------S-6B0700-----------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - GET STATUS
	AX = 0700h
Return: CH <> 00h if connection active
Notes:	this function is also supported by TelAPI and NPC NCSI
	Novell TelAPI returns CX=FF01h and CF clear
SeeAlso: AH=02h,AH=10h
--------N-6B08-------------------------------
INT 6B - TelAPI - CHECK FOR BREAK SIGNAL
	AH = 08h
	AL = circuit number
Return: CF clear if no breaks
	    AL = 00h
	    CX = 0000h
	CF set if one or more breaks received
Note:	this function also clears ??? flag
SeeAlso: INT 14/AX=FF00h
--------S-6B10-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - GET STATUS
	AH = 10h
	AL = connection ID (Novell TELAPI.EXE)
	CX = ???
	ES:BX -> buffer for status (see #2979)
Return: CF clear if successful
	    CL = ???
	    CH = ???
	CF set on error
	???
Notes:	this function is also supported by TelAPI
	when shelled out to an external protocol from Novell NASI, the circuit
	  whose status indicates that it is connected is the currently active
	  circuit
SeeAlso: AX=0700h,AH=12h,AH=1Fh

Format of NASI status:
Offset	Size	Description	(Table 2979)
 00h	BYTE	number of allocated virtual circuits
 01h	BYTE	reserved
 02h  9 BYTEs	states of emulated circuits 0-8
		00h idle
		01h attached Telnet session, in command state
		02h attached Telnet session, connected with host
		03h-06h ??? (not returned by TelAPI)
Note:	this description is derived from the Novell TelAPI emulation of NASI
--------S-6B11--DX0001-----------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - ALLOCATE A VIRTUAL CIRCUIT
	AH = 11h
	DX = 0001h
	AL = 00h
	ES:BX -> service name string (8 characters, blank-padded)
Return: CF clear if successful
	    AL = virtual circuit number allocated (01h for Novell TELAPI.EXE)
	    CL = ??? (01h for Novell TELAPI.EXE)
	    CH = ??? (01h for Novell TELAPI.EXE)
	CF set on error
	    ???
Note:	this function is also supported by TelAPI
SeeAlso: AH=12h,AH=15h,AH=16h,AH=17h,AH=18h
--------S-6B12-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - VIRTUAL CIRCUIT STATUS
	AH = 12h
	AL = virtual circuit number (0-8)
Return: CF clear if successful
	    AL = virtual circuit number
	    CL = virtual circuit's state
		00h idle
		01h Telnet session, in command state
		02h Telnet session, connected to host
		03h-06h ??? (not returned by TelAPI)
	CF set on error
	    AL = error code
		E2h invalid virtual circuit number
		E4h specified virtual circuit not allocated
Note:	this function is also supported by TelAPI
SeeAlso: AH=10h,AH=15h,AH=1Ah,AH=1Bh,AH=1Fh
--------S-6B13-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE REQUEST/REPLY SERVICE NAME
	AH = 13h
	AL = virtual circuit number
	CL = direction (00h get, nonzero set)
	ES:BX -> buffer for/containing service name
Return: ???
Note:	this function is also supported by TelAPI
SeeAlso: AH=14h,AH=15h
--------S-6B14-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE SERVICE ADDRESS
	AH = 14h
	AL = virtual circuit number
	ES:BX -> buffer for/containing service address
Return: ???
Note:	this function is also supported by TelAPI, which only supports
	  retrieving the address
SeeAlso: AH=13h,AH=15h,AH=21h
--------S-6B15-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE VIRTUAL CIRCUIT CONFIG
	AH = 15h
	AL = virtual circuit number
	CL = direction (00h get, nonzero set)
	ES:BX -> buffer for/containing virtual circuit config (see #2980)
Return: ES:BX buffer filled
Note:	this function is also supported by TelAPI
SeeAlso: AH=13h"NCSI",AH=14h"NCSI"

Format of virtual circuit configuration:
Offset	Size	Description	(Table 2980)
 00h	WORD	buffer length
 02h	WORD	port ID
 04h	WORD	receive rate
 06h	WORD	receive word length
 08h	WORD	receive stop bits
 0Ah	WORD	receive parity
 0Ch	WORD	transmit rate
 0Eh	WORD	transmit word length
 10h	WORD	transmit stop bits
 12h	WORD	transmit parity
 14h	WORD	DTR
 16h	WORD	RTS
--------S-6B16-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - LOG AND/OR INITIALIZE VIRTUAL CIRCUIT
	AH = 16h
	AL = virtual circuit number
	CL = ??? switch (00h, ???)
Return: CF clear if successful
	    AL = virtual circuit number
	CF set on error
	    ???
Note:	this function is also supported by TelAPI, which always returns CF
	  clear and AL=00h
SeeAlso: AH=11h,AH=12h,AH=17h
--------S-6B17-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - DISCONNECT A VIRTUAL CIRCUIT
	AH = 17h
	AL = virtual circuit number
Return: CF clear if successful
	CF set on error
	???
Note:	this function is also supported by TelAPI, which always returns CF
	  clear and AL=00h
SeeAlso: AH=11h,AH=16h
--------S-6B18-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - WRITE DATA ON A VIRTUAL CIRCUIT
	AH = 18h
	AL = virtual circuit number
	CX = number of characters to send
	ES:BX -> buffer containing characters to be sent
Return: CF clear if successful
	CF set on error
	???
Note:	this function is also supported by TelAPI, which always returns CF
	  clear and AL=30h
SeeAlso: AX=0000h,AH=12h,AH=19h
--------S-6B19-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - READ DATA ON A VIRTUAL CIRCUIT
	AH = 19h
	AL = virtual circuit number
	CX = number of characters to read
	ES:BX -> buffer for received characters
Return: CX = 0000h if failed
	CX = nonzero (possibly number of characters received) if successful
Note:	this function is also supported by TelAPI
SeeAlso: AX=0100h,AH=12h,AH=18h
--------S-6B1A-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - RECEIVE STATUS
	AH = 1Ah
	???
Return: ???
SeeAlso: AH=12h,AH=1Bh
--------S-6B1B-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - TRANSMIT STATUS
	AH = 1Bh
	???
Return: ???
SeeAlso: AH=12h,AH=1Ah
--------S-6B1C-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - CLEAR RECEIVE BUFFER
	AH = 1Ch
	AL = circuit number
Return: nothing
SeeAlso: AH=1Dh"NCSI",AH=1Eh"NCSI"
--------S-6B1D-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - TRANSMIT BUFFER CONTROL
	AH = 1Dh
	???
Return: ???
SeeAlso: AH=1Ch,AH=1Eh
--------S-6B1E-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - ISSUE CONTROL REQUEST
	AH = 1Eh
	???
Return: ???
SeeAlso: AH=1Ch,AH=1Dh
--------S-6B1F-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - EXTERNAL STATUS
	AH = 1Fh
	???
Return: ???
SeeAlso: AH=10h,AH=12h
--------S-6B20-------------------------------
INT 6B - Connection Manager CLIENT.EXE - ???
	AH = 20h
	???
Return: ???
Program: Connection Manager by Softwarehouse Corp. permits the sharing of
	  serial ports over an IPX or NetBIOS-based network
Note:	CLIENT.EXE returns CF set/AL=F9h if AH is not 00h to 21h on entry
--------S-6B21-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - QUERY NAME SERVICE
	AH = 21h
	AL = virtual circuit number
	CL = ??? (00h or 01h)
	ES:BX -> buffer for service name structure (see #2981)
Return: CF clear if successful
	    ES:BX buffer filled
	CF set on error
Notes:	a program should call this function after allocating a virtual circuit
	  and check that the general name matches the requested service
	prior to version 3.0, Novell's NASI returned the first available port;
	  v3.0+ returns the first port found--check the returned status to
	  determine whether the port is available
SeeAlso: AH=14h"NCSI"

Format of NCSI service name structure:
Offset	Size	Description	(Table 2981)
 00h	WORD	buffer length
 02h  8 BYTEs	service name
 0Ah  8 BYTEs	general name
 12h  8 BYTEs	specific name
 1Ah  4 BYTEs	???
---Novell NASI v3.0+ ---
 1Eh	BYTE	port number
 1Fh	BYTE	port status
		00h idle (available)
		01h allocated (available)
		02h connected
		03h on hold
----------6B6B-------------------------------
INT 6B - Tandy SCHOOLMATE PLUS - API
	AH = 6Bh
	AL = E0h to FFh
Note:	details not yet available
----------6C---------------------------------
INT 6C - system resume vector (CONVERTIBLE)
----------6C---------------------------------
INT 6C - DOS 3.2 Realtime Clock update
--------N-6C---------------------------------
INT 6C - DECnet DOS network scheduler
Notes:	the installation check consists of testing for a signature area
	  immediately preceding the interrupt handler (see #2982)
	also supported by DEC Pathworks for DOS
SeeAlso: INT 6B"DECnet",INT 6D"DECnet",INT 6E"DECnet"
Index:	installation check;DECnet DOS scheduler

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 2982)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "SCH")
--------h-6C---------------------------------
INT 6C C - HP Vectra AT - IRQ20 - HP-HIL CONTROLLER INTERRUPT
SeeAlso: INT 0C"IRQ4",INT 6B"HP Vectra",INT 6D"HP Vectra"
--------V-6D---------------------------------
INT 6D - VIDEO - many VGA - VIDEO BIOS ENTRY POINT
Desc:	points at the original INT 10 entry point set up by the VGA BIOS
Notes:	used by IBM, ATI VGA Wonder, Paradise, Video7, and NCR, and many others
	the Diamond Stealth64 BIOS uses this vector to store the INT 42 vector
	   of the inactive video (see INT 10/AH=12h/BL=35h)
SeeAlso: INT 10/AH=00h,INT 10/AH=0Eh,INT 10/AH=12h/BL=10h
--------V-6D---------------------------------
INT 6D - Trident SVGA - VIDEO BIOS HANDLER
Note:	the BIOS INT 10 handler on various Trident VGA cards consists merely
	  of a call to INT 6D followed by an IRET.
--------N-6D---------------------------------
INT 6D - DECnet DOS (before 2.1) - DATA LINK LAYER PROGRAM
	AH = function
	???
Return: ???
Note:	the installation check consists of testing for a signature area
	  immediately preceding the interrupt handler (see #2983)
SeeAlso: INT 69/AH=0Ah,INT 6C"DECnet",INT 6E"DECnet"
Index:	installation check;DECnet DOS Data Link Layer

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 2983)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "DLL")
--------h-6D---------------------------------
INT 6D C - HP Vectra AT - IRQ21 - RESERVED HARDWARE INTERRUPT
SeeAlso: INT 0D"IRQ5",INT 6C"HP Vectra",INT 6E"HP Vectra"
--------V-6DBD60-----------------------------
INT 6D U - Matrox Multiple Monitor Support v1.0 - ???
	AX = BD60h
	DS:SI -> buffer containing ??? (see #2984)
	???
Return: AX = 00BDh if function executed
	   ???:SI -> 22-byte buffer (inside TSR) filled with ??? (see #2984)
	AX unchanged if function disabled
Note:	this function is a NOP if AX=BD6Fh/BL=01h was called
SeeAlso: AX=BD61h,AX=BD6Fh,AX=BDFFh

Format of Matrox ??? buffer:
Offset	Size	Description	(Table 2984)
 00h  4 BYTEs	???
 04h	WORD	video mode width in pixels
 06h	WORD	video mode height in pixels
 08h	BYTE	???
 09h	BYTE	???
 0Ah	BYTE	???
 0Bh	BYTE	flags
		bit 1: ???
		bit 4: ??? (corresponds to bit 14 for AX=BD61h)
		bit 5: ??? (corresponds to bit 15 for AX=BD61h)
 0Ch	DWORD	-> ??? buffer
 10h	WORD	???
		bit 4: ??? (corresponds to bit 14 for AX=BD61h)
		bit 5: ??? (corresponds to bit 15 for AX=BD61h)
 12h  4 BYTEs	???
SeeAlso: #2985
--------V-6DBD61-----------------------------
INT 6D U - Matrox Multiple Monitor Support v1.0 - GET VIDEO MODE INFORMATION
	AX = BD61h
	BX = width in pixels (bits 13-0)
	    bit 14: ???
	    bit 15: ???
	CX = height in pixels
Return: AL = BDh if function supported
	    AH = status
		00h successful
		01h failed (resolution/flags not supported)
	    CX:BX -> video mode data structure (see #2985)
		  (first word is FFFFh if unsupported resolution)
	    EAX high word cleared
SeeAlso: AX=BD60h,AX=BD6Fh,AX=BDFFh

Format of Matrox video mode information (VCE structure):
Offset	Size	Description	(Table 2985)
 00h	WORD	width in pixels
 02h	WORD	height in pixels
 04h	WORD	???
 06h	DWORD	dot clock frequency
 0Ah 25 BYTEs	???
SeeAlso: #2984
--------V-6DBD6F-----------------------------
INT 6D U - Matrox Multiple Monitor Support v1.0 - INSTALLATION CHECK
	AX = BD6Fh
	BL = subfunction
	    00h installation check
	    01h disable TSR
	    02h enable TSR (see AX=BD60h)
Return: AX = 00BDh if installed
SeeAlso: AX=BD60h,AX=BD61h,AX=BDFFh
--------V-6DBDFF-----------------------------
INT 6D U - Matrox Multiple Monitor Support v1.0 - UNHOOK INTERRUPT (UNINSTALL)
	AX = BDFFh
Return: AX = 00BDh if supported
Note:	this function revectors INT 6D without checking that it points at the
	  TSR, and does not release the memory occupied by the TSR
SeeAlso: AX=BD60h,AX=BD61h,AX=BD6Fh
--------N-6E---------------------------------
INT 6E - DECnet DOS - DECnet NETWORK PROCESS API
Notes:	this is the main DECnet DOS access, and is described in Digital manual
	  AA-EB46B-TV ("DECnet-DOS Programmer's Reference Manual")
	there is a signature/data area immediately prior to the interrupt
	  handler which may be used as an installation check (see #2986)
Index:	installation check;DECnet DOS

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 2986)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "DNP")
--------h-6E---------------------------------
INT 6E C - HP Vectra AT - IRQ22 - RESERVED HARDWARE INTERRUPT
SeeAlso: INT 0E"IRQ6",INT 6D"HP Vectra",INT 6F/AH=00h"HP Vectra"
--------N-6F---------------------------------
INT 6F - Novell NetWare - PCOX API (3270 PC terminal interface)
	AX = function
	    0000h enter terminal mode
		Return: AX = status
			    0000h no action requested
			    0001h screen save
	    0001h reset interface and set configuration parameters
		DX = bitfields
		    bits 2-0: model number
		    bits 4-3: I/O address
		    bits 6-5: DMA channel
		Return: nothing
	    0002h set display parameters
		DX = bitfields
		    bits 1-0: OIA mode
		    bits 4-2: monitor support
		Return: nothing
	    0003h read status
		Return: AX = status word (see #2987)
	    0004h read cursor position
		Return: AX = cursor position
	    0005h get character from device buffer
		DX = cursor position
		Return: AH = type (00h data, 01h attribute)
			AL = data or attribute character
	    0006h send character
		DH = type (00h ASCII, 01h extended code)
		DL = ASCII character or extended code
		Return: nothing
	    0007h set timeout
		DX = timeout in seconds
		Return: nothing
	    0008h wait for location to be modified
		DX = cursor position
		Return: AX = status (0000h modified, nonzero timeout)
	    0009h NOP
	    000Ah restore display
		Return: nothing
	    000Bh update device buffer
		Return: AX = cursor positoin
	    000Ch write string to add information area
		DS:DX -> string
		Return: nothing
	    000Dh maintenance operations
		DX = maintenance operation code
		Return: AX = operation status
	    000Eh get control program version
		Return: AH = release number (major version)
			AL = level number (minor version)
	    000Fh get microcode version
		Return: AH = release number (major version)
			AL = level number (minor version)
	    0010h save or display graphics
		BX = length of data buffer
		CX = subfunction request code
		DS:DX -> data buffer
		Return: AX = return code
			CX = length of PIF data
	    0011h perform structured field operation
		CX = request number
		DS:DX -> parameter list
		Return: AX = status word (see #2987)
			CX = error number
	    0012h set cursor position for direct write buffer
		DX = new cursor position
		Return: AX = status word (see #2987)
	    0013h write direct to buffer
		DL = character to be written
		DH = translation option
		Return: AX = status word (see #2987)
	    0014h write direct to buffer without echo
		DL = character to be written
		DH = translation option
		Return: AX = status word (see #2987)
	    0015h set direct write string length
		DX = string value
		Return: nothing
	    0016h write string direct to buffer
		DS:DX -> string
		Return: AX = status word (see #2987)
	    0017h write string direct to buffer, untranslated
		DS:DX -> string
		Return: AX = status word (see #2987)
	    0018h get direct-write cursor position
		Return: AX = cursor position
	    0019h convert row/column to cursor position
		DH = display row (1-43)
		DL = display column (1-132)
		Return: AX = cursor position
	    001Ah convert cursor position to row/column
		DX = cursor position
		Return: AH = display row
			AL = display column
	    001Bh find next field
		DX = initial cursor position
		Return: AX = field cursor position
	    001Ch find previous field
		DX = initial cursor position
		Return: AX = field cursor position
	    001Dh find next unprotected field
		DX = initial cursor position
		Return: AX = field cursor position
	    001Eh find previous unprotected field
		DX = initial cursor position
		Return: AX = field cursor position
	    001Fh find next protected field
		DX = initial cursor position
		Return: AX = field cursor position
	    0020h find previous protected field
		DX = initial cursor position
		Return: AX = field cursor position
	    0021h masked search forward
		DH = mask
		DL = search pattern
		Return: AX = cursor position or 0000h
	    0022h masked search backward
		DH = mask
		DL = search pattern
		Return: AX = cursor position or 0FFFh
	    0023h find field length
		DX = cursor position
		Return: AX = field length
	    0024h read field
		DS:DX -> buffer for field contents
		Return: AX = status word (see #2987)
	    0025h read screen
		DS:DX -> buffer for screen contents
		Return: AX = status word (see #2987)
	    0026h read buffer untranslated
		DX = cursor position
		Return: AX = buffer code
			CX:BX -> 3278/79 device buffer image
	    0027h enable/disable keyboard
		DL = new state of keyboard breaks (00h enabled, 01h disabled)
		Return: nothing
	    0028h select host session
		DL = session short name
		Return: AX = session information
	    0029h retrieve host session name
		AX = short name (DFT) or 0000h (not available, CUT mode)
	    002Ah get current device buffer size
		Return: AX = device buffer size
			CX = segment of EAB
	    002Bh arm modified location trigger
		DX = cursor position
		Return: AX = status (0000h not available, 0001h successful)

Bitfields for PCOX status word:
Bit(s)	Description	(Table 2987)
 0,1	cursor type
 2	cursor inhibited
 3	display inhibited
 4	feature step inhibited
 5	480-character format code
 6,7	unused
 8-10	model number (2-5)
 11	unit has been reset by controller (cleared after status returned)
 12	buffer has been written into (cleared after status returned)
 13	alarm has been sounded (cleared after status returned)
 14-15	monitor type (01 mono, 10 color, 11 hybrid)
--------N-6F00-------------------------------
INT 6F - 10NET - LOGIN
	AH = 00h
	DS:DX -> login record (see #2988)
Return: CL = security level
	AX = status (see #2989)
SeeAlso: AH=01h,AH=80h,INT 21/AX=4402h"10MEMMGR"

Format of 10NET login record:
Offset	Size	Description	(Table 2988)
 00h  8 BYTEs	user name
 08h  8 BYTEs	password
 10h 12 BYTEs	name of SuperStation

(Table 2989)
Values for 10NET status:
 0000h	successful
 01FFh	"RTO_NERR" transmit interrupt lost (time out on response)
 02FFh	"NET_NERR" network (hardware) error
 03FFh	"PAS_NERR" invalid password
 04FFh	"LRN_NERR" local resource not available
 05FFh	"SRN_NERR" server resource not available
 06FFh	"LNM_NERR" already logged in under different name
 07FFh	"LSF_NERR" login security failure (node)
 08FFh	"NLI_NERR" not logged in
 09FFh	"DIVZ_NERR" position calc error
 0AFFh	"NT1_NERR" receive subfunction not = send subfunction (i.e. read,write)
 0BFFh	"RFNC_NERR" request function not in range
 0CFFh	"NSFH_NERR" no more server file handle entries left
 0DFFh	"NFTAB_NERR" no more shared file table entries left
 0EFFh	"NUFH_NERR" no more user file handle entries left
 0FFFh	"CHAT_NERR" chat permit not on
 10FFh	"NSRV_NERR" not a server on request
 11FFh	"NOBD_NERR" no transporter board error
 12FFh	"STO_NERR" time out on send
 13FFh	"INF_NERR" item not found (spool item not on queue)
 14FFh	"DACS_NERR" DOS access incompatible
 15FFh	"RLOCK_NERR" record already locked
 16FFh	"IVP_NERR" invalid parameter
 17FFh	"RLTO_NERR" record lock time out error
 18FFh	"CSPL_NERR" currently spooling to named device
 19FFh	"DRP_NERR" dropped receive message (throttle)
 1AFFh	"SOPV_NERR" open sharing violation
 1BFFh	"NTUF_NERR" no more tuf entries left
 1CFFh	"NOWN_NERR" not file owner on open
 1DFFh	"RSEC_NERR" read security not passed
 1EFFh	"WSEC_NERR" write security not passed
 1FFFh	"GSEC_NERR" group security not passed
 20FFh	"SEC1_NERR" security file failure
 21FFh	"ACT1_NERR" activity file failure
 22FFh	"SPL1_NERR" spool control file failure
 23FFh	"NMT_NERR" device not mounted (spooling)
 24FFh	"RSPL_NERR" spool file has not been terminated
 25FFh	"DNSH_NERR" device not mounted or is not being shared
 26FFh	"DUP_NERR" duplicate node ID
 27FFh	"FNF_NERR" file not found error
 28FFh	"NMF_NERR" no more files
 29FFh	"UN_NERR" unknown internal system error
 2AFFh	"QCP_NERR" print queue is full or corrupted
 2BFFh	"IFNC_NERR" invalid function
 2CFFh	"IVH_NERR" invalid handle
 2DFFh	"TOF_NERR" too many files opened
 2EFFh	"PNF_NERR" path not found
 2FFFh	"SACT_NERR" named file is active
---10NET v5.0+ ---
 30FFh	"NAK_NERR" received NAK on send (destination out of buffers)
 31FFh	"RENT_NERR" reentrancy in driver F_SEND
 32FFh	"RECV_NERR" driver could not be put in receive mode
 33FFh	"NRLT_NERR" no more RLTAB entries left
 34FFh	"DIAL_NERR" function requires an unsupported dialect
 35FFh	"IVD_NERR" invalid device
 36FFh	"NALV_NERR" netname access level violated
 37FFh	"NPIDNF_NERR" network path not found
 38FFh	"SP_NERR" server is paused
 39FFh	"TMNM_NERR" too many remote user names
 3AFFh	"DUPD_NERR" duplicate network device
 3BFFh	"DIU_NERR" shared device in use, can't delete
 3CFFh	"NNWD_NERR" network name was deleted
 3DFFh	"NPFS_NERR" not enough space for print file
 3EFFh	"NNNF_NERR" network name not found (can't find the call name)
 3FFFh	"NB_NERR" network busy
 40FFh	"NDNLE_NERR" network device no longer exists
 41FFh	"NBCLE_NERR" NetBIOS command limit exceeded
 42FFh	"FINT24_NERR" Fail on INT 24h
 43FFh	"PEXP_NERR" password expired
 44FFh	"NPUP_NERR" new password error
 45FFh	"MAXS_NERR" maximum allowed disk space exceeded
 46FFh	"TDOW_NERR" time-of-day/day-of-week error
SeeAlso: #3016
Index:	error codes;10Net|10Net;error codes
--------b-6F00-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_ISR" (internal) - RESPOND TO LOGICAL ISR
	AH = 00h
	BP = ID for driver (see #2990)
	DH = data type (see #2991)
	DL = physical device driver's index (driver ID / 6)
	BX,CX = data
	ES:0000h -> physical device's Describe Record (see #2998)
	---keypress event data---
	    BH = keyboard state (only if bit 5 of DH set) (see #2992)
	    BL = scancode (if bit 4 of DH clear)
	    CX = number of scancodes in list (if bit 4 of DH set)
	    ES:SI -> scancode list (if bit 4 of DH set)
	---motion event data---
	    BX = new X position (abs device) or X increment (relative device)
	    CX = new Y position (abs device) or Y increment (relative device)
	---button event data
	    BL = button information
		bits 15-8 reserved
		bit 7: button state (0 = down, 1 = up)
		bits 6-0: button number (0-7)
	    BH = reserved
Return: AH = status (see #2993)
	BP,DS destroyed
	---if device is keyboard translator---
	    BL = translated scancode
	    BH = new keyboard state (if DH bit 5 set) (see #2992)
	    DH = new scancode type (see #2991)
Notes:	INT 6F corresponds to IRQ23 on the original HP Vectra AT, which is
	  unavailable because of its use as a BIOS extension software interrupt
	the INT 6F handler consists of an instruction to load DS with the
	  driver's data segment followed by an indexed far jump using BP to
	  select the destination vector; since the interrupt handler is
	  located immediately following the dispatch table, the HP_VECTOR_TABLE
	  may be found by looking at offset 0000h in the INT 6F segment, and
	  its size is equal to the offset of the interrupt handler
	each entry in the HP_VECTOR table consists of a DWORD for the driver's
	  entry point address and a WORD for the driver's data segment
	this function is not user-callable, as it is a response to a physical
	  event, and assumes that the caller has already handled the physical
	  interrupt and updated the Describe Record (see #2998) to reflect
	  the event
SeeAlso: INT 6C"HP Vectra",INT 6F/AX=0200h"HP Vectra"

(Table 2990)
Values for HP Vectra EX-BIOS driver ID:
 0000h	V_SCOPY (null driver, but DS value points at system copyright string)
 0006h	V_DOLITTLE (null driver)
 000Ch	V_PNULL (null driver)
 0012h	V_SYSTEM
 0018h	reserved
 001Eh	V_S8259
 0024h	reserved
 002Ah	V_SINPUT
 0030h	reserved
 0036h	V_QWERTY (keyboard translator)
 003Ch	V_SOFTKEY (keyboard translator)
 0042h	V_FUNCTION (keyboard translator)
 0048h	V_NUMPAD (keyboard translator)
 004Eh	V_CCP (keyboard translator)
 0054h	V_SVIDEO
 005Ah	V_STRACK
 0060h	V_EVENT_TOUCH
 0066h	V_EVENT_TABLET
 006Ch	V_EVENT_POINTER
 0072h	reserved
 0078h	reserved
 007Eh	reserved
 0084h	reserved
 008Ah	V_CCPCUR (keyboard translator)
 0090h	V_RAW (keyboard translator)
 0096h	V_CCPNUM (keyboard translator)
 009Ch	V_OFF (keyboard translator)
 00A2h	V_CCPGID (translator: cursor control pad keys to GID data)
 00A8h	V_SKEY2FKEY (keyboard translator)
 00AEh	V_8041
 00B4h	V_PGID_CCP
 00BAh	C_LTABLET
 00C0h	V_LPOINTER (pointing device: mouse, etc.)
 00C6h	V_LTOUCH (touch screen)
 00CCh	V_LHPMOUSE
 00D2h	???
 ...
 0102h	???
 0108h	V_LNULL
 010Eh	reserved
 0114h	V_HPHIL
 011Ah-01C2h reserved
 016Eh	V_SCANDOOR (scancode management chip driver) (ES/QS/RS only)
 01C8h-0228h available

(Table 2991)
Values for HP Vectra EX-BIOS ISR data type:
 00h	reserved "T_KC_R0"
 01h	reserved "T_KC_R1"
 02h	ASCII data
 03h	reserved "T_KC_R3"
 04h	HP150 keyboard (ITF) scancode
 05h	reserved "T_KC_R5"
 06h	device-definable type
 07h	HP Vectra keyboard set
 08h	IBM AT scancode set
 09h	button data
 0Ah	IBM PC scancode set
 0Bh	Softkey keypad (F1-F8)
 0Ch	function key keypad (F1-F10)
 0Dh	HP Cursor Control Pad keypad
 0Eh	Qwerty keypad
 0Fh	Numeric keypad
 1xh	bit 4 set: string of CX scancode of type 0xh at ES:SI
 2xh	bit 5 set: BH contains current keyboard state
 40h	signed 8-bit relative data
 41h	signed 16-bit relative data
 42h	unsigned 8-bit absolute data
 43h	unsigned 16-bit absolute data
 45h	specially-formed data (80x25) generated by V_LTOUCH
 46h	specially-formed data (640x200) generated by V_LTABLET
 47h	specially-formed data (640x200) generated by V_LPOINTER

Bitfields for HP Vectra EX-BIOS keyboard state:
Bit(s)	Description	(Table 2992)
 0	Alt pressed
 1	Left Shift pressed
 2	Right Shift pressed
 3	Ctrl pressed
 4	CapsLock active
 5	NumLock active
 6	Right unlabeled key pressed (some international keyboards)
 7	Left unlabeled key pressed (some international keyboards)
SeeAlso: #0481

(Table 2993)
Values for HP Vectra EX-BIOS status:
 00h	successful
 02h	unsupported function
 04h	not serviced
 06h	done (no further processing should be performed on the ISR event)
 F2h	device is out of paper
 F4h	device is offline
 F6h	no more space for more drivers
 F8h	driver is busy
 FAh	bad parameter
 FEh	operation failed
Note:	status codes are always even; negative values (>= 80h) indicate errors
	  while positive values indicate exceptional conditions

Format of HP EX-BIOS driver header data:
Offset	Size	Description	(Table 2994)
 00h	WORD	driver attributes (see #2995)
 02h	WORD	string index of driver's name
 04h	WORD	driver's default logical device vector (see #2990)
 06h	WORD	driver's parent class (bitset) (see #2996)
 08h	WORD	driver's child class (bitset)
 0Ah	WORD	driver's parent vector
 0Ch	WORD	driver's child vector
 0Eh	BYTE	major subaddress
 0Fh	BYTE	minor subaddress
Notes:	this structure is located at offset 0 in the driver's data segment,
	  which in turn may be read from the HP_VECTOR_TABLE (refer to note in
	  main entry)
	only the first WORD is required, and everything from offset 6 onward
	  is only required if the device wishes to perform device mapping
SeeAlso: #2997,#2998

Bitfields for HP EX-BIOS driver header attributes:
Bit(s)	Description	(Table 2995)
 15	this is a complete driver header
 14	"ATR_DEVCFG" reserved
 13	driver can be mapped with the parent vector at offset 0Ah
 12	driver can be mapped with the child vector at offset 0Ch
 11-9	driver type
	000 reserved vector
	001 free vector
	010 EX-BIOS service
	011 logical driver (mapped from parent to child)
	100 mappable driver (cannot be last in driver chain)
	101 mappable driver that is last in driver chain
	110 input driver (mappable)
	111 reserved
 8	"ATR_STRING" reserved
 7	call SF_START whenever driver is remapped
 6-5	addressing requirements
	00 no subaddresses required
	01 requires major address be stored at offset 0Eh
	10 requires minor address be stored at offset 0Fh
	11 required major,minor, and mid addresses (minor in low nybble of
	      offset 0Fh, mid address in high nybble of 0Fh)
 4	driver can be shared between several parent drivers
 3	driver can be shared between several child drivers
 2	this driver header is in ROM
 1	"ATR_YIELD" reserved
 0	reserved
SeeAlso: #2994,#2996

Bitfields for HP EX-BIOS driver class:
Bit(s)	Description	(Table 2996)
 15	maps F1 to F8 softkeys
 14	keyboard
 13	cursor pad
 12	console device
 11	serial output device (may be capable of limited input)
 10	"CL_COMM" reserved
 9	interfaces multiple resources transparent to operating system
 8	serial output device filter (can be mapped between logical and physical
	  driver to perform translations)
 7	addressed block device
 6	priority boot device
 5	logical graphics input device
 4	physical graphics input device (can map to child of another driver)
 3	"CL_GID" can map to an event
 2	physical touch device
 1	reserved
 0	class extension bit
Note:	special values: FFFFh maps to all other devices (V_PNULL), and 0000h
	  maps to no other driver
SeeAlso: #2994

Format of HP EX-BIOS global data area:
Offset	Size	Description	(Table 2997)
 00h 20 BYTEs	reserved
 14h	BYTE	sound driver status
 15h	BYTE	number of pending key clicks (max 4) (see AH=34h/BP=0012h)
 16h	BYTE	current tick duration scaling factor
 17h	BYTE	current key click volume
 18h	WORD	current beep period (10 us increments) (see AH=3Ch/BP=0012h)
 1Ah	WORD	current beep duration (10 us increments)
 1Ch	BYTE	number of pending beep functions (max 4) (see AH=3Ah/BP=0012h)
 1Dh	BYTE	reserved
 1Eh	WORD	next unused string index number
 20h	...	reserved
SeeAlso: #2994

Format of HP EX-BIOS Driver Describe Record:
Offset	Size	Description	(Table 2998)
 00h 16 BYTEs	EX-BIOS driver header data (see #2994)
 10h	BYTE	device GID type
		bits 7-4: device type
		bits 3-0: physical device link address
 11h	BYTE	physical device ID (see #3000)
 12h	WORD	logical device status bits (see #2999)
 14h	BYTE	physical device vector number (driver ID / 6)
 15h	BYTE	maximum number of axes reported (0-2)
 16h	BYTE	device class
		bits 7-4: current class
		bits 3-0: default class
 17h	BYTE	number of buttons/prompts
		bits 7-4: number of prompts
		bits 3-0: number of buttons
 18h	BYTE	reserved
 19h	BYTE	(physical devices only) maximum output burst length
 1Ah	BYTE	(physical devices only) number of write registers
 1Bh	BYTE	(physical devices only) number of read registers
 1Ch	BYTE	button transition flags (bit 0 = button0, etc.)
 1Dh	BYTE	current button states (bit 0 = button0, etc.)
 1Eh	WORD	device resolution
 20h	WORD	maximum x-axis count
 22h	WORD	maximum y-axis count
 24h	WORD	X position data for absolute devices
 26h	WORD	Y position data for absolute devices
 28h	WORD	X delta for relative devices
 2Ah	WORD	Y delta for relative devices
 2Ch	WORD	(logical devices only) X-axis scaling accumulator
		(fraction of one logical unit)
 2Eh	WORD	(logical devices only) Y-axis scaling accumulator
		(fraction of one logical unit)

Bitfields for HP logical device status flags:
Bit(s)	Description	(Table 2999)
 15-5	reserved
 4	event enabled
 3	tracking enabled
 2	clipping enabled
 1	button error occurred
 0	interrupt in progress
SeeAlso: #2998

(Table 3000)
Values for HP-HIL device ID:
 00h-02h reserved
 03h	Swiss-French keyboard
 04h-06h reserved
 07h	Canadian-English keyboard
 08h-0Ah reserved
 0Bh	Italian keyboard
 0Ch	reserved
 0Dh	Dutch keyboard
 0Eh	Swedish keyboard
 0Fh	German keyboard
 10h-12h reserved
 13h	Spanish keyboard
 14h	reserved
 15h	Belgian (Flemish) keyboard
 16h	Finnish keyboard
 17h	UK keyboard
 18h	French-Canadian keyboard
 19h	Swiss-German keyboard
 1Ah	Nerwegian keyboard
 1Bh	Frensh keyboard
 1Ch	Danish keyboard
 1Dh	Katakana keyboard
 1Eh	Latin American-Spanish keyboard
 1Fh	US-American keyboard
 20h-2Bh reserved
 2Ch-2Fh tone generator
 30h-3Fh reserved
 40h-5Bh reserved (character entry)
 5Ch-5Fh barcode reader
 60h-67h reserved (relative positions)
 68h-6Bh mouse
 6Ch-6Fh trackball
 70h-7Fh reserved (relative positions)
 80h-87h reserved (absolute positions)
 88h-8Bh touchpad
 8Ch-8Fh touch screen
 90h-97h graphics tablet
 98h-9Fh reserved (absolute positions)
 A0h-BFh compressed keyboard (91-93 keys)
 C0h-DFh extended keyboard (107-109 keys)
 E0h-FFh standard keyboard (85-87 keys)
--------N-6F01-------------------------------
INT 6F - 10NET - LOGOFF
	AH = 01h
	DS:DX -> superstation ID or nulls (12 bytes)
Return: CX = number of files closed
	AX = status (see also #2989)
	    08FFh superstation ID not already logged in
SeeAlso: AH=00h"10NET",AH=81h
--------N-6F02-------------------------------
INT 6F - 10NET - STATUS OF NODE
	AH = 02h
	DS:DX -> 512-byte status record (see #3002)
Return: CF clear if successful
	CF set on error
	    AX = error code (see #2989)
SeeAlso: INT 21/AX=5E01h"10NET"

(Table 3001)
Values for 10NET station type:
 00h	workstation
 01h	superstation
 02h	gateway station
 03h	gateway active
 04h	logged into multiple superstations
 05h	reserved

Format of 10NET node status record:
Offset	Size	Description	(Table 3002)
 00h  8 BYTEs	user name (0 if none)
 08h	BYTE	station type (see #3001)
 09h 24 BYTEs	list of superstations logged into more than one superstation
 21h 12 BYTEs	node ID
 2Dh	WORD	message count for this station (send for user node, receive for
		  superstations)
---for superstations only---
 2Fh	WORD	drives allocated (bit 0=A:, bit 1=B:,...)
 31h	BYTE	user service flags (see #3003)
 32h	BYTE	printers allocated (bit 0=LPT1,...)
 33h	BYTE	number of unprinted spool files
 34h	BYTE	number of opened files
 35h	BYTE	number of logged on nodes
 36h	BYTE	primary drive (1=A:)
 37h	BYTE	reserved
 38h  N BYTEs	list of logged on node IDs (each 12 bytes, max 37 IDs)
1F4h  3 BYTEs	time: sec/min/hrs
1F7h  3 BYTEs	date: day/mon/year-1980

Bitfields for 10NET user service flags:
Bit(s)	Description	(Table 3003)
 7	gate
 6	print permit on
 4	SUBMIT is on
 3	mail waiting for node
 2	calendar waiting for you
 1	news waiting for you
 0	mail waiting for you
--------b-6F0200-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_INIT" - START INITIALIZING DRIVER
	AX = 0200h
	BP = driver ID (see #2990)
	BX = "last-used DS" value from HP global data area (see #2997)
Return: AH = status (see #2993)
	BX = new "last-used DS" value
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0202h,AH=0Ch"F_INS_FIXOWNDS"
--------b-6F0202-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_START" - COMPLETE DRIVER INITIALIZ.
	AX = 0202h
	BP = driver ID (see #2990)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0204h"HP Vectra"
--------W-6F0204-----------------------------
INT 6F C - MS Windows 3.0 - DOS APPLICATION SWITCH HOOK
	AX = 0204h
Return: AX = status
	    0000h switch is allowed
	    other switch not allowed
Note:	intercepting this call will allow a DOS application to ensure that
	  Windows will not switch away from it.
--------b-6F0204-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_REPORT_STATE" - GET DRIVER STATE
	AX = 0204h
	BP = driver ID (see #2990)
Return: AH = status (see #2993)
	DX = device state from Logical Describe Record (see #2998,#3004)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0206h"HP Vectra"

Bitfields for HP Vectra V_HPHIL driver state:
Bit(s)	Description	(Table 3004)
 0	link configuration in progress
 1	reserved
 2	no devices attached
 3	general failure
 4,5	reserved
 6	HP-HIL driver open
 7	reserved
 8	link has been reconfigured
 9	error during output request
 10	reserved
 11	output request complete
 12	timeout
 13-15	reserved
--------b-6F0206-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_VERSION_DESC" - GET DRIVER VERSION
	AX = 0206h
	BP = driver ID (see #2990)
Return: AH = status (see #2993)
	BX = driver release date code
	    (BL = BCD years since 1960, BH = BCD week number within year)
	CX = length of version string
	ES:DI -> version string
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0204h"HP Vectra",AX=0208h
--------b-6F0208-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_DEF_ATTR" - RESET TO DEFAULT ATTR
	AX = 0208h
	BP = driver ID (see #2990)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=020Ah,AX=020Ch
--------b-6F020A-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_GET_ATTR" - GET CURRENT ATTRIBUTES
	AX = 020Ah
	BP = driver ID (see #2990)
Return: AH = status (see #2993)
	BX,CX = current attributes
	BP,DS destroyed
	---for V_LTOUCH, V_LPOINTER---
	    BX = logical width
	    CX = logical height
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Ch
--------b-6F020C-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_SET_ATTR" - SET DEVICE ATTRIBUTES
	AX = 020Ch
	BP = driver ID (see #2990)
	BX,CX = new attributes
	---for V_LTOUCH, V_LPOINTER---
	    BX = new logical width
	    CX = new logical height
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Ah
--------b-6F020E-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_OPEN" - RESERVE DRIVER FOR ACCESS
	AX = 020Eh
	BP = driver ID (see #2990) for V_HPHIL, others
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	place device in open state, which allows output to the device
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=0210h
--------b-6F0210-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_CLOSE" - RELEASE DRIVER
	AX = 0210h
	BP = driver ID (see #2990) for V_HPHIL, others
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	place device in closed state, which disallows output to the device
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Eh
--------b-6F0212-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_TIMEOUT" - REPORT REQUESTED TIMEOUT
	AX = 0212h
	BP = driver ID (see #2990)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	report to driver that a previously-requested timeout interval has
	  expired
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Eh,AX=0214h,AX=0216h
--------b-6F0214-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_INTERVAL" - 60 HZ INTERVAL EXPIRED
	AX = 0214h
	BP = driver ID (see #2990)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	report to driver that a previously-requested 60 Hz interval has
	  expired
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Eh,AX=0212h,AX=0216h
--------b-6F0216-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_TEST" - PERFORM HARDWARE TEST
	AX = 0216h
	BP = driver ID (see #2990)
Return: AH = status (see #2993)
	BP,DS destroyed
	---on failure---
	CX = length of reason string
	ES:DI -> string describing error
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Eh,AX=0212h,AX=0214h
--------N-6F03-------------------------------
INT 6F - 10NET - GET ADDRESS OF CONFIGURATION TABLE
	AH = 03h
	DS:DI -> node ID (optional)
Return: ES:BX -> configuration table (see #3005)
SeeAlso: AH=13h,INT 21/AX=5E01h"10NET"

Format of 10NET configuration table:
Offset	Size	Description	(Table 3005)
-41	WORD	local device table address
-39	WORD	extended network error mapping table address
-37	WORD	shared device table address
-35	WORD	mounted device table address
-33	BYTE	receive buffer counter
-32	BYTE	collect buffer counter
-31	WORD	TUF address
-29	BYTE	enable flag
-28	BYTE	FCB keep flag
-27	WORD	reserved
---up to here, 10NET v3.3---
-25	WORD	count of dropped Send6F
-23	WORD	buffer start address
-21	WORD	comm driver base address
-19	WORD	send/receive retry count
-17	BYTE	number of 550ms loops before timeout
-16	WORD	UFH address
-14	WORD	CDIR address
-12	WORD	LTAB address
-10	WORD	SFH address
-8	WORD	FTAB address
-6	WORD	RLTAB address
-4	WORD	SMI address
-2	WORD	NTAB address
 00h	WORD	address of first CT_DRV
 02h	BYTE	number of DRV entries
 03h  8 BYTEs	login name
 0Bh 12 BYTEs	node ID (blank-padded)
 17h  6 BYTEs	node address
 1Dh	BYTE	flag
 1Eh	BYTE	CT_CFLG (chat permit)
		bit 1: sound bell
		bit 0: CHAT permit
 1Fh	BYTE	CT_PSFLG (see #3006)
 20h	BYTE	in 10Net flag
 21h	WORD	receive message count
 23h	WORD	send message count
 25h	WORD	retry count
 27h	WORD	failed count
 29h	WORD	driver errors
 2Bh	WORD	dropped responses/CHATs
 2Dh  9 BYTEs	LIST ID/NTAB address (3 entries--LPT1-3)
 36h  6 BYTEs	AUX ID/NTAB address (2 entries--COM1-2)
 3Ch	BYTE	active CB channel
 3Dh	BYTE	received 6F messages on queue
 3Eh  9 BYTEs	activity counters for channels 1-9
---beyond here, 10NET v3.3---
 47h	BYTE	bit 0: RS232 gate
		bit 1: Send6F gate (user set)
 48h	DWORD	pointer into gate (user set)
 4Ch	DWORD	pointer into 10Net send
 50h  N WORDs	addresses of timer blocks

Bitfields for CT_PSFLG:
Bit(s)	Description	(Table 3006)
 5	PRINT permit
 4	KB initiated
 3	CHAT called FOXPTRM
 2	SUBMIT active
 1	SUBMIT received
 0	SUBMIT permit
--------N-6F04-------------------------------
INT 6F - 10NET - SEND
	AH = 04h
	DS:BX -> send record (see #3007)
	DS:DX -> data (max 1024 bytes)
Return: CF clear if successful
	CF set on error
	    AX = error code (see #2989)
SeeAlso: AH=05h"10NET",AH=09h"10NET",AH=0Ah"10NET"

Format of 10NET send record:
Offset	Size	Description	(Table 3007)
 00h 12 BYTEs	receiving node's ID
		if first byte has high-order bit set, message is directed to
		  the CT_RGATE vector at the receiver
		if second byte is 00h, first byte is taken as a CB
		  channel number and delivered to all nodes on same channel
 0Ch	WORD	 length of data at DX
--------b-6F04--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_BASEHPVT" - GET HP_VECTOR_TABLE ADDRESS
	AH = 04h
	BP = 0012h (driver ID for V_SYSTEM)
Return: AH = status (see #2993)
	ES = segment of HP_VECTOR_TABLE (see also AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=06h"F_INS_XCHGFIX",AH=08h"F_INS_XCHGRSVD"
--------b-6F04--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_TRACK_INIT" - RESET TRACKING DRIVER TO DEFAULTS
	AH = 04h
	BP = 005Ah (driver ID for V_STRACK)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=06h"F_TRACK_ON",AH=08h"F_TRACK_OFF"
SeeAlso: AH=0Ah"F_DEF_MASKS",AH=0Ch"F_SET_LIMITS_X"
--------b-6F0400-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_LOCK" - RESERVE SUB-ADDRESSES
	AX = 0400h
	BP = driver ID (see #2990)
	DH,DL = major,minor address (optional)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	reserve specified sub-addresses on an already-allocated driver for
	  exclusive access
Note:	this function is documented as present but unsupported in the drivers
	  V_LTABLET, V_LPOINTER, and V_LTOUCH
SeeAlso: AX=0200h"HP Vectra",AX=0402h"SF_UNLOCK"
--------b-6F0400BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_ENABLE_SVC" - UNMASK 8041 SVC INT
	AX = 0400h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0402h"SF_DISABLE_SVC",AX=0404h"SF_ENABLE_KBD"
SeeAlso: AX=0408h"SF_ENABLE_HPHIL"
--------b-6F0400BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DEF_LINKS" - SET DEFAULT PARENTS
	AX = 0400h
	BP = 002Ah (driver ID for V_SINPUT)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	set the parent vectors in the physical device driver headers to their
	  system defaults
SeeAlso: AH=00h"HP Vectra",AX=0402h/BP=002Ah,AX=0404h/BP=002Ah
SeeAlso: AH=06h"F_INQUIRE"
--------b-6F0400BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_ID_HP" - INSTALLATION CHECK
	AX = 0400h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #2993)
	BX = 4850h ('BP')
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0402h/BP=0054h,AX=0404h/BP=0054h,AX=0406h/BP=0054h
SeeAlso: AX=0408h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0400BP00CC-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_MOUSE_COM" - INIT INT 33 HANDLER
	AX = 0400h
	BP = 00CCh (driver ID for V_LHPMOUSE)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0402h/BP=00CCh
--------b-6F0402-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_UNLOCK" - RELEASE SUB-ADDRESSES
	AX = 0402h
	BP = driver ID (see #2990)
	DH,DL = major,minor address (optional)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	release specified sub-addresses from exclusive access
Note:	this function is documented as present but unsupported in the drivers
	  V_LTABLET, V_LPOINTER, and VLTOUCH
SeeAlso: AX=0200h"HP Vectra",AX=0400h"SF_LOCK"
--------b-6F0402BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DISABLE_SVC" - MASK 8041 SVC INT
	AX = 0402h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=001Eh,AX=0406h/BP=001Eh
SeeAlso: AX=040Ah/BP=001Eh
--------b-6F0402BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_GET_LINKS" - GET DRIVER LINK FIELDS
	AX = 0402h
	BP = 002Ah (driver ID for V_SINPUT)
	ES:SI -> buffer for link table (see #3008)
Return: AH = status (see #2993)
	ES:SI buffer filled
	BP,DS destroyed
Desc:	get the parent and child vectors for the seven supported physical
	  device drivers
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_DEF_LINKS",AX=0404h"SF_SET_LINKS"
SeeAlso: AH=06h"F_INQUIRE"

Format of HP Vectra EX-BIOS driver link table:
Offset	Size	Description	(Table 3008)
 00h	BYTE	vector number of HP-HIL device #1's child
 01h	BYTE	vector number of HP-HIL device #1's parent
	...
 0Ch	BYTE	vector number of HP-HIL device #7's child
 0Dh	BYTE	vector number of HP-HIL device #7's parent
--------b-6F0402BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_GET_INFO" - GET DISPLAY INFO
	AX = 0402h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #2993)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0404h/BP=0054h,AX=0406h/BP=0054h
SeeAlso: AX=0408h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0402BP00CC-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_MOUSE_COM" - FORCE INT 33 INIT
	AX = 0402h
	BP = 00CCh (driver ID for V_LHPMOUSE)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	set up INT 33 even if no mouse is installed
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=00CCh
--------b-6F0404-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_TRACK_ON" - GRAPHICS CURSOR ON
	AX = 0404h
	BP = driver ID (see #2990) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	enables graphics cursor tracking of the logical device's movement
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_LOCK",AX=0406h"SF_TRACK_OFF"
--------b-6F0404BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_ENABLE_KBD" - UNMASK 8041 OBF INT
	AX = 0404h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_ENABLE_SVC",AX=0406h"SF_DISABLE_KBD"
SeeAlso: AX=0408h"SF_ENABLE_HPHIL"
--------b-6F0404BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_SET_LINKS" - SET DRIVER LINK FIELDS
	AX = 0404h
	BP = 002Ah (driver ID for V_SINPUT)
	ES:SI -> buffer containing link table (see #3008)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	specify the parent and child vectors for the seven supported physical
	  device drivers
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_DEF_LINKS",AX=0402h"SF_GET_LINKS"
SeeAlso: AH=06h"F_INQUIRE"
--------b-6F0404BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_SET_INFO" - SET EXT-CTRL INFO
	AX = 0404h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #2993)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0402h/BP=0054h,AX=0406h/BP=0054h
SeeAlso: AX=0408h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0406-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_TRACK_OFF" - GRAPHICS CURSOR OFF
	AX = 0406h
	BP = driver ID (see #2990) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	disables graphics cursor tracking of the logical device's movement
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_LOCK",AX=0404h"SF_TRACK_ON"
SeeAlso: AX=0408h"SF_CREATE_EVENT"
--------b-6F0406BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DISABLE_KBD" - MASK 8041 OBF INT
	AX = 0406h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0402h"SF_DISABLE_SVC",AX=0404h"SF_ENABLE_KBD"
SeeAlso: AX=040Ah"SF_DISABLE_HPHIL"
--------b-6F0406BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_MOD_INFO" - SET EXT-CTRL REG
	AX = 0406h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #2993)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0402h/BP=0054h,AX=0404h/BP=0054h
SeeAlso: AX=0408h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0406BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_RECONFIGURE" - RECONFIG LINK
	AX = 0406h
	BP = 0114h (driver ID for V_HPHIL)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=020Eh,AX=0408h"SF_CRV_WR_PROMPTS"
SeeAlso: AX=0410h"SF_CRV_SELF_TEST"
--------b-6F0408-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CREATE_EVENT" - SET EVENT HANDLER
	AX = 0408h
	BP = driver ID (see #2990) for V_LPOINTER, V_LTOUCH, V_LTABLET
	ES:SI -> new event handler (see AH=00h"HP Vectra")
	DX = new handler's DS
Return: AH = status (see #2993)
	ES:SI -> old event handler
	DX = old handler's DS
	BP,DS destroyed
Desc:	specify routine to be called on logical device events
Note:	when events occur, the event handler is called with the same registers
	  as the "F_ISR" function on AH=00h"HP Vectra"
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_LOCK",AX=0406h"SF_TRACK_OFF"
SeeAlso: AX=040Ah"SF_EVENT_ON",AX=040Ch"SF_EVENT_OFF",AH=06h"F_SAMPLE"
--------b-6F0408BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_ENABLE_HPHIL" - UNMASK HP-HIL INT
	AX = 0408h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=001Eh,AX=0404h/BP=001Eh
SeeAlso: AX=040Ah/BP=001Eh
--------b-6F0408BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_GET_RES" - GET VIDMODE RESOLUTN
	AX = 0408h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #2993)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0402h/BP=0054h,AX=0404h/BP=0054h
SeeAlso: AX=0406h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0408BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_WR_PROMPTS" - WRITE PROMPT
	AX = 0408h
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	DL = prompt number
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=020Eh,AX=0406h/BP=0114h,AX=040Ah/BP=0114h

Bitfields for HP Vectra V_HPHIL device address indicator:
Bit(s)	Description	(Table 3009)
 15-14	reserved
 13	address in DH is valid (must be set, clear is reserved)
 12	valid value in DL
 11-0	reserved
--------b-6F040A-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_EVENT_ON" - ENABLE EVENT HANDLER
	AX = 040Ah
	BP = driver ID (see #2990) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0408h"SF_CREATE_EVENT",AX=040Ch"SF_EVENT_OFF"
SeeAlso: AX=040Eh"SF_CLIPPING_ON"
--------b-6F040ABP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DISABLE_HPHIL" - MASK HP-HIL INT
	AX = 040Ah
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0402h/BP=001Eh,AX=0406h/BP=001Eh
SeeAlso: AX=0408h/BP=001Eh
--------b-6F040ABP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_SET_MODE" - SET VIDEO MODE
	AX = 040Ah
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #2993)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0402h/BP=0054h,AX=0404h/BP=0054h
SeeAlso: AX=0406h/BP=0054h,AX=0408h/BP=0054h
--------b-6F040ABP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CREATE_INTR" - CREATE INTERVAL ENTRY
	AX = 040Ah
	BP = 00AEh (driver ID for V_8041)
	BH = vector number of driver to be called regularly (vector addr / 6)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	add a driver to the list (max eight) of drivers which will be called
	  by the HP's 8041 at 60 Hz
Note:	the newly added entry will not be called until enabled with
	  AX=040Eh/BP=00AEh
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F040ABP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_WR_ACK" - ACKNOWLEDGE DEVICE
	AX = 040Ah
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	DL = acknowledge number (specific if 01h-07h, generic otherwise)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0406h/BP=0114h,AX=040Ch/BP=0114h
--------b-6F040C-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_EVENT_OFF" - DISABLE EVENT HANDLER
	AX = 040Ch
	BP = driver ID (see #2990) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0408h"SF_CREATE_EVENT",AX=040Ah"SF_EVENT_ON"
--------b-6F040CBP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DELET_INTR" - DELETE INTERVAL ENTRY
	AX = 040Ch
	BP = 00AEh (driver ID for V_8041)
	BH = vector number of driver to be removed (vector addr / 6)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	remove a driver to the list (max eight) of drivers which will be called
	  by the HP's 8041 at 60 Hz
SeeAlso: AH=00h"HP Vectra",AX=040Ah/BP=00AEh,AX=0410h/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F040CBP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_REPEAT" - SET KEY REPEAT RATE
	AX = 040Ch
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	DL = repeat rate (00h = 30 Hz, 01h = 60 Hz)
Return: AH = status (see #2993)
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=040Ah/BP=0114h,AX=040Eh/BP=0114h
--------b-6F040E-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CLIPPING_ON" - ENABLE CLIPPING
	AX = 040Eh
	BP = driver ID (see #2990) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	causes the physical device's motion to be clipped to prevent overflow
	  or underflow of the logical position
SeeAlso: AH=00h"HP Vectra",AX=040Ah"SF_EVENT_ON",AX=0410h"SF_CLIPPING_OFF"
--------b-6F040EBP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_ENABL_INTR" - START INTERRUPT SRVICE
	AX = 040Eh
	BP = 00AEh (driver ID for V_8041)
	BH = vector number of driver to be called regularly (vector addr / 6)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	enable 60 Hz calling of a driver previously added to the list of
	  drivers to be called by the HP's 8041
SeeAlso: AH=00h"HP Vectra",AX=040Ah/BP=00AEh,AX=0410h/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F040EBP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_DISABLE_REPEAT" - KEY REPT OFF
	AX = 040Eh
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
Return: AH = status (see #2993)
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=0114h,AX=0410h/BP=0114h
SeeAlso: AX=0416h/BP=0114h
--------b-6F0410-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CLIPPING_OFF" - DISABLE CLIPPING
	AX = 0410h
	BP = driver ID (see #2990) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	disables clipping of the physical device's motion, which may cause
	  overflow or underflow of the logical position
SeeAlso: AH=00h"HP Vectra",AX=040Ah"SF_EVENT_ON",AX=040Eh"SF_CLIPPING_ON"
--------b-6F0410BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DISBL_INTR" - END INTERRUPT SERVICE
	AX = 0410h
	BP = 00AEh (driver ID for V_8041)
	BH = vector number of driver (vector addr / 6)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	disable 60 Hz interval calls to the specified driver
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0410BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_SELF_TEST" - PERFORM SELFTEST
	AX = 0410h
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	ES:SI -> buffer for result
Return: AH = status (see #2993)
	CX = number of bytes in buffer
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=0114h,AX=0412h/BP=0114h
--------b-6F0412BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_SET_RAMSW" - SET RAM SWITCH IN 8041
	AX = 0412h
	BP = 00AEh (driver ID for V_8041)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	sets a flag in the 8041 indicating that a second 256K bank of RAM
	  on the motherboard is enabled
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0414h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0412BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_REPORT_STATUS" - GET DEVSTATUS
	AX = 0412h
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	ES:SI -> 15-byte buffer for status
Return: AH = status (see #2993)
	CX = number of bytes returned in buffer
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=0410h/BP=0114h,AX=0414h/BP=0114h
--------b-6F0414BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CLR_RAMSW" - CLEAR 8041 RAM SWITCH
	AX = 0414h
	BP = 00AEh (driver ID for V_8041)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	clears a flag in the 8041 indicating that a second 256K bank of RAM
	  on the motherboard is enabled, causing the second bank to be disabled
Note:	this function should normally never be called
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0418h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0414BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_REPORT_NAME" - GET DEV NAME
	AX = 0414h
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	ES:SI -> 15-byte buffer for name
Return: AH = status (see #2993)
	CX = number of bytes returned in buffer
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=0412h/BP=0114h
--------b-6F0416BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_SET_CRTSW" - SET CRT TO MULTIMODE
	AX = 0416h
	BP = 00AEh (driver ID for V_8041)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	sets a flag in the 8041 indicating that the primary display is the
	  Multimode graphics adapter (default)
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0418h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0416BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_KEYBOARD_REPEAT" - SET TYPEMATIC
	AX = 0416h
	BP = 0114h (driver ID for V_HPHIL)
	BH = what to set (00h typematic rate, 01h delay, 02h both)
	BL = flag (00h = non-CCP keypad, 01h = Cursor Control Pad only)
	DL = rate
	    bits 7-4: delay value
	    bits 3-0: typematic rate
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=040Eh/BP=0114h,AX=0418h/BP=0114h
--------b-6F0418BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CLR_CRTSW" - SET CRT TO MONOCHROME
	AX = 0418h
	BP = 00AEh (driver ID for V_8041)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	clears a flag in the 8041, indicating that the primary display is the
	  monochrome adapter
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0414h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0418BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_KEYBOARD_LED" - SET KEYBOARD LEDS
	AX = 0418h
	BP = 0114h (driver ID for V_HPHIL)
	BL = new LED states
	    bit 0: scroll lock
	    bit 1: NumLock
	    bit 2: CapsLock
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=040Eh/BP=0114h,AX=0416h/BP=0114h
--------b-6F041ABP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_PASS_THRU" - SEND DATA BYTE TO 8041
	AX = 041Ah
	BP = 00AEh (driver ID for V_8041)
	BL = byte to send to 8041
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=040Ah/BP=00AEh,AX=040Eh/BP=00AEh
--------N-6F05-------------------------------
INT 6F - 10NET - RECEIVE
	AH = 05h
	CX = number of seconds before timeout
	DS:DX -> receive buffer (see #3010)
Return: CF clear if successful
	    AH = FEh if dequeued message is a CB message
	CF set on error
	    AX = error code (see #2989)
SeeAlso: AH=04h"10NET"

Format of 10NET receive buffer:
Offset	Size	Description	(Table 3010)
 00h 12 BYTEs	sending node's ID
 0Ch	WORD	length of message
 0Eh  N BYTEs	message (maximum 1024 bytes)
--------b-6F06-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_BYTE" - WRITE A BYTE OF DATA TO DEVICE
	AH = 06h
	BP = driver ID (see #2990) for V_HPHIL, others
	AL = value to output
	---if driver is V_HPHIL---
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	DL = HP-HIL device register (00h-7Fh)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	output a byte to a specific HP-HIL device register
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=04h"HP Vectra",AH=08h"F_GET_BYTE",AH=0Ah"F_PUT_BUFFER"
--------b-6F06-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_SAMPLE" - POLL CURRENT ABSOLUTE POSITION
	AH = 06h
	BP = driver ID (see #2990) for V_LTOUCH, V_LPOINTER, V_LTABLET, etc.
Return: AH = status (see #2993)
	BX = current logical X position
	CX = current logical Y position
	DL = button transitions (bit N = button N state has changed)
	DH = current button states (bit N = current button N state)
	ES:0000h -> logical device's Describe Record (see #2998)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=040Ah"SF_EVENT_ON",AX=040Eh"SF_CLIPPING_ON"
--------b-6F06--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_XCHGFIX" - EXCH VALUES WITH FIXED VECTOR
	AH = 06h
	BP = 0012h (driver ID for V_SYSTEM)
	BX = vector address
	DX = new value for DS
	ES:DI -> new CS:IP entry point
Return: AH = status (see #2993)
	DX = old value for DS
	ES:DI -> old CS:IP entry point
	BP,DS destroyed
Desc:	replace an existing EX-BIOS driver at a fixed HPVT location without
	  initialization
SeeAlso: AH=00h"HP Vectra",AH=04h"F_INS_BASEHPVT",AH=08h"F_INS_XCHGRSVD"
SeeAlso: AH=0Ah"F_INS_XCHGFREE",AH=0Ch"F_INS_FIXOWNDS"
--------b-6F06--BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INQUIRE" - GET DRIVER PHYSICAL DESCRIBE RECORD
	AH = 06h
	BP = 002Ah (driver ID for V_SINPUT)
	AL = HP-HIL physical device number (01h-07h)
Return: AH = status (see #2993)
	ES:SI -> physical describe record for driver
	BP,DS destroyed
Note:	the returned physical describe record must not be modified
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=002Ah,AH=08h/BP=002Ah,AH=0Ah/BP=002Ah
SeeAlso: AH=0Ch/BP=002Ah
--------b-6F06--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_TRACK_ON" - ENABLE CURSOR TRACKING
	AH = 06h
	BP = 005Ah (driver ID for V_STRACK)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h"F_TRACK_INIT",AH=08h"F_TRACK_OFF"
SeeAlso: AH=0Ah"F_DEF_MASKS",AH=0Ch"F_SET_LIMITS_X"
--------N-6F07-------------------------------
INT 6F - 10NET - LOCK HANDLE
	AH = 07h
	BX = file handle
	CX:DX = starting offset in file
	SI = record length
Return: CF clear if successful
	CF set on error
	    AX = error code (see also AH=00h)
		0002h file not found
SeeAlso: AH=08h"10NET",AH=0Fh,INT 21/AH=5Ch
--------N-6F08-------------------------------
INT 6F - 10NET - UNLOCK HANDLE
	AH = 08h
	BX = file handle
	AL = mode
	    00h unlock all
	    01h unlock record at CX:DX
Return: CF clear if successful
	CF set on error
	    AX = error code (see also AH=00h)
		0002h file not found
SeeAlso: AH=07h,AH=0Fh,INT 21/AH=5Ch
--------b-6F08-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_GET_BYTE" - READ A BYTE OF DATA FROM DEVICE
	AH = 08h
	BP = driver ID (see #2990) for V_HPHIL (0114h), others
	---if device is V_HPHIL---
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	DL = HP-HIL device register (00h-7Fh)
Return: AH = status (see #2993)
	AL = value read from device
	BP,DS destroyed
Desc:	generic read-byte function; for driver V_HPHIL, retrieves the value
	  of a specific HP-HIL device register
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=06h"F_PUT_BYTE",AH=0Ah"F_PUT_BUFFER",AH=0Ch"F_GET_BUFFER"
--------b-6F08--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_XCHGRSVD" - EXCH VALUES WITH RESRVED VECTOR
	AH = 08h
	BP = 0012h (driver ID for V_SYSTEM)
	DX = new value for DS
	ES:DI -> new CS:IP entry point
Return: AH = status (00h,F6h) (see also #2993)
	    00h successful
		BX = vector address used
		DX = old value for DS
		ES:DI -> old CS:IP entry point
	BP,DS destroyed
Desc:	exchange the supplied entry point and DS with the values in the next
	  reserved entry in the HP_VECTOR_TABLE
Note:	returns AH=F6h if no more reserved vectors are available
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h,AH=0Ah/BP=0012h
SeeAlso: AH=0Ch/BP=0012h
--------b-6F08--BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INQUIRE_ALL" - GET DRIVER STATUS TABLE
	AH = 08h
	BP = 002Ah (driver ID for V_SINPUT)
	ES:SI -> buffer for device status table (see #3011)
Return: AH = status (see #2993)
	ES:SI buffer filled
	BP,DS destroyed
Note:	the returned physical describe record must not be modified
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=002Ah,AH=06h/BP=002Ah,AH=0Ah/BP=002Ah
SeeAlso: AH=0Ch/BP=002Ah

Format of HP Vectra HP-HIL physical device status table:
Offset	Size	Description	(Table 3011)
 00h	BYTE	status for HP-HIL device #1
		bit 0: device present
		bits 7-2 reserved
 01h	BYTE	device ID for HP-HIL device #1
	...
 0Ch	BYTE	status for HP-HIL device #7
 0Dh	BYTE	device ID for HP-HIL device #7
--------b-6F08--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_TRACK_OFF" - DISABLE CURSOR TRACKING
	AH = 08h
	BP = 005Ah (driver ID for V_STRACK)
Return: AH = status (see #2993)
	BP,DS destroyed
Note:	also removes the graphics cursor sprite from the screen
SeeAlso: AH=00h"HP Vectra",AH=04h"F_TRACK_INIT",AH=06h"F_TRACK_ON"
SeeAlso: AH=0Ah"F_DEF_MASKS",AH=0Ch"F_SET_LIMITS_X"
--------N-6F09-------------------------------
INT 6F - 10NET - SUBMIT
	AH = 09h
	DS:BX -> submit record (see #3012)
SeeAlso: AH=04h"10NET"

Format of 10NET submit record:
Offset	Size	Description	(Table 3012)
 00h 12 BYTEs	destination node ID (must be logged in)
 0Ch	WORD	length+2 of following 'command line' text
 0Eh  N BYTEs	command line text (<=100 bytes), system adds CR
--------N-6F0A-------------------------------
INT 6F - 10NET - CHAT
	AH = 0Ah
	DS:BX -> control parameters (see #3013)
	DS:DX -> chat message (see #3014)
SeeAlso: AH=04h"10NET",AH=8Ah

Format of 10NET chat control parameters:
Offset	Size	Description	(Table 3013)
 00h  8 BYTEs	sender ID, defaults to node's userID if nulls
 08h  8 BYTEs	destination user ID, 'EVERYONE' may be used
 10h 12 BYTEs	destination node ID

Format of 10NET chat message:
Offset	Size	Description	(Table 3014)
 00h	WORD	length+2 of following text
 02h  N BYTEs	text, max 101 bytes
--------b-6F0A-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_BUFFER" - WRITE A BUFFER TO DEVICE
	AH = 0Ah
	BP = driver ID (see #2990) for V_HPHIL (0114h), others
	CX = number of bytes to write
	ES:DI -> buffer containing data
	---if driver is V_HPHIL---
	BX = device address indicator (see #3009)
	DH = HP HIL device major address
	DL = HP-HIL device register (00h-7Fh)
Return: AH = status (see #2993)
	CX = number of unwritten bytes left in buffer
	BP,DS destroyed
SeeAlso: AH=06h"F_PUT_BYTE",AH=0Ah"F_PUT_BLOCK",AH=0Ch"F_GET_BUFFER"
SeeAlso: AH=0Eh"F_PUT_WORD"
--------b-6F0A-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_BLOCK" - WRITE BLOCKS TO DEVICE
	AH = 0Ah
	BP = driver ID (see #2990) for block device
	DH = device major number
	DL = device minor number
	ES:DI -> command block (see #3015)
Return: AH = status (see #2993)
	BX = operation status
	BP,DS destroyed
SeeAlso: AH=06h"F_PUT_BYTE",AH=0Ah"F_PUT_BUFFER",AH=0Ch"F_GET_BUFFER"
SeeAlso: AH=0Eh"F_PUT_WORD"

Format of HP Vectra F_PUT_BLOCK/F_GET_BLOCK command block:
Offset	Size	Description	(Table 3015)
 00h	DWORD	data transfer address
 04h	WORD	number of blocks
 06h	DWORD	block address (some devices only use low word)
--------b-6F0A--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_XCHGFREE" - EXCH VALUES WITH FREE VECTOR
	AH = 0Ah
	BP = 0012h (driver ID for V_SYSTEM)
	DX = new value for DS
	ES:DI -> new CS:IP entry point
Return: AH = status (00h,F6h) (see also #2993)
	    00h successful
		BX = vector address used
		DX = old value for DS
		ES:DI -> old CS:IP entry point
	BP,DS destroyed
Desc:	exchange the supplied entry point and DS with the values in the next
	  free entry in the HP_VECTOR_TABLE
Note:	returns AH=F6h if no more reserved vectors are available
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h,AH=08h/BP=0012h
SeeAlso: AH=0Ch/BP=0012h
--------b-6F0A--BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INQUIRE_FIRST" - GET PHYSICAL DRIVER VECTOR
	AH = 0Ah
	BP = 002Ah (driver ID for V_SINPUT)
Return: AH = status (see #2993)
	BX = vector address for first HP-HIL device
	BP,DS destroyed
Note:	all seven HP-HIL devices use consecutive vectors in the
	  HP_VECTOR_TABLE
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=002Ah,AH=06h/BP=002Ah,AH=08h/BP=002Ah
SeeAlso: AH=0Ch/BP=002Ah
--------b-6F0A--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_DEF_MASKS" - DEFINE GRAPHICS CURSOR MASKS
	AH = 0Ah
	BP = 005Ah (driver ID for V_STRACK)
	BH = width of save area in bytes
	BL = hot-spot X coordinate
	CH = height in scan lines
	CL = hot-spot Y coordinate
	ES:SI -> sprite mask (screen mask followed by XOR sprite mask)
Return: AH = status (see #2993)
	BP,DS destroyed
Note:	the save area is one byte wider than the actual sprite mask; the total
	  size of the sprite is at most 144 bytes
SeeAlso: AH=00h"HP Vectra",AH=04h"F_TRACK_INIT",AH=08h"F_TRACK_OFF"
SeeAlso: AH=0Ch"F_SET_LIMITS_X",AH=10h"F_PUT_SPRITE",AH=12h"F_REMOVE_SPRITE"
--------N-6F0B-------------------------------
INT 6F - 10NET - LOCK SEMAPHORE, RETURN IMMEDIATELY
	AH = 0Bh
	AL = drive number or 0
	ES:SI = Ethernet address or 0
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status (see #3016)
Note:	same as INT 60/AH=12h
SeeAlso: AH=0Ch"10NET",INT 60/AH=12h

(Table 3016)
Values for 10NET status:
 00h	successful
 01h	semaphore currently locked
 02h	server not responding
 03h	invalid semaphore name
 04h	semaphore list is full
 05h	invalid drive ID
 06h	invalid Ethernet address
 07h	not logged in
 08h	write to network failed
 09h	semaphore already logged in this CPU
SeeAlso: #2989
Index:	error codes;10-Net|10-Net;error codes
--------N-6F0C-------------------------------
INT 6F - 10NET - UNLOCK SEMAPHORE
	AH = 0Ch
	AL = drive number or 0
	ES:SI = Ethernet address or 0
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status (see also #3016)
	    01h semaphore not locked
Note:	same as INT 60/AH=13h
SeeAlso: AH=0Bh,INT 60/AH=13h
--------b-6F0C-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_GET_BUFFER" - READ A BUFFER OF DATA FROM DEVICE
	AH = 0Ch
	BP = driver ID (see #2990) for V_HPHIL (0114h), others
	CX = number of bytes or blocks to read
	DS:SI -> buffer for received data
Return: AH = status (see #2993 at AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=08h"F_GET_BYTE",AH=0Ah"F_PUT_BUFFER",AH=0Ch"F_GET_BLOCK"
SeeAlso: AH=10h"F_GET_WORD"
--------b-6F0C-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_GET_BLOCK" - READ BLOCKS OF DATA FROM DEVICE
	AH = 0Ch
	BP = driver ID (see #2990)
	DH = device major number
	DL = device minor number
	ES:DI -> command block (see #3015)
Return: AH = status (see #2993 at AH=00h"HP Vectra")
	BX = operation status
	BP,DS destroyed
SeeAlso: AH=08h"F_GET_BYTE",AH=0Ah"F_PUT_BLOCK",AH=0Ch"F_GET_BUFFER"
SeeAlso: AH=10h"F_GET_WORD"
--------b-6F0C--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FIXOWNDS" - INSTALL VALUES IN FIXED VECTOR
	AH = 0Ch
	BP = 0012h (driver ID for V_SYSTEM)
	BX = vector address used
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #2993)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), which should return the routine's DS
	  in BX.  If the SF_INIT call returns with error code FEh, the power-on
	  self-test sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h,AH=08h/BP=0012h
SeeAlso: AH=0Eh/BP=0012h,AH=12h/BP=0012h
--------b-6F0C--BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INQUIRE_ENTRY" - GET GID DRIVER ENTRY POINT
	AH = 0Ch
	BP = 002Ah (driver ID for V_SINPUT)
Return: AH = status (see #2993)
	ES:BX -> physical GID driver CS:IP
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=002Ah,AH=06h/BP=002Ah,AH=08h/BP=002Ah
SeeAlso: AH=0Ah/BP=002Ah
--------b-6F0C--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SET_LIMITS_X" - SET HORIZONTAL TRACKING LIMITS
	AH = 0Ch
	BP = 005Ah (driver ID for V_STRACK)
	CX = minimum X coordinate
	DX = maximum X coordinate
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=005Ah,AH=08h/BP=005Ah,AH=0Eh/BP=005Ah
SeeAlso: AH=10h/BP=005Ah,AH=12h/BP=005Ah,INT 33/AX=0007h
--------N-6F0D-------------------------------
INT 6F - 10NET - "WHO" - ENUMERATE USERS ON NETWORK
	AH = 0Dh
	AL = type code
	    01h return superstations only
	    02h return non-superstations only
	    otherwise return all
	CX = length of data buffer
	DS:DX -> array of records to be filled (see #3017)
Return: CL = number of records returned (responding stations)
SeeAlso: AH=16h,AH=8Dh

Format of station record:
Offset	Size	Description	(Table 3017)
 00h 12 BYTEs	node ID
 0Ch	BYTE	station flags (see #3018)
---if AL = 01h---
 0Dh	BYTE	version number
 0Eh	WORD	level number of 10Net software in responding node
---if AL = 02h---
 0Dh  8 BYTEs	user ID
 15h	BYTE	version number
 16h	WORD	level number

Bitfields for station flags:
Bit(s)	Description	(Table 3018)
 1	workstation
 2	superstation
 3	xgate
 4	active gate
--------N-6F0E-------------------------------
INT 6F - 10NET - SPOOL/PRINT
	AH = 0Eh
	DS:DX -> spool/print record (see #3020)
Return: CF clear if successful
	CF set on error
	    AX = error code (see also #2989)
		17FFh device not mounted
		18FFh already spooling to named device

(Table 3019)
Values for 10NET spooler operation code:
 0000h	initiate spool
 0001h	abort print
 0002h	close spool
 0003h	delete spool
 0004h	print
 0005h	get report info
 0006h	set chat template
 0007h	queue
 0008h	return queue
 0009h	queue non-spooled file for printing

Format of 10NET Spool/Print record:
Offset	Size	Description	(Table 3020)
 00h	WORD	operation code (see #3019)
 02h 11 BYTEs	file name in FCB format
---if operation code = 00h or 06h---
 0Dh	BYTE	notification flags (see #3021)
 0Eh	BYTE	days to keep (FFh=forever)
 0Fh	BYTE	bits 0,1: device (1=LPT1)
		bits 4-7: remote drive to store spool file (1=A,...)
 10h	WORD	length of following data area
 12h  N BYTEs	up to 64 bytes of description
---if operation code = 03h---
 0Dh  8 BYTEs	user ID to associate with filename
---if operation code = 04h---
 0Dh	WORD	block number
 0Fh  8 BYTEs	user ID to associate with filename
---if operation code = 05h---
 0Dh	BYTE	RRN to start retrieve
 0Eh	BYTE	bits 0,1: local print device (LPTx)
		bit 3: if set, return entries for all users
 0Fh	WORD	length of following area
 11h  N BYTEs	up to 1500 bytes to receive $SCNTL records returned
---if operation code = 07h---
 0Dh	BYTE	queue number
 0Eh	BYTE	bits 0,1: local print device (LPTx)
 0Fh	WORD	number of bytes of test print to be done
 11h	BYTE	code:
		01h print device
		02h test print count
		03h prn
---if operation code = 08h---
 0Dh	BYTE	queue location or $SCNTL location to start access
		returns next item for access:
		    00h-7Fh queued items
		    80h-FEh non-queued, non-printed items
		    FFh	no more items
 0Eh	WORD	unused
 10h	WORD	length of following area
 12h  N BYTEs	up to 64 bytes to receive $SCNTL records (see #3022)
---if operation code = 09h---
 0Dh  3 BYTEs	unused
 10h  N BYTEs	path to non-spooled file to be queued for printing

Bitfields for notification flags:
Bit(s)	Description	(Table 3021)
 7	queue to top
 6	do ID page
 5	no form feed
 4	reserved
 3	explicit queuing only
 2	notify at print completion
 1	notify server operator, with reply
 0	notify at print start

Format of 10NET $SCNTL record:
Offset	Size	Description	(Table 3022)
 00h  8 BYTEs	user ID
 08h 11 BYTEs	filename in FCB format
 13h  6 BYTEs	node ID
 19h  3 BYTEs	creation date
 1Ch	BYTE	notification flags (see #3021)
 1Dh	BYTE	retention time in days
 1Eh	BYTE	printing device (LPTx)
 1Fh  3 BYTEs	date last printed (0 = never)
 22h	BYTE	device containing spoolfile
 23h	WORD	bytes to print for test print
 25h	WORD	block number to start print
 27h	BYTE	reserved
--------b-6F0E-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_WORD" - WRITE WORD OF DATA TO DEVICE
	AH = 0Eh
	BP = driver ID (see #2990)
	DX = data word
Return: AH = status (see #2993 at AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=06h"F_PUT_BYTE",AH=0Ah"F_PUT_BUFFER",AH=10h"F_GET_WORD"
--------b-6F0E-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_WORD" - WRITE A WORD OF DATA
	AH = 0Eh
	BP = driver ID (see #2990)
	??? details not yet available
Return: ???
SeeAlso: AH=06h"HP Vectra",AH=0Ah"HP Vectra",AH=10h"HP Vectra"
--------b-6F0E--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FIXGETDS" - INSTALL VALUES IN FIXED VECTOR
	AH = 0Eh
	BP = 0012h (driver ID for V_SYSTEM)
	BX = vector address used
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #2993)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), with the "last used DS" value in BX;
	  the routine should adjust BX and return the new value.  If the
	  SF_INIT call returns with error code FEh, the power-on self-test
	  sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h,AH=0Ch/BP=0012h
SeeAlso: AH=10h/BP=0012h,AH=14h/BP=0012h
--------b-6F0E--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SET_LIMITS_Y" - SET VERTICAL TRACKING LIMITS
	AH = 0Eh
	BP = 005Ah (driver ID for V_STRACK)
	CX = minimum Y coordinate
	DX = maximum Y coordinate
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=005Ah,AH=08h/BP=005Ah,AH=0Ch/BP=005Ah
SeeAlso: AH=10h/BP=005Ah,AH=12h/BP=005Ah,INT 33/AX=0008h
--------N-6F0F-------------------------------
INT 6F - 10NET v5.0 - "RM LOCK" - ???
	AH = 0Fh
	???
Return: ???
SeeAlso: AH=07h,AH=08h"10NET"
--------N-6F10-------------------------------
INT 6F - 10NET - ATTACH/DETACH PRINTER
	AH = 10h
	AL = subfunction
	    00h initiate spooling if LPT1 is mounted
	    01h terminate spooling if LPT1 is mounted
SeeAlso: INT 21/AX=5D08h
--------b-6F10-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_GET_WORD" - READ WORD OF DATA FROM DEVICE
	AH = 10h
	BP = driver ID (see #2990)
Return: AH = status (see #2993 at AH=00h"HP Vectra")
	DX = data word
	BP,DS destroyed
SeeAlso: AH=08h"F_GET_BYTE",AH=0Ch"F_GET_BUFFER",AH=0Eh"F_PUT_WORD"
--------b-6F10--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FIXGLBDS" - INSTALL VALUES IN FIXED VECTOR
	AH = 10h
	BP = 0012h (driver ID for V_SYSTEM)
	BX = vector address used
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #2993)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), with BX set to the EX-BIOS global
	  data area. If the SF_INIT call returns with error code FEh, the
	  power-on self-test sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h
SeeAlso: AH=0Ch/BP=0012h,AH=0Eh/BP=0012h,AH=12h/BP=0012h,AH=16h/BP=0012h
--------b-6F10--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_SPRITE" - DISPLAY GRAPHICS CURSOR SPRITE
	AH = 10h
	BP = 005Ah (driver ID for V_STRACK)
	BX = X coordinate
	CX = Y coordinate
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h"F_TRACK_INIT",AH=08h"F_TRACK_OFF"
SeeAlso: AH=12h"F_REMOVE_SPRITE",INT 33/AX=0004h
--------N-6F11-------------------------------
INT 6F - 10NET - LOCK FCB
	AH = 11h
	AL = mode
	    01h sequential
	    02h random
	    03h random block
		CX = number of records
	DS:DX -> FCB (see #0693 at INT 21/AH=0Fh)
Return: CF clear if successful
	CF set on error
	    AX = error code (see also #2989)
		0002h file not found
SeeAlso: AH=12h,INT 21/AH=0Fh
--------N-6F12-------------------------------
INT 6F - 10NET - UNLOCK FCB
	AH = 12h
	AL = mode
	    00h sequential
	    01h random
	    02h random block
		CX = number of records
	DS:DX -> FCB (see #0693 at INT 21/AH=0Fh)
Return: CF clear if successful
	CF set on error
	    AX = error code (see also #2989)
		0002h file not found
SeeAlso: AH=11h
--------b-6F12--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FREEOWNDS" - INSTALL VALUES IN FREE VECTOR
	AH = 12h
	BP = 0012h (driver ID for V_SYSTEM)
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #2993)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), which should return the routine's DS
	  in BX.  If the SF_INIT call returns with error code FEh, the power-on
	  self-test sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=0Ch/BP=0012h,AH=14h/BP=0012h
SeeAlso: AH=16h/BP=0012h,AH=18h/BP=0012h
--------b-6F12--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_REMOVE_SPRITE" - REMOVE GRAPHICS CURSOR SPRITE
	AH = 12h
	BP = 005Ah (driver ID for V_STRACK)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=06h"F_TRACK_ON",AH=10h"F_PUT_SPRITE"
--------N-6F13-------------------------------
INT 6F - 10NET v3.3+ - GET REMOTE CONFIGURATION TABLE ADDRESS
	AH = 13h
	DS:DX -> node ID, 12 bytes blank-padded
Return: CF clear if successful
	    ES:BX = configuration table address on given machine
	CF set on error
	    AX = error code (see #2989)
SeeAlso: AH=03h
--------N-6F14-------------------------------
INT 6F - 10NET v3.3+ - GET REMOTE MEMORY
	AH = 14h
	BX:SI = address of remote memory
	CX = length (<=1024 bytes)
	DS:DX -> node ID, 12 bytes blank-padded
	DS:DI -> area to receive remote memory image
Return: CF clear if successful
	    CX = amount of memory copied to DS:SI
	CF set on error
	    AX = error code (see #2989)
--------b-6F14--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FREEGETDS" - INSTALL VALUES IN FREE VECTOR
	AH = 14h
	BP = 0012h (driver ID for V_SYSTEM)
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #2993)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), with the "last used DS" value in BX;
	  the routine should adjust BX and return the new value.  If the
	  SF_INIT call returns with error code FEh, the power-on self-test
	  sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=0Eh/BP=0012h,AH=12h/BP=0012h
SeeAlso: AH=16h/BP=0012h
--------N-6F1501-----------------------------
INT 6F - 10NET v3.3+ - GET SHARED DEVICE ENTRY
	AX = 1501h
	BX = zero-based index
	DS:SI -> node ID, 12 bytes blank-padded
	ES:DI -> 85-byte buffer for shared device table entry (see #3023)
Return: CF clear if successful
	    ES:DI buffer contains shared device table entry of BXth device
	CF set on error
	    AX = error code (see #2989)
SeeAlso: AX=1502h,AX=1503h,AX=9501h

Format of 10NET shared device table entry:
Offset	Size	Description	(Table 3023)
 00h  8 BYTEs	device
 08h  8 BYTEs	alias
 10h 64 BYTEs	path
 50h  8 BYTEs	password
 58h	BYTE	access
 59h  4 BYTEs	mask
--------N-6F1502-----------------------------
INT 6F - 10NET v3.3+ - SET SHARED DEVICE ENTRY
	AX = 1502h
	DS:SI -> node ID, 12 bytes blank-padded
	ES:DI -> valid shared device table entry
Return: CF clear if successful
	CF set on error
	    AX = error code (see #2989)
SeeAlso: AX=1501h,AX=1503h,AX=9502h
--------N-6F1503-----------------------------
INT 6F - 10NET v3.3+ - DELETE SHARED DEVICE ENTRY
	AX = 1503h
	BX = zero-based index
	DS:SI -> node ID, 12 bytes blank-padded
Return: CF clear if successful
	CF set on error
	    AX = error code (see #2989)
SeeAlso: AX=1501h,AX=1502h,AX=9503h
--------N-6F16-------------------------------
INT 6F - 10NET v5.0 - "GL WHO" - ???
	AH = 16h
	???
Return: ???
SeeAlso: AH=0Dh
--------b-6F16--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FREEGLBDS" - INSTALL VALUES IN FREE VECTOR
	AH = 16h
	BP = 0012h (driver ID for V_SYSTEM)
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #2993 at INT 6F/AH=00h"HP Vectra")
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), with BX set to the EX-BIOS global
	  data area.  If the SF_INIT call returns with error code FEh, the
	  power-on self-test sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=10h/BP=0012h,AH=12h/BP=0012h
SeeAlso: AH=14h/BP=0012h,AH=18h/BP=0012h
--------N-6F17-------------------------------
INT 6F - 10NET v3.3+ - MOUNT
	AH = 17h
	AL = local drive number (0=A:)
	BL = remote drive letter or '1'..'3' for LPTn or '4' or '5' for COMx
	DS:DX -> node ID, 12 bytes blank-padded
Return: CF clear if successful
	CF set on error
	    AX = error code (see #2989)
SeeAlso: AH=18h
--------N-6F18-------------------------------
INT 6F - 10NET v3.3+ - UNMOUNT
	AH = 18h
	AL = local drive number (0=A:)
	BL = type
	    00h	    disk
	    01h-03h LPTn
	    04h,05h COMx
Return: CF clear if successful
	CF set on error
	    AX = error code (see #2989)
SeeAlso: AH=17h
--------b-6F18--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FIND" - FIND DRIVER BY ATTRIBUTES
	AH = 18h
	BP = 0012h (driver ID for V_SYSTEM)
	AL = sense of test (00h equal, 02h non-equal)
	BX = AND mask
	DX = pattern
	SI = first vector address to search
	DI = offset in HP header of field to test
Return: AH = status (00h,FEh) (see #2993 at INT 6F/AH=00h"HP Vectra")
	BP,DS destroyed
	---if AH=00h---
	SI = first matching vector address
Desc:	compare successive drivers' header fields starting at address SI
	  until the header field AND BX is either equal or non-equal to DX
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=0Ch/BP=0012h,AH=10h/BP=0012h
SeeAlso: AH=12h/BP=0012h,AH=16h/BP=0012h
--------N-6F19-------------------------------
INT 6F U - 10NET v5.0 - AUDIT
	AH = 19h
	???
Return: ???
SeeAlso: AH=99h
--------N-6F1A-------------------------------
INT 6F U - 10NET v5.0 - "BULL" - ???
	AH = 1Ah
	???
Return: ???
--------N-6F1B-------------------------------
INT 6F U - 10NET v5.0 - "GMOUNT" - ???
	AH = 1Bh
	???
Return: ???
--------N-6F1C-------------------------------
INT 6F U - 10NET v5.0 - "GLOGIN" - GET LOGIN LIST
	AH = 1Ch
	???
Return: ???
--------N-6F1D-------------------------------
INT 6F U - 10NET v5.0 - "TABDATA" - ???
	AH = 1Dh
	???
Return: ???
--------N-6F1E-------------------------------
INT 6F U - 10NET v5.0 - "SCHED" - ???
	AH = 1Eh
	???
Return: ???
--------b-6F1E--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_RAM_GET" - GET EX-BIOS FREE RAM AREA
	AH = 1Eh
	BP = 0012h (driver ID for V_SYSTEM)
Return: AH = status (00h) (see #2993 at INT 6F/AH=00h"HP Vectra")
	BX = last-used DS
	DX = maximum DS
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=20h/BP=0012h,AH=22h/BP=0012h
--------N-6F1F-------------------------------
INT 6F U - 10NET v5.0 - "WHOAMI" - ???
	AH = 1Fh
	???
Return: ???
--------N-6F20-------------------------------
INT 6F U - 10NET v5.0 - ???
	AH = 20h
	???
Return: ???
--------b-6F20--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_RAM_RET" - RESERVE EX-BIOS MEMORY
	AH = 20h
	BP = 0012h (driver ID for V_SYSTEM)
	BX = new value for "last-used DS"
	DX = new value for "maximum DS"
Return: AH = status (00h) (see #2993 at INT 6F/AH=00h"HP Vectra")
	BP,DS destroyed
Note:	the F_INS_FIXGETDS and F_INS_FREEGETDS functions
	  (see AH=0Eh/BP=0012h,AH=14h/BP=0012h) also modify the values returned
	  by this call, requiring care if both methods are used to allocate
	  memory
SeeAlso: AH=00h"HP Vectra",AH=0Eh/BP=0012h,AH=14h/BP=0012h,AH=1Eh/BP=0012h
--------N-6F21-------------------------------
INT 6F U - 10NET v5.0 - ???
	AH = 21h
	???
Return: ???
--------N-6F22-------------------------------
INT 6F U - 10NET v5.0 - ???
	AH = 22h
	???
Return: ???
--------b-6F22--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_CMOS_GET" - READ CMOS MEMORY
	AH = 22h
	BP = 0012h (driver ID of V_SYSTEM)
	BL = address of CMOS byte to read
Return: AH = status (see #2993 at AH=00h"HP Vectra")
	AL = byte read
	BP,DS destroyed
Note:	supported by ES, QS, and RS series HP Vectras
SeeAlso: AH=00h"HP Vectra",AH=1Eh/BP=0012h,AH=24h/BP=0012h
--------b-6F24--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_CMOS_RET" - WRITE CMOS MEMORY
	AH = 24h
	BP = 0012h (driver ID of V_SYSTEM)
	BL = address of CMOS byte to write
	AL = new value
Return: AH = status (see #2993)
	BP,DS destroyed
Note:	updates the CMOS checksum fields (both IBM-standard and HP checksums)
SeeAlso: AH=00h"HP Vectra",AH=22h/BP=0012h
--------b-6F2A--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_YIELD" - GIVE UP CPU TO OTHER TASKS
	AH = 2Ah
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #2993)
	BP,DS destroyed
Note:	this is a hook for multitasking systems
SeeAlso: AH=00h"HP Vectra",INT 15/AX=1000h,INT 2F/AX=1680h
--------b-6F30--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_CLICK_ENABLE" - TURN ON KEYCLICKS
	AH = 30h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #2993 at AH=00h"HP Vectra")
	BP,DS destroyed
Desc:	enables keyclicks and flushes any pending keyclicks
SeeAlso: AH=32h/BP=0012h,AH=34h/BP=0012h,AH=36h/BP=0012h
--------b-6F32--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_CLICK_DISABLE" - TURN OFF KEYCLICKS
	AH = 32h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	disables keyclicks and flushes any pending keyclicks
SeeAlso: AH=00h"HP Vectra",AH=30h/BP=0012h,AH=38h/BP=0012h
--------b-6F34--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_CLICK" - GENERATE KEYCLICK
	AH = 34h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #2993)
	BP,DS destroyed
Desc:	generate a keyclick if fewer than four clicks are already pending
Note:	if keyclicks are already pending, the remaining click count is
	  incremented and the function returns immediately
SeeAlso: AH=00h"HP Vectra",AH=30h/BP=0012h,AH=36h/BP=0012h,AH=3Ah/BP=0012h
--------b-6F36--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_BEEP_ENABLE" - ENABLE BEEPS
	AH = 36h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #2993 at AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=30h/BP=0012h,AH=34h/BP=0012h,AH=38h/BP=0012h
--------b-6F38--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_BEEP_DISABLE" - DISABLE BEEPS
	AH = 38h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=32h/BP=0012h,AH=36h/BP=0012h
--------b-6F3A--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_BEEP" - SOUND BEEP WITH CURRENT VALUES
	AH = 3Ah
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #2993 at AH=00h"HP Vectra")
	BP,DS destroyed
Desc:	make a sound of the frequency and duration defined in the EX-BIOS
	  global data area (see #2997)
SeeAlso: AH=00h"HP Vectra",AH=34h/BP=0012h,AH=36h/BP=0012h,AH=38h/BP=0012h
SeeAlso: AH=3Ch/BP=0012h,AH=3Eh/BP=0012h
--------b-6F3C--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_SET_BEEP" - SET BEEP FREQUENCY AND DURATION
	AH = 3Ch
	BP = 0012h (driver ID of V_SYSTEM)
	BX = frequency in Hz (1-25000, 0 = off)
	DX = duration in 10-microsecond increments
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=3Ah/BP=0012h,AH=3Eh/BP=0012h,#2997
--------b-6F3E--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_TONE" - SOUND TONE WITH FREQ AND DURATION
	AH = 3Eh
	BP = 0012h (driver ID of V_SYSTEM)
	BX = frequency in Hz (1-25000, 0 = off)
	DX = duration in 10-microsecond increments
Return: AH = status (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=3Ah/BP=0012h,AH=3Ch/BP=0012h,AH=40h/BP=0012h
--------b-6F40--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_GET_FREE_INDEX" - FIND FREE STRING INDEX
	AH = 40h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #2993)
	BX = next free string index
	BP,DS destroyed
Desc:	get the next string index available to user programs
SeeAlso: AH=00h"HP Vectra",AH=42h/BP=0012h,AH=44h/BP=0012h,AH=46h/BP=0012h
--------b-6F42--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_DEL_BUCKET" - DEL HEADER FROM BUCKET LIST
	AH = 42h
	BP = 0012h (driver ID of V_SYSTEM)
	ES:DI -> bucket header (see #3024)
Return: AH = status (00h,FEh) (see #2993 at AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=40h/BP=0012h,AH=44h/BP=0012h

Format of HP Vectra EX-BIOS bucket header:
Offset	Size	Description	(Table 3024)
 00h	DWORD	pointer to next bucket header (FFFFh:FFFFh if last)
 04h	WORD	upper bound on string index
 06h	WORD	lower bound on string index
 08h	DWORD	pointer to array of string offset pointers
 0Ch	WORD	segment of strings
Note:	the strings pointed at by the offset pointers are byte-counted ASCIZ
	  strings
--------b-6F44--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_PUT_BUCKET" - ADD HEADER TO BUCKET HDR LIST
	AH = 44h
	BP = 0012h (driver ID of V_SYSTEM)
	ES:DI -> bucket header (see #3024)
Return: AH = status (00h) (see #2993)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=42h/BP=0012h,AH=46h/BP=0012h
--------b-6F46--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_GET_STRING" - FIND STRING IN BUCKET LIST
	AH = 46h
	BP = 0012h (driver ID of V_SYSTEM)
	BX = string index
Return: AH = status (00h,other) (see #2993)
	BP,DS destroyed
	---if successful---
	CX = length of string (excluding count byte and terminating NUL)
	DS:SI -> header for string
	ES:DI -> found string
SeeAlso: AH=00h"HP Vectra",AH=44h/BP=0012h,AH=48h/BP=0012h
--------b-6F48--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_GET_INDEX" - GET INDEX FOR STRING
	AH = 48h
	BP = 0012h (driver ID of V_SYSTEM)
	ES:DI -> ASCIZ string
Return: AH = status (00h,other) (see #2993 at AH=00h"HP Vectra")
	BP,DS destroyed
	---if successful---
	BX = index for the given string
SeeAlso: AH=00h"HP Vectra",AH=40h/BP=0012h,AH=46h/BP=0012h
--------A-6F636FBX6D70-----------------------
INT 6F - Clara Empricost - TSR Version - INSTALLATION CHECK
	AX = 636Fh ('co')
	BX = 6D70h ('mp')
	CX = 696Eh ('in')
	SS:DX -> WORD to set if installed
Return: SS:DX word set to 636Fh if installed
Program: Condition List Action Rejection Algorithm for the Evaluation
	  of Music at Pseudo-Random Idea COnstruction STage
	  (CLARA EMPRICOST) is an experimental program by Silas Brown
SeeAlso: AX=636Fh/BX=6D70h"UNINSTALL"
--------A-6F636FBX6D70-----------------------
INT 6F - Clara Empricost - TSR Version - UNINSTALL
	AX = 636Fh ('co')
	BX = 6D70h ('mp')
	CX = 6F73h ('os')
Return: nothing -- call installation check to determine whether successful
Program: Condition List Action Rejection Algorithm for the Evaluation
	  of Music at Pseudo-Random Idea COnstruction STage
	  (CLARA EMPRICOST) is an experimental program by Silas Brown
Notes:	 Saves any unfinished task and prevents processing of
	   new tasks, even if can't uninstall
	 If INT 28h or INT 6Fh have been chained since installation,
	   returns without changing interrupts or freeing memory
	 do not call while DOS is active (i.e. InDOS flag is nonzero or INT 28
	   is active and InDOS > 1)
SeeAlso: AX=636Fh/BX=6D70h"INSTALLATION CHECK"
--------N-6F80-------------------------------
INT 6F - 10NET v5.0 - LOGIN
	AH = 80h
	DS:DX -> login record (see #3025)
Return: CF clear if successful
	    BL = number of days until password expires (00h = never)
	    CL = security level
	CF set on error
	    AX = status (see #2989)
SeeAlso: AH=00h,AH=81h

Format of 10NET login record:
Offset	Size	Description	(Table 3025)
 00h  8 BYTEs	user name
 08h  8 BYTEs	password
 10h 15 BYTEs	server node ID
 1Fh  8 BYTEs	new password
 27h	BYTE	invoke mode (00h command line, 01h interactive)
--------N-6F81-------------------------------
INT 6F - 10NET v5.0 - LOGOUT
	AH = 81h
	DS:DX -> server node ID (DX=0000h for universal logout)
Return: AX = status (see #2989)
SeeAlso: AH=01h,AH=80h
--------N-6F8A-------------------------------
INT 6F - 10NET v5.0 - CHAT
	AH = 8Ah
	DS:BX -> chat parameters (see #3026)
	DS:DX -> chat message (see #3027)
Return: CF clear if successful
	CF set on error
	    AX = status (see #2989)
SeeAlso: AH=0Ah"10NET"

Format of 10NET chat parameters:
Offset	Size	Description	(Table 3026)
 00h  8 BYTEs	sender's user name
 08h  8 BYTEs	destination user name
 10h 15 BYTEs	destination node (0 if broadcast-style chat)

Format of 10NET chat message:
Offset	Size	Description	(Table 3027)
 00h	WORD	message length
 02h  N BYTEs	chat message contents
--------N-6F8D-------------------------------
INT 6F - 10NET v5.0 - "WHO" - ENUMERATE USERS ON NETWORK
	AH = 8Dh
	BX = service mask (see #3028)
	CX = length of buffer
	DS:DX -> buffer for array of Who data structures (see #3029)
Return: CF clear if successful
	    CX = number of nodes matching service mask
	    DS:DX buffer filled
	CF set on error
	    AX = status (see #2989)
SeeAlso: AH=0Dh

Bitfields for 10NET service mask:
Bit(s)	Description	(Table 3028)
 0	workstation
 1	file server
 2	print server
 3	de-spool server

Format of 10NET Who data structure:
Offset	Size	Description	(Table 3029)
 00h  8 BYTEs	user name
 08h 15 BYTEs	node ID
 17h  3 BYTEs	unique portion of Ethernet address
 1Ah	BYTE	Who group number
 1Bh	WORD	service mask (see #3028)
 1Dh	DWORD	serial number
 21h	BYTE	maximum concurrent users with same serial number allowed on net
 22h	BYTE	chat mask (see #3030)
 23h	BYTE	internal system bits (see #3031)
 24h  9 BYTEs	version number in format MM.mm.xxx
 2Dh	BYTE	number of shared directories
 2Eh	BYTE	number of shared printer queues

Bitfields for 10NET chat mask:
Bit(s)	Description	(Table 3030)
 0	chat permitted
 1	bell enabled
 2	chat keyboard initiated
 3	in INT 16 handler
 4	in Get Input
 5	display has timed out
 6	chat is idle

Bitfields for 10NET internal system bits:
Bit(s)	Description	(Table 3031)
 0	submit permitted
 1	submit initiated
 2	submit executing
 3	internal client call/chat/spool/autospool
 4	in spool termination
 5	print permitted
 6	waiting for keyboard input
--------N-6F9501-----------------------------
INT 6F - 10NET v5.0 - GET SHARED DEVICE ENTRY
	AX = 9501h
	BX = zero-based index
	DS:SI -> server's node ID
	ES:DI -> buffer for shared device structure (see #3032)
Return: CF clear if successful
	CF set on error
	    AX = status (see #2989)
SeeAlso: AX=1501h,AX=9502h,AX=9503h,AX=9504h

Format of 10NET shared device structure:
Offset	Size	Description	(Table 3032)
 00h  8 BYTEs	alias
 08h	BYTE	type (02h modem, 03h print queue, 04h directory)
 09h	BYTE	access rights
		bit 0: read
		bit 1: write
		bit 2: create
 0Ah  8 BYTEs	password
 12h 32 BYTEs	comment
---directory---
 32h 64 BYTEs	pathname of shared directory
---print queue---
 32h	BYTE	notification bit mask (see #3033)
 33h	BYTE	job control bit mask (see #3034)
 34h	WORD	number of days to retain file
 36h	WORD	test print length
 38h	BYTE	number of copies to print
 39h	BYTE	compression algorithm
 3Ah	BYTE	tab width (00h = don't expand)
 3Bh	BYTE	priority
 3Ch	WORD	time to open queue (FFFFh = always)
 3Eh	WORD	time to close queue
 40h	WORD	pause following queue switch, in clock ticks
 42h	WORD	pause between print jobs, in clock ticks
 44h	BYTE	associate queue file existence mask
		bit 0: queue switch file exists
		bit 1: initiate file exists
		bit 2: abort file exists
 45h  6 BYTEs	character sequence for page eject
 4Bh	BYTE	status of print queue
		bit 0: queue is closed
 4Ch	WORD	number of jobs on queue
 4Eh	WORD	offset of next print job to be dispatched (FFFFh = none)
 50h	BYTE	number of print devices in printer pool
 51h	WORD	offset of first print device structure (FFFFh if empty)

Bitfields for notification flags:
Bit(s)	Description	(Table 3033)
 0	user at print start
 1	operator at start, with reply
 2	user at print completion
 3	operator at completion, with reply
 4	user on queue switch
 5	operator on queue switch, with reply
 6	user on print error

Bitfields for 10NET job control mask:
Bit(s)	Description	(Table 3034)
 0	print banner page
 1	eject page at end of job
 2	mark as "held" (queue but don't print)
 3	rush job (queue at top)
 4	overwrite file with zeros before deletion
 5	hyperspool if possible
--------N-6F9502-----------------------------
INT 6F - 10NET v5.0 - SET SHARED DEVICE ENTRY
	AX = 9502h
	DS:SI -> server's node ID
	ES:DI -> shared device structure (see #3032)
Return: CF clear if successful
	CF set on error
	    AX = status (see #2989)
SeeAlso: AX=1502h,AX=9501h,AX=9503h,AX=9504h
--------N-6F9503-----------------------------
INT 6F - 10NET v5.0 - DELETE SHARED DEVICE
	AX = 9503h
	BX = zero-based index
	DS:SI -> server's node ID
Return: CF clear if successful
	CF set on error
	    AX = status (see #2989)
SeeAlso: AX=1503h,AX=9501h,AX=9502h,AX=9504h
--------N-6F9504-----------------------------
INT 6F - 10NET v5.0 - ENUMERATE USERS OF SHARED DEVICE
	AX = 9504h
	BX = zero-based shared device index
	CX = zero-based user index
	DS:SI -> server's node ID
Return: CF clear if successful
	    ES:DI -> node ID of the CX'th user of the BX'th device
	CF set on error
	    AX = status (see #2989)
SeeAlso: AX=9501h,AX=9502h,AX=9503h
--------N-6F99-------------------------------
INT 6F - 10NET v5.0 - AUDIT
	AH = 99h
	DS:SI -> server's node ID
	ES:DI -> data to be appended to audit trail file (max 106 bytes)
Return: CF clear if successful
	CF set on error
	    AX = status (see #2989)
SeeAlso: AH=19h,AH=9Ch
--------N-6F9C-------------------------------
INT 6F - 10NET v5.0 - GET LOGIN LIST
	AH = 9Ch
	BX = zero-based index
Return: CF clear if successful
	    DS:DI -> BX'th node ID that caller's machine is logged into
	CF set on error
	    AX = status (see #2989)
--------H-70---------------------------------
INT 70 C - IRQ8 - CMOS REAL-TIME CLOCK
Desc:	this interrupt is called when the real-time clock chip generates an
	  alarm or periodic interrupt, among others.  The periodic interrupt
	  occurs 1024 times per second.
Notes:	many BIOSes turn off the periodic interrupt in the INT 70h handler
	  unless in an event wait (see INT 15/AH=83h,INT 15/AH=86h).
	may be masked by setting bit 0 on I/O port A1h
SeeAlso: INT 08,INT 0F"HP 95LX",INT 15/AH=01h"Amstrad",INT 15/AH=83h
SeeAlso: INT 15/AH=86h,INT 1A/AH=02h,INT 58"DESQview",MEM FEE00320h
--------v-70---------------------------------
INT 70 - VIRUS - "Stupid" - ORIGINAL INT 21h VECTOR
Note:	the virus sets this interrupt to be the same as INT 21, and then
	  performs only INT 70 calls; since INT 70 is also generated by the
	  real-time clock on the PC/AT and higher, this could cause random
	  actions on an infected system
SeeAlso: INT 6B"VIRUS",INT 9E"VIRUS",INT E0"VIRUS"
--------H-71---------------------------------
INT 71 C - IRQ9 - REDIRECTED TO INT 0A BY BIOS
Notes:	may be masked by setting bit 1 on I/O port A1h
	the default BIOS handler invokes INT 0A for compatibility, since the
	  pin for IRQ2 on the PC expansion bus became the pin for IRQ9 on the
	  AT expansion bus.
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 0A"IRQ2",INT 59"IRQ9"
--------H-72---------------------------------
INT 72 C - IRQ10 - RESERVED
Note:	may be masked by setting bit 2 on I/O port A1h
SeeAlso: INT 5A"IRQ10"
--------H-73---------------------------------
INT 73 C - IRQ11 - RESERVED
Note:	may be masked by setting bit 3 on I/O port A1h
SeeAlso: INT 5B"IRQ11"
--------H-74---------------------------------
INT 74 C - IRQ12 - POINTING DEVICE (PS)
Notes:	may be masked by setting bit 4 on I/O port A1h
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 33/AX=0000h,INT 33/AX=0024h,INT 5C"NetBIOS"
--------H-75---------------------------------
INT 75 C - IRQ13 - MATH COPROCESSOR EXCEPTION (AT and up)
Desc:	redirected to INT 02 by the BIOS, for compatibility with the PC
Notes:	may be masked by setting bit 5 on I/O port A1h
	not all clones wire the coprocessor to generate this IRQ; some systems
	  generate an NMI (see INT 02) or assert the -ERROR pin on the CPU
	  (see INT 10"COPROCESSOR")
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 10"COPROCESSOR",INT 5D"IRQ13"
--------H-76---------------------------------
INT 76 C - IRQ14 - HARD DISK CONTROLLER OPERATION COMPLETE (AT and later)
Notes:	may be masked by setting bit 6 on I/O port A1h
	on the PS/2, this interrupt is designed to be shared with other
	  devices that produce an operation-complete interrupt, though
	  the only current user is the hard disk
SeeAlso: INT 0E"IRQ6",INT 15/AH=91h,INT 5E"IRQ14"
--------H-77---------------------------------
INT 77 C - IRQ15 - RESERVED (AT,PS)
Note:	may be masked by setting bit 7 on I/O port A1h
SeeAlso: INT 5F"IRQ15"
--------H-77---------------------------------
INT 77 C - IRQ15 - POWER CONSERVATION (Compaq SLT/286)
Note:	may be masked by setting bit 7 on I/O port A1h
SeeAlso: INT 15/AX=4600h,INT 5F"IRQ15"
--------E-78---------------------------------
INT 78 - UofSalford DBOS DOS extender - API
	AH = function
	    00h (PB) display 32-bit memory specified by command argument
	    01h (PT) display 32-bit instruction(s) specified by command arg
	    02h specify offset to subsequent PB and PT commands
	    03h switch to protected mode
		DWORD following INT instruction point to map; protected-mode
			  entry point is immediately following the DWORD
		Return: never
		Note:	if bit 31 of the map address is set, only a stub was
			  loaded by DOS and DBOS will load the entire program
	    04h specify that subsequent load (AH=03h) should leave program in
		  memory
	    05h release program from memory
	    06h set break point at address and option count from commandline
	    07h resume program execution
	    08h single-step program
	    09h set read/write breakpoint using 386 debug registers
	    0Ah set write breakpoint using 386 debug register
	    0Bh set memory byte to new value
	    0Ch display CPU registers
	    0Dh run until specified program address reached
	    0Fh print trace from program map
	    10h specify an offset using a map symbol
	    14h print memory without any offset
	    18h switch DBOS into/out of test mode (ON/OFF commandline args)
	    1Dh get address of real/protected-mode communication buffer
		Return: ES:BP -> comm buffer
	    1Eh set real-mode memory size (specify how much real-mode memory
		  to leave free when running FTN77 programs)
	    22h uninstall DBOS
	    24h force DBOS to emulate coprocessor instructions
	    26h set named DBOS switches from commandline
	    27h reset named DBOS switched from commandline
	    2Ah set list of dynamic link libraries to contents of commandline
		  file
	    35h specify that subsequent load (AH=03h) should stop at first
		  instruction
Return: ???
Notes:	DBOS supports functions 00h through 50h; many of these functions
	  provide a low-level debugging interface
	command arguments are read from the calling program's PSP
SeeAlso: INT 79"DBOS"
Index:	uninstall;DBOS DOS extender
--------E-78---------------------------------
INT 78 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ0
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 08,INT 10/AH=FFh"GO32",INT 79"GO32"
--------A-78---------------------------------
INT 78 R - AutoCAD Device Interface - PLOTTER - SEND COMMAND
	AX = function
	    0001h begin plot
		BX = file level
		    0000h ASCII file
		    0001h binary file
		    0002h AutoCAD DXB file
		    0003h installed ADI driver
	    0002h end plot (close plotter)
	    0003h move (pen up)
		BX = new X position
		CX = new Y position
	    0004h move (pen down)
		BX = new X position
		CX = new Y position
	    0005h select pen
		BX = pen number
	    0006h select drawing speed
		BX = drawing speed N
	    0007h select line style
		BX = line style N
	    0008h raise pen
	    0009h abort plot
Return: AX = 0000h (may be used for driver status in future releases)
SeeAlso: INT 79"AutoCAD",INT 7A/AX=0001h"AutoCAD",INT 7B/AX=8001h"AutoCAD"
--------d-78---------------------------------
INT 78 - ADP-60 IDE controller - ORIGINAL INT 13
SeeAlso: INT 79"ADP-60"
--------s-78-------------------------------
INT 78 - ULTRAMID - API
	AX = function
	--- digital functions ---
	    0000h start digital
		ES:DI -> Sound Structure
		Return: AX = voice used
	    0001h play next buffer
		ES:DI -> Sound Structure
	    0002h set panning
		BX = pan
		CX = voice
	    0003h set volume
		BX = volume
		CX = voice
	    0004h set rate (not yet implemented)
	    0005h pause digital
		CX = voice
	    0006h restart digital
		CX = voice
	    0007h stop digital
		CX = voice
	    0008h get digital position
		CX = voice
		Return: AX:DX -> position in PC buffer
	    0009h get voice status (not yet implemented)
	--- MIDI functions ---
	    000Ah load MIDI patches
		ES:DI -> MIDI track just after the Mtrk header
		BX:DX = length of MIDI track
	    000Bh load XMIDI patches
		ES:DI -> event buffer including the EVNT header
	    000Ch load patch
		CX = MIDI number of patch
	    000Dh unload patch
		CX = MIDI number of patch
	    000Eh start sequence
	    000Fh unload all patches
	    0010h MIDI out byte
		CX = MIDI byte
	    0011h MIDI out string
		CX = length
		ES:DI -> string of MIDI data
	    0012h all notes off
	--- resource functions ---
	    0013h allocate memory
		BX:DX = size of GUS memory needed
		Return: AX:DX = address of memory, or 0000:0000 if not avaiable
	    0014h free memory
		BX:DX = address of memory to be freed
	    0015h uninstall
	    0016h sem enter
	    0017h sem leave
	    0018h add external semaphore
		BX:DX -> external semaphore
	    0019h clear external semaphore
		BX:DX -> external semaphore
	    001Ah application start
	    001Bh application end
	--- v1.12 ---
	    001Ch ???
	    001Dh ???
	    001Eh ???
	    001Fh ???
Program: UltraMid is a TSR from Advanced Gravis to play MIDI and digital data
	   through the Gravis UltraSound (GUS)
Range:	INT 78 to INT 7F
Notes:	the installation check is testing for the signature "ULTRAMID" at
	  offset 0103h in the interrupt handler's segment
SeeAlso: INT 2F/AX=CD00h"ULTRAMID",INT 7E/AH=00h"SBOS",INT 7E/AX=00FEh"SBOS"
Index:	uninstall;UltraMID
--------d-7800-------------------------------
INT 78 - TARGA.DEV - CMC International SCSI device driver - SET I/O PORT
	AH = 00h
	DX = interface board I/O port
Return: CF set on error
	    AL = error code (see #3035)
Note:	if this routine is not called, the port is the driver's default
	  (usually 0280h or 0300h)
	an installation check is performed by TARGA.DEV upon initialization
	  by checking for the string "SCSI" at offset 03h into the interrupt
	  handler
SeeAlso: AH=01h,AH=02h
Index:	installation check;TARGA.DEV

(Table 3035)
Values for TARGA.DEV error code:
 00h	illegal command given to SCSI code
 01h	invalid I/O port specified (must be from 100H to 3F8H, and must be on
	  an 8-port boundary)
 02h	invalid DMA channel specified (must be from 1 to 3)
 03h	invalid SCSI board number specified (must be from 0 to 7)
 04h	error from data register test during self-test
 05h	SCSI input signals not all 0 when SCSI RST activated
 06h	SCSI input signals not all 0 before selecting a SCSI device
 07h	BSY signal is active; SCSI bus is busy
 08h	SCSI board not selected, BSY signal did not come on in response to
	  raising SEL
 09h	time-out waiting for status state, signifying end of DMA transfer
--------E-780000-----------------------------
INT 78 - HugeRealMode Driver - INSTALLATION CHECK
	AX = 0000h
Return: AX = DBCAh if installed
Program: the HugeRealMode driver was published in the German DOS Extra Nr. 20
	  (1992), and makes a 4G flat address space (for both data and code)
	  available to real-mode DOS programs
SeeAlso: AX=0001h
--------E-780001-----------------------------
INT 78 - HugeRealMode Driver - GET ENTRY POINT
	AX = 0001h
Return: ES:BX -> far call entry point (see #3037,#3052)
SeeAlso: AX=0000h

(Table 3036)
Values for HugeRealMode Server error code:
 00h	successful
 01h	unknown function
 02h	A20 disabled
 03h	A20 enabled
 04h	memory allocation error
 05h	memory not fixeable (LOCK)
 06h	memory not deallocaable
 07h	memory not moveable (UNLOCK)
 08h	change in memory allocation size not possible
 09h	file error (with .XMF-file)
 0Ah	memory error (with .XMF-file)
 0Bh	unknown procedure (currently Turbo Pascal unit only)

(Table 3037)
Call HugeRealMode Server "Enable A20" function with:
	AL = 00h
Return: AX = error code (see #3036)
Note:	The HugeRealMode Server requires an XMS-driver like HIMEM.SYS loaded
	  before HUGEREAL (for XMS-memory allocation and A20 control). It
	  utilizes some undocumented 386+ features to enable 4G code and data
	  segments (flat memory model) in the CPUs real-mode. It is not
	  compatible with V86-mode (as with most EMM386). For maximum speed
	  and compatibility with DOS it uses a two stage interrupt model
	  (see #3040)
SeeAlso: #3038,#3039,#3040

(Table 3038)
Call HugeRealMode Server "Disable A20" function with:
	AL = 01h
Return: AX = error code (see #3036)
SeeAlso: #3037,#3039

(Table 3039)
Call HugeRealMode Server "Query A20 State" function with:
	AL = 02h
Return: AX = A20 state (0000h disabled, 0001h enabled)
SeeAlso: #3037,#3038

(Table 3040)
Call HugeRealMode Server "Enable Two-Stage Interrupt Model" function with:
	AL = 03h
Return: AX = error code (see #3036)
Notes:	If the two stage interrupt model is disabled, the IP must stay below
	  1MB, because the high word of EIP is not saved correctly by the
	  standard interrupt management in real mode.  Routines in extended
	  memory may only be called with interrupts disabled (only usable for
	  very short routines).
	If the two stage interupt model is enabled, these conventions are not
	  required.  The outer (transparent) ISRs save the higher word of EIP
	  in the high word of CR3 (possible modification: in memory, if this
	  is not safe) and then invoke the standard ISRs.
	Because of this handling, one should use pseudo segmented code even in
	  extended memory (64K blocks located on 64K boundaries) to avoid the
	  misalignment of the saved EIP (in CR3). Another way is to track and
	  realign CR3 each time when jumping over a 64K boundary in extended
	  memory
SeeAlso: #3037,#3041

(Table 3041)
Call HugeRealMode Server "Disable Two-Stage Interrupt Model" function with:
	AL = 04h
Return: AX = error code (see #3036)
SeeAlso: #3037,#3040

(Table 3042)
Call HugeRealMode Server "Get Segment Address Of Server-Management Range" with:
	AL = 05h
Return: AX = error code (see #3036)
	ES = segment address
SeeAlso: #3052

(Table 3043)
Call HugeRealMode Server "Allocate Memory" function with:
	AL = 06h
	DX = length in KB
Return: AX = error code (see #3036)
	DX = handle
	EBX = start address of allocated block
SeeAlso: #3044,#3045

(Table 3044)
Call HugeRealMode Server "Deallocate Memory" function with:
	AL = 07h
	DX = handle
Return: AX = error code (see #3036)
SeeAlso: #3043,#3045

(Table 3045)
Call HugeRealMode Server "Modify Allocated Memory Size" function with:
	AL = 08h
	DX = handle
	BX = new size in KB
Return: AX = error code (see #3036)
	EBX = new address
SeeAlso: #3043,#3044

(Table 3046)
Call HugeRealMode Server "Load .XMF-file" function with:
	AL = 09h
	ES:BX -> filename (see #3047)
Return: AX = error code (see #3036)
	ECX = target address
Notes:	memory must be allocated before loading
	.XMF file format (eXtended Memory executable File format) is supported
	  by the HugeRealMode server for easier handling of XMS-code.
	The utility CONFXMF converts .OBJ-files (.COM 'tiny' model) to
	  .XMF-format
SeeAlso: #3043

Format of .XMF program file header:
Offset	Size	Description	(Table 3047)
 00h	DWORD	signature "XMF_"
 04h	WORD	length of programs code
 06h	WORD	count of 32bit addresses to relocate
 08h	WORD	offset to code start (releative to file start) (see #3048)
 0Ah	WORD	relocation table
Note:	each word contains a 16bit address, where a relocation has to be
	  performed
SeeAlso: #3046,#3048

Format of .XMF-file code header:
Offset	Size	Description	(Table 3048)
 00h	WORD	count of exported functions
 02h  N PWORDs	48bit pointers (16bit segment+32bit offset) to each function
		(16bit segment is always zero)
 var		start of program's code
SeeAlso: #3046,#3047

(Table 3049)
Call HugeRealMode Server "Set Segment Limits" function with:
	AL = 0Ah
	BL = segment limits (see #3050)
Return: AX = error code (see #3036)
SeeAlso: #3042

Bitfields for HugeRealMode Server segment limits:
Bit(s)	Description	(Table 3050)
 7	CS size: 1=4GB, 0=64KB
 6-5	not used
 4	SS size: 1=4GB, 0=64KB
 3	GS size
 2	FS size
 1	ES size
 0	DS size
SeeAlso: #3049

(Table 3051)
Call HugeRealMode Server "Transfer Memory From DOS To XMS" function with:
	AL = 0Bh
	ES:SI = source address
	EDI = target address
	ECX = length
Return: AX = error code
SeeAlso: #3052

(Table 3052)
Call HugeRealMode Server "Transfer Memory From XMS To DOS" function with:
	AL = 0Ch
	ESI = source address
	ES:DI = target address
	ECX = length
Return: AX = error code
SeeAlso: #3051
--------d-7801-------------------------------
INT 78 - TARGA.DEV - GET I/O PORT
	AH = 01h
Return: DX = current interface board I/O port
SeeAlso: AH=00h,AH=03h"TARGA"
--------d-7802-------------------------------
INT 78 - TARGA.DEV - SET DMA CHANNEL
	AH = 02h
	AL = interface board DMA channel
Return: CF set on error
	AL = error code (see #3035)
Note:	if this routine is not called, the DMA channel is the driver's default
	  (usually 3)
SeeAlso: AH=00h,AH=03h"TARGA"
--------d-7803-------------------------------
INT 78 - TARGA.DEV - GET DMA CHANNEL
	AH = 03h
Return: AL = current interface board DMA channel
SeeAlso: AH=01h,AH=02h
--------d-7804-------------------------------
INT 78 - TARGA.DEV - SET SCSI DEVICE NUMBER
	AH = 04h
	AL = SCSI device number
Return: CF set on error
	AL = error code (see #3035)
Note:	if this routine is not called, the device number used is the driver's
	  default (usually 0)
SeeAlso: AH=02h,AH=05h
--------d-7805-------------------------------
INT 78 - TARGA.DEV - GET SCSI DEVICE NUMBER
	AH = 05h
Return: AL = current SCSI device number
SeeAlso: AH=03h"TARGA",AH=04h
--------d-7806-------------------------------
INT 78 - TARGA.DEV - SET/CLEAR EARLY RETURN MODE
	AH = 06h
	AL = new state
	    00h clear early return mode
	    01h set early return mode
Note:	if early return mode is set then SCSI will return with no errors
	  when the last DMA transfer is started in a call with AH=13h or AH=14h
	if this routine is not called, early return mode is cleared
SeeAlso: AH=13h,AH=14h,AH=15h
--------d-7808-------------------------------
INT 78 - TARGA.DEV - INTERFACE BOARD SELF-TEST
	AH = 08h
Return: CF set on error
	AL = error code (see #3035)
Note:	the SCSI bus is also reset
SeeAlso: AH=09h
--------d-7809-------------------------------
INT 78 - TARGA.DEV - RESET SCSI BUS
	AH = 09h
Return: AL = error code if carry set (see #3035)
SeeAlso: AH=08h
--------d-7810-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND
	AH = 10h
	DS:SI -> command bytes (see #3053)
Return: AH = SCSI status byte
	CF clear if successful
	    AL = SCSI message byte
	CF set on error
	    AL = error code (see #3035)
SeeAlso: AH=11h,INT 21/AX=4403h"ST-01"

Format of SCSI Command:
Offset	Size	Description	(Table 3053)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7811-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND, RECEIVE DATA (PROGRAMMED I/O)
	AH = 11h
	DS:SI -> command bytes (see #3054)
	ES:BX -> data storage area
	CX = number of data bytes to transfer
Return: AH = SCSI status byte
	CF clear if successful
	    AL = SCSI message byte
	CF set on error
	    AL = error code (see #3035)
Note:	this command receives data internally one byte at a time
SeeAlso: AH=10h,AH=13h

Format of TARGA.DEV SCSI Command:
Offset	Size	Description	(Table 3054)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7812-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND AND DATA (PROGRAMMED I/O)
	AH = 12h
	DS:SI -> command bytes (see #3055)
	ES:BX -> data storage area
	CX = number of data bytes to transfer
Return: AH = SCSI status byte
	CF clear if successful
	    AL = SCSI message byte
	CF set on error
	    AL = error code (see #3035)
Note:	this command sends data internally one byte at a time
SeeAlso: AH=14h

Format of TARGA.DEV SCSI Command:
Offset	Size	Description	(Table 3055)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7813-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND, RECEIVE DATA (DMA)
	AH = 13h
	DS:SI -> command bytes (see #3056)
	ES:BX -> data storage area
	DX:CX = number of data bytes to transfer
Return: AH = SCSI status byte (if early return mode is clear)
	CF clear if successful
	    AL = SCSI message byte (if early return mode is clear)
	CF set on error
	    AL = error code (see #3035)
Note:	this command receives data using DMA
SeeAlso: AH=11h,AH=12h

Format of TARGA.DEV SCSI Command:
Offset	Size	Description	(Table 3056)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7814-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND AND DATA (DMA)
	AH = 14h
	DS:SI -> command bytes (see #3057)
	ES:BX -> data storage area
	DX:CX = number of data bytes to transfer
Return: AH = SCSI status byte (if early return mode is clear)
	CF clear if successful
	    AL = SCSI message byte (if early return mode is clear)
	CF set on error
	    AL = error code (see #3035)
Note:	this command sends data using DMA
SeeAlso: AH=12h,AH=13h

Format of TARGA.DEV SCSI Command:
Offset	Size	Description	(Table 3057)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7815-------------------------------
INT 78 - TARGA.DEV - FINISH DATA TRANSFER (DMA)
	AH = 15h
Return: AH = SCSI status byte
	CF clear if successful
	    AL = SCSI message byte
	CF set on error
	    AL = error code (see #3035)
Note:	if AH=06h was previously called to set the early return mode, this
	  function finishes a command AH=13h or AH=14h which returned before
	  the last DMA transfer was finished
SeeAlso: AH=06h,AH=13h,AH=14h
--------!---Section--------------------------
